var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __glob = (map) => (path) => {
  var fn = map[path];
  if (fn)
    return fn();
  throw new Error("Module not found in bundle: " + path);
};
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// <define:import.meta.env>
var define_import_meta_env_default;
var init_define_import_meta_env = __esm({
  "<define:import.meta.env>"() {
    define_import_meta_env_default = { DEV: true };
  }
});

// jotai.ts
import { unstable_createStore, useAtom } from "jotai";
import { useLayoutEffect } from "react";
var jotaiScope, jotaiStore;
var init_jotai = __esm({
  "jotai.ts"() {
    "use strict";
    init_define_import_meta_env();
    jotaiScope = Symbol();
    jotaiStore = unstable_createStore();
  }
});

// import("./locales/**/*.json") in i18n.ts
var globImport_locales_json;
var init_ = __esm({
  'import("./locales/**/*.json") in i18n.ts'() {
    globImport_locales_json = __glob({
      "./locales/ar-SA.json": () => import("./ar-SA-JA6F2FMJ.json"),
      "./locales/az-AZ.json": () => import("./az-AZ-GVIENQVH.json"),
      "./locales/bg-BG.json": () => import("./bg-BG-YFNNHCEP.json"),
      "./locales/bn-BD.json": () => import("./bn-BD-LMEIWSRD.json"),
      "./locales/ca-ES.json": () => import("./ca-ES-C2WGCLOT.json"),
      "./locales/cs-CZ.json": () => import("./cs-CZ-F2NDIQMB.json"),
      "./locales/da-DK.json": () => import("./da-DK-WBEQB3CJ.json"),
      "./locales/de-DE.json": () => import("./de-DE-VEIMCP7R.json"),
      "./locales/el-GR.json": () => import("./el-GR-TKRKG5GQ.json"),
      "./locales/en.json": () => import("./en-WKA7RN3L.json"),
      "./locales/es-ES.json": () => import("./es-ES-TOLWEZNW.json"),
      "./locales/eu-ES.json": () => import("./eu-ES-7CDRJQWJ.json"),
      "./locales/fa-IR.json": () => import("./fa-IR-527E2XGU.json"),
      "./locales/fi-FI.json": () => import("./fi-FI-NLQ7RQGZ.json"),
      "./locales/fr-FR.json": () => import("./fr-FR-KUHO4FLU.json"),
      "./locales/gl-ES.json": () => import("./gl-ES-NEXX3VBB.json"),
      "./locales/he-IL.json": () => import("./he-IL-MED2VGBZ.json"),
      "./locales/hi-IN.json": () => import("./hi-IN-5V633W7V.json"),
      "./locales/hu-HU.json": () => import("./hu-HU-2FOZGVGR.json"),
      "./locales/id-ID.json": () => import("./id-ID-I6BOLXTF.json"),
      "./locales/it-IT.json": () => import("./it-IT-WKPQOK4P.json"),
      "./locales/ja-JP.json": () => import("./ja-JP-VKA4ISRU.json"),
      "./locales/kaa.json": () => import("./kaa-IKPRSBNY.json"),
      "./locales/kab-KAB.json": () => import("./kab-KAB-IE4PHQTZ.json"),
      "./locales/kk-KZ.json": () => import("./kk-KZ-MNJT6XSV.json"),
      "./locales/km-KH.json": () => import("./km-KH-LADGDFXV.json"),
      "./locales/ko-KR.json": () => import("./ko-KR-XD7AVF2F.json"),
      "./locales/ku-TR.json": () => import("./ku-TR-4XBHKDQA.json"),
      "./locales/lt-LT.json": () => import("./lt-LT-QC35R4YH.json"),
      "./locales/lv-LV.json": () => import("./lv-LV-GSD5D3BA.json"),
      "./locales/mr-IN.json": () => import("./mr-IN-KOLSWM7Y.json"),
      "./locales/my-MM.json": () => import("./my-MM-M53KMUET.json"),
      "./locales/nb-NO.json": () => import("./nb-NO-XXC6U37A.json"),
      "./locales/nl-NL.json": () => import("./nl-NL-HCCJQEUO.json"),
      "./locales/nn-NO.json": () => import("./nn-NO-6P7Z2PI2.json"),
      "./locales/oc-FR.json": () => import("./oc-FR-JRJKPLNT.json"),
      "./locales/pa-IN.json": () => import("./pa-IN-LZWLEPIB.json"),
      "./locales/percentages.json": () => import("./percentages-UCQDHIQF.json"),
      "./locales/pl-PL.json": () => import("./pl-PL-3WBLCXI2.json"),
      "./locales/pt-BR.json": () => import("./pt-BR-O3ZPTUNW.json"),
      "./locales/pt-PT.json": () => import("./pt-PT-7AQTSAFO.json"),
      "./locales/ro-RO.json": () => import("./ro-RO-HJ65JYWV.json"),
      "./locales/ru-RU.json": () => import("./ru-RU-P7ROIYNC.json"),
      "./locales/si-LK.json": () => import("./si-LK-7ZSWVION.json"),
      "./locales/sk-SK.json": () => import("./sk-SK-NXVBGLYY.json"),
      "./locales/sl-SI.json": () => import("./sl-SI-VFTWOYNP.json"),
      "./locales/sv-SE.json": () => import("./sv-SE-YONBLQNW.json"),
      "./locales/ta-IN.json": () => import("./ta-IN-BSETPMLX.json"),
      "./locales/th-TH.json": () => import("./th-TH-URTRDITB.json"),
      "./locales/tr-TR.json": () => import("./tr-TR-N5SCAVTB.json"),
      "./locales/uk-UA.json": () => import("./uk-UA-LBCYVSQZ.json"),
      "./locales/vi-VN.json": () => import("./vi-VN-POZWLIUU.json"),
      "./locales/zh-CN.json": () => import("./zh-CN-FUF5V3SC.json"),
      "./locales/zh-HK.json": () => import("./zh-HK-OB4VW42C.json"),
      "./locales/zh-TW.json": () => import("./zh-TW-5JPVKOM7.json")
    });
  }
});

// i18n.ts
import fallbackLangData from "./en-WKA7RN3L.json";
import percentages from "./percentages-UCQDHIQF.json";
import { atom, useAtomValue } from "jotai";
var COMPLETION_THRESHOLD, defaultLang, languages, TEST_LANG_CODE, currentLang, currentLangData, setLanguage, getLanguage, findPartsForData, t, editorLangCodeAtom, useI18n;
var init_i18n = __esm({
  "i18n.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_jotai();
    init_();
    COMPLETION_THRESHOLD = 85;
    defaultLang = { code: "en", label: "English" };
    languages = [
      defaultLang,
      ...[
        { code: "ar-SA", label: "\u0627\u0644\u0639\u0631\u0628\u064A\u0629", rtl: true },
        { code: "bg-BG", label: "\u0411\u044A\u043B\u0433\u0430\u0440\u0441\u043A\u0438" },
        { code: "ca-ES", label: "Catal\xE0" },
        { code: "cs-CZ", label: "\u010Cesky" },
        { code: "de-DE", label: "Deutsch" },
        { code: "el-GR", label: "\u0395\u03BB\u03BB\u03B7\u03BD\u03B9\u03BA\u03AC" },
        { code: "es-ES", label: "Espa\xF1ol" },
        { code: "eu-ES", label: "Euskara" },
        { code: "fa-IR", label: "\u0641\u0627\u0631\u0633\u06CC", rtl: true },
        { code: "fi-FI", label: "Suomi" },
        { code: "fr-FR", label: "Fran\xE7ais" },
        { code: "gl-ES", label: "Galego" },
        { code: "he-IL", label: "\u05E2\u05D1\u05E8\u05D9\u05EA", rtl: true },
        { code: "hi-IN", label: "\u0939\u093F\u0928\u094D\u0926\u0940" },
        { code: "hu-HU", label: "Magyar" },
        { code: "id-ID", label: "Bahasa Indonesia" },
        { code: "it-IT", label: "Italiano" },
        { code: "ja-JP", label: "\u65E5\u672C\u8A9E" },
        { code: "kab-KAB", label: "Taqbaylit" },
        { code: "kk-KZ", label: "\u049A\u0430\u0437\u0430\u049B \u0442\u0456\u043B\u0456" },
        { code: "ko-KR", label: "\uD55C\uAD6D\uC5B4" },
        { code: "ku-TR", label: "Kurd\xEE" },
        { code: "lt-LT", label: "Lietuvi\u0173" },
        { code: "lv-LV", label: "Latvie\u0161u" },
        { code: "my-MM", label: "Burmese" },
        { code: "nb-NO", label: "Norsk bokm\xE5l" },
        { code: "nl-NL", label: "Nederlands" },
        { code: "nn-NO", label: "Norsk nynorsk" },
        { code: "oc-FR", label: "Occitan" },
        { code: "pa-IN", label: "\u0A2A\u0A70\u0A1C\u0A3E\u0A2C\u0A40" },
        { code: "pl-PL", label: "Polski" },
        { code: "pt-BR", label: "Portugu\xEAs Brasileiro" },
        { code: "pt-PT", label: "Portugu\xEAs" },
        { code: "ro-RO", label: "Rom\xE2n\u0103" },
        { code: "ru-RU", label: "\u0420\u0443\u0441\u0441\u043A\u0438\u0439" },
        { code: "sk-SK", label: "Sloven\u010Dina" },
        { code: "sv-SE", label: "Svenska" },
        { code: "sl-SI", label: "Sloven\u0161\u010Dina" },
        { code: "tr-TR", label: "T\xFCrk\xE7e" },
        { code: "uk-UA", label: "\u0423\u043A\u0440\u0430\u0457\u043D\u0441\u044C\u043A\u0430" },
        { code: "zh-CN", label: "\u7B80\u4F53\u4E2D\u6587" },
        { code: "zh-TW", label: "\u7E41\u9AD4\u4E2D\u6587" },
        { code: "vi-VN", label: "Ti\u1EBFng Vi\u1EC7t" },
        { code: "mr-IN", label: "\u092E\u0930\u093E\u0920\u0940" }
      ].filter(
        (lang) => percentages[lang.code] >= COMPLETION_THRESHOLD
      ).sort((left, right) => left.label > right.label ? 1 : -1)
    ];
    TEST_LANG_CODE = "__test__";
    if (define_import_meta_env_default.DEV) {
      languages.unshift(
        { code: TEST_LANG_CODE, label: "test language" },
        {
          code: `${TEST_LANG_CODE}.rtl`,
          label: "\u202Atest language (rtl)\u202C",
          rtl: true
        }
      );
    }
    currentLang = defaultLang;
    currentLangData = {};
    setLanguage = async (lang) => {
      currentLang = lang;
      document.documentElement.dir = currentLang.rtl ? "rtl" : "ltr";
      document.documentElement.lang = currentLang.code;
      if (lang.code.startsWith(TEST_LANG_CODE)) {
        currentLangData = {};
      } else {
        try {
          currentLangData = await globImport_locales_json(`./locales/${currentLang.code}.json`);
        } catch (error) {
          console.error(`Failed to load language ${lang.code}:`, error.message);
          currentLangData = fallbackLangData;
        }
      }
      jotaiStore.set(editorLangCodeAtom, lang.code);
    };
    getLanguage = () => currentLang;
    findPartsForData = (data, parts) => {
      for (let index = 0; index < parts.length; ++index) {
        const part = parts[index];
        if (data[part] === void 0) {
          return void 0;
        }
        data = data[part];
      }
      if (typeof data !== "string") {
        return void 0;
      }
      return data;
    };
    t = (path, replacement, fallback) => {
      if (currentLang.code.startsWith(TEST_LANG_CODE)) {
        const name = replacement ? `${path}(${JSON.stringify(replacement).slice(1, -1)})` : path;
        return `\u202A[[${name}]]\u202C`;
      }
      const parts = path.split(".");
      let translation2 = findPartsForData(currentLangData, parts) || findPartsForData(fallbackLangData, parts) || fallback;
      if (translation2 === void 0) {
        const errorMessage = `Can't find translation for ${path}`;
        if (define_import_meta_env_default.PROD) {
          console.warn(errorMessage);
          return "";
        }
        throw new Error(errorMessage);
      }
      if (replacement) {
        for (const key in replacement) {
          translation2 = translation2.replace(`{{${key}}}`, String(replacement[key]));
        }
      }
      return translation2;
    };
    editorLangCodeAtom = atom(defaultLang.code);
    useI18n = () => {
      const langCode = useAtomValue(editorLangCodeAtom, jotaiScope);
      return { t, langCode };
    };
  }
});

// components/Spinner.scss
var init_Spinner = __esm({
  "components/Spinner.scss"() {
  }
});

// components/Spinner.tsx
import React from "react";
import { jsx } from "react/jsx-runtime";
var Spinner, Spinner_default;
var init_Spinner2 = __esm({
  "components/Spinner.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_Spinner();
    Spinner = ({
      size = "1em",
      circleWidth = 8,
      synchronized = false
    }) => {
      const mountTime = React.useRef(Date.now());
      const mountDelay = -(mountTime.current % 1600);
      return /* @__PURE__ */ jsx("div", { className: "Spinner", children: /* @__PURE__ */ jsx(
        "svg",
        {
          viewBox: "0 0 100 100",
          style: {
            width: size,
            height: size,
            // fix for remounting causing spinner flicker
            ["--spinner-delay"]: synchronized ? `${mountDelay}ms` : 0
          },
          children: /* @__PURE__ */ jsx(
            "circle",
            {
              cx: "50",
              cy: "50",
              r: 50 - circleWidth / 2,
              strokeWidth: circleWidth,
              fill: "none",
              strokeMiterlimit: "10"
            }
          )
        }
      ) });
    };
    Spinner_default = Spinner;
  }
});

// css/variables.module.scss
var variables_module_default;
var init_variables_module = __esm({
  "css/variables.module.scss"() {
    variables_module_default = {};
  }
});

// colors.ts
import oc from "open-color";
var pick, MAX_CUSTOM_COLORS_USED_IN_CANVAS, COLORS_PER_ROW, DEFAULT_CHART_COLOR_INDEX, DEFAULT_ELEMENT_STROKE_COLOR_INDEX, DEFAULT_ELEMENT_BACKGROUND_COLOR_INDEX, ELEMENTS_PALETTE_SHADE_INDEXES, getSpecificColorShades, COLOR_PALETTE, COMMON_ELEMENT_SHADES, DEFAULT_ELEMENT_STROKE_PICKS, DEFAULT_ELEMENT_BACKGROUND_PICKS, DEFAULT_CANVAS_BACKGROUND_PICKS, DEFAULT_ELEMENT_STROKE_COLOR_PALETTE, DEFAULT_ELEMENT_BACKGROUND_COLOR_PALETTE, getAllColorsSpecificShade, rgbToHex;
var init_colors = __esm({
  "colors.ts"() {
    "use strict";
    init_define_import_meta_env();
    pick = (source, keys) => {
      return keys.reduce((acc, key) => {
        if (key in source) {
          acc[key] = source[key];
        }
        return acc;
      }, {});
    };
    MAX_CUSTOM_COLORS_USED_IN_CANVAS = 5;
    COLORS_PER_ROW = 5;
    DEFAULT_CHART_COLOR_INDEX = 4;
    DEFAULT_ELEMENT_STROKE_COLOR_INDEX = 4;
    DEFAULT_ELEMENT_BACKGROUND_COLOR_INDEX = 1;
    ELEMENTS_PALETTE_SHADE_INDEXES = [0, 2, 4, 6, 8];
    getSpecificColorShades = (color, indexArr) => {
      return indexArr.map((index) => oc[color][index]);
    };
    COLOR_PALETTE = {
      transparent: "transparent",
      black: "#1e1e1e",
      white: "#ffffff",
      // open-colors
      gray: getSpecificColorShades("gray", ELEMENTS_PALETTE_SHADE_INDEXES),
      red: getSpecificColorShades("red", ELEMENTS_PALETTE_SHADE_INDEXES),
      pink: getSpecificColorShades("pink", ELEMENTS_PALETTE_SHADE_INDEXES),
      grape: getSpecificColorShades("grape", ELEMENTS_PALETTE_SHADE_INDEXES),
      violet: getSpecificColorShades("violet", ELEMENTS_PALETTE_SHADE_INDEXES),
      blue: getSpecificColorShades("blue", ELEMENTS_PALETTE_SHADE_INDEXES),
      cyan: getSpecificColorShades("cyan", ELEMENTS_PALETTE_SHADE_INDEXES),
      teal: getSpecificColorShades("teal", ELEMENTS_PALETTE_SHADE_INDEXES),
      green: getSpecificColorShades("green", ELEMENTS_PALETTE_SHADE_INDEXES),
      yellow: getSpecificColorShades("yellow", ELEMENTS_PALETTE_SHADE_INDEXES),
      orange: getSpecificColorShades("orange", ELEMENTS_PALETTE_SHADE_INDEXES),
      // radix bronze shades 3,5,7,9,11
      bronze: ["#f8f1ee", "#eaddd7", "#d2bab0", "#a18072", "#846358"]
    };
    COMMON_ELEMENT_SHADES = pick(COLOR_PALETTE, [
      "cyan",
      "blue",
      "violet",
      "grape",
      "pink",
      "green",
      "teal",
      "yellow",
      "orange",
      "red"
    ]);
    DEFAULT_ELEMENT_STROKE_PICKS = [
      COLOR_PALETTE.black,
      COLOR_PALETTE.red[DEFAULT_ELEMENT_STROKE_COLOR_INDEX],
      COLOR_PALETTE.green[DEFAULT_ELEMENT_STROKE_COLOR_INDEX],
      COLOR_PALETTE.blue[DEFAULT_ELEMENT_STROKE_COLOR_INDEX],
      COLOR_PALETTE.yellow[DEFAULT_ELEMENT_STROKE_COLOR_INDEX]
    ];
    DEFAULT_ELEMENT_BACKGROUND_PICKS = [
      COLOR_PALETTE.transparent,
      COLOR_PALETTE.red[DEFAULT_ELEMENT_BACKGROUND_COLOR_INDEX],
      COLOR_PALETTE.green[DEFAULT_ELEMENT_BACKGROUND_COLOR_INDEX],
      COLOR_PALETTE.blue[DEFAULT_ELEMENT_BACKGROUND_COLOR_INDEX],
      COLOR_PALETTE.yellow[DEFAULT_ELEMENT_BACKGROUND_COLOR_INDEX]
    ];
    DEFAULT_CANVAS_BACKGROUND_PICKS = [
      COLOR_PALETTE.white,
      // radix slate2
      "#f8f9fa",
      // radix blue2
      "#f5faff",
      // radix yellow2
      "#fffce8",
      // radix bronze2
      "#fdf8f6"
    ];
    DEFAULT_ELEMENT_STROKE_COLOR_PALETTE = {
      // 1st row
      transparent: COLOR_PALETTE.transparent,
      white: COLOR_PALETTE.white,
      gray: COLOR_PALETTE.gray,
      black: COLOR_PALETTE.black,
      bronze: COLOR_PALETTE.bronze,
      // rest
      ...COMMON_ELEMENT_SHADES
    };
    DEFAULT_ELEMENT_BACKGROUND_COLOR_PALETTE = {
      transparent: COLOR_PALETTE.transparent,
      white: COLOR_PALETTE.white,
      gray: COLOR_PALETTE.gray,
      black: COLOR_PALETTE.black,
      bronze: COLOR_PALETTE.bronze,
      ...COMMON_ELEMENT_SHADES
    };
    getAllColorsSpecificShade = (index) => [
      // 2nd row
      COLOR_PALETTE.cyan[index],
      COLOR_PALETTE.blue[index],
      COLOR_PALETTE.violet[index],
      COLOR_PALETTE.grape[index],
      COLOR_PALETTE.pink[index],
      // 3rd row
      COLOR_PALETTE.green[index],
      COLOR_PALETTE.teal[index],
      COLOR_PALETTE.yellow[index],
      COLOR_PALETTE.orange[index],
      COLOR_PALETTE.red[index]
    ];
    rgbToHex = (r, g, b) => `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;
  }
});

// constants.ts
var isDarwin, isWindows, isAndroid, isFirefox, isChrome, isSafari, isIOS, isBrave, APP_NAME, DRAGGING_THRESHOLD, LINE_CONFIRM_THRESHOLD, ELEMENT_SHIFT_TRANSLATE_AMOUNT, ELEMENT_TRANSLATE_AMOUNT, TEXT_TO_CENTER_SNAP_THRESHOLD, SHIFT_LOCKING_ANGLE, CURSOR_TYPE, POINTER_BUTTON, POINTER_EVENTS, YOUTUBE_STATES, ENV, CLASSES, FONT_FAMILY, THEME, FRAME_STYLE, WINDOWS_EMOJI_FALLBACK_FONT, MIN_FONT_SIZE, DEFAULT_FONT_SIZE, DEFAULT_FONT_FAMILY, DEFAULT_TEXT_ALIGN, DEFAULT_VERTICAL_ALIGN, DEFAULT_TRANSFORM_HANDLE_SPACING, GRID_SIZE, IMAGE_MIME_TYPES, ALLOWED_PASTE_MIME_TYPES, MIME_TYPES, EXPORT_IMAGE_TYPES, EXPORT_DATA_TYPES, EXPORT_SOURCE, IMAGE_RENDER_TIMEOUT, TAP_TWICE_TIMEOUT, TOUCH_CTX_MENU_TIMEOUT, SCROLL_TIMEOUT, ZOOM_STEP, MIN_ZOOM, HYPERLINK_TOOLTIP_DELAY, THEME_FILTER, URL_QUERY_KEYS, URL_HASH_KEYS, DEFAULT_UI_OPTIONS, MQ_MAX_WIDTH_PORTRAIT, MQ_MAX_WIDTH_LANDSCAPE, MQ_MAX_HEIGHT_LANDSCAPE, MQ_RIGHT_SIDEBAR_MIN_WIDTH, LIBRARY_SIDEBAR_WIDTH, MAX_DECIMALS_FOR_SVG_EXPORT, EXPORT_SCALES, DEFAULT_EXPORT_PADDING, DEFAULT_MAX_IMAGE_WIDTH_OR_HEIGHT, MAX_ALLOWED_FILE_BYTES, SVG_NS, VERSIONS, BOUND_TEXT_PADDING, ARROW_LABEL_WIDTH_FRACTION, ARROW_LABEL_FONT_SIZE_TO_MIN_WIDTH_RATIO, VERTICAL_ALIGN, TEXT_ALIGN, ELEMENT_READY_TO_ERASE_OPACITY, DEFAULT_PROPORTIONAL_RADIUS, DEFAULT_ADAPTIVE_RADIUS, ROUNDNESS, PRECEDING_ELEMENT_KEY, ROUGHNESS, STROKE_WIDTH, DEFAULT_ELEMENT_PROPS, LIBRARY_SIDEBAR_TAB, DEFAULT_SIDEBAR, LIBRARY_DISABLED_TYPES, TOOL_TYPE, EDITOR_LS_KEYS, DEFAULT_FILENAME;
var init_constants = __esm({
  "constants.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_variables_module();
    init_colors();
    isDarwin = /Mac|iPod|iPhone|iPad/.test(navigator.platform);
    isWindows = /^Win/.test(navigator.platform);
    isAndroid = /\b(android)\b/i.test(navigator.userAgent);
    isFirefox = "netscape" in window && navigator.userAgent.indexOf("rv:") > 1 && navigator.userAgent.indexOf("Gecko") > 1;
    isChrome = navigator.userAgent.indexOf("Chrome") !== -1;
    isSafari = !isChrome && navigator.userAgent.indexOf("Safari") !== -1;
    isIOS = /iPad|iPhone/.test(navigator.platform) || // iPadOS 13+
    navigator.userAgent.includes("Mac") && "ontouchend" in document;
    isBrave = () => navigator.brave?.isBrave?.name === "isBrave";
    APP_NAME = "Excalidraw";
    DRAGGING_THRESHOLD = 10;
    LINE_CONFIRM_THRESHOLD = 8;
    ELEMENT_SHIFT_TRANSLATE_AMOUNT = 5;
    ELEMENT_TRANSLATE_AMOUNT = 1;
    TEXT_TO_CENTER_SNAP_THRESHOLD = 30;
    SHIFT_LOCKING_ANGLE = Math.PI / 12;
    CURSOR_TYPE = {
      TEXT: "text",
      CROSSHAIR: "crosshair",
      GRABBING: "grabbing",
      GRAB: "grab",
      POINTER: "pointer",
      MOVE: "move",
      AUTO: ""
    };
    POINTER_BUTTON = {
      MAIN: 0,
      WHEEL: 1,
      SECONDARY: 2,
      TOUCH: -1,
      ERASER: 5
    };
    POINTER_EVENTS = {
      enabled: "all",
      disabled: "none",
      // asserted as any so it can be freely assigned to React Element
      // "pointerEnvets" CSS prop
      inheritFromUI: "var(--ui-pointerEvents)"
    };
    YOUTUBE_STATES = {
      UNSTARTED: -1,
      ENDED: 0,
      PLAYING: 1,
      PAUSED: 2,
      BUFFERING: 3,
      CUED: 5
    };
    ENV = {
      TEST: "test",
      DEVELOPMENT: "development"
    };
    CLASSES = {
      SHAPE_ACTIONS_MENU: "App-menu__left"
    };
    FONT_FAMILY = {
      Virgil: 1,
      Helvetica: 2,
      Cascadia: 3,
      Assistant: 4
    };
    THEME = {
      LIGHT: "light",
      DARK: "dark"
    };
    FRAME_STYLE = {
      strokeColor: "#bbb",
      strokeWidth: 2,
      strokeStyle: "solid",
      fillStyle: "solid",
      roughness: 0,
      roundness: null,
      backgroundColor: "transparent",
      radius: 8,
      nameOffsetY: 3,
      nameColorLightTheme: "#999999",
      nameColorDarkTheme: "#7a7a7a",
      nameFontSize: 14,
      nameLineHeight: 1.25
    };
    WINDOWS_EMOJI_FALLBACK_FONT = "Segoe UI Emoji";
    MIN_FONT_SIZE = 1;
    DEFAULT_FONT_SIZE = 20;
    DEFAULT_FONT_FAMILY = FONT_FAMILY.Virgil;
    DEFAULT_TEXT_ALIGN = "left";
    DEFAULT_VERTICAL_ALIGN = "top";
    DEFAULT_TRANSFORM_HANDLE_SPACING = 2;
    GRID_SIZE = 20;
    IMAGE_MIME_TYPES = {
      svg: "image/svg+xml",
      png: "image/png",
      jpg: "image/jpeg",
      gif: "image/gif",
      webp: "image/webp",
      bmp: "image/bmp",
      ico: "image/x-icon",
      avif: "image/avif",
      jfif: "image/jfif"
    };
    ALLOWED_PASTE_MIME_TYPES = ["text/plain", "text/html"];
    MIME_TYPES = {
      json: "application/json",
      // excalidraw data
      excalidraw: "application/vnd.excalidraw+json",
      excalidrawlib: "application/vnd.excalidrawlib+json",
      // image-encoded excalidraw data
      "excalidraw.svg": "image/svg+xml",
      "excalidraw.png": "image/png",
      // binary
      binary: "application/octet-stream",
      // image
      ...IMAGE_MIME_TYPES
    };
    EXPORT_IMAGE_TYPES = {
      png: "png",
      svg: "svg",
      clipboard: "clipboard"
    };
    EXPORT_DATA_TYPES = {
      excalidraw: "excalidraw",
      excalidrawClipboard: "excalidraw/clipboard",
      excalidrawLibrary: "excalidrawlib",
      excalidrawClipboardWithAPI: "excalidraw-api/clipboard"
    };
    EXPORT_SOURCE = window.EXCALIDRAW_EXPORT_SOURCE || window.location.origin;
    IMAGE_RENDER_TIMEOUT = 500;
    TAP_TWICE_TIMEOUT = 300;
    TOUCH_CTX_MENU_TIMEOUT = 500;
    SCROLL_TIMEOUT = 100;
    ZOOM_STEP = 0.1;
    MIN_ZOOM = 0.1;
    HYPERLINK_TOOLTIP_DELAY = 300;
    THEME_FILTER = variables_module_default.themeFilter;
    URL_QUERY_KEYS = {
      addLibrary: "addLibrary"
    };
    URL_HASH_KEYS = {
      addLibrary: "addLibrary"
    };
    DEFAULT_UI_OPTIONS = {
      canvasActions: {
        changeViewBackgroundColor: true,
        clearCanvas: true,
        export: { saveFileToDisk: true },
        loadScene: true,
        saveToActiveFile: true,
        toggleTheme: null,
        saveAsImage: true
      },
      tools: {
        image: true
      }
    };
    MQ_MAX_WIDTH_PORTRAIT = 730;
    MQ_MAX_WIDTH_LANDSCAPE = 1e3;
    MQ_MAX_HEIGHT_LANDSCAPE = 500;
    MQ_RIGHT_SIDEBAR_MIN_WIDTH = 1229;
    LIBRARY_SIDEBAR_WIDTH = parseInt(variables_module_default.rightSidebarWidth);
    MAX_DECIMALS_FOR_SVG_EXPORT = 2;
    EXPORT_SCALES = [1, 2, 3];
    DEFAULT_EXPORT_PADDING = 10;
    DEFAULT_MAX_IMAGE_WIDTH_OR_HEIGHT = 1440;
    MAX_ALLOWED_FILE_BYTES = 2 * 1024 * 1024;
    SVG_NS = "http://www.w3.org/2000/svg";
    VERSIONS = {
      excalidraw: 2,
      excalidrawLibrary: 2
    };
    BOUND_TEXT_PADDING = 5;
    ARROW_LABEL_WIDTH_FRACTION = 0.7;
    ARROW_LABEL_FONT_SIZE_TO_MIN_WIDTH_RATIO = 11;
    VERTICAL_ALIGN = {
      TOP: "top",
      MIDDLE: "middle",
      BOTTOM: "bottom"
    };
    TEXT_ALIGN = {
      LEFT: "left",
      CENTER: "center",
      RIGHT: "right"
    };
    ELEMENT_READY_TO_ERASE_OPACITY = 20;
    DEFAULT_PROPORTIONAL_RADIUS = 0.25;
    DEFAULT_ADAPTIVE_RADIUS = 32;
    ROUNDNESS = {
      // Used for legacy rounding (rectangles), which currently works the same
      // as PROPORTIONAL_RADIUS, but we need to differentiate for UI purposes and
      // forwards-compat.
      LEGACY: 1,
      // Used for linear elements & diamonds
      PROPORTIONAL_RADIUS: 2,
      // Current default algorithm for rectangles, using fixed pixel radius.
      // It's working similarly to a regular border-radius, but attemps to make
      // radius visually similar across differnt element sizes, especially
      // very large and very small elements.
      //
      // NOTE right now we don't allow configuration and use a constant radius
      // (see DEFAULT_ADAPTIVE_RADIUS constant)
      ADAPTIVE_RADIUS: 3
    };
    PRECEDING_ELEMENT_KEY = "__precedingElement__";
    ROUGHNESS = {
      architect: 0,
      artist: 1,
      cartoonist: 2
    };
    STROKE_WIDTH = {
      thin: 1,
      bold: 2,
      extraBold: 4
    };
    DEFAULT_ELEMENT_PROPS = {
      strokeColor: COLOR_PALETTE.black,
      backgroundColor: COLOR_PALETTE.transparent,
      fillStyle: "solid",
      strokeWidth: 2,
      strokeStyle: "solid",
      roughness: ROUGHNESS.artist,
      opacity: 100,
      locked: false
    };
    LIBRARY_SIDEBAR_TAB = "library";
    DEFAULT_SIDEBAR = {
      name: "default",
      defaultTab: LIBRARY_SIDEBAR_TAB
    };
    LIBRARY_DISABLED_TYPES = /* @__PURE__ */ new Set([
      "iframe",
      "embeddable",
      "image"
    ]);
    TOOL_TYPE = {
      selection: "selection",
      rectangle: "rectangle",
      diamond: "diamond",
      ellipse: "ellipse",
      arrow: "arrow",
      line: "line",
      freedraw: "freedraw",
      text: "text",
      image: "image",
      eraser: "eraser",
      hand: "hand",
      frame: "frame",
      magicframe: "magicframe",
      embeddable: "embeddable",
      laser: "laser"
    };
    EDITOR_LS_KEYS = {
      OAI_API_KEY: "excalidraw-oai-api-key",
      // legacy naming (non)scheme
      MERMAID_TO_EXCALIDRAW: "mermaid-to-excalidraw",
      PUBLISH_LIBRARY: "publish-library-data"
    };
    DEFAULT_FILENAME = "Untitled";
  }
});

// components/LoadingMessage.tsx
import { useState, useEffect } from "react";
import clsx from "clsx";
import { jsx as jsx2, jsxs } from "react/jsx-runtime";
var LoadingMessage;
var init_LoadingMessage = __esm({
  "components/LoadingMessage.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_i18n();
    init_Spinner2();
    init_constants();
    LoadingMessage = ({
      delay,
      theme
    }) => {
      const [isWaiting, setIsWaiting] = useState(!!delay);
      useEffect(() => {
        if (!delay) {
          return;
        }
        const timer = setTimeout(() => {
          setIsWaiting(false);
        }, delay);
        return () => clearTimeout(timer);
      }, [delay]);
      if (isWaiting) {
        return null;
      }
      return /* @__PURE__ */ jsxs(
        "div",
        {
          className: clsx("LoadingMessage", {
            "LoadingMessage--dark": theme === THEME.DARK
          }),
          children: [
            /* @__PURE__ */ jsx2("div", { children: /* @__PURE__ */ jsx2(Spinner_default, {}) }),
            /* @__PURE__ */ jsx2("div", { className: "LoadingMessage-text", children: t("labels.loadingScene") })
          ]
        }
      );
    };
  }
});

// components/InitializeApp.tsx
import { useEffect as useEffect2, useState as useState2 } from "react";
import { jsx as jsx3 } from "react/jsx-runtime";
var InitializeApp;
var init_InitializeApp = __esm({
  "components/InitializeApp.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_LoadingMessage();
    init_i18n();
    InitializeApp = (props) => {
      const [loading, setLoading] = useState2(true);
      useEffect2(() => {
        const updateLang = async () => {
          await setLanguage(currentLang2);
          setLoading(false);
        };
        const currentLang2 = languages.find((lang) => lang.code === props.langCode) || defaultLang;
        updateLang();
      }, [props.langCode]);
      return loading ? /* @__PURE__ */ jsx3(LoadingMessage, { theme: props.theme }) : props.children;
    };
  }
});

// utils.ts
function addEventListener(target, type, listener, options) {
  if (!target) {
    return () => {
    };
  }
  target?.addEventListener?.(type, listener, options);
  return () => {
    target?.removeEventListener?.(type, listener, options);
  };
}
function getSvgPathFromStroke(points, closed = true) {
  const len = points.length;
  if (len < 4) {
    return ``;
  }
  let a = points[0];
  let b = points[1];
  const c = points[2];
  let result = `M${a[0].toFixed(2)},${a[1].toFixed(2)} Q${b[0].toFixed(
    2
  )},${b[1].toFixed(2)} ${average(b[0], c[0]).toFixed(2)},${average(
    b[1],
    c[1]
  ).toFixed(2)} T`;
  for (let i = 2, max = len - 1; i < max; i++) {
    a = points[i];
    b = points[i + 1];
    result += `${average(a[0], b[0]).toFixed(2)},${average(a[1], b[1]).toFixed(
      2
    )} `;
  }
  if (closed) {
    result += "Z";
  }
  return result;
}
var mockDateTime, getDateTime, capitalizeString, isToolIcon, isInputLike, isInteractive, isWritableElement, getFontFamilyString, getFontString, debounce, throttleRAF, easeOut, easeOutInterpolate, easeToValuesRAF, chunk, distance, updateActiveTool, getShortcutKey, viewportCoordsToSceneCoords, sceneCoordsToViewportCoords, getGlobalCSSVariable, RS_LTR_CHARS, RS_RTL_CHARS, RE_RTL_CHECK, isRTL, tupleToCoors, muteFSAbortError, findIndex, findLastIndex, isTransparent, getNearestScrollableContainer, focusNearestParent, bytesToHexString, getUpdatedTimestamp, arrayToMap, arrayToMapWithIndex, isTestEnv, wrapEvent, updateObject, getFrame, isPromiseLike, queryFocusableElements, _defaultIsShallowComparatorFallback, isShallowEqual, composeEventHandlers, assertNever, memoize, isMemberOf, cloneJSON, isFiniteNumber, updateStable, average, normalizeEOL, toBrandedType;
var init_utils = __esm({
  "utils.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_colors();
    init_constants();
    mockDateTime = null;
    getDateTime = () => {
      if (mockDateTime) {
        return mockDateTime;
      }
      const date = /* @__PURE__ */ new Date();
      const year = date.getFullYear();
      const month = `${date.getMonth() + 1}`.padStart(2, "0");
      const day = `${date.getDate()}`.padStart(2, "0");
      const hr = `${date.getHours()}`.padStart(2, "0");
      const min = `${date.getMinutes()}`.padStart(2, "0");
      return `${year}-${month}-${day}-${hr}${min}`;
    };
    capitalizeString = (str) => str.charAt(0).toUpperCase() + str.slice(1);
    isToolIcon = (target) => target instanceof HTMLElement && target.className.includes("ToolIcon");
    isInputLike = (target) => target instanceof HTMLElement && target.dataset.type === "wysiwyg" || target instanceof HTMLBRElement || // newline in wysiwyg
    target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement || target instanceof HTMLSelectElement;
    isInteractive = (target) => {
      return isInputLike(target) || target instanceof Element && !!target.closest("label, button");
    };
    isWritableElement = (target) => target instanceof HTMLElement && target.dataset.type === "wysiwyg" || target instanceof HTMLBRElement || // newline in wysiwyg
    target instanceof HTMLTextAreaElement || target instanceof HTMLInputElement && (target.type === "text" || target.type === "number" || target.type === "password");
    getFontFamilyString = ({
      fontFamily
    }) => {
      for (const [fontFamilyString, id] of Object.entries(FONT_FAMILY)) {
        if (id === fontFamily) {
          return `${fontFamilyString}, ${WINDOWS_EMOJI_FALLBACK_FONT}`;
        }
      }
      return WINDOWS_EMOJI_FALLBACK_FONT;
    };
    getFontString = ({
      fontSize,
      fontFamily
    }) => {
      return `${fontSize}px ${getFontFamilyString({ fontFamily })}`;
    };
    debounce = (fn, timeout) => {
      let handle = 0;
      let lastArgs = null;
      const ret = (...args) => {
        lastArgs = args;
        clearTimeout(handle);
        handle = window.setTimeout(() => {
          lastArgs = null;
          fn(...args);
        }, timeout);
      };
      ret.flush = () => {
        clearTimeout(handle);
        if (lastArgs) {
          const _lastArgs = lastArgs;
          lastArgs = null;
          fn(..._lastArgs);
        }
      };
      ret.cancel = () => {
        lastArgs = null;
        clearTimeout(handle);
      };
      return ret;
    };
    throttleRAF = (fn, opts) => {
      let timerId = null;
      let lastArgs = null;
      let lastArgsTrailing = null;
      const scheduleFunc = (args) => {
        timerId = window.requestAnimationFrame(() => {
          timerId = null;
          fn(...args);
          lastArgs = null;
          if (lastArgsTrailing) {
            lastArgs = lastArgsTrailing;
            lastArgsTrailing = null;
            scheduleFunc(lastArgs);
          }
        });
      };
      const ret = (...args) => {
        if (define_import_meta_env_default.MODE === "test") {
          fn(...args);
          return;
        }
        lastArgs = args;
        if (timerId === null) {
          scheduleFunc(lastArgs);
        } else if (opts?.trailing) {
          lastArgsTrailing = args;
        }
      };
      ret.flush = () => {
        if (timerId !== null) {
          cancelAnimationFrame(timerId);
          timerId = null;
        }
        if (lastArgs) {
          fn(...lastArgsTrailing || lastArgs);
          lastArgs = lastArgsTrailing = null;
        }
      };
      ret.cancel = () => {
        lastArgs = lastArgsTrailing = null;
        if (timerId !== null) {
          cancelAnimationFrame(timerId);
          timerId = null;
        }
      };
      return ret;
    };
    easeOut = (k) => {
      return 1 - Math.pow(1 - k, 4);
    };
    easeOutInterpolate = (from3, to, progress) => {
      return (to - from3) * easeOut(progress) + from3;
    };
    easeToValuesRAF = ({
      fromValues,
      toValues,
      onStep,
      duration = 250,
      interpolateValue,
      onStart,
      onEnd,
      onCancel
    }) => {
      let canceled = false;
      let frameId = 0;
      let startTime;
      function step(timestamp) {
        if (canceled) {
          return;
        }
        if (startTime === void 0) {
          startTime = timestamp;
          onStart?.();
        }
        const elapsed = Math.min(timestamp - startTime, duration);
        const factor = easeOut(elapsed / duration);
        const newValues = {};
        Object.keys(fromValues).forEach((key) => {
          const _key = key;
          const result = (toValues[_key] - fromValues[_key]) * factor + fromValues[_key];
          newValues[_key] = result;
        });
        onStep(newValues);
        if (elapsed < duration) {
          const progress = elapsed / duration;
          const newValues2 = {};
          Object.keys(fromValues).forEach((key) => {
            const _key = key;
            const startValue = fromValues[_key];
            const endValue = toValues[_key];
            let result;
            result = interpolateValue ? interpolateValue(startValue, endValue, progress, _key) : easeOutInterpolate(startValue, endValue, progress);
            if (result == null) {
              result = easeOutInterpolate(startValue, endValue, progress);
            }
            newValues2[_key] = result;
          });
          onStep(newValues2);
          frameId = window.requestAnimationFrame(step);
        } else {
          onStep(toValues);
          onEnd?.();
        }
      }
      frameId = window.requestAnimationFrame(step);
      return () => {
        onCancel?.();
        canceled = true;
        window.cancelAnimationFrame(frameId);
      };
    };
    chunk = (array, size) => {
      if (!array.length || size < 1) {
        return [];
      }
      let index = 0;
      let resIndex = 0;
      const result = Array(Math.ceil(array.length / size));
      while (index < array.length) {
        result[resIndex++] = array.slice(index, index += size);
      }
      return result;
    };
    distance = (x, y) => Math.abs(x - y);
    updateActiveTool = (appState, data) => {
      if (data.type === "custom") {
        return {
          ...appState.activeTool,
          type: "custom",
          customType: data.customType,
          locked: data.locked ?? appState.activeTool.locked
        };
      }
      return {
        ...appState.activeTool,
        lastActiveTool: data.lastActiveToolBeforeEraser === void 0 ? appState.activeTool.lastActiveTool : data.lastActiveToolBeforeEraser,
        type: data.type,
        customType: null,
        locked: data.locked ?? appState.activeTool.locked
      };
    };
    getShortcutKey = (shortcut) => {
      shortcut = shortcut.replace(/\bAlt\b/i, "Alt").replace(/\bShift\b/i, "Shift").replace(/\b(Enter|Return)\b/i, "Enter");
      if (isDarwin) {
        return shortcut.replace(/\bCtrlOrCmd\b/gi, "Cmd").replace(/\bAlt\b/i, "Option");
      }
      return shortcut.replace(/\bCtrlOrCmd\b/gi, "Ctrl");
    };
    viewportCoordsToSceneCoords = ({ clientX, clientY }, {
      zoom,
      offsetLeft,
      offsetTop,
      scrollX,
      scrollY
    }) => {
      const x = (clientX - offsetLeft) / zoom.value - scrollX;
      const y = (clientY - offsetTop) / zoom.value - scrollY;
      return { x, y };
    };
    sceneCoordsToViewportCoords = ({ sceneX, sceneY }, {
      zoom,
      offsetLeft,
      offsetTop,
      scrollX,
      scrollY
    }) => {
      const x = (sceneX + scrollX) * zoom.value + offsetLeft;
      const y = (sceneY + scrollY) * zoom.value + offsetTop;
      return { x, y };
    };
    getGlobalCSSVariable = (name) => getComputedStyle(document.documentElement).getPropertyValue(`--${name}`);
    RS_LTR_CHARS = "A-Za-z\xC0-\xD6\xD8-\xF6\xF8-\u02B8\u0300-\u0590\u0800-\u1FFF\u2C00-\uFB1C\uFDFE-\uFE6F\uFEFD-\uFFFF";
    RS_RTL_CHARS = "\u0591-\u07FF\uFB1D-\uFDFD\uFE70-\uFEFC";
    RE_RTL_CHECK = new RegExp(`^[^${RS_LTR_CHARS}]*[${RS_RTL_CHARS}]`);
    isRTL = (text) => RE_RTL_CHECK.test(text);
    tupleToCoors = (xyTuple) => {
      const [x, y] = xyTuple;
      return { x, y };
    };
    muteFSAbortError = (error) => {
      if (error?.name === "AbortError") {
        console.warn(error);
        return;
      }
      throw error;
    };
    findIndex = (array, cb, fromIndex = 0) => {
      if (fromIndex < 0) {
        fromIndex = array.length + fromIndex;
      }
      fromIndex = Math.min(array.length, Math.max(fromIndex, 0));
      let index = fromIndex - 1;
      while (++index < array.length) {
        if (cb(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    };
    findLastIndex = (array, cb, fromIndex = array.length - 1) => {
      if (fromIndex < 0) {
        fromIndex = array.length + fromIndex;
      }
      fromIndex = Math.min(array.length - 1, Math.max(fromIndex, 0));
      let index = fromIndex + 1;
      while (--index > -1) {
        if (cb(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    };
    isTransparent = (color) => {
      const isRGBTransparent = color.length === 5 && color.substr(4, 1) === "0";
      const isRRGGBBTransparent = color.length === 9 && color.substr(7, 2) === "00";
      return isRGBTransparent || isRRGGBBTransparent || color === COLOR_PALETTE.transparent;
    };
    getNearestScrollableContainer = (element) => {
      let parent = element.parentElement;
      while (parent) {
        if (parent === document.body) {
          return document;
        }
        const { overflowY } = window.getComputedStyle(parent);
        const hasScrollableContent = parent.scrollHeight > parent.clientHeight;
        if (hasScrollableContent && (overflowY === "auto" || overflowY === "scroll" || overflowY === "overlay")) {
          return parent;
        }
        parent = parent.parentElement;
      }
      return document;
    };
    focusNearestParent = (element) => {
      let parent = element.parentElement;
      while (parent) {
        if (parent.tabIndex > -1) {
          parent.focus();
          return;
        }
        parent = parent.parentElement;
      }
    };
    bytesToHexString = (bytes) => {
      return Array.from(bytes).map((byte) => `0${byte.toString(16)}`.slice(-2)).join("");
    };
    getUpdatedTimestamp = () => isTestEnv() ? 1 : Date.now();
    arrayToMap = (items) => {
      if (items instanceof Map) {
        return items;
      }
      return items.reduce((acc, element) => {
        acc.set(typeof element === "string" ? element : element.id, element);
        return acc;
      }, /* @__PURE__ */ new Map());
    };
    arrayToMapWithIndex = (elements) => elements.reduce((acc, element, idx) => {
      acc.set(element.id, [element, idx]);
      return acc;
    }, /* @__PURE__ */ new Map());
    isTestEnv = () => define_import_meta_env_default.MODE === "test";
    wrapEvent = (name, nativeEvent) => {
      return new CustomEvent(name, {
        detail: {
          nativeEvent
        },
        cancelable: true
      });
    };
    updateObject = (obj, updates) => {
      let didChange = false;
      for (const key in updates) {
        const value = updates[key];
        if (typeof value !== "undefined") {
          if (obj[key] === value && // if object, always update because its attrs could have changed
          (typeof value !== "object" || value === null)) {
            continue;
          }
          didChange = true;
        }
      }
      if (!didChange) {
        return obj;
      }
      return {
        ...obj,
        ...updates
      };
    };
    getFrame = () => {
      try {
        return window.self === window.top ? "top" : "iframe";
      } catch (error) {
        return "iframe";
      }
    };
    isPromiseLike = (value) => {
      return !!value && typeof value === "object" && "then" in value && "catch" in value && "finally" in value;
    };
    queryFocusableElements = (container) => {
      const focusableElements = container?.querySelectorAll(
        "button, a, input, select, textarea, div[tabindex], label[tabindex]"
      );
      return focusableElements ? Array.from(focusableElements).filter(
        (element) => element.tabIndex > -1 && !element.disabled
      ) : [];
    };
    _defaultIsShallowComparatorFallback = (a, b) => {
      if (Array.isArray(a) && Array.isArray(b) && a.length === 0 && b.length === 0) {
        return true;
      }
      return a === b;
    };
    isShallowEqual = (objA, objB, comparators, debug = false) => {
      const aKeys = Object.keys(objA);
      const bKeys = Object.keys(objB);
      if (aKeys.length !== bKeys.length) {
        return false;
      }
      if (comparators && Array.isArray(comparators)) {
        for (const key of comparators) {
          const ret = objA[key] === objB[key] || _defaultIsShallowComparatorFallback(objA[key], objB[key]);
          if (!ret) {
            if (debug) {
              console.warn(
                `%cisShallowEqual: ${key} not equal ->`,
                "color: #8B4000",
                objA[key],
                objB[key]
              );
            }
            return false;
          }
        }
        return true;
      }
      return aKeys.every((key) => {
        const comparator = comparators?.[key];
        const ret = comparator ? comparator(objA[key], objB[key]) : objA[key] === objB[key] || _defaultIsShallowComparatorFallback(objA[key], objB[key]);
        if (!ret && debug) {
          console.warn(
            `%cisShallowEqual: ${key} not equal ->`,
            "color: #8B4000",
            objA[key],
            objB[key]
          );
        }
        return ret;
      });
    };
    composeEventHandlers = (originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) => {
      return function handleEvent(event) {
        originalEventHandler?.(event);
        if (!checkForDefaultPrevented || !event?.defaultPrevented) {
          return ourEventHandler?.(event);
        }
      };
    };
    assertNever = (value, message, softAssert) => {
      if (!message) {
        return value;
      }
      if (softAssert) {
        console.error(message);
        return value;
      }
      throw new Error(message);
    };
    memoize = (func) => {
      let lastArgs;
      let lastResult;
      const ret = function(opts) {
        const currentArgs = Object.entries(opts);
        if (lastArgs) {
          let argsAreEqual = true;
          for (const [key, value] of currentArgs) {
            if (lastArgs.get(key) !== value) {
              argsAreEqual = false;
              break;
            }
          }
          if (argsAreEqual) {
            return lastResult;
          }
        }
        const result = func(opts);
        lastArgs = new Map(currentArgs);
        lastResult = result;
        return result;
      };
      ret.clear = () => {
        lastArgs = void 0;
        lastResult = void 0;
      };
      return ret;
    };
    isMemberOf = (collection, value) => {
      return collection instanceof Set || collection instanceof Map ? collection.has(value) : "includes" in collection ? collection.includes(value) : collection.hasOwnProperty(value);
    };
    cloneJSON = (obj) => JSON.parse(JSON.stringify(obj));
    isFiniteNumber = (value) => {
      return typeof value === "number" && Number.isFinite(value);
    };
    updateStable = (prevValue, nextValue) => {
      if (isShallowEqual(prevValue, nextValue)) {
        return prevValue;
      }
      return nextValue;
    };
    average = (a, b) => (a + b) / 2;
    normalizeEOL = (str) => {
      return str.replace(/\r?\n|\r/g, "\n");
    };
    toBrandedType = (value) => {
      return value;
    };
  }
});

// element/typeChecks.ts
var isInitializedImageElement, isImageElement, isEmbeddableElement, isIframeElement, isIframeLikeElement, isTextElement, isFrameElement, isMagicFrameElement, isFrameLikeElement, isFreeDrawElement, isFreeDrawElementType, isLinearElement, isArrowElement, isLinearElementType, isBindingElement, isBindingElementType, isBindableElement, isTextBindableContainer, isExcalidrawElement, hasBoundTextElement, isBoundToContainer, isUsingAdaptiveRadius, isUsingProportionalRadius, canApplyRoundnessTypeToElement, getDefaultRoundnessTypeForElement;
var init_typeChecks = __esm({
  "element/typeChecks.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_constants();
    init_utils();
    isInitializedImageElement = (element) => {
      return !!element && element.type === "image" && !!element.fileId;
    };
    isImageElement = (element) => {
      return !!element && element.type === "image";
    };
    isEmbeddableElement = (element) => {
      return !!element && element.type === "embeddable";
    };
    isIframeElement = (element) => {
      return !!element && element.type === "iframe";
    };
    isIframeLikeElement = (element) => {
      return !!element && (element.type === "iframe" || element.type === "embeddable");
    };
    isTextElement = (element) => {
      return element != null && element.type === "text";
    };
    isFrameElement = (element) => {
      return element != null && element.type === "frame";
    };
    isMagicFrameElement = (element) => {
      return element != null && element.type === "magicframe";
    };
    isFrameLikeElement = (element) => {
      return element != null && (element.type === "frame" || element.type === "magicframe");
    };
    isFreeDrawElement = (element) => {
      return element != null && isFreeDrawElementType(element.type);
    };
    isFreeDrawElementType = (elementType) => {
      return elementType === "freedraw";
    };
    isLinearElement = (element) => {
      return element != null && isLinearElementType(element.type);
    };
    isArrowElement = (element) => {
      return element != null && element.type === "arrow";
    };
    isLinearElementType = (elementType) => {
      return elementType === "arrow" || elementType === "line";
    };
    isBindingElement = (element, includeLocked = true) => {
      return element != null && (!element.locked || includeLocked === true) && isBindingElementType(element.type);
    };
    isBindingElementType = (elementType) => {
      return elementType === "arrow";
    };
    isBindableElement = (element, includeLocked = true) => {
      return element != null && (!element.locked || includeLocked === true) && (element.type === "rectangle" || element.type === "diamond" || element.type === "ellipse" || element.type === "image" || element.type === "iframe" || element.type === "embeddable" || element.type === "frame" || element.type === "magicframe" || element.type === "text" && !element.containerId);
    };
    isTextBindableContainer = (element, includeLocked = true) => {
      return element != null && (!element.locked || includeLocked === true) && (element.type === "rectangle" || element.type === "diamond" || element.type === "ellipse" || isArrowElement(element));
    };
    isExcalidrawElement = (element) => {
      const type = element?.type;
      if (!type) {
        return false;
      }
      switch (type) {
        case "text":
        case "diamond":
        case "rectangle":
        case "iframe":
        case "embeddable":
        case "ellipse":
        case "arrow":
        case "freedraw":
        case "line":
        case "frame":
        case "magicframe":
        case "image":
        case "selection": {
          return true;
        }
        default: {
          assertNever(type, null);
          return false;
        }
      }
    };
    hasBoundTextElement = (element) => {
      return isTextBindableContainer(element) && !!element.boundElements?.some(({ type }) => type === "text");
    };
    isBoundToContainer = (element) => {
      return element !== null && "containerId" in element && element.containerId !== null && isTextElement(element);
    };
    isUsingAdaptiveRadius = (type) => type === "rectangle" || type === "embeddable" || type === "iframe" || type === "image";
    isUsingProportionalRadius = (type) => type === "line" || type === "arrow" || type === "diamond";
    canApplyRoundnessTypeToElement = (roundnessType, element) => {
      if ((roundnessType === ROUNDNESS.ADAPTIVE_RADIUS || // if legacy roundness, it can be applied to elements that currently
      // use adaptive radius
      roundnessType === ROUNDNESS.LEGACY) && isUsingAdaptiveRadius(element.type)) {
        return true;
      }
      if (roundnessType === ROUNDNESS.PROPORTIONAL_RADIUS && isUsingProportionalRadius(element.type)) {
        return true;
      }
      return false;
    };
    getDefaultRoundnessTypeForElement = (element) => {
      if (isUsingProportionalRadius(element.type)) {
        return {
          type: ROUNDNESS.PROPORTIONAL_RADIUS
        };
      }
      if (isUsingAdaptiveRadius(element.type)) {
        return {
          type: ROUNDNESS.ADAPTIVE_RADIUS
        };
      }
      return null;
    };
  }
});

// random.ts
import { Random } from "roughjs/bin/math";
import { nanoid } from "nanoid";
var random, testIdBase, randomInteger, randomId;
var init_random = __esm({
  "random.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_utils();
    random = new Random(Date.now());
    testIdBase = 0;
    randomInteger = () => Math.floor(random.next() * 2 ** 31);
    randomId = () => isTestEnv() ? `id${testIdBase++}` : nanoid();
  }
});

// scene/Scene.ts
var getNonDeletedElements, hashSelectionOpts, isIdKey, Scene, Scene_default;
var init_Scene = __esm({
  "scene/Scene.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_element();
    init_typeChecks();
    init_selection();
    init_random();
    init_utils();
    getNonDeletedElements = (allElements) => {
      const elementsMap = /* @__PURE__ */ new Map();
      const elements = [];
      for (const element of allElements) {
        if (!element.isDeleted) {
          elements.push(element);
          elementsMap.set(element.id, element);
        }
      }
      return { elementsMap, elements };
    };
    hashSelectionOpts = (opts) => {
      const keys = ["includeBoundTextElement", "includeElementsInFrames"];
      let hash = "";
      for (const key of keys) {
        hash += `${key}:${opts[key] ? "1" : "0"}`;
      }
      return hash;
    };
    isIdKey = (elementKey) => {
      if (typeof elementKey === "string") {
        return true;
      }
      return false;
    };
    Scene = class _Scene {
      // ---------------------------------------------------------------------------
      // static methods/props
      // ---------------------------------------------------------------------------
      static sceneMapByElement = /* @__PURE__ */ new WeakMap();
      static sceneMapById = /* @__PURE__ */ new Map();
      static mapElementToScene(elementKey, scene, mapElementIds = true) {
        if (isIdKey(elementKey)) {
          if (!mapElementIds) {
            return;
          }
          this.sceneMapById.set(elementKey, scene);
        } else {
          this.sceneMapByElement.set(elementKey, scene);
          if (!mapElementIds) {
            this.sceneMapById.set(elementKey.id, scene);
          }
        }
      }
      static getScene(elementKey) {
        if (isIdKey(elementKey)) {
          return this.sceneMapById.get(elementKey) || null;
        }
        return this.sceneMapByElement.get(elementKey) || null;
      }
      // ---------------------------------------------------------------------------
      // instance methods/props
      // ---------------------------------------------------------------------------
      callbacks = /* @__PURE__ */ new Set();
      nonDeletedElements = [];
      nonDeletedElementsMap = toBrandedType(
        /* @__PURE__ */ new Map()
      );
      elements = [];
      nonDeletedFramesLikes = [];
      frames = [];
      elementsMap = toBrandedType(/* @__PURE__ */ new Map());
      selectedElementsCache = {
        selectedElementIds: null,
        elements: null,
        cache: /* @__PURE__ */ new Map()
      };
      versionNonce;
      getElementsMapIncludingDeleted() {
        return this.elementsMap;
      }
      getNonDeletedElementsMap() {
        return this.nonDeletedElementsMap;
      }
      getElementsIncludingDeleted() {
        return this.elements;
      }
      getNonDeletedElements() {
        return this.nonDeletedElements;
      }
      getFramesIncludingDeleted() {
        return this.frames;
      }
      getSelectedElements(opts) {
        const hash = hashSelectionOpts(opts);
        const elements = opts?.elements || this.nonDeletedElements;
        if (this.selectedElementsCache.elements === elements && this.selectedElementsCache.selectedElementIds === opts.selectedElementIds) {
          const cached = this.selectedElementsCache.cache.get(hash);
          if (cached) {
            return cached;
          }
        } else if (opts?.elements == null) {
          this.selectedElementsCache.cache.clear();
        }
        const selectedElements = getSelectedElements(
          elements,
          { selectedElementIds: opts.selectedElementIds },
          opts
        );
        if (opts?.elements == null) {
          this.selectedElementsCache.selectedElementIds = opts.selectedElementIds;
          this.selectedElementsCache.elements = this.nonDeletedElements;
          this.selectedElementsCache.cache.set(hash, selectedElements);
        }
        return selectedElements;
      }
      getNonDeletedFramesLikes() {
        return this.nonDeletedFramesLikes;
      }
      getElement(id) {
        return this.elementsMap.get(id) || null;
      }
      getVersionNonce() {
        return this.versionNonce;
      }
      getNonDeletedElement(id) {
        const element = this.getElement(id);
        if (element && isNonDeletedElement(element)) {
          return element;
        }
        return null;
      }
      /**
       * A utility method to help with updating all scene elements, with the added
       * performance optimization of not renewing the array if no change is made.
       *
       * Maps all current excalidraw elements, invoking the callback for each
       * element. The callback should either return a new mapped element, or the
       * original element if no changes are made. If no changes are made to any
       * element, this results in a no-op. Otherwise, the newly mapped elements
       * are set as the next scene's elements.
       *
       * @returns whether a change was made
       */
      mapElements(iteratee) {
        let didChange = false;
        const newElements = this.elements.map((element) => {
          const nextElement = iteratee(element);
          if (nextElement !== element) {
            didChange = true;
          }
          return nextElement;
        });
        if (didChange) {
          this.replaceAllElements(newElements);
        }
        return didChange;
      }
      replaceAllElements(nextElements, mapElementIds = true) {
        this.elements = // ts doesn't like `Array.isArray` of `instanceof Map`
        nextElements instanceof Array ? nextElements : Array.from(nextElements.values());
        const nextFrameLikes = [];
        this.elementsMap.clear();
        this.elements.forEach((element) => {
          if (isFrameLikeElement(element)) {
            nextFrameLikes.push(element);
          }
          this.elementsMap.set(element.id, element);
          _Scene.mapElementToScene(element, this, mapElementIds);
        });
        const nonDeletedElements = getNonDeletedElements(this.elements);
        this.nonDeletedElements = nonDeletedElements.elements;
        this.nonDeletedElementsMap = nonDeletedElements.elementsMap;
        this.frames = nextFrameLikes;
        this.nonDeletedFramesLikes = getNonDeletedElements(this.frames).elements;
        this.informMutation();
      }
      informMutation() {
        this.versionNonce = randomInteger();
        for (const callback of Array.from(this.callbacks)) {
          callback();
        }
      }
      addCallback(cb) {
        if (this.callbacks.has(cb)) {
          throw new Error();
        }
        this.callbacks.add(cb);
        return () => {
          if (!this.callbacks.has(cb)) {
            throw new Error();
          }
          this.callbacks.delete(cb);
        };
      }
      destroy() {
        this.nonDeletedElements = [];
        this.elements = [];
        this.nonDeletedFramesLikes = [];
        this.frames = [];
        this.elementsMap.clear();
        this.selectedElementsCache.selectedElementIds = null;
        this.selectedElementsCache.elements = null;
        this.selectedElementsCache.cache.clear();
        _Scene.sceneMapById.forEach((scene, elementKey) => {
          if (scene === this) {
            _Scene.sceneMapById.delete(elementKey);
          }
        });
        this.callbacks.clear();
      }
      insertElementAtIndex(element, index) {
        if (!Number.isFinite(index) || index < 0) {
          throw new Error(
            "insertElementAtIndex can only be called with index >= 0"
          );
        }
        const nextElements = [
          ...this.elements.slice(0, index),
          element,
          ...this.elements.slice(index)
        ];
        this.replaceAllElements(nextElements);
      }
      insertElementsAtIndex(elements, index) {
        if (!Number.isFinite(index) || index < 0) {
          throw new Error(
            "insertElementAtIndex can only be called with index >= 0"
          );
        }
        const nextElements = [
          ...this.elements.slice(0, index),
          ...elements,
          ...this.elements.slice(index)
        ];
        this.replaceAllElements(nextElements);
      }
      addNewElement = (element) => {
        if (element.frameId) {
          this.insertElementAtIndex(element, this.getElementIndex(element.frameId));
        } else {
          this.replaceAllElements([...this.elements, element]);
        }
      };
      getElementIndex(elementId) {
        return this.elements.findIndex((element) => element.id === elementId);
      }
      getContainerElement = (element) => {
        if (!element) {
          return null;
        }
        if (element.containerId) {
          return this.getElement(element.containerId) || null;
        }
        return null;
      };
    };
    Scene_default = Scene;
  }
});

// points.ts
var getSizeFromPoints, rescalePoints;
var init_points = __esm({
  "points.ts"() {
    "use strict";
    init_define_import_meta_env();
    getSizeFromPoints = (points) => {
      const xs = points.map((point2) => point2[0]);
      const ys = points.map((point2) => point2[1]);
      return {
        width: Math.max(...xs) - Math.min(...xs),
        height: Math.max(...ys) - Math.min(...ys)
      };
    };
    rescalePoints = (dimension, newSize, points, normalize) => {
      const coordinates = points.map((point2) => point2[dimension]);
      const maxCoordinate = Math.max(...coordinates);
      const minCoordinate = Math.min(...coordinates);
      const size = maxCoordinate - minCoordinate;
      const scale = size === 0 ? 1 : newSize / size;
      let nextMinCoordinate = Infinity;
      const scaledPoints = points.map((point2) => {
        const newCoordinate = point2[dimension] * scale;
        const newPoint = [...point2];
        newPoint[dimension] = newCoordinate;
        if (newCoordinate < nextMinCoordinate) {
          nextMinCoordinate = newCoordinate;
        }
        return newPoint;
      });
      if (!normalize) {
        return scaledPoints;
      }
      if (scaledPoints.length === 2) {
        return scaledPoints;
      }
      const translation2 = minCoordinate - nextMinCoordinate;
      const nextPoints = scaledPoints.map(
        (scaledPoint) => scaledPoint.map((value, currentDimension) => {
          return currentDimension === dimension ? value + translation2 : value;
        })
      );
      return nextPoints;
    };
  }
});

// math.ts
var rotate, rotatePoint, adjustXYWithRotation, distance2d, centerPoint, isPathALoop, isPointInPolygon, isPointWithinBounds, orderedColinearOrientation, doSegmentsIntersect, getGridPoint, getCornerRadius, getControlPointsForBezierCurve, getBezierXY, getPointsInBezierCurve, getBezierCurveArcLengths, getBezierCurveLength, mapIntervalToBezierT, arePointsEqual, isRightAngle, rangesOverlap, rangeIntersection, isValueInRange;
var init_math = __esm({
  "math.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_constants();
    init_bounds();
    init_ShapeCache();
    rotate = (x, y, cx, cy, angle) => (
      // =()cos()sin+
      // =()sin+()cos+.
      // https://math.stackexchange.com/questions/2204520/how-do-i-rotate-a-line-segment-in-a-specific-point-on-the-line
      [
        (x - cx) * Math.cos(angle) - (y - cy) * Math.sin(angle) + cx,
        (x - cx) * Math.sin(angle) + (y - cy) * Math.cos(angle) + cy
      ]
    );
    rotatePoint = (point2, center, angle) => rotate(point2[0], point2[1], center[0], center[1], angle);
    adjustXYWithRotation = (sides, x, y, angle, deltaX1, deltaY1, deltaX2, deltaY2) => {
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      if (sides.e && sides.w) {
        x += deltaX1 + deltaX2;
      } else if (sides.e) {
        x += deltaX1 * (1 + cos);
        y += deltaX1 * sin;
        x += deltaX2 * (1 - cos);
        y += deltaX2 * -sin;
      } else if (sides.w) {
        x += deltaX1 * (1 - cos);
        y += deltaX1 * -sin;
        x += deltaX2 * (1 + cos);
        y += deltaX2 * sin;
      }
      if (sides.n && sides.s) {
        y += deltaY1 + deltaY2;
      } else if (sides.n) {
        x += deltaY1 * sin;
        y += deltaY1 * (1 - cos);
        x += deltaY2 * -sin;
        y += deltaY2 * (1 + cos);
      } else if (sides.s) {
        x += deltaY1 * -sin;
        y += deltaY1 * (1 + cos);
        x += deltaY2 * sin;
        y += deltaY2 * (1 - cos);
      }
      return [x, y];
    };
    distance2d = (x1, y1, x2, y2) => {
      const xd = x2 - x1;
      const yd = y2 - y1;
      return Math.hypot(xd, yd);
    };
    centerPoint = (a, b) => {
      return [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];
    };
    isPathALoop = (points, zoomValue = 1) => {
      if (points.length >= 3) {
        const [first, last] = [points[0], points[points.length - 1]];
        const distance3 = distance2d(first[0], first[1], last[0], last[1]);
        return distance3 <= LINE_CONFIRM_THRESHOLD / zoomValue;
      }
      return false;
    };
    isPointInPolygon = (points, x, y) => {
      const vertices = points.length;
      if (vertices < 3) {
        return false;
      }
      const extreme = [Number.MAX_SAFE_INTEGER, y];
      const p = [x, y];
      let count = 0;
      for (let i = 0; i < vertices; i++) {
        const current = points[i];
        const next = points[(i + 1) % vertices];
        if (doSegmentsIntersect(current, next, p, extreme)) {
          if (orderedColinearOrientation(current, p, next) === 0) {
            return isPointWithinBounds(current, p, next);
          }
          count++;
        }
      }
      return count % 2 === 1;
    };
    isPointWithinBounds = (p, q, r) => {
      return q[0] <= Math.max(p[0], r[0]) && q[0] >= Math.min(p[0], r[0]) && q[1] <= Math.max(p[1], r[1]) && q[1] >= Math.min(p[1], r[1]);
    };
    orderedColinearOrientation = (p, q, r) => {
      const val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);
      if (val === 0) {
        return 0;
      }
      return val > 0 ? 1 : 2;
    };
    doSegmentsIntersect = (p1, q1, p2, q2) => {
      const o1 = orderedColinearOrientation(p1, q1, p2);
      const o2 = orderedColinearOrientation(p1, q1, q2);
      const o3 = orderedColinearOrientation(p2, q2, p1);
      const o4 = orderedColinearOrientation(p2, q2, q1);
      if (o1 !== o2 && o3 !== o4) {
        return true;
      }
      if (o1 === 0 && isPointWithinBounds(p1, p2, q1)) {
        return true;
      }
      if (o2 === 0 && isPointWithinBounds(p1, q2, q1)) {
        return true;
      }
      if (o3 === 0 && isPointWithinBounds(p2, p1, q2)) {
        return true;
      }
      if (o4 === 0 && isPointWithinBounds(p2, q1, q2)) {
        return true;
      }
      return false;
    };
    getGridPoint = (x, y, gridSize) => {
      if (gridSize) {
        return [
          Math.round(x / gridSize) * gridSize,
          Math.round(y / gridSize) * gridSize
        ];
      }
      return [x, y];
    };
    getCornerRadius = (x, element) => {
      if (element.roundness?.type === ROUNDNESS.PROPORTIONAL_RADIUS || element.roundness?.type === ROUNDNESS.LEGACY) {
        return x * DEFAULT_PROPORTIONAL_RADIUS;
      }
      if (element.roundness?.type === ROUNDNESS.ADAPTIVE_RADIUS) {
        const fixedRadiusSize = element.roundness?.value ?? DEFAULT_ADAPTIVE_RADIUS;
        const CUTOFF_SIZE = fixedRadiusSize / DEFAULT_PROPORTIONAL_RADIUS;
        if (x <= CUTOFF_SIZE) {
          return x * DEFAULT_PROPORTIONAL_RADIUS;
        }
        return fixedRadiusSize;
      }
      return 0;
    };
    getControlPointsForBezierCurve = (element, endPoint) => {
      const shape = ShapeCache.generateElementShape(element, null);
      if (!shape) {
        return null;
      }
      const ops = getCurvePathOps(shape[0]);
      let currentP = [0, 0];
      let index = 0;
      let minDistance = Infinity;
      let controlPoints = null;
      while (index < ops.length) {
        const { op, data } = ops[index];
        if (op === "move") {
          currentP = data;
        }
        if (op === "bcurveTo") {
          const p0 = currentP;
          const p1 = [data[0], data[1]];
          const p2 = [data[2], data[3]];
          const p3 = [data[4], data[5]];
          const distance3 = distance2d(p3[0], p3[1], endPoint[0], endPoint[1]);
          if (distance3 < minDistance) {
            minDistance = distance3;
            controlPoints = [p0, p1, p2, p3];
          }
          currentP = p3;
        }
        index++;
      }
      return controlPoints;
    };
    getBezierXY = (p0, p1, p2, p3, t2) => {
      const equation2 = (t3, idx) => Math.pow(1 - t3, 3) * p3[idx] + 3 * t3 * Math.pow(1 - t3, 2) * p2[idx] + 3 * Math.pow(t3, 2) * (1 - t3) * p1[idx] + p0[idx] * Math.pow(t3, 3);
      const tx = equation2(t2, 0);
      const ty = equation2(t2, 1);
      return [tx, ty];
    };
    getPointsInBezierCurve = (element, endPoint) => {
      const controlPoints = getControlPointsForBezierCurve(
        element,
        endPoint
      );
      if (!controlPoints) {
        return [];
      }
      const pointsOnCurve = [];
      let t2 = 1;
      while (t2 > 0) {
        const point2 = getBezierXY(
          controlPoints[0],
          controlPoints[1],
          controlPoints[2],
          controlPoints[3],
          t2
        );
        pointsOnCurve.push([point2[0], point2[1]]);
        t2 -= 0.05;
      }
      if (pointsOnCurve.length) {
        if (arePointsEqual(pointsOnCurve.at(-1), endPoint)) {
          pointsOnCurve.push([endPoint[0], endPoint[1]]);
        }
      }
      return pointsOnCurve;
    };
    getBezierCurveArcLengths = (element, endPoint) => {
      const arcLengths = [];
      arcLengths[0] = 0;
      const points = getPointsInBezierCurve(element, endPoint);
      let index = 0;
      let distance3 = 0;
      while (index < points.length - 1) {
        const segmentDistance = distance2d(
          points[index][0],
          points[index][1],
          points[index + 1][0],
          points[index + 1][1]
        );
        distance3 += segmentDistance;
        arcLengths.push(distance3);
        index++;
      }
      return arcLengths;
    };
    getBezierCurveLength = (element, endPoint) => {
      const arcLengths = getBezierCurveArcLengths(element, endPoint);
      return arcLengths.at(-1);
    };
    mapIntervalToBezierT = (element, endPoint, interval) => {
      const arcLengths = getBezierCurveArcLengths(element, endPoint);
      const pointsCount = arcLengths.length - 1;
      const curveLength = arcLengths.at(-1);
      const targetLength = interval * curveLength;
      let low = 0;
      let high = pointsCount;
      let index = 0;
      while (low < high) {
        index = Math.floor(low + (high - low) / 2);
        if (arcLengths[index] < targetLength) {
          low = index + 1;
        } else {
          high = index;
        }
      }
      if (arcLengths[index] > targetLength) {
        index--;
      }
      if (arcLengths[index] === targetLength) {
        return index / pointsCount;
      }
      return 1 - (index + (targetLength - arcLengths[index]) / (arcLengths[index + 1] - arcLengths[index])) / pointsCount;
    };
    arePointsEqual = (p1, p2) => {
      return p1[0] === p2[0] && p1[1] === p2[1];
    };
    isRightAngle = (angle) => {
      return Math.round(angle / Math.PI * 1e4) % 5e3 === 0;
    };
    rangesOverlap = ([a0, a1], [b0, b1]) => {
      if (a0 <= b0) {
        return a1 >= b0;
      }
      if (a0 >= b0) {
        return b1 >= a0;
      }
      return false;
    };
    rangeIntersection = (rangeA, rangeB) => {
      const rangeStart = Math.max(rangeA[0], rangeB[0]);
      const rangeEnd = Math.min(rangeA[1], rangeB[1]);
      if (rangeStart <= rangeEnd) {
        return [rangeStart, rangeEnd];
      }
      return null;
    };
    isValueInRange = (value, min, max) => {
      return value >= min && value <= max;
    };
  }
});

// scene/comparisons.ts
var hasBackground, hasStrokeColor, hasStrokeWidth, hasStrokeStyle, canChangeRoundness, canHaveArrowheads, getElementAtPosition, getElementsAtPosition;
var init_comparisons = __esm({
  "scene/comparisons.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_typeChecks();
    hasBackground = (type) => type === "rectangle" || type === "iframe" || type === "embeddable" || type === "ellipse" || type === "diamond" || type === "line" || type === "freedraw";
    hasStrokeColor = (type) => type !== "image" && type !== "frame" && type !== "magicframe";
    hasStrokeWidth = (type) => type === "rectangle" || type === "iframe" || type === "embeddable" || type === "ellipse" || type === "diamond" || type === "freedraw" || type === "arrow" || type === "line";
    hasStrokeStyle = (type) => type === "rectangle" || type === "iframe" || type === "embeddable" || type === "ellipse" || type === "diamond" || type === "arrow" || type === "line";
    canChangeRoundness = (type) => type === "rectangle" || type === "iframe" || type === "embeddable" || type === "arrow" || type === "line" || type === "diamond" || type === "image";
    canHaveArrowheads = (type) => type === "arrow";
    getElementAtPosition = (elements, isAtPositionFn) => {
      let hitElement = null;
      for (let index = elements.length - 1; index >= 0; --index) {
        const element = elements[index];
        if (element.isDeleted) {
          continue;
        }
        if (isAtPositionFn(element)) {
          hitElement = element;
          break;
        }
      }
      return hitElement;
    };
    getElementsAtPosition = (elements, isAtPositionFn) => {
      const iframeLikes = [];
      const elsAtPos = elements.filter((element) => {
        const hit = !element.isDeleted && isAtPositionFn(element);
        if (hit) {
          if (isIframeElement(element)) {
            iframeLikes.push(element);
            return false;
          }
          return true;
        }
        return false;
      });
      return elsAtPos.concat(iframeLikes);
    };
  }
});

// scene/Shape.ts
import { simplify } from "points-on-curve";
function adjustRoughness(element) {
  const roughness = element.roughness;
  const maxSize = Math.max(element.width, element.height);
  const minSize = Math.min(element.width, element.height);
  if (
    // both sides relatively big
    minSize >= 20 && maxSize >= 50 || // is round & both sides above 15px
    minSize >= 15 && !!element.roundness && canChangeRoundness(element.type) || // relatively long linear element
    isLinearElement(element) && maxSize >= 50
  ) {
    return roughness;
  }
  return Math.min(roughness / (maxSize < 10 ? 3 : 2), 2.5);
}
var getDashArrayDashed, getDashArrayDotted, generateRoughOptions, modifyIframeLikeForRoughOptions, getArrowheadShapes, _generateElementShape;
var init_Shape = __esm({
  "scene/Shape.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_element();
    init_math();
    init_renderElement();
    init_utils();
    init_constants();
    init_typeChecks();
    init_comparisons();
    getDashArrayDashed = (strokeWidth) => [8, 8 + strokeWidth];
    getDashArrayDotted = (strokeWidth) => [1.5, 6 + strokeWidth];
    generateRoughOptions = (element, continuousPath = false) => {
      const options = {
        seed: element.seed,
        strokeLineDash: element.strokeStyle === "dashed" ? getDashArrayDashed(element.strokeWidth) : element.strokeStyle === "dotted" ? getDashArrayDotted(element.strokeWidth) : void 0,
        // for non-solid strokes, disable multiStroke because it tends to make
        // dashes/dots overlay each other
        disableMultiStroke: element.strokeStyle !== "solid",
        // for non-solid strokes, increase the width a bit to make it visually
        // similar to solid strokes, because we're also disabling multiStroke
        strokeWidth: element.strokeStyle !== "solid" ? element.strokeWidth + 0.5 : element.strokeWidth,
        // when increasing strokeWidth, we must explicitly set fillWeight and
        // hachureGap because if not specified, roughjs uses strokeWidth to
        // calculate them (and we don't want the fills to be modified)
        fillWeight: element.strokeWidth / 2,
        hachureGap: element.strokeWidth * 4,
        roughness: adjustRoughness(element),
        stroke: element.strokeColor,
        preserveVertices: continuousPath || element.roughness < ROUGHNESS.cartoonist
      };
      switch (element.type) {
        case "rectangle":
        case "iframe":
        case "embeddable":
        case "diamond":
        case "ellipse": {
          options.fillStyle = element.fillStyle;
          options.fill = isTransparent(element.backgroundColor) ? void 0 : element.backgroundColor;
          if (element.type === "ellipse") {
            options.curveFitting = 1;
          }
          return options;
        }
        case "line":
        case "freedraw": {
          if (isPathALoop(element.points)) {
            options.fillStyle = element.fillStyle;
            options.fill = element.backgroundColor === "transparent" ? void 0 : element.backgroundColor;
          }
          return options;
        }
        case "arrow":
          return options;
        default: {
          throw new Error(`Unimplemented type ${element.type}`);
        }
      }
    };
    modifyIframeLikeForRoughOptions = (element, isExporting, embedsValidationStatus) => {
      if (isIframeLikeElement(element) && (isExporting || isEmbeddableElement(element) && embedsValidationStatus?.get(element.id) !== true) && isTransparent(element.backgroundColor) && isTransparent(element.strokeColor)) {
        return {
          ...element,
          roughness: 0,
          backgroundColor: "#d3d3d3",
          fillStyle: "solid"
        };
      } else if (isIframeElement(element)) {
        return {
          ...element,
          strokeColor: isTransparent(element.strokeColor) ? "#000000" : element.strokeColor,
          backgroundColor: isTransparent(element.backgroundColor) ? "#f4f4f6" : element.backgroundColor
        };
      }
      return element;
    };
    getArrowheadShapes = (element, shape, position, arrowhead, generator, options, canvasBackgroundColor) => {
      const arrowheadPoints = getArrowheadPoints(
        element,
        shape,
        position,
        arrowhead
      );
      if (arrowheadPoints === null) {
        return [];
      }
      switch (arrowhead) {
        case "dot":
        case "circle":
        case "circle_outline": {
          const [x, y, diameter] = arrowheadPoints;
          delete options.strokeLineDash;
          return [
            generator.circle(x, y, diameter, {
              ...options,
              fill: arrowhead === "circle_outline" ? canvasBackgroundColor : element.strokeColor,
              fillStyle: "solid",
              stroke: element.strokeColor,
              roughness: Math.min(0.5, options.roughness || 0)
            })
          ];
        }
        case "triangle":
        case "triangle_outline": {
          const [x, y, x2, y2, x3, y3] = arrowheadPoints;
          delete options.strokeLineDash;
          return [
            generator.polygon(
              [
                [x, y],
                [x2, y2],
                [x3, y3],
                [x, y]
              ],
              {
                ...options,
                fill: arrowhead === "triangle_outline" ? canvasBackgroundColor : element.strokeColor,
                fillStyle: "solid",
                roughness: Math.min(1, options.roughness || 0)
              }
            )
          ];
        }
        case "diamond":
        case "diamond_outline": {
          const [x, y, x2, y2, x3, y3, x4, y4] = arrowheadPoints;
          delete options.strokeLineDash;
          return [
            generator.polygon(
              [
                [x, y],
                [x2, y2],
                [x3, y3],
                [x4, y4],
                [x, y]
              ],
              {
                ...options,
                fill: arrowhead === "diamond_outline" ? canvasBackgroundColor : element.strokeColor,
                fillStyle: "solid",
                roughness: Math.min(1, options.roughness || 0)
              }
            )
          ];
        }
        case "bar":
        case "arrow":
        default: {
          const [x2, y2, x3, y3, x4, y4] = arrowheadPoints;
          if (element.strokeStyle === "dotted") {
            const dash = getDashArrayDotted(element.strokeWidth - 1);
            options.strokeLineDash = [dash[0], dash[1] - 1];
          } else {
            delete options.strokeLineDash;
          }
          options.roughness = Math.min(1, options.roughness || 0);
          return [
            generator.line(x3, y3, x2, y2, options),
            generator.line(x4, y4, x2, y2, options)
          ];
        }
      }
    };
    _generateElementShape = (element, generator, {
      isExporting,
      canvasBackgroundColor,
      embedsValidationStatus
    }) => {
      switch (element.type) {
        case "rectangle":
        case "iframe":
        case "embeddable": {
          let shape;
          if (element.roundness) {
            const w = element.width;
            const h = element.height;
            const r = getCornerRadius(Math.min(w, h), element);
            shape = generator.path(
              `M ${r} 0 L ${w - r} 0 Q ${w} 0, ${w} ${r} L ${w} ${h - r} Q ${w} ${h}, ${w - r} ${h} L ${r} ${h} Q 0 ${h}, 0 ${h - r} L 0 ${r} Q 0 0, ${r} 0`,
              generateRoughOptions(
                modifyIframeLikeForRoughOptions(
                  element,
                  isExporting,
                  embedsValidationStatus
                ),
                true
              )
            );
          } else {
            shape = generator.rectangle(
              0,
              0,
              element.width,
              element.height,
              generateRoughOptions(
                modifyIframeLikeForRoughOptions(
                  element,
                  isExporting,
                  embedsValidationStatus
                ),
                false
              )
            );
          }
          return shape;
        }
        case "diamond": {
          let shape;
          const [topX, topY, rightX, rightY, bottomX, bottomY, leftX, leftY] = getDiamondPoints(element);
          if (element.roundness) {
            const verticalRadius = getCornerRadius(Math.abs(topX - leftX), element);
            const horizontalRadius = getCornerRadius(
              Math.abs(rightY - topY),
              element
            );
            shape = generator.path(
              `M ${topX + verticalRadius} ${topY + horizontalRadius} L ${rightX - verticalRadius} ${rightY - horizontalRadius}
            C ${rightX} ${rightY}, ${rightX} ${rightY}, ${rightX - verticalRadius} ${rightY + horizontalRadius}
            L ${bottomX + verticalRadius} ${bottomY - horizontalRadius}
            C ${bottomX} ${bottomY}, ${bottomX} ${bottomY}, ${bottomX - verticalRadius} ${bottomY - horizontalRadius}
            L ${leftX + verticalRadius} ${leftY + horizontalRadius}
            C ${leftX} ${leftY}, ${leftX} ${leftY}, ${leftX + verticalRadius} ${leftY - horizontalRadius}
            L ${topX - verticalRadius} ${topY + horizontalRadius}
            C ${topX} ${topY}, ${topX} ${topY}, ${topX + verticalRadius} ${topY + horizontalRadius}`,
              generateRoughOptions(element, true)
            );
          } else {
            shape = generator.polygon(
              [
                [topX, topY],
                [rightX, rightY],
                [bottomX, bottomY],
                [leftX, leftY]
              ],
              generateRoughOptions(element)
            );
          }
          return shape;
        }
        case "ellipse": {
          const shape = generator.ellipse(
            element.width / 2,
            element.height / 2,
            element.width,
            element.height,
            generateRoughOptions(element)
          );
          return shape;
        }
        case "line":
        case "arrow": {
          let shape;
          const options = generateRoughOptions(element);
          const points = element.points.length ? element.points : [[0, 0]];
          if (!element.roundness) {
            if (options.fill) {
              shape = [generator.polygon(points, options)];
            } else {
              shape = [generator.linearPath(points, options)];
            }
          } else {
            shape = [generator.curve(points, options)];
          }
          if (element.type === "arrow") {
            const { startArrowhead = null, endArrowhead = "arrow" } = element;
            if (startArrowhead !== null) {
              const shapes = getArrowheadShapes(
                element,
                shape,
                "start",
                startArrowhead,
                generator,
                options,
                canvasBackgroundColor
              );
              shape.push(...shapes);
            }
            if (endArrowhead !== null) {
              if (endArrowhead === void 0) {
              }
              const shapes = getArrowheadShapes(
                element,
                shape,
                "end",
                endArrowhead,
                generator,
                options,
                canvasBackgroundColor
              );
              shape.push(...shapes);
            }
          }
          return shape;
        }
        case "freedraw": {
          let shape;
          generateFreeDrawShape(element);
          if (isPathALoop(element.points)) {
            const simplifiedPoints = simplify(element.points, 0.75);
            shape = generator.curve(simplifiedPoints, {
              ...generateRoughOptions(element),
              stroke: "none"
            });
          } else {
            shape = null;
          }
          return shape;
        }
        case "frame":
        case "magicframe":
        case "text":
        case "image": {
          const shape = null;
          return shape;
        }
        default: {
          assertNever(
            element,
            `generateElementShape(): Unimplemented type ${element?.type}`
          );
          return null;
        }
      }
    };
  }
});

// ga.ts
var point, offset, nvector, reverse, add, sub, mul, mulScalar, meet, join, joinScalar, dot, norm, inorm, normalized, inormalized, isNumber, E0, E1, E2, E01, E20, E12, E012;
var init_ga = __esm({
  "ga.ts"() {
    "use strict";
    init_define_import_meta_env();
    point = (x, y) => [0, 0, 0, 0, y, x, 1, 0];
    offset = (x, y) => [
      0,
      0,
      0,
      0,
      y,
      x,
      0,
      0
    ];
    nvector = (value = 0, index = 0) => {
      const result = [0, 0, 0, 0, 0, 0, 0, 0];
      if (index < 0 || index > 7) {
        throw new Error(`Expected \`index\` between 0 and 7, got \`${index}\``);
      }
      if (value !== 0) {
        result[index] = value;
      }
      return result;
    };
    reverse = (nvector2) => [
      nvector2[0],
      nvector2[1],
      nvector2[2],
      nvector2[3],
      -nvector2[4],
      -nvector2[5],
      -nvector2[6],
      -nvector2[7]
    ];
    add = (a, b) => {
      if (isNumber(b)) {
        return [a[0] + b, a[1], a[2], a[3], a[4], a[5], a[6], a[7]];
      }
      return [
        a[0] + b[0],
        a[1] + b[1],
        a[2] + b[2],
        a[3] + b[3],
        a[4] + b[4],
        a[5] + b[5],
        a[6] + b[6],
        a[7] + b[7]
      ];
    };
    sub = (a, b) => {
      if (isNumber(b)) {
        return [a[0] - b, a[1], a[2], a[3], a[4], a[5], a[6], a[7]];
      }
      return [
        a[0] - b[0],
        a[1] - b[1],
        a[2] - b[2],
        a[3] - b[3],
        a[4] - b[4],
        a[5] - b[5],
        a[6] - b[6],
        a[7] - b[7]
      ];
    };
    mul = (a, b) => {
      if (isNumber(b)) {
        return [
          a[0] * b,
          a[1] * b,
          a[2] * b,
          a[3] * b,
          a[4] * b,
          a[5] * b,
          a[6] * b,
          a[7] * b
        ];
      }
      return [
        mulScalar(a, b),
        b[1] * a[0] + b[0] * a[1] - b[4] * a[2] + b[5] * a[3] + b[2] * a[4] - b[3] * a[5] - b[7] * a[6] - b[6] * a[7],
        b[2] * a[0] + b[0] * a[2] - b[6] * a[3] + b[3] * a[6],
        b[3] * a[0] + b[6] * a[2] + b[0] * a[3] - b[2] * a[6],
        b[4] * a[0] + b[2] * a[1] - b[1] * a[2] + b[7] * a[3] + b[0] * a[4] + b[6] * a[5] - b[5] * a[6] + b[3] * a[7],
        b[5] * a[0] - b[3] * a[1] + b[7] * a[2] + b[1] * a[3] - b[6] * a[4] + b[0] * a[5] + b[4] * a[6] + b[2] * a[7],
        b[6] * a[0] + b[3] * a[2] - b[2] * a[3] + b[0] * a[6],
        b[7] * a[0] + b[6] * a[1] + b[5] * a[2] + b[4] * a[3] + b[3] * a[4] + b[2] * a[5] + b[1] * a[6] + b[0] * a[7]
      ];
    };
    mulScalar = (a, b) => b[0] * a[0] + b[2] * a[2] + b[3] * a[3] - b[6] * a[6];
    meet = (a, b) => [
      b[0] * a[0],
      b[1] * a[0] + b[0] * a[1],
      b[2] * a[0] + b[0] * a[2],
      b[3] * a[0] + b[0] * a[3],
      b[4] * a[0] + b[2] * a[1] - b[1] * a[2] + b[0] * a[4],
      b[5] * a[0] - b[3] * a[1] + b[1] * a[3] + b[0] * a[5],
      b[6] * a[0] + b[3] * a[2] - b[2] * a[3] + b[0] * a[6],
      b[7] * a[0] + b[6] * a[1] + b[5] * a[2] + b[4] * a[3] + b[3] * a[4] + b[2] * a[5] + b[1] * a[6]
    ];
    join = (a, b) => [
      joinScalar(a, b),
      a[1] * b[7] + a[4] * b[5] - a[5] * b[4] + a[7] * b[1],
      a[2] * b[7] - a[4] * b[6] + a[6] * b[4] + a[7] * b[2],
      a[3] * b[7] + a[5] * b[6] - a[6] * b[5] + a[7] * b[3],
      a[4] * b[7] + a[7] * b[4],
      a[5] * b[7] + a[7] * b[5],
      a[6] * b[7] + a[7] * b[6],
      a[7] * b[7]
    ];
    joinScalar = (a, b) => a[0] * b[7] + a[1] * b[6] + a[2] * b[5] + a[3] * b[4] + a[4] * b[3] + a[5] * b[2] + a[6] * b[1] + a[7] * b[0];
    dot = (a, b) => [
      b[0] * a[0] + b[2] * a[2] + b[3] * a[3] - b[6] * a[6],
      b[1] * a[0] + b[0] * a[1] - b[4] * a[2] + b[5] * a[3] + b[2] * a[4] - b[3] * a[5] - b[7] * a[6] - b[6] * a[7],
      b[2] * a[0] + b[0] * a[2] - b[6] * a[3] + b[3] * a[6],
      b[3] * a[0] + b[6] * a[2] + b[0] * a[3] - b[2] * a[6],
      b[4] * a[0] + b[7] * a[3] + b[0] * a[4] + b[3] * a[7],
      b[5] * a[0] + b[7] * a[2] + b[0] * a[5] + b[2] * a[7],
      b[6] * a[0] + b[0] * a[6],
      b[7] * a[0] + b[0] * a[7]
    ];
    norm = (a) => Math.sqrt(Math.abs(a[0] * a[0] - a[2] * a[2] - a[3] * a[3] + a[6] * a[6]));
    inorm = (a) => Math.sqrt(Math.abs(a[7] * a[7] - a[5] * a[5] - a[4] * a[4] + a[1] * a[1]));
    normalized = (a) => {
      const n = norm(a);
      if (n === 0 || n === 1) {
        return a;
      }
      const sign2 = a[6] < 0 ? -1 : 1;
      return mul(a, sign2 / n);
    };
    inormalized = (a) => {
      const n = inorm(a);
      if (n === 0 || n === 1) {
        return a;
      }
      return mul(a, 1 / n);
    };
    isNumber = (a) => typeof a === "number";
    E0 = nvector(1, 1);
    E1 = nvector(1, 2);
    E2 = nvector(1, 3);
    E01 = nvector(1, 4);
    E20 = nvector(1, 5);
    E12 = nvector(1, 6);
    E012 = nvector(1, 7);
  }
});

// galines.ts
var equation, through, orthogonal, orthogonalThrough, sign;
var init_galines = __esm({
  "galines.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_ga();
    equation = (a, b, c) => normalized([0, c, a, b, 0, 0, 0, 0]);
    through = (from3, to) => normalized(join(to, from3));
    orthogonal = (line, point2) => dot(line, point2);
    orthogonalThrough = (against, intersection) => orthogonal(through(against, intersection), intersection);
    sign = (line) => Math.sign(line[1]);
  }
});

// gapoints.ts
var from, toTuple, abs, intersect, distance2, distanceToLine;
var init_gapoints = __esm({
  "gapoints.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_ga();
    init_galines();
    init_ga();
    from = ([x, y]) => [
      0,
      0,
      0,
      0,
      y,
      x,
      1,
      0
    ];
    toTuple = (point2) => [point2[5], point2[4]];
    abs = (point2) => [
      0,
      0,
      0,
      0,
      Math.abs(point2[4]),
      Math.abs(point2[5]),
      1,
      0
    ];
    intersect = (line1, line2) => normalized(meet(line1, line2));
    distance2 = (point1, point2) => norm(join(point1, point2));
    distanceToLine = (point2, line) => joinScalar(point2, line);
  }
});

// gadirections.ts
var from2, fromTo;
var init_gadirections = __esm({
  "gadirections.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_ga();
    from2 = (point2) => [
      0,
      0,
      0,
      0,
      point2[4],
      point2[5],
      0,
      0
    ];
    fromTo = (from3, to) => inormalized([0, 0, 0, 0, to[4] - from3[4], to[5] - from3[5], 0, 0]);
  }
});

// gatransforms.ts
var rotation, translation, translationOrthogonal, compose, apply;
var init_gatransforms = __esm({
  "gatransforms.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_ga();
    init_gadirections();
    rotation = (pivot, angle) => add(mul(pivot, Math.sin(angle / 2)), Math.cos(angle / 2));
    translation = (direction) => [
      1,
      0,
      0,
      0,
      -(0.5 * direction[5]),
      0.5 * direction[4],
      0,
      0
    ];
    translationOrthogonal = (direction, distance3) => {
      const scale = 0.5 * distance3;
      return [1, 0, 0, 0, scale * direction[4], scale * direction[5], 0, 0];
    };
    compose = (motor1, motor2) => mul(motor2, motor1);
    apply = (motor, nvector2) => normalized(mul(mul(motor, nvector2), reverse(motor)));
  }
});

// element/transformHandles.ts
var transformHandleSizes, ROTATION_RESIZE_HANDLE_GAP, OMIT_SIDES_FOR_MULTIPLE_ELEMENTS, OMIT_SIDES_FOR_FRAME, OMIT_SIDES_FOR_TEXT_ELEMENT, OMIT_SIDES_FOR_LINE_SLASH, OMIT_SIDES_FOR_LINE_BACKSLASH, generateTransformHandle, getTransformHandlesFromCoords, getTransformHandles, shouldShowBoundingBox;
var init_transformHandles = __esm({
  "element/transformHandles.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_bounds();
    init_math();
    init_element();
    init_typeChecks();
    init_constants();
    transformHandleSizes = {
      mouse: 8,
      pen: 16,
      touch: 28
    };
    ROTATION_RESIZE_HANDLE_GAP = 16;
    OMIT_SIDES_FOR_MULTIPLE_ELEMENTS = {
      e: true,
      s: true,
      n: true,
      w: true
    };
    OMIT_SIDES_FOR_FRAME = {
      e: true,
      s: true,
      n: true,
      w: true,
      rotation: true
    };
    OMIT_SIDES_FOR_TEXT_ELEMENT = {
      e: true,
      s: true,
      n: true,
      w: true
    };
    OMIT_SIDES_FOR_LINE_SLASH = {
      e: true,
      s: true,
      n: true,
      w: true,
      nw: true,
      se: true
    };
    OMIT_SIDES_FOR_LINE_BACKSLASH = {
      e: true,
      s: true,
      n: true,
      w: true
    };
    generateTransformHandle = (x, y, width, height, cx, cy, angle) => {
      const [xx, yy] = rotate(x + width / 2, y + height / 2, cx, cy, angle);
      return [xx - width / 2, yy - height / 2, width, height];
    };
    getTransformHandlesFromCoords = ([x1, y1, x2, y2, cx, cy], angle, zoom, pointerType, omitSides = {}, margin = 4) => {
      const size = transformHandleSizes[pointerType];
      const handleWidth = size / zoom.value;
      const handleHeight = size / zoom.value;
      const handleMarginX = size / zoom.value;
      const handleMarginY = size / zoom.value;
      const width = x2 - x1;
      const height = y2 - y1;
      const dashedLineMargin = margin / zoom.value;
      const centeringOffset = (size - DEFAULT_TRANSFORM_HANDLE_SPACING * 2) / (2 * zoom.value);
      const transformHandles = {
        nw: omitSides.nw ? void 0 : generateTransformHandle(
          x1 - dashedLineMargin - handleMarginX + centeringOffset,
          y1 - dashedLineMargin - handleMarginY + centeringOffset,
          handleWidth,
          handleHeight,
          cx,
          cy,
          angle
        ),
        ne: omitSides.ne ? void 0 : generateTransformHandle(
          x2 + dashedLineMargin - centeringOffset,
          y1 - dashedLineMargin - handleMarginY + centeringOffset,
          handleWidth,
          handleHeight,
          cx,
          cy,
          angle
        ),
        sw: omitSides.sw ? void 0 : generateTransformHandle(
          x1 - dashedLineMargin - handleMarginX + centeringOffset,
          y2 + dashedLineMargin - centeringOffset,
          handleWidth,
          handleHeight,
          cx,
          cy,
          angle
        ),
        se: omitSides.se ? void 0 : generateTransformHandle(
          x2 + dashedLineMargin - centeringOffset,
          y2 + dashedLineMargin - centeringOffset,
          handleWidth,
          handleHeight,
          cx,
          cy,
          angle
        ),
        rotation: omitSides.rotation ? void 0 : generateTransformHandle(
          x1 + width / 2 - handleWidth / 2,
          y1 - dashedLineMargin - handleMarginY + centeringOffset - ROTATION_RESIZE_HANDLE_GAP / zoom.value,
          handleWidth,
          handleHeight,
          cx,
          cy,
          angle
        )
      };
      const minimumSizeForEightHandles = 5 * transformHandleSizes.mouse / zoom.value;
      if (Math.abs(width) > minimumSizeForEightHandles) {
        if (!omitSides.n) {
          transformHandles.n = generateTransformHandle(
            x1 + width / 2 - handleWidth / 2,
            y1 - dashedLineMargin - handleMarginY + centeringOffset,
            handleWidth,
            handleHeight,
            cx,
            cy,
            angle
          );
        }
        if (!omitSides.s) {
          transformHandles.s = generateTransformHandle(
            x1 + width / 2 - handleWidth / 2,
            y2 + dashedLineMargin - centeringOffset,
            handleWidth,
            handleHeight,
            cx,
            cy,
            angle
          );
        }
      }
      if (Math.abs(height) > minimumSizeForEightHandles) {
        if (!omitSides.w) {
          transformHandles.w = generateTransformHandle(
            x1 - dashedLineMargin - handleMarginX + centeringOffset,
            y1 + height / 2 - handleHeight / 2,
            handleWidth,
            handleHeight,
            cx,
            cy,
            angle
          );
        }
        if (!omitSides.e) {
          transformHandles.e = generateTransformHandle(
            x2 + dashedLineMargin - centeringOffset,
            y1 + height / 2 - handleHeight / 2,
            handleWidth,
            handleHeight,
            cx,
            cy,
            angle
          );
        }
      }
      return transformHandles;
    };
    getTransformHandles = (element, zoom, elementsMap, pointerType = "mouse") => {
      if (element.locked) {
        return {};
      }
      let omitSides = {};
      if (element.type === "freedraw" || isLinearElement(element)) {
        if (element.points.length === 2) {
          const [, p1] = element.points;
          if (p1[0] === 0 || p1[1] === 0) {
            omitSides = OMIT_SIDES_FOR_LINE_BACKSLASH;
          } else if (p1[0] > 0 && p1[1] < 0) {
            omitSides = OMIT_SIDES_FOR_LINE_SLASH;
          } else if (p1[0] > 0 && p1[1] > 0) {
            omitSides = OMIT_SIDES_FOR_LINE_BACKSLASH;
          } else if (p1[0] < 0 && p1[1] > 0) {
            omitSides = OMIT_SIDES_FOR_LINE_SLASH;
          } else if (p1[0] < 0 && p1[1] < 0) {
            omitSides = OMIT_SIDES_FOR_LINE_BACKSLASH;
          }
        }
      } else if (isTextElement(element)) {
        omitSides = OMIT_SIDES_FOR_TEXT_ELEMENT;
      } else if (isFrameLikeElement(element)) {
        omitSides = {
          rotation: true
        };
      }
      const dashedLineMargin = isLinearElement(element) ? DEFAULT_TRANSFORM_HANDLE_SPACING + 8 : DEFAULT_TRANSFORM_HANDLE_SPACING;
      return getTransformHandlesFromCoords(
        getElementAbsoluteCoords(element, elementsMap, true),
        element.angle,
        zoom,
        pointerType,
        omitSides,
        dashedLineMargin
      );
    };
    shouldShowBoundingBox = (elements, appState) => {
      if (appState.editingLinearElement) {
        return false;
      }
      if (elements.length > 1) {
        return true;
      }
      const element = elements[0];
      if (!isLinearElement(element)) {
        return true;
      }
      return element.points.length > 2;
    };
  }
});

// element/collision.ts
import { pointsOnBezierCurves } from "points-on-curve";
var isElementDraggableFromInside, hitTest, isHittingElementBoundingBoxWithoutHittingElement, isHittingElementNotConsideringBoundingBox, isElementSelected, isPointHittingElementBoundingBox, bindingBorderTest, maxBindingGap, hitTestPointAgainstElement, distanceToBindableElement, isStrictlyInside, isInsideCheck, isNearCheck, isOutsideCheck, distanceToRectangle, distanceToRectangleBox, distanceToDiamond, distanceToEllipse, ellipseParamsForTest, hitTestFreeDrawElement, hitTestLinear, pointRelativeToElement, pointRelativeToDivElement, relativizationToElementCenter, coordsCenter, determineFocusDistance, determineFocusPoint, intersectElementWithLine, getSortedElementLineIntersections, getCorners, intersectSegment, offsetSegment, getEllipseIntersections, getCircleIntersections, findFocusPointForEllipse, findFocusPointForRectangulars, pointInBezierEquation, hitTestCurveInside, hitTestRoughShape;
var init_collision = __esm({
  "element/collision.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_ga();
    init_gapoints();
    init_gadirections();
    init_galines();
    init_gatransforms();
    init_math();
    init_bounds();
    init_typeChecks();
    init_element();
    init_utils();
    init_transformHandles();
    init_textElement();
    init_ShapeCache();
    isElementDraggableFromInside = (element) => {
      if (element.type === "arrow") {
        return false;
      }
      if (element.type === "freedraw") {
        return true;
      }
      const isDraggableFromInside = !isTransparent(element.backgroundColor) || hasBoundTextElement(element) || isIframeLikeElement(element);
      if (element.type === "line") {
        return isDraggableFromInside && isPathALoop(element.points);
      }
      return isDraggableFromInside || isImageElement(element);
    };
    hitTest = (element, appState, frameNameBoundsCache, x, y, elementsMap) => {
      const threshold = 10 / appState.zoom.value;
      const point2 = [x, y];
      if (isElementSelected(appState, element) && shouldShowBoundingBox([element], appState)) {
        return isPointHittingElementBoundingBox(
          element,
          elementsMap,
          point2,
          threshold,
          frameNameBoundsCache
        );
      }
      const boundTextElement = getBoundTextElement(element, elementsMap);
      if (boundTextElement) {
        const isHittingBoundTextElement = hitTest(
          boundTextElement,
          appState,
          frameNameBoundsCache,
          x,
          y,
          elementsMap
        );
        if (isHittingBoundTextElement) {
          return true;
        }
      }
      return isHittingElementNotConsideringBoundingBox(
        element,
        appState,
        frameNameBoundsCache,
        point2,
        elementsMap
      );
    };
    isHittingElementBoundingBoxWithoutHittingElement = (element, appState, frameNameBoundsCache, x, y, elementsMap) => {
      const threshold = 10 / appState.zoom.value;
      const boundTextElement = getBoundTextElement(element, elementsMap);
      if (boundTextElement && hitTest(boundTextElement, appState, frameNameBoundsCache, x, y, elementsMap)) {
        return false;
      }
      return !isHittingElementNotConsideringBoundingBox(
        element,
        appState,
        frameNameBoundsCache,
        [x, y],
        elementsMap
      ) && isPointHittingElementBoundingBox(
        element,
        elementsMap,
        [x, y],
        threshold,
        frameNameBoundsCache
      );
    };
    isHittingElementNotConsideringBoundingBox = (element, appState, frameNameBoundsCache, point2, elementsMap) => {
      const threshold = 10 / appState.zoom.value;
      const check = isTextElement(element) ? isStrictlyInside : isElementDraggableFromInside(element) ? isInsideCheck : isNearCheck;
      return hitTestPointAgainstElement({
        element,
        elementsMap,
        point: point2,
        threshold,
        check,
        frameNameBoundsCache
      });
    };
    isElementSelected = (appState, element) => appState.selectedElementIds[element.id];
    isPointHittingElementBoundingBox = (element, elementsMap, [x, y], threshold, frameNameBoundsCache) => {
      if (isFrameLikeElement(element)) {
        return hitTestPointAgainstElement({
          element,
          elementsMap,
          point: [x, y],
          threshold,
          check: isInsideCheck,
          frameNameBoundsCache
        });
      }
      const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);
      const elementCenterX = (x1 + x2) / 2;
      const elementCenterY = (y1 + y2) / 2;
      const [rotatedX, rotatedY] = rotate(
        x,
        y,
        elementCenterX,
        elementCenterY,
        -element.angle
      );
      return rotatedX > x1 - threshold && rotatedX < x2 + threshold && rotatedY > y1 - threshold && rotatedY < y2 + threshold;
    };
    bindingBorderTest = (element, { x, y }, elementsMap) => {
      const threshold = maxBindingGap(element, element.width, element.height);
      const check = isOutsideCheck;
      const point2 = [x, y];
      return hitTestPointAgainstElement({
        element,
        elementsMap,
        point: point2,
        threshold,
        check,
        frameNameBoundsCache: null
      });
    };
    maxBindingGap = (element, elementWidth, elementHeight) => {
      const shapeRatio = element.type === "diamond" ? 1 / Math.sqrt(2) : 1;
      const smallerDimension = shapeRatio * Math.min(elementWidth, elementHeight);
      return Math.max(16, Math.min(0.25 * smallerDimension, 32));
    };
    hitTestPointAgainstElement = (args) => {
      switch (args.element.type) {
        case "rectangle":
        case "iframe":
        case "embeddable":
        case "image":
        case "text":
        case "diamond":
        case "ellipse":
          const distance3 = distanceToBindableElement(
            args.element,
            args.point,
            args.elementsMap
          );
          return args.check(distance3, args.threshold);
        case "freedraw": {
          if (!args.check(
            distanceToRectangle(args.element, args.point, args.elementsMap),
            args.threshold
          )) {
            return false;
          }
          return hitTestFreeDrawElement(
            args.element,
            args.point,
            args.threshold,
            args.elementsMap
          );
        }
        case "arrow":
        case "line":
          return hitTestLinear(args);
        case "selection":
          console.warn(
            "This should not happen, we need to investigate why it does."
          );
          return false;
        case "frame":
        case "magicframe": {
          if (args.check(
            distanceToBindableElement(args.element, args.point, args.elementsMap),
            args.threshold
          )) {
            return true;
          }
          const frameNameBounds = args.frameNameBoundsCache?.get(args.element);
          if (frameNameBounds) {
            return args.check(
              distanceToRectangleBox(frameNameBounds, args.point),
              args.threshold
            );
          }
          return false;
        }
      }
    };
    distanceToBindableElement = (element, point2, elementsMap) => {
      switch (element.type) {
        case "rectangle":
        case "image":
        case "text":
        case "iframe":
        case "embeddable":
        case "frame":
        case "magicframe":
          return distanceToRectangle(element, point2, elementsMap);
        case "diamond":
          return distanceToDiamond(element, point2, elementsMap);
        case "ellipse":
          return distanceToEllipse(element, point2, elementsMap);
      }
    };
    isStrictlyInside = (distance3, threshold) => {
      return distance3 < 0;
    };
    isInsideCheck = (distance3, threshold) => {
      return distance3 < threshold;
    };
    isNearCheck = (distance3, threshold) => {
      return Math.abs(distance3) < threshold;
    };
    isOutsideCheck = (distance3, threshold) => {
      return 0 <= distance3 && distance3 < threshold;
    };
    distanceToRectangle = (element, point2, elementsMap) => {
      const [, pointRel, hwidth, hheight] = pointRelativeToElement(
        element,
        point2,
        elementsMap
      );
      return Math.max(
        distanceToLine(pointRel, equation(0, 1, -hheight)),
        distanceToLine(pointRel, equation(1, 0, -hwidth))
      );
    };
    distanceToRectangleBox = (box, point2) => {
      const [, pointRel, hwidth, hheight] = pointRelativeToDivElement(point2, box);
      return Math.max(
        distanceToLine(pointRel, equation(0, 1, -hheight)),
        distanceToLine(pointRel, equation(1, 0, -hwidth))
      );
    };
    distanceToDiamond = (element, point2, elementsMap) => {
      const [, pointRel, hwidth, hheight] = pointRelativeToElement(
        element,
        point2,
        elementsMap
      );
      const side = equation(hheight, hwidth, -hheight * hwidth);
      return distanceToLine(pointRel, side);
    };
    distanceToEllipse = (element, point2, elementsMap) => {
      const [pointRel, tangent] = ellipseParamsForTest(element, point2, elementsMap);
      return -sign(tangent) * distanceToLine(pointRel, tangent);
    };
    ellipseParamsForTest = (element, point2, elementsMap) => {
      const [, pointRel, hwidth, hheight] = pointRelativeToElement(
        element,
        point2,
        elementsMap
      );
      const [px, py] = toTuple(pointRel);
      let tx = 0.707;
      let ty = 0.707;
      const a = hwidth;
      const b = hheight;
      [0, 1, 2, 3].forEach((_) => {
        const xx = a * tx;
        const yy = b * ty;
        const ex = (a * a - b * b) * tx ** 3 / a;
        const ey = (b * b - a * a) * ty ** 3 / b;
        const rx = xx - ex;
        const ry = yy - ey;
        const qx = px - ex;
        const qy = py - ey;
        const r = Math.hypot(ry, rx);
        const q = Math.hypot(qy, qx);
        tx = Math.min(1, Math.max(0, (qx * r / q + ex) / a));
        ty = Math.min(1, Math.max(0, (qy * r / q + ey) / b));
        const t2 = Math.hypot(ty, tx);
        tx /= t2;
        ty /= t2;
      });
      const closestPoint = point(a * tx, b * ty);
      const tangent = orthogonalThrough(pointRel, closestPoint);
      return [pointRel, tangent];
    };
    hitTestFreeDrawElement = (element, point2, threshold, elementsMap) => {
      let x;
      let y;
      if (element.angle === 0) {
        x = point2[0] - element.x;
        y = point2[1] - element.y;
      } else {
        const [minX, minY, maxX, maxY] = getElementAbsoluteCoords(
          element,
          elementsMap
        );
        const rotatedPoint = rotatePoint(
          point2,
          [minX + (maxX - minX) / 2, minY + (maxY - minY) / 2],
          -element.angle
        );
        x = rotatedPoint[0] - element.x;
        y = rotatedPoint[1] - element.y;
      }
      let [A, B] = element.points;
      let P;
      if (distance2d(A[0], A[1], x, y) < threshold || distance2d(B[0], B[1], x, y) < threshold) {
        return true;
      }
      for (let i = 0; i < element.points.length; i++) {
        const delta = [B[0] - A[0], B[1] - A[1]];
        const length = Math.hypot(delta[1], delta[0]);
        const U = [delta[0] / length, delta[1] / length];
        const C = [x - A[0], y - A[1]];
        const d = (C[0] * U[0] + C[1] * U[1]) / Math.hypot(U[1], U[0]);
        P = [A[0] + U[0] * d, A[1] + U[1] * d];
        const da = distance2d(P[0], P[1], A[0], A[1]);
        const db = distance2d(P[0], P[1], B[0], B[1]);
        P = db < da && da > length ? B : da < db && db > length ? A : P;
        if (Math.hypot(y - P[1], x - P[0]) < threshold) {
          return true;
        }
        A = B;
        B = element.points[i + 1];
      }
      const shape = ShapeCache.get(element);
      if (shape && shape.sets.length) {
        return element.fillStyle === "solid" ? hitTestCurveInside(shape, x, y, "round") : hitTestRoughShape(shape, x, y, threshold);
      }
      return false;
    };
    hitTestLinear = (args) => {
      const { element, threshold } = args;
      if (!ShapeCache.get(element)) {
        return false;
      }
      const [point2, pointAbs, hwidth, hheight] = pointRelativeToElement(
        args.element,
        args.point,
        args.elementsMap
      );
      const side1 = equation(0, 1, -hheight);
      const side2 = equation(1, 0, -hwidth);
      if (!isInsideCheck(distanceToLine(pointAbs, side1), threshold) || !isInsideCheck(distanceToLine(pointAbs, side2), threshold)) {
        return false;
      }
      const [relX, relY] = toTuple(point2);
      const shape = ShapeCache.get(element);
      if (!shape) {
        return false;
      }
      if (args.check === isInsideCheck) {
        const hit = shape.some(
          (subshape) => hitTestCurveInside(
            subshape,
            relX,
            relY,
            element.roundness ? "round" : "sharp"
          )
        );
        if (hit) {
          return true;
        }
      }
      return shape.some(
        (subshape) => hitTestRoughShape(subshape, relX, relY, threshold)
      );
    };
    pointRelativeToElement = (element, pointTuple, elementsMap) => {
      const point2 = from(pointTuple);
      const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);
      const center = coordsCenter(x1, y1, x2, y2);
      const rotate2 = rotation(center, element.angle);
      const pointRotated = apply(rotate2, point2);
      const pointRelToCenter = sub(pointRotated, from2(center));
      const pointRelToCenterAbs = abs(pointRelToCenter);
      const elementPos = offset(element.x, element.y);
      const pointRelToPos = sub(pointRotated, elementPos);
      const halfWidth = (x2 - x1) / 2;
      const halfHeight = (y2 - y1) / 2;
      return [pointRelToPos, pointRelToCenterAbs, halfWidth, halfHeight];
    };
    pointRelativeToDivElement = (pointTuple, rectangle) => {
      const point2 = from(pointTuple);
      const [x1, y1, x2, y2] = getRectangleBoxAbsoluteCoords(rectangle);
      const center = coordsCenter(x1, y1, x2, y2);
      const rotate2 = rotation(center, rectangle.angle);
      const pointRotated = apply(rotate2, point2);
      const pointRelToCenter = sub(pointRotated, from2(center));
      const pointRelToCenterAbs = abs(pointRelToCenter);
      const elementPos = offset(rectangle.x, rectangle.y);
      const pointRelToPos = sub(pointRotated, elementPos);
      const halfWidth = (x2 - x1) / 2;
      const halfHeight = (y2 - y1) / 2;
      return [pointRelToPos, pointRelToCenterAbs, halfWidth, halfHeight];
    };
    relativizationToElementCenter = (element, elementsMap) => {
      const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);
      const center = coordsCenter(x1, y1, x2, y2);
      const rotate2 = rotation(center, element.angle);
      const translate2 = reverse(
        translation(from2(center))
      );
      return compose(rotate2, translate2);
    };
    coordsCenter = (x1, y1, x2, y2) => {
      return point((x1 + x2) / 2, (y1 + y2) / 2);
    };
    determineFocusDistance = (element, a, b, elementsMap) => {
      const relateToCenter = relativizationToElementCenter(element, elementsMap);
      const aRel = apply(relateToCenter, from(a));
      const bRel = apply(relateToCenter, from(b));
      const line = through(aRel, bRel);
      const q = element.height / element.width;
      const hwidth = element.width / 2;
      const hheight = element.height / 2;
      const n = line[2];
      const m = line[3];
      const c = line[1];
      const mabs = Math.abs(m);
      const nabs = Math.abs(n);
      let ret;
      switch (element.type) {
        case "rectangle":
        case "image":
        case "text":
        case "iframe":
        case "embeddable":
        case "frame":
        case "magicframe":
          ret = c / (hwidth * (nabs + q * mabs));
          break;
        case "diamond":
          ret = mabs < nabs ? c / (nabs * hwidth) : c / (mabs * hheight);
          break;
        case "ellipse":
          ret = c / (hwidth * Math.sqrt(n ** 2 + q ** 2 * m ** 2));
          break;
      }
      return ret || 0;
    };
    determineFocusPoint = (element, focus, adjecentPoint, elementsMap) => {
      if (focus === 0) {
        const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);
        const center = coordsCenter(x1, y1, x2, y2);
        return toTuple(center);
      }
      const relateToCenter = relativizationToElementCenter(element, elementsMap);
      const adjecentPointRel = apply(
        relateToCenter,
        from(adjecentPoint)
      );
      const reverseRelateToCenter = reverse(relateToCenter);
      let point2;
      switch (element.type) {
        case "rectangle":
        case "image":
        case "text":
        case "diamond":
        case "iframe":
        case "embeddable":
        case "frame":
        case "magicframe":
          point2 = findFocusPointForRectangulars(element, focus, adjecentPointRel);
          break;
        case "ellipse":
          point2 = findFocusPointForEllipse(element, focus, adjecentPointRel);
          break;
      }
      return toTuple(apply(reverseRelateToCenter, point2));
    };
    intersectElementWithLine = (element, a, b, gap = 0, elementsMap) => {
      const relateToCenter = relativizationToElementCenter(element, elementsMap);
      const aRel = apply(relateToCenter, from(a));
      const bRel = apply(relateToCenter, from(b));
      const line = through(aRel, bRel);
      const reverseRelateToCenter = reverse(relateToCenter);
      const intersections = getSortedElementLineIntersections(
        element,
        line,
        aRel,
        gap
      );
      return intersections.map(
        (point2) => toTuple(apply(reverseRelateToCenter, point2))
      );
    };
    getSortedElementLineIntersections = (element, line, nearPoint, gap = 0) => {
      let intersections;
      switch (element.type) {
        case "rectangle":
        case "image":
        case "text":
        case "diamond":
        case "iframe":
        case "embeddable":
        case "frame":
        case "magicframe":
          const corners = getCorners(element);
          intersections = corners.flatMap((point2, i) => {
            const edge = [point2, corners[(i + 1) % 4]];
            return intersectSegment(line, offsetSegment(edge, gap));
          }).concat(
            corners.flatMap((point2) => getCircleIntersections(point2, gap, line))
          );
          break;
        case "ellipse":
          intersections = getEllipseIntersections(element, gap, line);
          break;
      }
      if (intersections.length < 2) {
        return [];
      }
      const sortedIntersections = intersections.sort(
        (i1, i2) => distance2(i1, nearPoint) - distance2(i2, nearPoint)
      );
      return [
        sortedIntersections[0],
        sortedIntersections[sortedIntersections.length - 1]
      ];
    };
    getCorners = (element, scale = 1) => {
      const hx = scale * element.width / 2;
      const hy = scale * element.height / 2;
      switch (element.type) {
        case "rectangle":
        case "image":
        case "text":
        case "iframe":
        case "embeddable":
        case "frame":
        case "magicframe":
          return [
            point(hx, hy),
            point(hx, -hy),
            point(-hx, -hy),
            point(-hx, hy)
          ];
        case "diamond":
          return [
            point(0, hy),
            point(hx, 0),
            point(0, -hy),
            point(-hx, 0)
          ];
      }
    };
    intersectSegment = (line, segment) => {
      const [a, b] = segment;
      const aDist = distanceToLine(a, line);
      const bDist = distanceToLine(b, line);
      if (aDist * bDist >= 0) {
        return [];
      }
      return [intersect(line, through(a, b))];
    };
    offsetSegment = (segment, distance3) => {
      const [a, b] = segment;
      const offset2 = translationOrthogonal(
        fromTo(a, b),
        distance3
      );
      return [apply(offset2, a), apply(offset2, b)];
    };
    getEllipseIntersections = (element, gap, line) => {
      const a = element.width / 2 + gap;
      const b = element.height / 2 + gap;
      const m = line[2];
      const n = line[3];
      const c = line[1];
      const squares = a * a * m * m + b * b * n * n;
      const discr = squares - c * c;
      if (squares === 0 || discr <= 0) {
        return [];
      }
      const discrRoot = Math.sqrt(discr);
      const xn = -a * a * m * c;
      const yn = -b * b * n * c;
      return [
        point(
          (xn + a * b * n * discrRoot) / squares,
          (yn - a * b * m * discrRoot) / squares
        ),
        point(
          (xn - a * b * n * discrRoot) / squares,
          (yn + a * b * m * discrRoot) / squares
        )
      ];
    };
    getCircleIntersections = (center, radius, line) => {
      if (radius === 0) {
        return distanceToLine(line, center) === 0 ? [center] : [];
      }
      const m = line[2];
      const n = line[3];
      const c = line[1];
      const [a, b] = toTuple(center);
      const r = radius;
      const squares = m * m + n * n;
      const discr = r * r * squares - (m * a + n * b + c) ** 2;
      if (squares === 0 || discr <= 0) {
        return [];
      }
      const discrRoot = Math.sqrt(discr);
      const xn = a * n * n - b * m * n - m * c;
      const yn = b * m * m - a * m * n - n * c;
      return [
        point((xn + n * discrRoot) / squares, (yn - m * discrRoot) / squares),
        point((xn - n * discrRoot) / squares, (yn + m * discrRoot) / squares)
      ];
    };
    findFocusPointForEllipse = (ellipse, relativeDistance, point2) => {
      const relativeDistanceAbs = Math.abs(relativeDistance);
      const a = ellipse.width * relativeDistanceAbs / 2;
      const b = ellipse.height * relativeDistanceAbs / 2;
      const orientation = Math.sign(relativeDistance);
      const [px, pyo] = toTuple(point2);
      const py = pyo === 0 ? 1e-4 : pyo;
      const squares = px ** 2 * b ** 2 + py ** 2 * a ** 2;
      const m = (-px * b ** 2 + orientation * py * Math.sqrt(Math.max(0, squares - a ** 2 * b ** 2))) / squares;
      let n = (-m * px - 1) / py;
      if (n === 0) {
        n = (Object.is(n, -0) ? -1 : 1) * 0.01;
      }
      const x = -(a ** 2 * m) / (n ** 2 * b ** 2 + m ** 2 * a ** 2);
      return point(x, (-m * x - 1) / n);
    };
    findFocusPointForRectangulars = (element, relativeDistance, point2) => {
      const relativeDistanceAbs = Math.abs(relativeDistance);
      const orientation = Math.sign(relativeDistance);
      const corners = getCorners(element, relativeDistanceAbs);
      let maxDistance = 0;
      let tangentPoint = null;
      corners.forEach((corner) => {
        const distance3 = orientation * through(point2, corner)[1];
        if (distance3 > maxDistance) {
          maxDistance = distance3;
          tangentPoint = corner;
        }
      });
      return tangentPoint;
    };
    pointInBezierEquation = (p0, p1, p2, p3, [mx, my], lineThreshold) => {
      const equation2 = (t3, idx) => Math.pow(1 - t3, 3) * p3[idx] + 3 * t3 * Math.pow(1 - t3, 2) * p2[idx] + 3 * Math.pow(t3, 2) * (1 - t3) * p1[idx] + p0[idx] * Math.pow(t3, 3);
      let t2 = 0;
      while (t2 <= 1) {
        const tx = equation2(t2, 0);
        const ty = equation2(t2, 1);
        const diff = Math.sqrt(Math.pow(tx - mx, 2) + Math.pow(ty - my, 2));
        if (diff < lineThreshold) {
          return true;
        }
        t2 += 0.01;
      }
      return false;
    };
    hitTestCurveInside = (drawable, x, y, roundness) => {
      const ops = getCurvePathOps(drawable);
      const points = [];
      let odd = false;
      for (const operation of ops) {
        if (operation.op === "move") {
          odd = !odd;
          if (odd) {
            points.push([operation.data[0], operation.data[1]]);
          }
        } else if (operation.op === "bcurveTo") {
          if (odd) {
            points.push([operation.data[0], operation.data[1]]);
            points.push([operation.data[2], operation.data[3]]);
            points.push([operation.data[4], operation.data[5]]);
          }
        } else if (operation.op === "lineTo") {
          if (odd) {
            points.push([operation.data[0], operation.data[1]]);
          }
        }
      }
      if (points.length >= 4) {
        if (roundness === "sharp") {
          return isPointInPolygon(points, x, y);
        }
        const polygonPoints = pointsOnBezierCurves(points, 10, 5);
        return isPointInPolygon(polygonPoints, x, y);
      }
      return false;
    };
    hitTestRoughShape = (drawable, x, y, lineThreshold) => {
      const ops = getCurvePathOps(drawable);
      let currentP = [0, 0];
      return ops.some(({ op, data }, idx) => {
        if (op === "move") {
          currentP = data;
        } else if (op === "bcurveTo") {
          const p1 = [data[0], data[1]];
          const p2 = [data[2], data[3]];
          const p3 = [data[4], data[5]];
          const p0 = currentP;
          currentP = p3;
          const retVal = pointInBezierEquation(
            p0,
            p1,
            p2,
            p3,
            [x, y],
            lineThreshold
          );
          return retVal;
        } else if (op === "lineTo") {
          return hitTestCurveInside(drawable, x, y, "sharp");
        } else if (op === "qcurveTo") {
          console.warn("qcurveTo is not implemented yet");
        }
        return false;
      });
    };
  }
});

// keys.ts
var CODES, KEYS, isArrowKey, shouldResizeFromCenter, shouldMaintainAspectRatio, shouldRotateWithDiscreteAngle;
var init_keys = __esm({
  "keys.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_constants();
    CODES = {
      EQUAL: "Equal",
      MINUS: "Minus",
      NUM_ADD: "NumpadAdd",
      NUM_SUBTRACT: "NumpadSubtract",
      NUM_ZERO: "Numpad0",
      BRACKET_RIGHT: "BracketRight",
      BRACKET_LEFT: "BracketLeft",
      ONE: "Digit1",
      TWO: "Digit2",
      THREE: "Digit3",
      NINE: "Digit9",
      QUOTE: "Quote",
      ZERO: "Digit0",
      SLASH: "Slash",
      C: "KeyC",
      D: "KeyD",
      H: "KeyH",
      V: "KeyV",
      Z: "KeyZ",
      R: "KeyR",
      S: "KeyS"
    };
    KEYS = {
      ARROW_DOWN: "ArrowDown",
      ARROW_LEFT: "ArrowLeft",
      ARROW_RIGHT: "ArrowRight",
      ARROW_UP: "ArrowUp",
      PAGE_UP: "PageUp",
      PAGE_DOWN: "PageDown",
      BACKSPACE: "Backspace",
      ALT: "Alt",
      CTRL_OR_CMD: isDarwin ? "metaKey" : "ctrlKey",
      DELETE: "Delete",
      ENTER: "Enter",
      ESCAPE: "Escape",
      QUESTION_MARK: "?",
      SPACE: " ",
      TAB: "Tab",
      CHEVRON_LEFT: "<",
      CHEVRON_RIGHT: ">",
      PERIOD: ".",
      COMMA: ",",
      SUBTRACT: "-",
      A: "a",
      C: "c",
      D: "d",
      E: "e",
      F: "f",
      G: "g",
      H: "h",
      I: "i",
      L: "l",
      O: "o",
      P: "p",
      Q: "q",
      R: "r",
      S: "s",
      T: "t",
      V: "v",
      X: "x",
      Y: "y",
      Z: "z",
      K: "k",
      W: "w",
      0: "0",
      1: "1",
      2: "2",
      3: "3",
      4: "4",
      5: "5",
      6: "6",
      7: "7",
      8: "8",
      9: "9"
    };
    isArrowKey = (key) => key === KEYS.ARROW_LEFT || key === KEYS.ARROW_RIGHT || key === KEYS.ARROW_DOWN || key === KEYS.ARROW_UP;
    shouldResizeFromCenter = (event) => event.altKey;
    shouldMaintainAspectRatio = (event) => event.shiftKey;
    shouldRotateWithDiscreteAngle = (event) => event.shiftKey;
  }
});

// element/binding.ts
var shouldEnableBindingForPointerEvent, isBindingEnabled, getNonDeletedElements2, bindOrUnbindLinearElement, bindOrUnbindLinearElementEdge, bindOrUnbindSelectedElements, maybeBindBindableElement, maybeBindLinearElement, bindLinearElement, isLinearElementSimpleAndAlreadyBoundOnOppositeEdge, isLinearElementSimpleAndAlreadyBound, unbindLinearElements, unbindLinearElement, getHoveredElementForBinding, calculateFocusAndGap, updateBoundElements, doesNeedUpdate, getSimultaneouslyUpdatedElementIds, updateBoundPoint, maybeCalculateNewGapWhenScaling, getEligibleElementsForBinding, getElligibleElementsForBindingElement, getElligibleElementForBindingElement, getLinearElementEdgeCoors, getElligibleElementsForBindableElementAndWhere, isLinearElementEligibleForNewBindingByBindable, fixBindingsAfterDuplication, newBindingAfterDuplication, fixBindingsAfterDeletion, newBindingAfterDeletion, newBoundElementsAfterDeletion;
var init_binding = __esm({
  "element/binding.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_scene();
    init_typeChecks();
    init_collision();
    init_mutateElement();
    init_Scene();
    init_linearElementEditor();
    init_utils();
    init_keys();
    init_textElement();
    shouldEnableBindingForPointerEvent = (event) => {
      return !event[KEYS.CTRL_OR_CMD];
    };
    isBindingEnabled = (appState) => {
      return appState.isBindingEnabled;
    };
    getNonDeletedElements2 = (scene, ids) => {
      const result = [];
      ids.forEach((id) => {
        const element = scene.getNonDeletedElement(id);
        if (element != null) {
          result.push(element);
        }
      });
      return result;
    };
    bindOrUnbindLinearElement = (linearElement, startBindingElement, endBindingElement, elementsMap) => {
      const boundToElementIds = /* @__PURE__ */ new Set();
      const unboundFromElementIds = /* @__PURE__ */ new Set();
      bindOrUnbindLinearElementEdge(
        linearElement,
        startBindingElement,
        endBindingElement,
        "start",
        boundToElementIds,
        unboundFromElementIds,
        elementsMap
      );
      bindOrUnbindLinearElementEdge(
        linearElement,
        endBindingElement,
        startBindingElement,
        "end",
        boundToElementIds,
        unboundFromElementIds,
        elementsMap
      );
      const onlyUnbound = Array.from(unboundFromElementIds).filter(
        (id) => !boundToElementIds.has(id)
      );
      getNonDeletedElements2(Scene_default.getScene(linearElement), onlyUnbound).forEach(
        (element) => {
          mutateElement(element, {
            boundElements: element.boundElements?.filter(
              (element2) => element2.type !== "arrow" || element2.id !== linearElement.id
            )
          });
        }
      );
    };
    bindOrUnbindLinearElementEdge = (linearElement, bindableElement, otherEdgeBindableElement, startOrEnd, boundToElementIds, unboundFromElementIds, elementsMap) => {
      if (bindableElement !== "keep") {
        if (bindableElement != null) {
          if (otherEdgeBindableElement == null || (otherEdgeBindableElement === "keep" ? !isLinearElementSimpleAndAlreadyBoundOnOppositeEdge(
            linearElement,
            bindableElement,
            startOrEnd
          ) : startOrEnd === "start" || otherEdgeBindableElement.id !== bindableElement.id)) {
            bindLinearElement(
              linearElement,
              bindableElement,
              startOrEnd,
              elementsMap
            );
            boundToElementIds.add(bindableElement.id);
          }
        } else {
          const unbound = unbindLinearElement(linearElement, startOrEnd);
          if (unbound != null) {
            unboundFromElementIds.add(unbound);
          }
        }
      }
    };
    bindOrUnbindSelectedElements = (selectedElements, elements, elementsMap) => {
      selectedElements.forEach((selectedElement) => {
        if (isBindingElement(selectedElement)) {
          bindOrUnbindLinearElement(
            selectedElement,
            getElligibleElementForBindingElement(
              selectedElement,
              "start",
              elements,
              elementsMap
            ),
            getElligibleElementForBindingElement(
              selectedElement,
              "end",
              elements,
              elementsMap
            ),
            elementsMap
          );
        } else if (isBindableElement(selectedElement)) {
          maybeBindBindableElement(selectedElement, elementsMap);
        }
      });
    };
    maybeBindBindableElement = (bindableElement, elementsMap) => {
      getElligibleElementsForBindableElementAndWhere(
        bindableElement,
        elementsMap
      ).forEach(
        ([linearElement, where]) => bindOrUnbindLinearElement(
          linearElement,
          where === "end" ? "keep" : bindableElement,
          where === "start" ? "keep" : bindableElement,
          elementsMap
        )
      );
    };
    maybeBindLinearElement = (linearElement, appState, scene, pointerCoords, elementsMap) => {
      if (appState.startBoundElement != null) {
        bindLinearElement(
          linearElement,
          appState.startBoundElement,
          "start",
          elementsMap
        );
      }
      const hoveredElement = getHoveredElementForBinding(
        pointerCoords,
        scene.getNonDeletedElements(),
        elementsMap
      );
      if (hoveredElement != null && !isLinearElementSimpleAndAlreadyBoundOnOppositeEdge(
        linearElement,
        hoveredElement,
        "end"
      )) {
        bindLinearElement(linearElement, hoveredElement, "end", elementsMap);
      }
    };
    bindLinearElement = (linearElement, hoveredElement, startOrEnd, elementsMap) => {
      mutateElement(linearElement, {
        [startOrEnd === "start" ? "startBinding" : "endBinding"]: {
          elementId: hoveredElement.id,
          ...calculateFocusAndGap(
            linearElement,
            hoveredElement,
            startOrEnd,
            elementsMap
          )
        }
      });
      const boundElementsMap = arrayToMap(hoveredElement.boundElements || []);
      if (!boundElementsMap.has(linearElement.id)) {
        mutateElement(hoveredElement, {
          boundElements: (hoveredElement.boundElements || []).concat({
            id: linearElement.id,
            type: "arrow"
          })
        });
      }
    };
    isLinearElementSimpleAndAlreadyBoundOnOppositeEdge = (linearElement, bindableElement, startOrEnd) => {
      const otherBinding = linearElement[startOrEnd === "start" ? "endBinding" : "startBinding"];
      return isLinearElementSimpleAndAlreadyBound(
        linearElement,
        otherBinding?.elementId,
        bindableElement
      );
    };
    isLinearElementSimpleAndAlreadyBound = (linearElement, alreadyBoundToId, bindableElement) => {
      return alreadyBoundToId === bindableElement.id && linearElement.points.length < 3;
    };
    unbindLinearElements = (elements, elementsMap) => {
      elements.forEach((element) => {
        if (isBindingElement(element)) {
          bindOrUnbindLinearElement(element, null, null, elementsMap);
        }
      });
    };
    unbindLinearElement = (linearElement, startOrEnd) => {
      const field = startOrEnd === "start" ? "startBinding" : "endBinding";
      const binding = linearElement[field];
      if (binding == null) {
        return null;
      }
      mutateElement(linearElement, { [field]: null });
      return binding.elementId;
    };
    getHoveredElementForBinding = (pointerCoords, elements, elementsMap) => {
      const hoveredElement = getElementAtPosition(
        elements,
        (element) => isBindableElement(element, false) && bindingBorderTest(element, pointerCoords, elementsMap)
      );
      return hoveredElement;
    };
    calculateFocusAndGap = (linearElement, hoveredElement, startOrEnd, elementsMap) => {
      const direction = startOrEnd === "start" ? -1 : 1;
      const edgePointIndex = direction === -1 ? 0 : linearElement.points.length - 1;
      const adjacentPointIndex = edgePointIndex - direction;
      const edgePoint = LinearElementEditor.getPointAtIndexGlobalCoordinates(
        linearElement,
        edgePointIndex,
        elementsMap
      );
      const adjacentPoint = LinearElementEditor.getPointAtIndexGlobalCoordinates(
        linearElement,
        adjacentPointIndex,
        elementsMap
      );
      return {
        focus: determineFocusDistance(
          hoveredElement,
          adjacentPoint,
          edgePoint,
          elementsMap
        ),
        gap: Math.max(
          1,
          distanceToBindableElement(hoveredElement, edgePoint, elementsMap)
        )
      };
    };
    updateBoundElements = (changedElement, elementsMap, options) => {
      const boundLinearElements = (changedElement.boundElements ?? []).filter(
        (el) => el.type === "arrow"
      );
      if (boundLinearElements.length === 0) {
        return;
      }
      const { newSize, simultaneouslyUpdated } = options ?? {};
      const simultaneouslyUpdatedElementIds = getSimultaneouslyUpdatedElementIds(
        simultaneouslyUpdated
      );
      const scene = Scene_default.getScene(changedElement);
      getNonDeletedElements2(
        scene,
        boundLinearElements.map((el) => el.id)
      ).forEach((element) => {
        if (!isLinearElement(element)) {
          return;
        }
        const bindableElement = changedElement;
        if (!doesNeedUpdate(element, bindableElement)) {
          return;
        }
        const startBinding = maybeCalculateNewGapWhenScaling(
          bindableElement,
          element.startBinding,
          newSize
        );
        const endBinding = maybeCalculateNewGapWhenScaling(
          bindableElement,
          element.endBinding,
          newSize
        );
        if (simultaneouslyUpdatedElementIds.has(element.id)) {
          mutateElement(element, { startBinding, endBinding });
          return;
        }
        updateBoundPoint(
          element,
          "start",
          startBinding,
          changedElement,
          elementsMap
        );
        updateBoundPoint(
          element,
          "end",
          endBinding,
          changedElement,
          elementsMap
        );
        const boundText = getBoundTextElement(
          element,
          scene.getNonDeletedElementsMap()
        );
        if (boundText) {
          handleBindTextResize(element, scene.getNonDeletedElementsMap(), false);
        }
      });
    };
    doesNeedUpdate = (boundElement, changedElement) => {
      return boundElement.startBinding?.elementId === changedElement.id || boundElement.endBinding?.elementId === changedElement.id;
    };
    getSimultaneouslyUpdatedElementIds = (simultaneouslyUpdated) => {
      return new Set((simultaneouslyUpdated || []).map((element) => element.id));
    };
    updateBoundPoint = (linearElement, startOrEnd, binding, changedElement, elementsMap) => {
      if (binding == null || // We only need to update the other end if this is a 2 point line element
      binding.elementId !== changedElement.id && linearElement.points.length > 2) {
        return;
      }
      const bindingElement = Scene_default.getScene(linearElement).getElement(
        binding.elementId
      );
      if (bindingElement == null) {
        return;
      }
      const direction = startOrEnd === "start" ? -1 : 1;
      const edgePointIndex = direction === -1 ? 0 : linearElement.points.length - 1;
      const adjacentPointIndex = edgePointIndex - direction;
      const adjacentPoint = LinearElementEditor.getPointAtIndexGlobalCoordinates(
        linearElement,
        adjacentPointIndex,
        elementsMap
      );
      const focusPointAbsolute = determineFocusPoint(
        bindingElement,
        binding.focus,
        adjacentPoint,
        elementsMap
      );
      let newEdgePoint;
      if (binding.gap === 0) {
        newEdgePoint = focusPointAbsolute;
      } else {
        const intersections = intersectElementWithLine(
          bindingElement,
          adjacentPoint,
          focusPointAbsolute,
          binding.gap,
          elementsMap
        );
        if (intersections.length === 0) {
          newEdgePoint = focusPointAbsolute;
        } else {
          newEdgePoint = intersections[0];
        }
      }
      LinearElementEditor.movePoints(
        linearElement,
        [
          {
            index: edgePointIndex,
            point: LinearElementEditor.pointFromAbsoluteCoords(
              linearElement,
              newEdgePoint,
              elementsMap
            )
          }
        ],
        { [startOrEnd === "start" ? "startBinding" : "endBinding"]: binding }
      );
    };
    maybeCalculateNewGapWhenScaling = (changedElement, currentBinding, newSize) => {
      if (currentBinding == null || newSize == null) {
        return currentBinding;
      }
      const { gap, focus, elementId } = currentBinding;
      const { width: newWidth, height: newHeight } = newSize;
      const { width, height } = changedElement;
      const newGap = Math.max(
        1,
        Math.min(
          maxBindingGap(changedElement, newWidth, newHeight),
          gap * (newWidth < newHeight ? newWidth / width : newHeight / height)
        )
      );
      return { elementId, gap: newGap, focus };
    };
    getEligibleElementsForBinding = (selectedElements, elements, elementsMap) => {
      const includedElementIds = new Set(selectedElements.map(({ id }) => id));
      return selectedElements.flatMap(
        (selectedElement) => isBindingElement(selectedElement, false) ? getElligibleElementsForBindingElement(
          selectedElement,
          elements,
          elementsMap
        ).filter(
          (element) => !includedElementIds.has(element.id)
        ) : isBindableElement(selectedElement, false) ? getElligibleElementsForBindableElementAndWhere(
          selectedElement,
          elementsMap
        ).filter((binding) => !includedElementIds.has(binding[0].id)) : []
      );
    };
    getElligibleElementsForBindingElement = (linearElement, elements, elementsMap) => {
      return [
        getElligibleElementForBindingElement(
          linearElement,
          "start",
          elements,
          elementsMap
        ),
        getElligibleElementForBindingElement(
          linearElement,
          "end",
          elements,
          elementsMap
        )
      ].filter(
        (element) => element != null
      );
    };
    getElligibleElementForBindingElement = (linearElement, startOrEnd, elements, elementsMap) => {
      return getHoveredElementForBinding(
        getLinearElementEdgeCoors(linearElement, startOrEnd, elementsMap),
        elements,
        elementsMap
      );
    };
    getLinearElementEdgeCoors = (linearElement, startOrEnd, elementsMap) => {
      const index = startOrEnd === "start" ? 0 : -1;
      return tupleToCoors(
        LinearElementEditor.getPointAtIndexGlobalCoordinates(
          linearElement,
          index,
          elementsMap
        )
      );
    };
    getElligibleElementsForBindableElementAndWhere = (bindableElement, elementsMap) => {
      const scene = Scene_default.getScene(bindableElement);
      return scene.getNonDeletedElements().map((element) => {
        if (!isBindingElement(element, false)) {
          return null;
        }
        const canBindStart = isLinearElementEligibleForNewBindingByBindable(
          element,
          "start",
          bindableElement,
          elementsMap
        );
        const canBindEnd = isLinearElementEligibleForNewBindingByBindable(
          element,
          "end",
          bindableElement,
          elementsMap
        );
        if (!canBindStart && !canBindEnd) {
          return null;
        }
        return [
          element,
          canBindStart && canBindEnd ? "both" : canBindStart ? "start" : "end",
          bindableElement
        ];
      }).filter((maybeElement) => maybeElement != null);
    };
    isLinearElementEligibleForNewBindingByBindable = (linearElement, startOrEnd, bindableElement, elementsMap) => {
      const existingBinding = linearElement[startOrEnd === "start" ? "startBinding" : "endBinding"];
      return existingBinding == null && !isLinearElementSimpleAndAlreadyBoundOnOppositeEdge(
        linearElement,
        bindableElement,
        startOrEnd
      ) && bindingBorderTest(
        bindableElement,
        getLinearElementEdgeCoors(linearElement, startOrEnd, elementsMap),
        elementsMap
      );
    };
    fixBindingsAfterDuplication = (sceneElements, oldElements, oldIdToDuplicatedId, duplicatesServeAsOld) => {
      const allBoundElementIds = /* @__PURE__ */ new Set();
      const allBindableElementIds = /* @__PURE__ */ new Set();
      const shouldReverseRoles = duplicatesServeAsOld === "duplicatesServeAsOld";
      oldElements.forEach((oldElement) => {
        const { boundElements } = oldElement;
        if (boundElements != null && boundElements.length > 0) {
          boundElements.forEach((boundElement) => {
            if (shouldReverseRoles && !oldIdToDuplicatedId.has(boundElement.id)) {
              allBoundElementIds.add(boundElement.id);
            }
          });
          allBindableElementIds.add(oldIdToDuplicatedId.get(oldElement.id));
        }
        if (isBindingElement(oldElement)) {
          if (oldElement.startBinding != null) {
            const { elementId } = oldElement.startBinding;
            if (shouldReverseRoles && !oldIdToDuplicatedId.has(elementId)) {
              allBindableElementIds.add(elementId);
            }
          }
          if (oldElement.endBinding != null) {
            const { elementId } = oldElement.endBinding;
            if (shouldReverseRoles && !oldIdToDuplicatedId.has(elementId)) {
              allBindableElementIds.add(elementId);
            }
          }
          if (oldElement.startBinding != null || oldElement.endBinding != null) {
            allBoundElementIds.add(oldIdToDuplicatedId.get(oldElement.id));
          }
        }
      });
      sceneElements.filter(
        ({ id }) => allBoundElementIds.has(id)
      ).forEach((element) => {
        const { startBinding, endBinding } = element;
        mutateElement(element, {
          startBinding: newBindingAfterDuplication(
            startBinding,
            oldIdToDuplicatedId
          ),
          endBinding: newBindingAfterDuplication(endBinding, oldIdToDuplicatedId)
        });
      });
      sceneElements.filter(({ id }) => allBindableElementIds.has(id)).forEach((bindableElement) => {
        const { boundElements } = bindableElement;
        if (boundElements != null && boundElements.length > 0) {
          mutateElement(bindableElement, {
            boundElements: boundElements.map(
              (boundElement) => oldIdToDuplicatedId.has(boundElement.id) ? {
                id: oldIdToDuplicatedId.get(boundElement.id),
                type: boundElement.type
              } : boundElement
            )
          });
        }
      });
    };
    newBindingAfterDuplication = (binding, oldIdToDuplicatedId) => {
      if (binding == null) {
        return null;
      }
      const { elementId, focus, gap } = binding;
      return {
        focus,
        gap,
        elementId: oldIdToDuplicatedId.get(elementId) ?? elementId
      };
    };
    fixBindingsAfterDeletion = (sceneElements, deletedElements) => {
      const deletedElementIds = new Set(
        deletedElements.map((element) => element.id)
      );
      const affectedElements = /* @__PURE__ */ new Set();
      deletedElements.forEach((deletedElement) => {
        if (isBindableElement(deletedElement)) {
          deletedElement.boundElements?.forEach((element) => {
            if (!deletedElementIds.has(element.id)) {
              affectedElements.add(element.id);
            }
          });
        } else if (isBindingElement(deletedElement)) {
          if (deletedElement.startBinding) {
            affectedElements.add(deletedElement.startBinding.elementId);
          }
          if (deletedElement.endBinding) {
            affectedElements.add(deletedElement.endBinding.elementId);
          }
        }
      });
      sceneElements.filter(({ id }) => affectedElements.has(id)).forEach((element) => {
        if (isBindableElement(element)) {
          mutateElement(element, {
            boundElements: newBoundElementsAfterDeletion(
              element.boundElements,
              deletedElementIds
            )
          });
        } else if (isBindingElement(element)) {
          mutateElement(element, {
            startBinding: newBindingAfterDeletion(
              element.startBinding,
              deletedElementIds
            ),
            endBinding: newBindingAfterDeletion(
              element.endBinding,
              deletedElementIds
            )
          });
        }
      });
    };
    newBindingAfterDeletion = (binding, deletedElementIds) => {
      if (binding == null || deletedElementIds.has(binding.elementId)) {
        return null;
      }
      return binding;
    };
    newBoundElementsAfterDeletion = (boundElements, deletedElementIds) => {
      if (!boundElements) {
        return null;
      }
      return boundElements.filter((ele) => !deletedElementIds.has(ele.id));
    };
  }
});

// element/linearElementEditor.ts
var editorMidPointsCache, LinearElementEditor, normalizeSelectedPoints;
var init_linearElementEditor = __esm({
  "element/linearElementEditor.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_math();
    init_element();
    init_bounds();
    init_mutateElement();
    init_binding();
    init_utils();
    init_typeChecks();
    init_keys();
    init_textElement();
    init_constants();
    init_ShapeCache();
    editorMidPointsCache = { version: null, points: [], zoom: null };
    LinearElementEditor = class _LinearElementEditor {
      elementId;
      /** indices */
      selectedPointsIndices;
      pointerDownState;
      /** whether you're dragging a point */
      isDragging;
      lastUncommittedPoint;
      pointerOffset;
      startBindingElement;
      endBindingElement;
      hoverPointIndex;
      segmentMidPointHoveredCoords;
      constructor(element) {
        this.elementId = element.id;
        _LinearElementEditor.normalizePoints(element);
        this.selectedPointsIndices = null;
        this.lastUncommittedPoint = null;
        this.isDragging = false;
        this.pointerOffset = { x: 0, y: 0 };
        this.startBindingElement = "keep";
        this.endBindingElement = "keep";
        this.pointerDownState = {
          prevSelectedPointsIndices: null,
          lastClickedPoint: -1,
          origin: null,
          segmentMidpoint: {
            value: null,
            index: null,
            added: false
          }
        };
        this.hoverPointIndex = -1;
        this.segmentMidPointHoveredCoords = null;
      }
      // ---------------------------------------------------------------------------
      // static methods
      // ---------------------------------------------------------------------------
      static POINT_HANDLE_SIZE = 10;
      /**
       * @param id the `elementId` from the instance of this class (so that we can
       *  statically guarantee this method returns an ExcalidrawLinearElement)
       */
      static getElement(id, elementsMap) {
        const element = elementsMap.get(id);
        if (element) {
          return element;
        }
        return null;
      }
      static handleBoxSelection(event, appState, setState, elementsMap) {
        if (!appState.editingLinearElement || appState.draggingElement?.type !== "selection") {
          return false;
        }
        const { editingLinearElement } = appState;
        const { selectedPointsIndices, elementId } = editingLinearElement;
        const element = _LinearElementEditor.getElement(elementId, elementsMap);
        if (!element) {
          return false;
        }
        const [selectionX1, selectionY1, selectionX2, selectionY2] = getElementAbsoluteCoords(appState.draggingElement, elementsMap);
        const pointsSceneCoords = _LinearElementEditor.getPointsGlobalCoordinates(
          element,
          elementsMap
        );
        const nextSelectedPoints = pointsSceneCoords.reduce(
          (acc, point2, index) => {
            if (point2[0] >= selectionX1 && point2[0] <= selectionX2 && point2[1] >= selectionY1 && point2[1] <= selectionY2 || event.shiftKey && selectedPointsIndices?.includes(index)) {
              acc.push(index);
            }
            return acc;
          },
          []
        );
        setState({
          editingLinearElement: {
            ...editingLinearElement,
            selectedPointsIndices: nextSelectedPoints.length ? nextSelectedPoints : null
          }
        });
      }
      /** @returns whether point was dragged */
      static handlePointDragging(event, appState, scenePointerX, scenePointerY, maybeSuggestBinding, linearElementEditor, elementsMap) {
        if (!linearElementEditor) {
          return false;
        }
        const { selectedPointsIndices, elementId } = linearElementEditor;
        const element = _LinearElementEditor.getElement(elementId, elementsMap);
        if (!element) {
          return false;
        }
        const draggingPoint = element.points[linearElementEditor.pointerDownState.lastClickedPoint];
        if (selectedPointsIndices && draggingPoint) {
          if (shouldRotateWithDiscreteAngle(event) && selectedPointsIndices.length === 1 && element.points.length > 1) {
            const selectedIndex = selectedPointsIndices[0];
            const referencePoint = element.points[selectedIndex === 0 ? 1 : selectedIndex - 1];
            const [width, height] = _LinearElementEditor._getShiftLockedDelta(
              element,
              elementsMap,
              referencePoint,
              [scenePointerX, scenePointerY],
              event[KEYS.CTRL_OR_CMD] ? null : appState.gridSize
            );
            _LinearElementEditor.movePoints(element, [
              {
                index: selectedIndex,
                point: [width + referencePoint[0], height + referencePoint[1]],
                isDragging: selectedIndex === linearElementEditor.pointerDownState.lastClickedPoint
              }
            ]);
          } else {
            const newDraggingPointPosition = _LinearElementEditor.createPointAt(
              element,
              elementsMap,
              scenePointerX - linearElementEditor.pointerOffset.x,
              scenePointerY - linearElementEditor.pointerOffset.y,
              event[KEYS.CTRL_OR_CMD] ? null : appState.gridSize
            );
            const deltaX = newDraggingPointPosition[0] - draggingPoint[0];
            const deltaY = newDraggingPointPosition[1] - draggingPoint[1];
            _LinearElementEditor.movePoints(
              element,
              selectedPointsIndices.map((pointIndex) => {
                const newPointPosition = pointIndex === linearElementEditor.pointerDownState.lastClickedPoint ? _LinearElementEditor.createPointAt(
                  element,
                  elementsMap,
                  scenePointerX - linearElementEditor.pointerOffset.x,
                  scenePointerY - linearElementEditor.pointerOffset.y,
                  event[KEYS.CTRL_OR_CMD] ? null : appState.gridSize
                ) : [
                  element.points[pointIndex][0] + deltaX,
                  element.points[pointIndex][1] + deltaY
                ];
                return {
                  index: pointIndex,
                  point: newPointPosition,
                  isDragging: pointIndex === linearElementEditor.pointerDownState.lastClickedPoint
                };
              })
            );
          }
          const boundTextElement = getBoundTextElement(element, elementsMap);
          if (boundTextElement) {
            handleBindTextResize(element, elementsMap, false);
          }
          if (isBindingElement(element, false)) {
            const coords = [];
            const firstSelectedIndex = selectedPointsIndices[0];
            if (firstSelectedIndex === 0) {
              coords.push(
                tupleToCoors(
                  _LinearElementEditor.getPointGlobalCoordinates(
                    element,
                    element.points[0],
                    elementsMap
                  )
                )
              );
            }
            const lastSelectedIndex = selectedPointsIndices[selectedPointsIndices.length - 1];
            if (lastSelectedIndex === element.points.length - 1) {
              coords.push(
                tupleToCoors(
                  _LinearElementEditor.getPointGlobalCoordinates(
                    element,
                    element.points[lastSelectedIndex],
                    elementsMap
                  )
                )
              );
            }
            if (coords.length) {
              maybeSuggestBinding(element, coords);
            }
          }
          return true;
        }
        return false;
      }
      static handlePointerUp(event, editingLinearElement, appState, elements, elementsMap) {
        const { elementId, selectedPointsIndices, isDragging, pointerDownState } = editingLinearElement;
        const element = _LinearElementEditor.getElement(elementId, elementsMap);
        if (!element) {
          return editingLinearElement;
        }
        const bindings = {};
        if (isDragging && selectedPointsIndices) {
          for (const selectedPoint of selectedPointsIndices) {
            if (selectedPoint === 0 || selectedPoint === element.points.length - 1) {
              if (isPathALoop(element.points, appState.zoom.value)) {
                _LinearElementEditor.movePoints(element, [
                  {
                    index: selectedPoint,
                    point: selectedPoint === 0 ? element.points[element.points.length - 1] : element.points[0]
                  }
                ]);
              }
              const bindingElement = isBindingEnabled(appState) ? getHoveredElementForBinding(
                tupleToCoors(
                  _LinearElementEditor.getPointAtIndexGlobalCoordinates(
                    element,
                    selectedPoint,
                    elementsMap
                  )
                ),
                elements,
                elementsMap
              ) : null;
              bindings[selectedPoint === 0 ? "startBindingElement" : "endBindingElement"] = bindingElement;
            }
          }
        }
        return {
          ...editingLinearElement,
          ...bindings,
          // if clicking without previously dragging a point(s), and not holding
          // shift, deselect all points except the one clicked. If holding shift,
          // toggle the point.
          selectedPointsIndices: isDragging || event.shiftKey ? !isDragging && event.shiftKey && pointerDownState.prevSelectedPointsIndices?.includes(
            pointerDownState.lastClickedPoint
          ) ? selectedPointsIndices && selectedPointsIndices.filter(
            (pointIndex) => pointIndex !== pointerDownState.lastClickedPoint
          ) : selectedPointsIndices : selectedPointsIndices?.includes(pointerDownState.lastClickedPoint) ? [pointerDownState.lastClickedPoint] : selectedPointsIndices,
          isDragging: false,
          pointerOffset: { x: 0, y: 0 }
        };
      }
      static getEditorMidPoints = (element, elementsMap, appState) => {
        const boundText = getBoundTextElement(element, elementsMap);
        if (!appState.editingLinearElement && element.points.length > 2 && !boundText) {
          return [];
        }
        if (editorMidPointsCache.version === element.version && editorMidPointsCache.zoom === appState.zoom.value) {
          return editorMidPointsCache.points;
        }
        _LinearElementEditor.updateEditorMidPointsCache(
          element,
          elementsMap,
          appState
        );
        return editorMidPointsCache.points;
      };
      static updateEditorMidPointsCache = (element, elementsMap, appState) => {
        const points = _LinearElementEditor.getPointsGlobalCoordinates(
          element,
          elementsMap
        );
        let index = 0;
        const midpoints = [];
        while (index < points.length - 1) {
          if (_LinearElementEditor.isSegmentTooShort(
            element,
            element.points[index],
            element.points[index + 1],
            appState.zoom
          )) {
            midpoints.push(null);
            index++;
            continue;
          }
          const segmentMidPoint = _LinearElementEditor.getSegmentMidPoint(
            element,
            points[index],
            points[index + 1],
            index + 1,
            elementsMap
          );
          midpoints.push(segmentMidPoint);
          index++;
        }
        editorMidPointsCache.points = midpoints;
        editorMidPointsCache.version = element.version;
        editorMidPointsCache.zoom = appState.zoom.value;
      };
      static getSegmentMidpointHitCoords = (linearElementEditor, scenePointer, appState, elementsMap) => {
        const { elementId } = linearElementEditor;
        const element = _LinearElementEditor.getElement(elementId, elementsMap);
        if (!element) {
          return null;
        }
        const clickedPointIndex = _LinearElementEditor.getPointIndexUnderCursor(
          element,
          elementsMap,
          appState.zoom,
          scenePointer.x,
          scenePointer.y
        );
        if (clickedPointIndex >= 0) {
          return null;
        }
        const points = _LinearElementEditor.getPointsGlobalCoordinates(
          element,
          elementsMap
        );
        if (points.length >= 3 && !appState.editingLinearElement) {
          return null;
        }
        const threshold = _LinearElementEditor.POINT_HANDLE_SIZE / appState.zoom.value;
        const existingSegmentMidpointHitCoords = linearElementEditor.segmentMidPointHoveredCoords;
        if (existingSegmentMidpointHitCoords) {
          const distance3 = distance2d(
            existingSegmentMidpointHitCoords[0],
            existingSegmentMidpointHitCoords[1],
            scenePointer.x,
            scenePointer.y
          );
          if (distance3 <= threshold) {
            return existingSegmentMidpointHitCoords;
          }
        }
        let index = 0;
        const midPoints = _LinearElementEditor.getEditorMidPoints(element, elementsMap, appState);
        while (index < midPoints.length) {
          if (midPoints[index] !== null) {
            const distance3 = distance2d(
              midPoints[index][0],
              midPoints[index][1],
              scenePointer.x,
              scenePointer.y
            );
            if (distance3 <= threshold) {
              return midPoints[index];
            }
          }
          index++;
        }
        return null;
      };
      static isSegmentTooShort(element, startPoint, endPoint, zoom) {
        let distance3 = distance2d(
          startPoint[0],
          startPoint[1],
          endPoint[0],
          endPoint[1]
        );
        if (element.points.length > 2 && element.roundness) {
          distance3 = getBezierCurveLength(element, endPoint);
        }
        return distance3 * zoom.value < _LinearElementEditor.POINT_HANDLE_SIZE * 4;
      }
      static getSegmentMidPoint(element, startPoint, endPoint, endPointIndex, elementsMap) {
        let segmentMidPoint = centerPoint(startPoint, endPoint);
        if (element.points.length > 2 && element.roundness) {
          const controlPoints = getControlPointsForBezierCurve(
            element,
            element.points[endPointIndex]
          );
          if (controlPoints) {
            const t2 = mapIntervalToBezierT(
              element,
              element.points[endPointIndex],
              0.5
            );
            const [tx, ty] = getBezierXY(
              controlPoints[0],
              controlPoints[1],
              controlPoints[2],
              controlPoints[3],
              t2
            );
            segmentMidPoint = _LinearElementEditor.getPointGlobalCoordinates(
              element,
              [tx, ty],
              elementsMap
            );
          }
        }
        return segmentMidPoint;
      }
      static getSegmentMidPointIndex(linearElementEditor, appState, midPoint, elementsMap) {
        const element = _LinearElementEditor.getElement(
          linearElementEditor.elementId,
          elementsMap
        );
        if (!element) {
          return -1;
        }
        const midPoints = _LinearElementEditor.getEditorMidPoints(
          element,
          elementsMap,
          appState
        );
        let index = 0;
        while (index < midPoints.length) {
          if (_LinearElementEditor.arePointsEqual(midPoint, midPoints[index])) {
            return index + 1;
          }
          index++;
        }
        return -1;
      }
      static handlePointerDown(event, appState, history, scenePointer, linearElementEditor, elements, elementsMap) {
        const ret = {
          didAddPoint: false,
          hitElement: null,
          linearElementEditor: null
        };
        if (!linearElementEditor) {
          return ret;
        }
        const { elementId } = linearElementEditor;
        const element = _LinearElementEditor.getElement(elementId, elementsMap);
        if (!element) {
          return ret;
        }
        const segmentMidpoint = _LinearElementEditor.getSegmentMidpointHitCoords(
          linearElementEditor,
          scenePointer,
          appState,
          elementsMap
        );
        let segmentMidpointIndex = null;
        if (segmentMidpoint) {
          segmentMidpointIndex = _LinearElementEditor.getSegmentMidPointIndex(
            linearElementEditor,
            appState,
            segmentMidpoint,
            elementsMap
          );
        }
        if (event.altKey && appState.editingLinearElement) {
          if (linearElementEditor.lastUncommittedPoint == null) {
            mutateElement(element, {
              points: [
                ...element.points,
                _LinearElementEditor.createPointAt(
                  element,
                  elementsMap,
                  scenePointer.x,
                  scenePointer.y,
                  event[KEYS.CTRL_OR_CMD] ? null : appState.gridSize
                )
              ]
            });
            ret.didAddPoint = true;
          }
          history.resumeRecording();
          ret.linearElementEditor = {
            ...linearElementEditor,
            pointerDownState: {
              prevSelectedPointsIndices: linearElementEditor.selectedPointsIndices,
              lastClickedPoint: -1,
              origin: { x: scenePointer.x, y: scenePointer.y },
              segmentMidpoint: {
                value: segmentMidpoint,
                index: segmentMidpointIndex,
                added: false
              }
            },
            selectedPointsIndices: [element.points.length - 1],
            lastUncommittedPoint: null,
            endBindingElement: getHoveredElementForBinding(
              scenePointer,
              elements,
              elementsMap
            )
          };
          ret.didAddPoint = true;
          return ret;
        }
        const clickedPointIndex = _LinearElementEditor.getPointIndexUnderCursor(
          element,
          elementsMap,
          appState.zoom,
          scenePointer.x,
          scenePointer.y
        );
        if (clickedPointIndex >= 0 || segmentMidpoint) {
          ret.hitElement = element;
        } else {
          const { startBindingElement, endBindingElement } = linearElementEditor;
          if (isBindingEnabled(appState) && isBindingElement(element)) {
            bindOrUnbindLinearElement(
              element,
              startBindingElement,
              endBindingElement,
              elementsMap
            );
          }
        }
        const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);
        const cx = (x1 + x2) / 2;
        const cy = (y1 + y2) / 2;
        const targetPoint = clickedPointIndex > -1 && rotate(
          element.x + element.points[clickedPointIndex][0],
          element.y + element.points[clickedPointIndex][1],
          cx,
          cy,
          element.angle
        );
        const nextSelectedPointsIndices = clickedPointIndex > -1 || event.shiftKey ? event.shiftKey || linearElementEditor.selectedPointsIndices?.includes(clickedPointIndex) ? normalizeSelectedPoints([
          ...linearElementEditor.selectedPointsIndices || [],
          clickedPointIndex
        ]) : [clickedPointIndex] : null;
        ret.linearElementEditor = {
          ...linearElementEditor,
          pointerDownState: {
            prevSelectedPointsIndices: linearElementEditor.selectedPointsIndices,
            lastClickedPoint: clickedPointIndex,
            origin: { x: scenePointer.x, y: scenePointer.y },
            segmentMidpoint: {
              value: segmentMidpoint,
              index: segmentMidpointIndex,
              added: false
            }
          },
          selectedPointsIndices: nextSelectedPointsIndices,
          pointerOffset: targetPoint ? {
            x: scenePointer.x - targetPoint[0],
            y: scenePointer.y - targetPoint[1]
          } : { x: 0, y: 0 }
        };
        return ret;
      }
      static arePointsEqual(point1, point2) {
        if (!point1 && !point2) {
          return true;
        }
        if (!point1 || !point2) {
          return false;
        }
        return arePointsEqual(point1, point2);
      }
      static handlePointerMove(event, scenePointerX, scenePointerY, appState, elementsMap) {
        if (!appState.editingLinearElement) {
          return null;
        }
        const { elementId, lastUncommittedPoint } = appState.editingLinearElement;
        const element = _LinearElementEditor.getElement(elementId, elementsMap);
        if (!element) {
          return appState.editingLinearElement;
        }
        const { points } = element;
        const lastPoint = points[points.length - 1];
        if (!event.altKey) {
          if (lastPoint === lastUncommittedPoint) {
            _LinearElementEditor.deletePoints(element, [points.length - 1]);
          }
          return {
            ...appState.editingLinearElement,
            lastUncommittedPoint: null
          };
        }
        let newPoint;
        if (shouldRotateWithDiscreteAngle(event) && points.length >= 2) {
          const lastCommittedPoint = points[points.length - 2];
          const [width, height] = _LinearElementEditor._getShiftLockedDelta(
            element,
            elementsMap,
            lastCommittedPoint,
            [scenePointerX, scenePointerY],
            event[KEYS.CTRL_OR_CMD] ? null : appState.gridSize
          );
          newPoint = [
            width + lastCommittedPoint[0],
            height + lastCommittedPoint[1]
          ];
        } else {
          newPoint = _LinearElementEditor.createPointAt(
            element,
            elementsMap,
            scenePointerX - appState.editingLinearElement.pointerOffset.x,
            scenePointerY - appState.editingLinearElement.pointerOffset.y,
            event[KEYS.CTRL_OR_CMD] ? null : appState.gridSize
          );
        }
        if (lastPoint === lastUncommittedPoint) {
          _LinearElementEditor.movePoints(element, [
            {
              index: element.points.length - 1,
              point: newPoint
            }
          ]);
        } else {
          _LinearElementEditor.addPoints(element, appState, [{ point: newPoint }]);
        }
        return {
          ...appState.editingLinearElement,
          lastUncommittedPoint: element.points[element.points.length - 1]
        };
      }
      /** scene coords */
      static getPointGlobalCoordinates(element, point2, elementsMap) {
        const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);
        const cx = (x1 + x2) / 2;
        const cy = (y1 + y2) / 2;
        let { x, y } = element;
        [x, y] = rotate(x + point2[0], y + point2[1], cx, cy, element.angle);
        return [x, y];
      }
      /** scene coords */
      static getPointsGlobalCoordinates(element, elementsMap) {
        const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);
        const cx = (x1 + x2) / 2;
        const cy = (y1 + y2) / 2;
        return element.points.map((point2) => {
          let { x, y } = element;
          [x, y] = rotate(x + point2[0], y + point2[1], cx, cy, element.angle);
          return [x, y];
        });
      }
      static getPointAtIndexGlobalCoordinates(element, indexMaybeFromEnd, elementsMap) {
        const index = indexMaybeFromEnd < 0 ? element.points.length + indexMaybeFromEnd : indexMaybeFromEnd;
        const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);
        const cx = (x1 + x2) / 2;
        const cy = (y1 + y2) / 2;
        const point2 = element.points[index];
        const { x, y } = element;
        return point2 ? rotate(x + point2[0], y + point2[1], cx, cy, element.angle) : rotate(x, y, cx, cy, element.angle);
      }
      static pointFromAbsoluteCoords(element, absoluteCoords, elementsMap) {
        const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);
        const cx = (x1 + x2) / 2;
        const cy = (y1 + y2) / 2;
        const [x, y] = rotate(
          absoluteCoords[0],
          absoluteCoords[1],
          cx,
          cy,
          -element.angle
        );
        return [x - element.x, y - element.y];
      }
      static getPointIndexUnderCursor(element, elementsMap, zoom, x, y) {
        const pointHandles = _LinearElementEditor.getPointsGlobalCoordinates(
          element,
          elementsMap
        );
        let idx = pointHandles.length;
        while (--idx > -1) {
          const point2 = pointHandles[idx];
          if (distance2d(x, y, point2[0], point2[1]) * zoom.value < // +1px to account for outline stroke
          _LinearElementEditor.POINT_HANDLE_SIZE + 1) {
            return idx;
          }
        }
        return -1;
      }
      static createPointAt(element, elementsMap, scenePointerX, scenePointerY, gridSize) {
        const pointerOnGrid = getGridPoint(scenePointerX, scenePointerY, gridSize);
        const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);
        const cx = (x1 + x2) / 2;
        const cy = (y1 + y2) / 2;
        const [rotatedX, rotatedY] = rotate(
          pointerOnGrid[0],
          pointerOnGrid[1],
          cx,
          cy,
          -element.angle
        );
        return [rotatedX - element.x, rotatedY - element.y];
      }
      /**
       * Normalizes line points so that the start point is at [0,0]. This is
       * expected in various parts of the codebase. Also returns new x/y to account
       * for the potential normalization.
       */
      static getNormalizedPoints(element) {
        const { points } = element;
        const offsetX = points[0][0];
        const offsetY = points[0][1];
        return {
          points: points.map((point2, _idx) => {
            return [point2[0] - offsetX, point2[1] - offsetY];
          }),
          x: element.x + offsetX,
          y: element.y + offsetY
        };
      }
      // element-mutating methods
      // ---------------------------------------------------------------------------
      static normalizePoints(element) {
        mutateElement(element, _LinearElementEditor.getNormalizedPoints(element));
      }
      static duplicateSelectedPoints(appState, elementsMap) {
        if (!appState.editingLinearElement) {
          return false;
        }
        const { selectedPointsIndices, elementId } = appState.editingLinearElement;
        const element = _LinearElementEditor.getElement(elementId, elementsMap);
        if (!element || selectedPointsIndices === null) {
          return false;
        }
        const { points } = element;
        const nextSelectedIndices = [];
        let pointAddedToEnd = false;
        let indexCursor = -1;
        const nextPoints = points.reduce((acc, point2, index) => {
          ++indexCursor;
          acc.push(point2);
          const isSelected = selectedPointsIndices.includes(index);
          if (isSelected) {
            const nextPoint = points[index + 1];
            if (!nextPoint) {
              pointAddedToEnd = true;
            }
            acc.push(
              nextPoint ? [(point2[0] + nextPoint[0]) / 2, (point2[1] + nextPoint[1]) / 2] : [point2[0], point2[1]]
            );
            nextSelectedIndices.push(indexCursor + 1);
            ++indexCursor;
          }
          return acc;
        }, []);
        mutateElement(element, { points: nextPoints });
        if (pointAddedToEnd) {
          const lastPoint = element.points[element.points.length - 1];
          _LinearElementEditor.movePoints(element, [
            {
              index: element.points.length - 1,
              point: [lastPoint[0] + 30, lastPoint[1] + 30]
            }
          ]);
        }
        return {
          appState: {
            ...appState,
            editingLinearElement: {
              ...appState.editingLinearElement,
              selectedPointsIndices: nextSelectedIndices
            }
          }
        };
      }
      static deletePoints(element, pointIndices) {
        let offsetX = 0;
        let offsetY = 0;
        const isDeletingOriginPoint = pointIndices.includes(0);
        if (isDeletingOriginPoint) {
          const firstNonDeletedPoint = element.points.find((point2, idx) => {
            return !pointIndices.includes(idx);
          });
          if (firstNonDeletedPoint) {
            offsetX = firstNonDeletedPoint[0];
            offsetY = firstNonDeletedPoint[1];
          }
        }
        const nextPoints = element.points.reduce((acc, point2, idx) => {
          if (!pointIndices.includes(idx)) {
            acc.push(
              !acc.length ? [0, 0] : [point2[0] - offsetX, point2[1] - offsetY]
            );
          }
          return acc;
        }, []);
        _LinearElementEditor._updatePoints(element, nextPoints, offsetX, offsetY);
      }
      static addPoints(element, appState, targetPoints) {
        const offsetX = 0;
        const offsetY = 0;
        const nextPoints = [...element.points, ...targetPoints.map((x) => x.point)];
        _LinearElementEditor._updatePoints(element, nextPoints, offsetX, offsetY);
      }
      static movePoints(element, targetPoints, otherUpdates) {
        const { points } = element;
        let offsetX = 0;
        let offsetY = 0;
        const selectedOriginPoint = targetPoints.find(({ index }) => index === 0);
        if (selectedOriginPoint) {
          offsetX = selectedOriginPoint.point[0] + points[selectedOriginPoint.index][0];
          offsetY = selectedOriginPoint.point[1] + points[selectedOriginPoint.index][1];
        }
        const nextPoints = points.map((point2, idx) => {
          const selectedPointData = targetPoints.find((p) => p.index === idx);
          if (selectedPointData) {
            if (selectedOriginPoint) {
              return point2;
            }
            const deltaX = selectedPointData.point[0] - points[selectedPointData.index][0];
            const deltaY = selectedPointData.point[1] - points[selectedPointData.index][1];
            return [point2[0] + deltaX, point2[1] + deltaY];
          }
          return offsetX || offsetY ? [point2[0] - offsetX, point2[1] - offsetY] : point2;
        });
        _LinearElementEditor._updatePoints(
          element,
          nextPoints,
          offsetX,
          offsetY,
          otherUpdates
        );
      }
      static shouldAddMidpoint(linearElementEditor, pointerCoords, appState, elementsMap) {
        const element = _LinearElementEditor.getElement(
          linearElementEditor.elementId,
          elementsMap
        );
        if (!element) {
          return false;
        }
        const { segmentMidpoint } = linearElementEditor.pointerDownState;
        if (segmentMidpoint.added || segmentMidpoint.value === null || segmentMidpoint.index === null || linearElementEditor.pointerDownState.origin === null) {
          return false;
        }
        const origin = linearElementEditor.pointerDownState.origin;
        const dist = distance2d(
          origin.x,
          origin.y,
          pointerCoords.x,
          pointerCoords.y
        );
        if (!appState.editingLinearElement && dist < DRAGGING_THRESHOLD / appState.zoom.value) {
          return false;
        }
        return true;
      }
      static addMidpoint(linearElementEditor, pointerCoords, appState, snapToGrid, elementsMap) {
        const element = _LinearElementEditor.getElement(
          linearElementEditor.elementId,
          elementsMap
        );
        if (!element) {
          return;
        }
        const { segmentMidpoint } = linearElementEditor.pointerDownState;
        const ret = {
          pointerDownState: linearElementEditor.pointerDownState,
          selectedPointsIndices: linearElementEditor.selectedPointsIndices
        };
        const midpoint = _LinearElementEditor.createPointAt(
          element,
          elementsMap,
          pointerCoords.x,
          pointerCoords.y,
          snapToGrid ? appState.gridSize : null
        );
        const points = [
          ...element.points.slice(0, segmentMidpoint.index),
          midpoint,
          ...element.points.slice(segmentMidpoint.index)
        ];
        mutateElement(element, {
          points
        });
        ret.pointerDownState = {
          ...linearElementEditor.pointerDownState,
          segmentMidpoint: {
            ...linearElementEditor.pointerDownState.segmentMidpoint,
            added: true
          },
          lastClickedPoint: segmentMidpoint.index
        };
        ret.selectedPointsIndices = [segmentMidpoint.index];
        return ret;
      }
      static _updatePoints(element, nextPoints, offsetX, offsetY, otherUpdates) {
        const nextCoords = getElementPointsCoords(element, nextPoints);
        const prevCoords = getElementPointsCoords(element, element.points);
        const nextCenterX = (nextCoords[0] + nextCoords[2]) / 2;
        const nextCenterY = (nextCoords[1] + nextCoords[3]) / 2;
        const prevCenterX = (prevCoords[0] + prevCoords[2]) / 2;
        const prevCenterY = (prevCoords[1] + prevCoords[3]) / 2;
        const dX = prevCenterX - nextCenterX;
        const dY = prevCenterY - nextCenterY;
        const rotated = rotate(offsetX, offsetY, dX, dY, element.angle);
        mutateElement(element, {
          ...otherUpdates,
          points: nextPoints,
          x: element.x + rotated[0],
          y: element.y + rotated[1]
        });
      }
      static _getShiftLockedDelta(element, elementsMap, referencePoint, scenePointer, gridSize) {
        const referencePointCoords = _LinearElementEditor.getPointGlobalCoordinates(
          element,
          referencePoint,
          elementsMap
        );
        const [gridX, gridY] = getGridPoint(
          scenePointer[0],
          scenePointer[1],
          gridSize
        );
        const { width, height } = getLockedLinearCursorAlignSize(
          referencePointCoords[0],
          referencePointCoords[1],
          gridX,
          gridY
        );
        return rotatePoint([width, height], [0, 0], -element.angle);
      }
      static getBoundTextElementPosition = (element, boundTextElement, elementsMap) => {
        const points = _LinearElementEditor.getPointsGlobalCoordinates(
          element,
          elementsMap
        );
        if (points.length < 2) {
          mutateElement(boundTextElement, { isDeleted: true });
        }
        let x = 0;
        let y = 0;
        if (element.points.length % 2 === 1) {
          const index = Math.floor(element.points.length / 2);
          const midPoint = _LinearElementEditor.getPointGlobalCoordinates(
            element,
            element.points[index],
            elementsMap
          );
          x = midPoint[0] - boundTextElement.width / 2;
          y = midPoint[1] - boundTextElement.height / 2;
        } else {
          const index = element.points.length / 2 - 1;
          let midSegmentMidpoint = editorMidPointsCache.points[index];
          if (element.points.length === 2) {
            midSegmentMidpoint = centerPoint(points[0], points[1]);
          }
          if (!midSegmentMidpoint || editorMidPointsCache.version !== element.version) {
            midSegmentMidpoint = _LinearElementEditor.getSegmentMidPoint(
              element,
              points[index],
              points[index + 1],
              index + 1,
              elementsMap
            );
          }
          x = midSegmentMidpoint[0] - boundTextElement.width / 2;
          y = midSegmentMidpoint[1] - boundTextElement.height / 2;
        }
        return { x, y };
      };
      static getMinMaxXYWithBoundText = (element, elementsMap, elementBounds, boundTextElement) => {
        let [x1, y1, x2, y2] = elementBounds;
        const cx = (x1 + x2) / 2;
        const cy = (y1 + y2) / 2;
        const { x: boundTextX1, y: boundTextY1 } = _LinearElementEditor.getBoundTextElementPosition(
          element,
          boundTextElement,
          elementsMap
        );
        const boundTextX2 = boundTextX1 + boundTextElement.width;
        const boundTextY2 = boundTextY1 + boundTextElement.height;
        const topLeftRotatedPoint = rotatePoint([x1, y1], [cx, cy], element.angle);
        const topRightRotatedPoint = rotatePoint([x2, y1], [cx, cy], element.angle);
        const counterRotateBoundTextTopLeft = rotatePoint(
          [boundTextX1, boundTextY1],
          [cx, cy],
          -element.angle
        );
        const counterRotateBoundTextTopRight = rotatePoint(
          [boundTextX2, boundTextY1],
          [cx, cy],
          -element.angle
        );
        const counterRotateBoundTextBottomLeft = rotatePoint(
          [boundTextX1, boundTextY2],
          [cx, cy],
          -element.angle
        );
        const counterRotateBoundTextBottomRight = rotatePoint(
          [boundTextX2, boundTextY2],
          [cx, cy],
          -element.angle
        );
        if (topLeftRotatedPoint[0] < topRightRotatedPoint[0] && topLeftRotatedPoint[1] >= topRightRotatedPoint[1]) {
          x1 = Math.min(x1, counterRotateBoundTextBottomLeft[0]);
          x2 = Math.max(
            x2,
            Math.max(
              counterRotateBoundTextTopRight[0],
              counterRotateBoundTextBottomRight[0]
            )
          );
          y1 = Math.min(y1, counterRotateBoundTextTopLeft[1]);
          y2 = Math.max(y2, counterRotateBoundTextBottomRight[1]);
        } else if (topLeftRotatedPoint[0] >= topRightRotatedPoint[0] && topLeftRotatedPoint[1] > topRightRotatedPoint[1]) {
          x1 = Math.min(x1, counterRotateBoundTextBottomRight[0]);
          x2 = Math.max(
            x2,
            Math.max(
              counterRotateBoundTextTopLeft[0],
              counterRotateBoundTextTopRight[0]
            )
          );
          y1 = Math.min(y1, counterRotateBoundTextBottomLeft[1]);
          y2 = Math.max(y2, counterRotateBoundTextTopRight[1]);
        } else if (topLeftRotatedPoint[0] >= topRightRotatedPoint[0]) {
          x1 = Math.min(x1, counterRotateBoundTextTopRight[0]);
          x2 = Math.max(x2, counterRotateBoundTextBottomLeft[0]);
          y1 = Math.min(y1, counterRotateBoundTextBottomRight[1]);
          y2 = Math.max(y2, counterRotateBoundTextTopLeft[1]);
        } else if (topLeftRotatedPoint[1] <= topRightRotatedPoint[1]) {
          x1 = Math.min(
            x1,
            Math.min(
              counterRotateBoundTextTopRight[0],
              counterRotateBoundTextTopLeft[0]
            )
          );
          x2 = Math.max(x2, counterRotateBoundTextBottomRight[0]);
          y1 = Math.min(y1, counterRotateBoundTextTopRight[1]);
          y2 = Math.max(y2, counterRotateBoundTextBottomLeft[1]);
        }
        return [x1, y1, x2, y2, cx, cy];
      };
      static getElementAbsoluteCoords = (element, elementsMap, includeBoundText = false) => {
        let coords;
        let x1;
        let y1;
        let x2;
        let y2;
        if (element.points.length < 2 || !ShapeCache.get(element)) {
          const { minX, minY, maxX, maxY } = element.points.reduce(
            (limits, [x, y]) => {
              limits.minY = Math.min(limits.minY, y);
              limits.minX = Math.min(limits.minX, x);
              limits.maxX = Math.max(limits.maxX, x);
              limits.maxY = Math.max(limits.maxY, y);
              return limits;
            },
            { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity }
          );
          x1 = minX + element.x;
          y1 = minY + element.y;
          x2 = maxX + element.x;
          y2 = maxY + element.y;
        } else {
          const shape = ShapeCache.generateElementShape(element, null);
          const ops = getCurvePathOps(shape[0]);
          const [minX, minY, maxX, maxY] = getMinMaxXYFromCurvePathOps(ops);
          x1 = minX + element.x;
          y1 = minY + element.y;
          x2 = maxX + element.x;
          y2 = maxY + element.y;
        }
        const cx = (x1 + x2) / 2;
        const cy = (y1 + y2) / 2;
        coords = [x1, y1, x2, y2, cx, cy];
        if (!includeBoundText) {
          return coords;
        }
        const boundTextElement = getBoundTextElement(element, elementsMap);
        if (boundTextElement) {
          coords = _LinearElementEditor.getMinMaxXYWithBoundText(
            element,
            elementsMap,
            [x1, y1, x2, y2],
            boundTextElement
          );
        }
        return coords;
      };
    };
    normalizeSelectedPoints = (points) => {
      let nextPoints = [
        ...new Set(points.filter((p) => p !== null && p !== -1))
      ];
      nextPoints = nextPoints.sort((a, b) => a - b);
      return nextPoints.length ? nextPoints : null;
    };
  }
});

// element/containerCache.ts
var originalContainerCache, updateOriginalContainerCache, resetOriginalContainerCache, getOriginalContainerHeightFromCache;
var init_containerCache = __esm({
  "element/containerCache.ts"() {
    "use strict";
    init_define_import_meta_env();
    originalContainerCache = {};
    updateOriginalContainerCache = (id, height) => {
      const data = originalContainerCache[id] || (originalContainerCache[id] = { height });
      data.height = height;
      return data;
    };
    resetOriginalContainerCache = (id) => {
      if (originalContainerCache[id]) {
        delete originalContainerCache[id];
      }
    };
    getOriginalContainerHeightFromCache = (id) => {
      return originalContainerCache[id]?.height ?? null;
    };
  }
});

// element/textElement.ts
var normalizeText, splitIntoLines, redrawTextBoundingBox, bindTextToShapeAfterDuplication, handleBindTextResize, computeBoundTextPosition, measureText, measureBaseline, detectLineHeight, getLineHeightInPx, getApproxMinLineHeight, canvas, getLineWidth, getTextWidth, getTextHeight, parseTokens, wrapText, charWidth, DUMMY_TEXT, getApproxMinLineWidth, getMaxCharWidth, getBoundTextElementId, getBoundTextElement, getContainerElement, getContainerCenter, getContainerCoords, getTextElementAngle, shouldAllowVerticalAlign, suppportsHorizontalAlign, getTextBindableContainerAtPosition, VALID_CONTAINER_TYPES, isValidTextContainer, computeContainerDimensionForBoundText, getBoundTextMaxWidth, getBoundTextMaxHeight, isMeasureTextSupported, DEFAULT_LINE_HEIGHT, getDefaultLineHeight;
var init_textElement = __esm({
  "element/textElement.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_utils();
    init_mutateElement();
    init_constants();
    init_element();
    init_typeChecks();
    init_linearElementEditor();
    init_typeChecks();
    init_element();
    init_scene();
    init_collision();
    init_containerCache();
    normalizeText = (text) => {
      return normalizeEOL(text).replace(/\t/g, "        ");
    };
    splitIntoLines = (text) => {
      return normalizeText(text).split("\n");
    };
    redrawTextBoundingBox = (textElement, container, elementsMap) => {
      let maxWidth = void 0;
      const boundTextUpdates = {
        x: textElement.x,
        y: textElement.y,
        text: textElement.text,
        width: textElement.width,
        height: textElement.height,
        baseline: textElement.baseline
      };
      boundTextUpdates.text = textElement.text;
      if (container) {
        maxWidth = getBoundTextMaxWidth(container, textElement);
        boundTextUpdates.text = wrapText(
          textElement.originalText,
          getFontString(textElement),
          maxWidth
        );
      }
      const metrics = measureText(
        boundTextUpdates.text,
        getFontString(textElement),
        textElement.lineHeight
      );
      boundTextUpdates.width = metrics.width;
      boundTextUpdates.height = metrics.height;
      boundTextUpdates.baseline = metrics.baseline;
      if (container) {
        const maxContainerHeight = getBoundTextMaxHeight(
          container,
          textElement
        );
        const maxContainerWidth = getBoundTextMaxWidth(container, textElement);
        if (!isArrowElement(container) && metrics.height > maxContainerHeight) {
          const nextHeight = computeContainerDimensionForBoundText(
            metrics.height,
            container.type
          );
          mutateElement(container, { height: nextHeight });
          updateOriginalContainerCache(container.id, nextHeight);
        }
        if (metrics.width > maxContainerWidth) {
          const nextWidth = computeContainerDimensionForBoundText(
            metrics.width,
            container.type
          );
          mutateElement(container, { width: nextWidth });
        }
        const updatedTextElement = {
          ...textElement,
          ...boundTextUpdates
        };
        const { x, y } = computeBoundTextPosition(
          container,
          updatedTextElement,
          elementsMap
        );
        boundTextUpdates.x = x;
        boundTextUpdates.y = y;
      }
      mutateElement(textElement, boundTextUpdates);
    };
    bindTextToShapeAfterDuplication = (newElements, oldElements, oldIdToDuplicatedId) => {
      const newElementsMap = arrayToMap(newElements);
      oldElements.forEach((element) => {
        const newElementId = oldIdToDuplicatedId.get(element.id);
        const boundTextElementId = getBoundTextElementId(element);
        if (boundTextElementId) {
          const newTextElementId = oldIdToDuplicatedId.get(boundTextElementId);
          if (newTextElementId) {
            const newContainer = newElementsMap.get(newElementId);
            if (newContainer) {
              mutateElement(newContainer, {
                boundElements: (element.boundElements || []).filter(
                  (boundElement) => boundElement.id !== newTextElementId && boundElement.id !== boundTextElementId
                ).concat({
                  type: "text",
                  id: newTextElementId
                })
              });
            }
            const newTextElement2 = newElementsMap.get(newTextElementId);
            if (newTextElement2 && isTextElement(newTextElement2)) {
              mutateElement(newTextElement2, {
                containerId: newContainer ? newElementId : null
              });
            }
          }
        }
      });
    };
    handleBindTextResize = (container, elementsMap, transformHandleType, shouldMaintainAspectRatio2 = false) => {
      const boundTextElementId = getBoundTextElementId(container);
      if (!boundTextElementId) {
        return;
      }
      resetOriginalContainerCache(container.id);
      const textElement = getBoundTextElement(container, elementsMap);
      if (textElement && textElement.text) {
        if (!container) {
          return;
        }
        let text = textElement.text;
        let nextHeight = textElement.height;
        let nextWidth = textElement.width;
        const maxWidth = getBoundTextMaxWidth(container, textElement);
        const maxHeight = getBoundTextMaxHeight(container, textElement);
        let containerHeight = container.height;
        let nextBaseLine = textElement.baseline;
        if (shouldMaintainAspectRatio2 || transformHandleType !== "n" && transformHandleType !== "s") {
          if (text) {
            text = wrapText(
              textElement.originalText,
              getFontString(textElement),
              maxWidth
            );
          }
          const metrics = measureText(
            text,
            getFontString(textElement),
            textElement.lineHeight
          );
          nextHeight = metrics.height;
          nextWidth = metrics.width;
          nextBaseLine = metrics.baseline;
        }
        if (nextHeight > maxHeight) {
          containerHeight = computeContainerDimensionForBoundText(
            nextHeight,
            container.type
          );
          const diff = containerHeight - container.height;
          const updatedY = !isArrowElement(container) && (transformHandleType === "ne" || transformHandleType === "nw" || transformHandleType === "n") ? container.y - diff : container.y;
          mutateElement(container, {
            height: containerHeight,
            y: updatedY
          });
        }
        mutateElement(textElement, {
          text,
          width: nextWidth,
          height: nextHeight,
          baseline: nextBaseLine
        });
        if (!isArrowElement(container)) {
          mutateElement(
            textElement,
            computeBoundTextPosition(container, textElement, elementsMap)
          );
        }
      }
    };
    computeBoundTextPosition = (container, boundTextElement, elementsMap) => {
      if (isArrowElement(container)) {
        return LinearElementEditor.getBoundTextElementPosition(
          container,
          boundTextElement,
          elementsMap
        );
      }
      const containerCoords = getContainerCoords(container);
      const maxContainerHeight = getBoundTextMaxHeight(container, boundTextElement);
      const maxContainerWidth = getBoundTextMaxWidth(container, boundTextElement);
      let x;
      let y;
      if (boundTextElement.verticalAlign === VERTICAL_ALIGN.TOP) {
        y = containerCoords.y;
      } else if (boundTextElement.verticalAlign === VERTICAL_ALIGN.BOTTOM) {
        y = containerCoords.y + (maxContainerHeight - boundTextElement.height);
      } else {
        y = containerCoords.y + (maxContainerHeight / 2 - boundTextElement.height / 2);
      }
      if (boundTextElement.textAlign === TEXT_ALIGN.LEFT) {
        x = containerCoords.x;
      } else if (boundTextElement.textAlign === TEXT_ALIGN.RIGHT) {
        x = containerCoords.x + (maxContainerWidth - boundTextElement.width);
      } else {
        x = containerCoords.x + (maxContainerWidth / 2 - boundTextElement.width / 2);
      }
      return { x, y };
    };
    measureText = (text, font, lineHeight) => {
      text = text.split("\n").map((x) => x || " ").join("\n");
      const fontSize = parseFloat(font);
      const height = getTextHeight(text, fontSize, lineHeight);
      const width = getTextWidth(text, font);
      const baseline = measureBaseline(text, font, lineHeight);
      return { width, height, baseline };
    };
    measureBaseline = (text, font, lineHeight, wrapInContainer) => {
      const container = document.createElement("div");
      container.style.position = "absolute";
      container.style.whiteSpace = "pre";
      container.style.font = font;
      container.style.minHeight = "1em";
      if (wrapInContainer) {
        container.style.overflow = "hidden";
        container.style.wordBreak = "break-word";
        container.style.whiteSpace = "pre-wrap";
      }
      container.style.lineHeight = String(lineHeight);
      container.innerText = text;
      document.body.appendChild(container);
      const span = document.createElement("span");
      span.style.display = "inline-block";
      span.style.overflow = "hidden";
      span.style.width = "1px";
      span.style.height = "1px";
      container.appendChild(span);
      let baseline = span.offsetTop + span.offsetHeight;
      const height = container.offsetHeight;
      if (isSafari) {
        const canvasHeight = getTextHeight(text, parseFloat(font), lineHeight);
        const fontSize = parseFloat(font);
        const domHeight = getTextHeight(text, Math.round(fontSize), lineHeight);
        if (canvasHeight > height) {
          baseline += canvasHeight - domHeight;
        }
        if (height > canvasHeight) {
          baseline -= domHeight - canvasHeight;
        }
      }
      document.body.removeChild(container);
      return baseline;
    };
    detectLineHeight = (textElement) => {
      const lineCount = splitIntoLines(textElement.text).length;
      return textElement.height / lineCount / textElement.fontSize;
    };
    getLineHeightInPx = (fontSize, lineHeight) => {
      return fontSize * lineHeight;
    };
    getApproxMinLineHeight = (fontSize, lineHeight) => {
      return getLineHeightInPx(fontSize, lineHeight) + BOUND_TEXT_PADDING * 2;
    };
    getLineWidth = (text, font) => {
      if (!canvas) {
        canvas = document.createElement("canvas");
      }
      const canvas2dContext = canvas.getContext("2d");
      canvas2dContext.font = font;
      const width = canvas2dContext.measureText(text).width;
      if (isTestEnv()) {
        return width * 10;
      }
      return width;
    };
    getTextWidth = (text, font) => {
      const lines = splitIntoLines(text);
      let width = 0;
      lines.forEach((line) => {
        width = Math.max(width, getLineWidth(line, font));
      });
      return width;
    };
    getTextHeight = (text, fontSize, lineHeight) => {
      const lineCount = splitIntoLines(text).length;
      return getLineHeightInPx(fontSize, lineHeight) * lineCount;
    };
    parseTokens = (text) => {
      const words = text.split("-");
      if (words.length > 1) {
        words.forEach((word, index) => {
          if (index !== words.length - 1) {
            words[index] = word += "-";
          }
        });
      }
      return words.join(" ").split(" ");
    };
    wrapText = (text, font, maxWidth) => {
      if (!Number.isFinite(maxWidth) || maxWidth < 0) {
        return text;
      }
      const lines = [];
      const originalLines = text.split("\n");
      const spaceWidth = getLineWidth(" ", font);
      let currentLine = "";
      let currentLineWidthTillNow = 0;
      const push = (str) => {
        if (str.trim()) {
          lines.push(str);
        }
      };
      const resetParams = () => {
        currentLine = "";
        currentLineWidthTillNow = 0;
      };
      originalLines.forEach((originalLine) => {
        const currentLineWidth = getTextWidth(originalLine, font);
        if (currentLineWidth <= maxWidth) {
          lines.push(originalLine);
          return;
        }
        const words = parseTokens(originalLine);
        resetParams();
        let index = 0;
        while (index < words.length) {
          const currentWordWidth = getLineWidth(words[index], font);
          if (currentWordWidth === maxWidth) {
            push(words[index]);
            index++;
          } else if (currentWordWidth > maxWidth) {
            push(currentLine);
            resetParams();
            while (words[index].length > 0) {
              const currentChar = String.fromCodePoint(
                words[index].codePointAt(0)
              );
              const width = charWidth.calculate(currentChar, font);
              currentLineWidthTillNow += width;
              words[index] = words[index].slice(currentChar.length);
              if (currentLineWidthTillNow >= maxWidth) {
                push(currentLine);
                currentLine = currentChar;
                currentLineWidthTillNow = width;
              } else {
                currentLine += currentChar;
              }
            }
            if (currentLineWidthTillNow + spaceWidth >= maxWidth) {
              push(currentLine);
              resetParams();
            } else if (!currentLine.endsWith("-")) {
              currentLine += " ";
              currentLineWidthTillNow += spaceWidth;
            }
            index++;
          } else {
            while (currentLineWidthTillNow < maxWidth && index < words.length) {
              const word = words[index];
              currentLineWidthTillNow = getLineWidth(currentLine + word, font);
              if (currentLineWidthTillNow > maxWidth) {
                push(currentLine);
                resetParams();
                break;
              }
              index++;
              const shouldAppendSpace = !word.endsWith("-");
              currentLine += word;
              if (shouldAppendSpace) {
                currentLine += " ";
              }
              if (currentLineWidthTillNow + spaceWidth >= maxWidth) {
                if (shouldAppendSpace) {
                  lines.push(currentLine.slice(0, -1));
                } else {
                  lines.push(currentLine);
                }
                resetParams();
                break;
              }
            }
          }
        }
        if (currentLine.slice(-1) === " ") {
          currentLine = currentLine.slice(0, -1);
          push(currentLine);
        }
      });
      return lines.join("\n");
    };
    charWidth = /* @__PURE__ */ (() => {
      const cachedCharWidth = {};
      const calculate = (char, font) => {
        const ascii = char.charCodeAt(0);
        if (!cachedCharWidth[font]) {
          cachedCharWidth[font] = [];
        }
        if (!cachedCharWidth[font][ascii]) {
          const width = getLineWidth(char, font);
          cachedCharWidth[font][ascii] = width;
        }
        return cachedCharWidth[font][ascii];
      };
      const getCache = (font) => {
        return cachedCharWidth[font];
      };
      return {
        calculate,
        getCache
      };
    })();
    DUMMY_TEXT = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789".toLocaleUpperCase();
    getApproxMinLineWidth = (font, lineHeight) => {
      const maxCharWidth = getMaxCharWidth(font);
      if (maxCharWidth === 0) {
        return measureText(DUMMY_TEXT.split("").join("\n"), font, lineHeight).width + BOUND_TEXT_PADDING * 2;
      }
      return maxCharWidth + BOUND_TEXT_PADDING * 2;
    };
    getMaxCharWidth = (font) => {
      const cache = charWidth.getCache(font);
      if (!cache) {
        return 0;
      }
      const cacheWithOutEmpty = cache.filter((val) => val !== void 0);
      return Math.max(...cacheWithOutEmpty);
    };
    getBoundTextElementId = (container) => {
      return container?.boundElements?.length ? container?.boundElements?.filter((ele) => ele.type === "text")[0]?.id || null : null;
    };
    getBoundTextElement = (element, elementsMap) => {
      if (!element) {
        return null;
      }
      const boundTextElementId = getBoundTextElementId(element);
      if (boundTextElementId) {
        return elementsMap.get(boundTextElementId) || null;
      }
      return null;
    };
    getContainerElement = (element, elementsMap) => {
      if (!element) {
        return null;
      }
      if (element.containerId) {
        return elementsMap.get(element.containerId) || null;
      }
      return null;
    };
    getContainerCenter = (container, appState, elementsMap) => {
      if (!isArrowElement(container)) {
        return {
          x: container.x + container.width / 2,
          y: container.y + container.height / 2
        };
      }
      const points = LinearElementEditor.getPointsGlobalCoordinates(
        container,
        elementsMap
      );
      if (points.length % 2 === 1) {
        const index2 = Math.floor(container.points.length / 2);
        const midPoint = LinearElementEditor.getPointGlobalCoordinates(
          container,
          container.points[index2],
          elementsMap
        );
        return { x: midPoint[0], y: midPoint[1] };
      }
      const index = container.points.length / 2 - 1;
      let midSegmentMidpoint = LinearElementEditor.getEditorMidPoints(
        container,
        elementsMap,
        appState
      )[index];
      if (!midSegmentMidpoint) {
        midSegmentMidpoint = LinearElementEditor.getSegmentMidPoint(
          container,
          points[index],
          points[index + 1],
          index + 1,
          elementsMap
        );
      }
      return { x: midSegmentMidpoint[0], y: midSegmentMidpoint[1] };
    };
    getContainerCoords = (container) => {
      let offsetX = BOUND_TEXT_PADDING;
      let offsetY = BOUND_TEXT_PADDING;
      if (container.type === "ellipse") {
        offsetX += container.width / 2 * (1 - Math.sqrt(2) / 2);
        offsetY += container.height / 2 * (1 - Math.sqrt(2) / 2);
      }
      if (container.type === "diamond") {
        offsetX += container.width / 4;
        offsetY += container.height / 4;
      }
      return {
        x: container.x + offsetX,
        y: container.y + offsetY
      };
    };
    getTextElementAngle = (textElement, container) => {
      if (!container || isArrowElement(container)) {
        return textElement.angle;
      }
      return container.angle;
    };
    shouldAllowVerticalAlign = (selectedElements, elementsMap) => {
      return selectedElements.some((element) => {
        if (isBoundToContainer(element)) {
          const container = getContainerElement(element, elementsMap);
          if (isArrowElement(container)) {
            return false;
          }
          return true;
        }
        return false;
      });
    };
    suppportsHorizontalAlign = (selectedElements, elementsMap) => {
      return selectedElements.some((element) => {
        if (isBoundToContainer(element)) {
          const container = getContainerElement(element, elementsMap);
          if (isArrowElement(container)) {
            return false;
          }
          return true;
        }
        return isTextElement(element);
      });
    };
    getTextBindableContainerAtPosition = (elements, appState, x, y, elementsMap) => {
      const selectedElements = getSelectedElements(elements, appState);
      if (selectedElements.length === 1) {
        return isTextBindableContainer(selectedElements[0], false) ? selectedElements[0] : null;
      }
      let hitElement = null;
      for (let index = elements.length - 1; index >= 0; --index) {
        if (elements[index].isDeleted) {
          continue;
        }
        const [x1, y1, x2, y2] = getElementAbsoluteCoords(
          elements[index],
          elementsMap
        );
        if (isArrowElement(elements[index]) && isHittingElementNotConsideringBoundingBox(
          elements[index],
          appState,
          null,
          [x, y],
          elementsMap
        )) {
          hitElement = elements[index];
          break;
        } else if (x1 < x && x < x2 && y1 < y && y < y2) {
          hitElement = elements[index];
          break;
        }
      }
      return isTextBindableContainer(hitElement, false) ? hitElement : null;
    };
    VALID_CONTAINER_TYPES = /* @__PURE__ */ new Set([
      "rectangle",
      "ellipse",
      "diamond",
      "arrow"
    ]);
    isValidTextContainer = (element) => VALID_CONTAINER_TYPES.has(element.type);
    computeContainerDimensionForBoundText = (dimension, containerType) => {
      dimension = Math.ceil(dimension);
      const padding = BOUND_TEXT_PADDING * 2;
      if (containerType === "ellipse") {
        return Math.round((dimension + padding) / Math.sqrt(2) * 2);
      }
      if (containerType === "arrow") {
        return dimension + padding * 8;
      }
      if (containerType === "diamond") {
        return 2 * (dimension + padding);
      }
      return dimension + padding;
    };
    getBoundTextMaxWidth = (container, boundTextElement) => {
      const { width } = container;
      if (isArrowElement(container)) {
        const minWidth = (boundTextElement?.fontSize ?? DEFAULT_FONT_SIZE) * ARROW_LABEL_FONT_SIZE_TO_MIN_WIDTH_RATIO;
        return Math.max(ARROW_LABEL_WIDTH_FRACTION * width, minWidth);
      }
      if (container.type === "ellipse") {
        return Math.round(width / 2 * Math.sqrt(2)) - BOUND_TEXT_PADDING * 2;
      }
      if (container.type === "diamond") {
        return Math.round(width / 2) - BOUND_TEXT_PADDING * 2;
      }
      return width - BOUND_TEXT_PADDING * 2;
    };
    getBoundTextMaxHeight = (container, boundTextElement) => {
      const { height } = container;
      if (isArrowElement(container)) {
        const containerHeight = height - BOUND_TEXT_PADDING * 8 * 2;
        if (containerHeight <= 0) {
          return boundTextElement.height;
        }
        return height;
      }
      if (container.type === "ellipse") {
        return Math.round(height / 2 * Math.sqrt(2)) - BOUND_TEXT_PADDING * 2;
      }
      if (container.type === "diamond") {
        return Math.round(height / 2) - BOUND_TEXT_PADDING * 2;
      }
      return height - BOUND_TEXT_PADDING * 2;
    };
    isMeasureTextSupported = () => {
      const width = getTextWidth(
        DUMMY_TEXT,
        getFontString({
          fontSize: DEFAULT_FONT_SIZE,
          fontFamily: DEFAULT_FONT_FAMILY
        })
      );
      return width > 0;
    };
    DEFAULT_LINE_HEIGHT = {
      // ~1.25 is the average for Virgil in WebKit and Blink.
      // Gecko (FF) uses ~1.28.
      [FONT_FAMILY.Virgil]: 1.25,
      // ~1.15 is the average for Virgil in WebKit and Blink.
      // Gecko if all over the place.
      [FONT_FAMILY.Helvetica]: 1.15,
      // ~1.2 is the average for Virgil in WebKit and Blink, and kinda Gecko too
      [FONT_FAMILY.Cascadia]: 1.2
    };
    getDefaultLineHeight = (fontFamily) => {
      if (fontFamily in DEFAULT_LINE_HEIGHT) {
        return DEFAULT_LINE_HEIGHT[fontFamily];
      }
      return DEFAULT_LINE_HEIGHT[DEFAULT_FONT_FAMILY];
    };
  }
});

// element/bounds.ts
import rough from "roughjs/bin/rough";
var ElementBounds, getElementAbsoluteCoords, getElementLineSegments, getRectangleBoxAbsoluteCoords, getDiamondPoints, getCurvePathOps, getBezierValueForT, solveQuadratic, getCubicBezierCurveBound, getMinMaxXYFromCurvePathOps, getBoundsFromPoints, getFreeDrawElementAbsoluteCoords, getArrowheadSize, getArrowheadAngle, getArrowheadPoints, generateLinearElementShape, getLinearElementRotatedBounds, getElementBounds, getCommonBounds, getDraggedElementsBounds, getResizedElementAbsoluteCoords, getElementPointsCoords, getClosestElementBounds, getCommonBoundingBox, getVisibleSceneBounds;
var init_bounds = __esm({
  "element/bounds.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_math();
    init_Shape();
    init_typeChecks();
    init_points();
    init_textElement();
    init_linearElementEditor();
    init_ShapeCache();
    init_utils();
    ElementBounds = class _ElementBounds {
      static boundsCache = /* @__PURE__ */ new WeakMap();
      static getBounds(element, elementsMap) {
        const cachedBounds = _ElementBounds.boundsCache.get(element);
        if (cachedBounds?.version && cachedBounds.version === element.version && // we don't invalidate cache when we update containers and not labels,
        // which is causing problems down the line. Fix TBA.
        !isBoundToContainer(element)) {
          return cachedBounds.bounds;
        }
        const bounds = _ElementBounds.calculateBounds(element, elementsMap);
        _ElementBounds.boundsCache.set(element, {
          version: element.version,
          bounds
        });
        return bounds;
      }
      static calculateBounds(element, elementsMap) {
        let bounds;
        const [x1, y1, x2, y2, cx, cy] = getElementAbsoluteCoords(
          element,
          elementsMap
        );
        if (isFreeDrawElement(element)) {
          const [minX, minY, maxX, maxY] = getBoundsFromPoints(
            element.points.map(
              ([x, y]) => rotate(x, y, cx - element.x, cy - element.y, element.angle)
            )
          );
          return [
            minX + element.x,
            minY + element.y,
            maxX + element.x,
            maxY + element.y
          ];
        } else if (isLinearElement(element)) {
          bounds = getLinearElementRotatedBounds(element, cx, cy, elementsMap);
        } else if (element.type === "diamond") {
          const [x11, y11] = rotate(cx, y1, cx, cy, element.angle);
          const [x12, y12] = rotate(cx, y2, cx, cy, element.angle);
          const [x22, y22] = rotate(x1, cy, cx, cy, element.angle);
          const [x21, y21] = rotate(x2, cy, cx, cy, element.angle);
          const minX = Math.min(x11, x12, x22, x21);
          const minY = Math.min(y11, y12, y22, y21);
          const maxX = Math.max(x11, x12, x22, x21);
          const maxY = Math.max(y11, y12, y22, y21);
          bounds = [minX, minY, maxX, maxY];
        } else if (element.type === "ellipse") {
          const w = (x2 - x1) / 2;
          const h = (y2 - y1) / 2;
          const cos = Math.cos(element.angle);
          const sin = Math.sin(element.angle);
          const ww = Math.hypot(w * cos, h * sin);
          const hh = Math.hypot(h * cos, w * sin);
          bounds = [cx - ww, cy - hh, cx + ww, cy + hh];
        } else {
          const [x11, y11] = rotate(x1, y1, cx, cy, element.angle);
          const [x12, y12] = rotate(x1, y2, cx, cy, element.angle);
          const [x22, y22] = rotate(x2, y2, cx, cy, element.angle);
          const [x21, y21] = rotate(x2, y1, cx, cy, element.angle);
          const minX = Math.min(x11, x12, x22, x21);
          const minY = Math.min(y11, y12, y22, y21);
          const maxX = Math.max(x11, x12, x22, x21);
          const maxY = Math.max(y11, y12, y22, y21);
          bounds = [minX, minY, maxX, maxY];
        }
        return bounds;
      }
    };
    getElementAbsoluteCoords = (element, elementsMap, includeBoundText = false) => {
      if (isFreeDrawElement(element)) {
        return getFreeDrawElementAbsoluteCoords(element);
      } else if (isLinearElement(element)) {
        return LinearElementEditor.getElementAbsoluteCoords(
          element,
          elementsMap,
          includeBoundText
        );
      } else if (isTextElement(element)) {
        const container = elementsMap ? getContainerElement(element, elementsMap) : null;
        if (isArrowElement(container)) {
          const coords = LinearElementEditor.getBoundTextElementPosition(
            container,
            element,
            elementsMap
          );
          return [
            coords.x,
            coords.y,
            coords.x + element.width,
            coords.y + element.height,
            coords.x + element.width / 2,
            coords.y + element.height / 2
          ];
        }
      }
      return [
        element.x,
        element.y,
        element.x + element.width,
        element.y + element.height,
        element.x + element.width / 2,
        element.y + element.height / 2
      ];
    };
    getElementLineSegments = (element, elementsMap) => {
      const [x1, y1, x2, y2, cx, cy] = getElementAbsoluteCoords(
        element,
        elementsMap
      );
      const center = [cx, cy];
      if (isLinearElement(element) || isFreeDrawElement(element)) {
        const segments = [];
        let i = 0;
        while (i < element.points.length - 1) {
          segments.push([
            rotatePoint(
              [
                element.points[i][0] + element.x,
                element.points[i][1] + element.y
              ],
              center,
              element.angle
            ),
            rotatePoint(
              [
                element.points[i + 1][0] + element.x,
                element.points[i + 1][1] + element.y
              ],
              center,
              element.angle
            )
          ]);
          i++;
        }
        return segments;
      }
      const [nw, ne, sw, se, n, s, w, e] = [
        [x1, y1],
        [x2, y1],
        [x1, y2],
        [x2, y2],
        [cx, y1],
        [cx, y2],
        [x1, cy],
        [x2, cy]
      ].map((point2) => rotatePoint(point2, center, element.angle));
      if (element.type === "diamond") {
        return [
          [n, w],
          [n, e],
          [s, w],
          [s, e]
        ];
      }
      if (element.type === "ellipse") {
        return [
          [n, w],
          [n, e],
          [s, w],
          [s, e],
          [n, w],
          [n, e],
          [s, w],
          [s, e]
        ];
      }
      return [
        [nw, ne],
        [sw, se],
        [nw, sw],
        [ne, se],
        [nw, e],
        [sw, e],
        [ne, w],
        [se, w]
      ];
    };
    getRectangleBoxAbsoluteCoords = (boxSceneCoords) => {
      return [
        boxSceneCoords.x,
        boxSceneCoords.y,
        boxSceneCoords.x + boxSceneCoords.width,
        boxSceneCoords.y + boxSceneCoords.height,
        boxSceneCoords.x + boxSceneCoords.width / 2,
        boxSceneCoords.y + boxSceneCoords.height / 2
      ];
    };
    getDiamondPoints = (element) => {
      const topX = Math.floor(element.width / 2) + 1;
      const topY = 0;
      const rightX = element.width;
      const rightY = Math.floor(element.height / 2) + 1;
      const bottomX = topX;
      const bottomY = element.height;
      const leftX = 0;
      const leftY = rightY;
      return [topX, topY, rightX, rightY, bottomX, bottomY, leftX, leftY];
    };
    getCurvePathOps = (shape) => {
      for (const set of shape.sets) {
        if (set.type === "path") {
          return set.ops;
        }
      }
      return shape.sets[0].ops;
    };
    getBezierValueForT = (t2, p0, p1, p2, p3) => {
      const oneMinusT = 1 - t2;
      return Math.pow(oneMinusT, 3) * p0 + 3 * Math.pow(oneMinusT, 2) * t2 * p1 + 3 * oneMinusT * Math.pow(t2, 2) * p2 + Math.pow(t2, 3) * p3;
    };
    solveQuadratic = (p0, p1, p2, p3) => {
      const i = p1 - p0;
      const j = p2 - p1;
      const k = p3 - p2;
      const a = 3 * i - 6 * j + 3 * k;
      const b = 6 * j - 6 * i;
      const c = 3 * i;
      const sqrtPart = b * b - 4 * a * c;
      const hasSolution = sqrtPart >= 0;
      if (!hasSolution) {
        return false;
      }
      let s1 = null;
      let s2 = null;
      let t1 = Infinity;
      let t2 = Infinity;
      if (a === 0) {
        t1 = t2 = -c / b;
      } else {
        t1 = (-b + Math.sqrt(sqrtPart)) / (2 * a);
        t2 = (-b - Math.sqrt(sqrtPart)) / (2 * a);
      }
      if (t1 >= 0 && t1 <= 1) {
        s1 = getBezierValueForT(t1, p0, p1, p2, p3);
      }
      if (t2 >= 0 && t2 <= 1) {
        s2 = getBezierValueForT(t2, p0, p1, p2, p3);
      }
      return [s1, s2];
    };
    getCubicBezierCurveBound = (p0, p1, p2, p3) => {
      const solX = solveQuadratic(p0[0], p1[0], p2[0], p3[0]);
      const solY = solveQuadratic(p0[1], p1[1], p2[1], p3[1]);
      let minX = Math.min(p0[0], p3[0]);
      let maxX = Math.max(p0[0], p3[0]);
      if (solX) {
        const xs = solX.filter((x) => x !== null);
        minX = Math.min(minX, ...xs);
        maxX = Math.max(maxX, ...xs);
      }
      let minY = Math.min(p0[1], p3[1]);
      let maxY = Math.max(p0[1], p3[1]);
      if (solY) {
        const ys = solY.filter((y) => y !== null);
        minY = Math.min(minY, ...ys);
        maxY = Math.max(maxY, ...ys);
      }
      return [minX, minY, maxX, maxY];
    };
    getMinMaxXYFromCurvePathOps = (ops, transformXY) => {
      let currentP = [0, 0];
      const { minX, minY, maxX, maxY } = ops.reduce(
        (limits, { op, data }) => {
          if (op === "move") {
            currentP = data;
          } else if (op === "bcurveTo") {
            const _p1 = [data[0], data[1]];
            const _p2 = [data[2], data[3]];
            const _p3 = [data[4], data[5]];
            const p1 = transformXY ? transformXY(..._p1) : _p1;
            const p2 = transformXY ? transformXY(..._p2) : _p2;
            const p3 = transformXY ? transformXY(..._p3) : _p3;
            const p0 = transformXY ? transformXY(...currentP) : currentP;
            currentP = _p3;
            const [minX2, minY2, maxX2, maxY2] = getCubicBezierCurveBound(
              p0,
              p1,
              p2,
              p3
            );
            limits.minX = Math.min(limits.minX, minX2);
            limits.minY = Math.min(limits.minY, minY2);
            limits.maxX = Math.max(limits.maxX, maxX2);
            limits.maxY = Math.max(limits.maxY, maxY2);
          } else if (op === "lineTo") {
          } else if (op === "qcurveTo") {
          }
          return limits;
        },
        { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity }
      );
      return [minX, minY, maxX, maxY];
    };
    getBoundsFromPoints = (points) => {
      let minX = Infinity;
      let minY = Infinity;
      let maxX = -Infinity;
      let maxY = -Infinity;
      for (const [x, y] of points) {
        minX = Math.min(minX, x);
        minY = Math.min(minY, y);
        maxX = Math.max(maxX, x);
        maxY = Math.max(maxY, y);
      }
      return [minX, minY, maxX, maxY];
    };
    getFreeDrawElementAbsoluteCoords = (element) => {
      const [minX, minY, maxX, maxY] = getBoundsFromPoints(element.points);
      const x1 = minX + element.x;
      const y1 = minY + element.y;
      const x2 = maxX + element.x;
      const y2 = maxY + element.y;
      return [x1, y1, x2, y2, (x1 + x2) / 2, (y1 + y2) / 2];
    };
    getArrowheadSize = (arrowhead) => {
      switch (arrowhead) {
        case "arrow":
          return 25;
        case "diamond":
        case "diamond_outline":
          return 12;
        default:
          return 15;
      }
    };
    getArrowheadAngle = (arrowhead) => {
      switch (arrowhead) {
        case "bar":
          return 90;
        case "arrow":
          return 20;
        default:
          return 25;
      }
    };
    getArrowheadPoints = (element, shape, position, arrowhead) => {
      const ops = getCurvePathOps(shape[0]);
      if (ops.length < 1) {
        return null;
      }
      const index = position === "start" ? 1 : ops.length - 1;
      const data = ops[index].data;
      const p3 = [data[4], data[5]];
      const p2 = [data[2], data[3]];
      const p1 = [data[0], data[1]];
      const prevOp = ops[index - 1];
      let p0 = [0, 0];
      if (prevOp.op === "move") {
        p0 = prevOp.data;
      } else if (prevOp.op === "bcurveTo") {
        p0 = [prevOp.data[4], prevOp.data[5]];
      }
      const equation2 = (t2, idx) => Math.pow(1 - t2, 3) * p3[idx] + 3 * t2 * Math.pow(1 - t2, 2) * p2[idx] + 3 * Math.pow(t2, 2) * (1 - t2) * p1[idx] + p0[idx] * Math.pow(t2, 3);
      const [x2, y2] = position === "start" ? p0 : p3;
      const [x1, y1] = [equation2(0.3, 0), equation2(0.3, 1)];
      const distance3 = Math.hypot(x2 - x1, y2 - y1);
      const nx = (x2 - x1) / distance3;
      const ny = (y2 - y1) / distance3;
      const size = getArrowheadSize(arrowhead);
      let length = 0;
      {
        const [cx, cy] = position === "end" ? element.points[element.points.length - 1] : element.points[0];
        const [px, py] = element.points.length > 1 ? position === "end" ? element.points[element.points.length - 2] : element.points[1] : [0, 0];
        length = Math.hypot(cx - px, cy - py);
      }
      const lengthMultiplier = arrowhead === "diamond" || arrowhead === "diamond_outline" ? 0.25 : 0.5;
      const minSize = Math.min(size, length * lengthMultiplier);
      const xs = x2 - nx * minSize;
      const ys = y2 - ny * minSize;
      if (arrowhead === "dot" || arrowhead === "circle" || arrowhead === "circle_outline") {
        const diameter = Math.hypot(ys - y2, xs - x2) + element.strokeWidth - 2;
        return [x2, y2, diameter];
      }
      const angle = getArrowheadAngle(arrowhead);
      const [x3, y3] = rotate(xs, ys, x2, y2, -angle * Math.PI / 180);
      const [x4, y4] = rotate(xs, ys, x2, y2, angle * Math.PI / 180);
      if (arrowhead === "diamond" || arrowhead === "diamond_outline") {
        let ox;
        let oy;
        if (position === "start") {
          const [px, py] = element.points.length > 1 ? element.points[1] : [0, 0];
          [ox, oy] = rotate(
            x2 + minSize * 2,
            y2,
            x2,
            y2,
            Math.atan2(py - y2, px - x2)
          );
        } else {
          const [px, py] = element.points.length > 1 ? element.points[element.points.length - 2] : [0, 0];
          [ox, oy] = rotate(
            x2 - minSize * 2,
            y2,
            x2,
            y2,
            Math.atan2(y2 - py, x2 - px)
          );
        }
        return [x2, y2, x3, y3, ox, oy, x4, y4];
      }
      return [x2, y2, x3, y3, x4, y4];
    };
    generateLinearElementShape = (element) => {
      const generator = rough.generator();
      const options = generateRoughOptions(element);
      const method = (() => {
        if (element.roundness) {
          return "curve";
        }
        if (options.fill) {
          return "polygon";
        }
        return "linearPath";
      })();
      return generator[method](element.points, options);
    };
    getLinearElementRotatedBounds = (element, cx, cy, elementsMap) => {
      const boundTextElement = getBoundTextElement(element, elementsMap);
      if (element.points.length < 2) {
        const [pointX, pointY] = element.points[0];
        const [x, y] = rotate(
          element.x + pointX,
          element.y + pointY,
          cx,
          cy,
          element.angle
        );
        let coords2 = [x, y, x, y];
        if (boundTextElement) {
          const coordsWithBoundText = LinearElementEditor.getMinMaxXYWithBoundText(
            element,
            elementsMap,
            [x, y, x, y],
            boundTextElement
          );
          coords2 = [
            coordsWithBoundText[0],
            coordsWithBoundText[1],
            coordsWithBoundText[2],
            coordsWithBoundText[3]
          ];
        }
        return coords2;
      }
      const cachedShape = ShapeCache.get(element)?.[0];
      const shape = cachedShape ?? generateLinearElementShape(element);
      const ops = getCurvePathOps(shape);
      const transformXY = (x, y) => rotate(element.x + x, element.y + y, cx, cy, element.angle);
      const res = getMinMaxXYFromCurvePathOps(ops, transformXY);
      let coords = [res[0], res[1], res[2], res[3]];
      if (boundTextElement) {
        const coordsWithBoundText = LinearElementEditor.getMinMaxXYWithBoundText(
          element,
          elementsMap,
          coords,
          boundTextElement
        );
        coords = [
          coordsWithBoundText[0],
          coordsWithBoundText[1],
          coordsWithBoundText[2],
          coordsWithBoundText[3]
        ];
      }
      return coords;
    };
    getElementBounds = (element, elementsMap) => {
      return ElementBounds.getBounds(element, elementsMap);
    };
    getCommonBounds = (elements) => {
      if (!elements.length) {
        return [0, 0, 0, 0];
      }
      let minX = Infinity;
      let maxX = -Infinity;
      let minY = Infinity;
      let maxY = -Infinity;
      const elementsMap = arrayToMap(elements);
      elements.forEach((element) => {
        const [x1, y1, x2, y2] = getElementBounds(element, elementsMap);
        minX = Math.min(minX, x1);
        minY = Math.min(minY, y1);
        maxX = Math.max(maxX, x2);
        maxY = Math.max(maxY, y2);
      });
      return [minX, minY, maxX, maxY];
    };
    getDraggedElementsBounds = (elements, dragOffset) => {
      const [minX, minY, maxX, maxY] = getCommonBounds(elements);
      return [
        minX + dragOffset.x,
        minY + dragOffset.y,
        maxX + dragOffset.x,
        maxY + dragOffset.y
      ];
    };
    getResizedElementAbsoluteCoords = (element, nextWidth, nextHeight, normalizePoints) => {
      if (!(isLinearElement(element) || isFreeDrawElement(element))) {
        return [
          element.x,
          element.y,
          element.x + nextWidth,
          element.y + nextHeight
        ];
      }
      const points = rescalePoints(
        0,
        nextWidth,
        rescalePoints(1, nextHeight, element.points, normalizePoints),
        normalizePoints
      );
      let bounds;
      if (isFreeDrawElement(element)) {
        bounds = getBoundsFromPoints(points);
      } else {
        const gen = rough.generator();
        const curve = !element.roundness ? gen.linearPath(
          points,
          generateRoughOptions(element)
        ) : gen.curve(points, generateRoughOptions(element));
        const ops = getCurvePathOps(curve);
        bounds = getMinMaxXYFromCurvePathOps(ops);
      }
      const [minX, minY, maxX, maxY] = bounds;
      return [
        minX + element.x,
        minY + element.y,
        maxX + element.x,
        maxY + element.y
      ];
    };
    getElementPointsCoords = (element, points) => {
      const gen = rough.generator();
      const curve = element.roundness == null ? gen.linearPath(
        points,
        generateRoughOptions(element)
      ) : gen.curve(points, generateRoughOptions(element));
      const ops = getCurvePathOps(curve);
      const [minX, minY, maxX, maxY] = getMinMaxXYFromCurvePathOps(ops);
      return [
        minX + element.x,
        minY + element.y,
        maxX + element.x,
        maxY + element.y
      ];
    };
    getClosestElementBounds = (elements, from3) => {
      if (!elements.length) {
        return [0, 0, 0, 0];
      }
      let minDistance = Infinity;
      let closestElement = elements[0];
      const elementsMap = arrayToMap(elements);
      elements.forEach((element) => {
        const [x1, y1, x2, y2] = getElementBounds(element, elementsMap);
        const distance3 = distance2d((x1 + x2) / 2, (y1 + y2) / 2, from3.x, from3.y);
        if (distance3 < minDistance) {
          minDistance = distance3;
          closestElement = element;
        }
      });
      return getElementBounds(closestElement, elementsMap);
    };
    getCommonBoundingBox = (elements) => {
      const [minX, minY, maxX, maxY] = getCommonBounds(elements);
      return {
        minX,
        minY,
        maxX,
        maxY,
        width: maxX - minX,
        height: maxY - minY,
        midX: (minX + maxX) / 2,
        midY: (minY + maxY) / 2
      };
    };
    getVisibleSceneBounds = ({
      scrollX,
      scrollY,
      width,
      height,
      zoom
    }) => {
      return [
        -scrollX,
        -scrollY,
        -scrollX + width / zoom.value,
        -scrollY + height / zoom.value
      ];
    };
  }
});

// appState.ts
var defaultExportScale, getDefaultAppState, APP_STATE_STORAGE_CONF, _clearAppStateForStorage, cleanAppStateForExport, clearAppStateForDatabase, isEraserActive, isHandToolActive;
var init_appState = __esm({
  "appState.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_colors();
    init_constants();
    defaultExportScale = EXPORT_SCALES.includes(devicePixelRatio) ? devicePixelRatio : 1;
    getDefaultAppState = () => {
      return {
        showWelcomeScreen: false,
        theme: THEME.LIGHT,
        collaborators: /* @__PURE__ */ new Map(),
        currentChartType: "bar",
        currentItemBackgroundColor: DEFAULT_ELEMENT_PROPS.backgroundColor,
        currentItemEndArrowhead: "arrow",
        currentItemFillStyle: DEFAULT_ELEMENT_PROPS.fillStyle,
        currentItemFontFamily: DEFAULT_FONT_FAMILY,
        currentItemFontSize: DEFAULT_FONT_SIZE,
        currentItemOpacity: DEFAULT_ELEMENT_PROPS.opacity,
        currentItemRoughness: DEFAULT_ELEMENT_PROPS.roughness,
        currentItemStartArrowhead: null,
        currentItemStrokeColor: DEFAULT_ELEMENT_PROPS.strokeColor,
        currentItemRoundness: "round",
        currentItemStrokeStyle: DEFAULT_ELEMENT_PROPS.strokeStyle,
        currentItemStrokeWidth: DEFAULT_ELEMENT_PROPS.strokeWidth,
        currentItemTextAlign: DEFAULT_TEXT_ALIGN,
        cursorButton: "up",
        activeEmbeddable: null,
        draggingElement: null,
        editingElement: null,
        editingGroupId: null,
        editingLinearElement: null,
        activeTool: {
          type: "selection",
          customType: null,
          locked: DEFAULT_ELEMENT_PROPS.locked,
          lastActiveTool: null
        },
        penMode: false,
        penDetected: false,
        errorMessage: null,
        exportBackground: true,
        exportScale: defaultExportScale,
        exportEmbedScene: false,
        exportWithDarkMode: false,
        fileHandle: null,
        gridSize: null,
        isBindingEnabled: true,
        defaultSidebarDockedPreference: false,
        isLoading: false,
        isResizing: false,
        isRotating: false,
        lastPointerDownWith: "mouse",
        multiElement: null,
        name: null,
        contextMenu: null,
        openMenu: null,
        openPopup: null,
        openSidebar: null,
        openDialog: null,
        pasteDialog: { shown: false, data: null },
        previousSelectedElementIds: {},
        resizingElement: null,
        scrolledOutside: false,
        scrollX: 0,
        scrollY: 0,
        selectedElementIds: {},
        selectedGroupIds: {},
        selectedElementsAreBeingDragged: false,
        selectionElement: null,
        shouldCacheIgnoreZoom: false,
        showStats: false,
        startBoundElement: null,
        suggestedBindings: [],
        frameRendering: { enabled: true, clip: true, name: true, outline: true },
        frameToHighlight: null,
        editingFrame: null,
        elementsToHighlight: null,
        toast: null,
        viewBackgroundColor: COLOR_PALETTE.white,
        zenModeEnabled: false,
        zoom: {
          value: 1
        },
        viewModeEnabled: false,
        pendingImageElementId: null,
        showHyperlinkPopup: false,
        selectedLinearElement: null,
        snapLines: [],
        originSnapOffset: {
          x: 0,
          y: 0
        },
        objectsSnapModeEnabled: false,
        userToFollow: null,
        followedBy: /* @__PURE__ */ new Set()
      };
    };
    APP_STATE_STORAGE_CONF = /* @__PURE__ */ ((config) => config)({
      showWelcomeScreen: { browser: true, export: false, server: false },
      theme: { browser: true, export: false, server: false },
      collaborators: { browser: false, export: false, server: false },
      currentChartType: { browser: true, export: false, server: false },
      currentItemBackgroundColor: { browser: true, export: false, server: false },
      currentItemEndArrowhead: { browser: true, export: false, server: false },
      currentItemFillStyle: { browser: true, export: false, server: false },
      currentItemFontFamily: { browser: true, export: false, server: false },
      currentItemFontSize: { browser: true, export: false, server: false },
      currentItemRoundness: {
        browser: true,
        export: false,
        server: false
      },
      currentItemOpacity: { browser: true, export: false, server: false },
      currentItemRoughness: { browser: true, export: false, server: false },
      currentItemStartArrowhead: { browser: true, export: false, server: false },
      currentItemStrokeColor: { browser: true, export: false, server: false },
      currentItemStrokeStyle: { browser: true, export: false, server: false },
      currentItemStrokeWidth: { browser: true, export: false, server: false },
      currentItemTextAlign: { browser: true, export: false, server: false },
      cursorButton: { browser: true, export: false, server: false },
      activeEmbeddable: { browser: false, export: false, server: false },
      draggingElement: { browser: false, export: false, server: false },
      editingElement: { browser: false, export: false, server: false },
      editingGroupId: { browser: true, export: false, server: false },
      editingLinearElement: { browser: false, export: false, server: false },
      activeTool: { browser: true, export: false, server: false },
      penMode: { browser: true, export: false, server: false },
      penDetected: { browser: true, export: false, server: false },
      errorMessage: { browser: false, export: false, server: false },
      exportBackground: { browser: true, export: false, server: false },
      exportEmbedScene: { browser: true, export: false, server: false },
      exportScale: { browser: true, export: false, server: false },
      exportWithDarkMode: { browser: true, export: false, server: false },
      fileHandle: { browser: false, export: false, server: false },
      gridSize: { browser: true, export: true, server: true },
      height: { browser: false, export: false, server: false },
      isBindingEnabled: { browser: false, export: false, server: false },
      defaultSidebarDockedPreference: {
        browser: true,
        export: false,
        server: false
      },
      isLoading: { browser: false, export: false, server: false },
      isResizing: { browser: false, export: false, server: false },
      isRotating: { browser: false, export: false, server: false },
      lastPointerDownWith: { browser: true, export: false, server: false },
      multiElement: { browser: false, export: false, server: false },
      name: { browser: true, export: false, server: false },
      offsetLeft: { browser: false, export: false, server: false },
      offsetTop: { browser: false, export: false, server: false },
      contextMenu: { browser: false, export: false, server: false },
      openMenu: { browser: true, export: false, server: false },
      openPopup: { browser: false, export: false, server: false },
      openSidebar: { browser: true, export: false, server: false },
      openDialog: { browser: false, export: false, server: false },
      pasteDialog: { browser: false, export: false, server: false },
      previousSelectedElementIds: { browser: true, export: false, server: false },
      resizingElement: { browser: false, export: false, server: false },
      scrolledOutside: { browser: true, export: false, server: false },
      scrollX: { browser: true, export: false, server: false },
      scrollY: { browser: true, export: false, server: false },
      selectedElementIds: { browser: true, export: false, server: false },
      selectedGroupIds: { browser: true, export: false, server: false },
      selectedElementsAreBeingDragged: {
        browser: false,
        export: false,
        server: false
      },
      selectionElement: { browser: false, export: false, server: false },
      shouldCacheIgnoreZoom: { browser: true, export: false, server: false },
      showStats: { browser: true, export: false, server: false },
      startBoundElement: { browser: false, export: false, server: false },
      suggestedBindings: { browser: false, export: false, server: false },
      frameRendering: { browser: false, export: false, server: false },
      frameToHighlight: { browser: false, export: false, server: false },
      editingFrame: { browser: false, export: false, server: false },
      elementsToHighlight: { browser: false, export: false, server: false },
      toast: { browser: false, export: false, server: false },
      viewBackgroundColor: { browser: true, export: true, server: true },
      width: { browser: false, export: false, server: false },
      zenModeEnabled: { browser: true, export: false, server: false },
      zoom: { browser: true, export: false, server: false },
      viewModeEnabled: { browser: false, export: false, server: false },
      pendingImageElementId: { browser: false, export: false, server: false },
      showHyperlinkPopup: { browser: false, export: false, server: false },
      selectedLinearElement: { browser: true, export: false, server: false },
      snapLines: { browser: false, export: false, server: false },
      originSnapOffset: { browser: false, export: false, server: false },
      objectsSnapModeEnabled: { browser: true, export: false, server: false },
      userToFollow: { browser: false, export: false, server: false },
      followedBy: { browser: false, export: false, server: false }
    });
    _clearAppStateForStorage = (appState, exportType) => {
      const stateForExport = {};
      for (const key of Object.keys(appState)) {
        const propConfig = APP_STATE_STORAGE_CONF[key];
        if (propConfig?.[exportType]) {
          const nextValue = appState[key];
          stateForExport[key] = nextValue;
        }
      }
      return stateForExport;
    };
    cleanAppStateForExport = (appState) => {
      return _clearAppStateForStorage(appState, "export");
    };
    clearAppStateForDatabase = (appState) => {
      return _clearAppStateForStorage(appState, "server");
    };
    isEraserActive = ({
      activeTool
    }) => activeTool.type === "eraser";
    isHandToolActive = ({
      activeTool
    }) => {
      return activeTool.type === "hand";
    };
  }
});

// actions/register.ts
var actions, register;
var init_register = __esm({
  "actions/register.ts"() {
    "use strict";
    init_define_import_meta_env();
    actions = [];
    register = (action) => {
      actions = actions.concat(action);
      return action;
    };
  }
});

// cursor.ts
import OpenColor from "open-color";
var laserPointerCursorSVG_tag, laserPointerCursorBackgroundSVG, laserPointerCursorIconSVG, laserPointerCursorDataURL_lightMode, laserPointerCursorDataURL_darkMode, resetCursor, setCursor, eraserCanvasCache, previewDataURL, setEraserCursor, setCursorForShape;
var init_cursor = __esm({
  "cursor.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_constants();
    init_appState();
    laserPointerCursorSVG_tag = `<svg viewBox="0 0 24 24" stroke-width="1" width="28" height="28" xmlns="http://www.w3.org/2000/svg">`;
    laserPointerCursorBackgroundSVG = `<path d="M6.164 11.755a5.314 5.314 0 0 1-4.932-5.298 5.314 5.314 0 0 1 5.311-5.311 5.314 5.314 0 0 1 5.307 5.113l8.773 8.773a3.322 3.322 0 0 1 0 4.696l-.895.895a3.322 3.322 0 0 1-4.696 0l-8.868-8.868Z" style="fill:#fff"/>`;
    laserPointerCursorIconSVG = `<path stroke="#1b1b1f" fill="#fff" d="m7.868 11.113 7.773 7.774a2.359 2.359 0 0 0 1.667.691 2.368 2.368 0 0 0 2.357-2.358c0-.625-.248-1.225-.69-1.667L11.201 7.78 9.558 9.469l-1.69 1.643v.001Zm10.273 3.606-3.333 3.333m-3.25-6.583 2 2m-7-7 3 3M3.664 3.625l1 1M2.529 6.922l1.407-.144m5.735-2.932-1.118.866M4.285 9.823l.758-1.194m1.863-6.207-.13 1.408"/>`;
    laserPointerCursorDataURL_lightMode = `data:${MIME_TYPES.svg},${encodeURIComponent(
      `${laserPointerCursorSVG_tag}${laserPointerCursorIconSVG}</svg>`
    )}`;
    laserPointerCursorDataURL_darkMode = `data:${MIME_TYPES.svg},${encodeURIComponent(
      `${laserPointerCursorSVG_tag}${laserPointerCursorBackgroundSVG}${laserPointerCursorIconSVG}</svg>`
    )}`;
    resetCursor = (interactiveCanvas) => {
      if (interactiveCanvas) {
        interactiveCanvas.style.cursor = "";
      }
    };
    setCursor = (interactiveCanvas, cursor) => {
      if (interactiveCanvas) {
        interactiveCanvas.style.cursor = cursor;
      }
    };
    setEraserCursor = (interactiveCanvas, theme) => {
      const cursorImageSizePx = 20;
      const drawCanvas = () => {
        const isDarkTheme = theme === THEME.DARK;
        eraserCanvasCache = document.createElement("canvas");
        eraserCanvasCache.theme = theme;
        eraserCanvasCache.height = cursorImageSizePx;
        eraserCanvasCache.width = cursorImageSizePx;
        const context = eraserCanvasCache.getContext("2d");
        context.lineWidth = 1;
        context.beginPath();
        context.arc(
          eraserCanvasCache.width / 2,
          eraserCanvasCache.height / 2,
          5,
          0,
          2 * Math.PI
        );
        context.fillStyle = isDarkTheme ? OpenColor.black : OpenColor.white;
        context.fill();
        context.strokeStyle = isDarkTheme ? OpenColor.white : OpenColor.black;
        context.stroke();
        previewDataURL = eraserCanvasCache.toDataURL(MIME_TYPES.svg);
      };
      if (!eraserCanvasCache || eraserCanvasCache.theme !== theme) {
        drawCanvas();
      }
      setCursor(
        interactiveCanvas,
        `url(${previewDataURL}) ${cursorImageSizePx / 2} ${cursorImageSizePx / 2}, auto`
      );
    };
    setCursorForShape = (interactiveCanvas, appState) => {
      if (!interactiveCanvas) {
        return;
      }
      if (appState.activeTool.type === "selection") {
        resetCursor(interactiveCanvas);
      } else if (isHandToolActive(appState)) {
        interactiveCanvas.style.cursor = CURSOR_TYPE.GRAB;
      } else if (isEraserActive(appState)) {
        setEraserCursor(interactiveCanvas, appState.theme);
      } else if (appState.activeTool.type === "laser") {
        const url = appState.theme === THEME.LIGHT ? laserPointerCursorDataURL_lightMode : laserPointerCursorDataURL_darkMode;
        interactiveCanvas.style.cursor = `url(${url}), auto`;
      } else if (!["image", "custom"].includes(appState.activeTool.type)) {
        interactiveCanvas.style.cursor = CURSOR_TYPE.CROSSHAIR;
      } else if (appState.activeTool.type !== "image") {
        interactiveCanvas.style.cursor = CURSOR_TYPE.AUTO;
      }
    };
  }
});

// groups.ts
var selectGroup, selectGroupsForSelectedElements, isSelectedViaGroup, getSelectedGroupForElement, getSelectedGroupIds, selectGroupsFromGivenElements, editGroupForSelectedElement, isElementInGroup, getElementsInGroup, getSelectedGroupIdForElement, getNewGroupIdsForDuplication, addToGroup, removeFromSelectedGroups, getMaximumGroups;
var init_groups = __esm({
  "groups.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_scene();
    init_textElement();
    init_selection();
    selectGroup = (groupId, appState, elements) => {
      const elementsInGroup = elements.reduce(
        (acc, element) => {
          if (element.groupIds.includes(groupId)) {
            acc[element.id] = true;
          }
          return acc;
        },
        {}
      );
      if (Object.keys(elementsInGroup).length < 2) {
        if (appState.selectedGroupIds[groupId] || appState.editingGroupId === groupId) {
          return {
            selectedElementIds: appState.selectedElementIds,
            selectedGroupIds: { ...appState.selectedGroupIds, [groupId]: false },
            editingGroupId: null
          };
        }
        return appState;
      }
      return {
        editingGroupId: appState.editingGroupId,
        selectedGroupIds: { ...appState.selectedGroupIds, [groupId]: true },
        selectedElementIds: {
          ...appState.selectedElementIds,
          ...elementsInGroup
        }
      };
    };
    selectGroupsForSelectedElements = function() {
      let lastSelectedElements = null;
      let lastElements = null;
      let lastReturnValue = null;
      const _selectGroups = (selectedElements, elements, appState, prevAppState) => {
        if (lastReturnValue !== void 0 && elements === lastElements && selectedElements === lastSelectedElements && appState.editingGroupId === lastReturnValue?.editingGroupId) {
          return lastReturnValue;
        }
        const selectedGroupIds = {};
        for (const selectedElement of selectedElements) {
          let groupIds = selectedElement.groupIds;
          if (appState.editingGroupId) {
            const indexOfEditingGroup = groupIds.indexOf(appState.editingGroupId);
            if (indexOfEditingGroup > -1) {
              groupIds = groupIds.slice(0, indexOfEditingGroup);
            }
          }
          if (groupIds.length > 0) {
            const lastSelectedGroup = groupIds[groupIds.length - 1];
            selectedGroupIds[lastSelectedGroup] = true;
          }
        }
        const groupElementsIndex = {};
        const selectedElementIdsInGroups = elements.reduce(
          (acc, element) => {
            const groupId = element.groupIds.find((id) => selectedGroupIds[id]);
            if (groupId) {
              acc[element.id] = true;
              if (!Array.isArray(groupElementsIndex[groupId])) {
                groupElementsIndex[groupId] = [element.id];
              } else {
                groupElementsIndex[groupId].push(element.id);
              }
            }
            return acc;
          },
          {}
        );
        for (const groupId of Object.keys(groupElementsIndex)) {
          if (groupElementsIndex[groupId].length < 2) {
            if (selectedGroupIds[groupId]) {
              selectedGroupIds[groupId] = false;
            }
          }
        }
        lastElements = elements;
        lastSelectedElements = selectedElements;
        lastReturnValue = {
          editingGroupId: appState.editingGroupId,
          selectedGroupIds,
          selectedElementIds: makeNextSelectedElementIds(
            {
              ...appState.selectedElementIds,
              ...selectedElementIdsInGroups
            },
            prevAppState
          )
        };
        return lastReturnValue;
      };
      const selectGroupsForSelectedElements2 = (appState, elements, prevAppState, app) => {
        const selectedElements = app ? app.scene.getSelectedElements({
          selectedElementIds: appState.selectedElementIds,
          // supplying elements explicitly in case we're passed non-state elements
          elements
        }) : getSelectedElements(elements, appState);
        if (!selectedElements.length) {
          return {
            selectedGroupIds: {},
            editingGroupId: null,
            selectedElementIds: makeNextSelectedElementIds(
              appState.selectedElementIds,
              prevAppState
            )
          };
        }
        return _selectGroups(selectedElements, elements, appState, prevAppState);
      };
      selectGroupsForSelectedElements2.clearCache = () => {
        lastElements = null;
        lastSelectedElements = null;
        lastReturnValue = null;
      };
      return selectGroupsForSelectedElements2;
    }();
    isSelectedViaGroup = (appState, element) => getSelectedGroupForElement(appState, element) != null;
    getSelectedGroupForElement = (appState, element) => element.groupIds.filter((groupId) => groupId !== appState.editingGroupId).find((groupId) => appState.selectedGroupIds[groupId]);
    getSelectedGroupIds = (appState) => Object.entries(appState.selectedGroupIds).filter(([groupId, isSelected]) => isSelected).map(([groupId, isSelected]) => groupId);
    selectGroupsFromGivenElements = (elements, appState) => {
      let nextAppState = {
        ...appState,
        selectedGroupIds: {}
      };
      for (const element of elements) {
        let groupIds = element.groupIds;
        if (appState.editingGroupId) {
          const indexOfEditingGroup = groupIds.indexOf(appState.editingGroupId);
          if (indexOfEditingGroup > -1) {
            groupIds = groupIds.slice(0, indexOfEditingGroup);
          }
        }
        if (groupIds.length > 0) {
          const groupId = groupIds[groupIds.length - 1];
          nextAppState = {
            ...nextAppState,
            ...selectGroup(groupId, nextAppState, elements)
          };
        }
      }
      return nextAppState.selectedGroupIds;
    };
    editGroupForSelectedElement = (appState, element) => {
      return {
        ...appState,
        editingGroupId: element.groupIds.length ? element.groupIds[0] : null,
        selectedGroupIds: {},
        selectedElementIds: {
          [element.id]: true
        }
      };
    };
    isElementInGroup = (element, groupId) => element.groupIds.includes(groupId);
    getElementsInGroup = (elements, groupId) => {
      const elementsInGroup = [];
      for (const element of elements.values()) {
        if (isElementInGroup(element, groupId)) {
          elementsInGroup.push(element);
        }
      }
      return elementsInGroup;
    };
    getSelectedGroupIdForElement = (element, selectedGroupIds) => element.groupIds.find((groupId) => selectedGroupIds[groupId]);
    getNewGroupIdsForDuplication = (groupIds, editingGroupId, mapper) => {
      const copy = [...groupIds];
      const positionOfEditingGroupId = editingGroupId ? groupIds.indexOf(editingGroupId) : -1;
      const endIndex = positionOfEditingGroupId > -1 ? positionOfEditingGroupId : groupIds.length;
      for (let index = 0; index < endIndex; index++) {
        copy[index] = mapper(copy[index]);
      }
      return copy;
    };
    addToGroup = (prevGroupIds, newGroupId, editingGroupId) => {
      const groupIds = [...prevGroupIds];
      const positionOfEditingGroupId = editingGroupId ? groupIds.indexOf(editingGroupId) : -1;
      const positionToInsert = positionOfEditingGroupId > -1 ? positionOfEditingGroupId : groupIds.length;
      groupIds.splice(positionToInsert, 0, newGroupId);
      return groupIds;
    };
    removeFromSelectedGroups = (groupIds, selectedGroupIds) => groupIds.filter((groupId) => !selectedGroupIds[groupId]);
    getMaximumGroups = (elements, elementsMap) => {
      const groups = /* @__PURE__ */ new Map();
      elements.forEach((element) => {
        const groupId = element.groupIds.length === 0 ? element.id : element.groupIds[element.groupIds.length - 1];
        const currentGroupMembers = groups.get(groupId) || [];
        const boundTextElement = getBoundTextElement(element, elementsMap);
        if (boundTextElement) {
          currentGroupMembers.push(boundTextElement);
        }
        groups.set(groupId, [...currentGroupMembers, element]);
      });
      return Array.from(groups.values());
    };
  }
});

// element/newElement.ts
var _newElementBase, newElement, newEmbeddableElement, newIframeElement, newFrameElement, newMagicFrameElement, getTextElementPositionOffsets, newTextElement, getAdjustedDimensions, refreshTextDimensions, updateTextElement, newFreeDrawElement, newLinearElement, newImageElement, _deepCopyElement, deepCopyElement, regenerateId, duplicateElement, duplicateElements;
var init_newElement = __esm({
  "element/newElement.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_utils();
    init_random();
    init_mutateElement();
    init_groups();
    init_element();
    init_math();
    init_bounds();
    init_textElement();
    init_constants();
    _newElementBase = (type, {
      x,
      y,
      strokeColor = DEFAULT_ELEMENT_PROPS.strokeColor,
      backgroundColor = DEFAULT_ELEMENT_PROPS.backgroundColor,
      fillStyle = DEFAULT_ELEMENT_PROPS.fillStyle,
      strokeWidth = DEFAULT_ELEMENT_PROPS.strokeWidth,
      strokeStyle = DEFAULT_ELEMENT_PROPS.strokeStyle,
      roughness = DEFAULT_ELEMENT_PROPS.roughness,
      opacity = DEFAULT_ELEMENT_PROPS.opacity,
      width = 0,
      height = 0,
      angle = 0,
      groupIds = [],
      frameId = null,
      roundness = null,
      boundElements = null,
      link = null,
      locked = DEFAULT_ELEMENT_PROPS.locked,
      ...rest
    }) => {
      const element = {
        id: rest.id || randomId(),
        type,
        x,
        y,
        width,
        height,
        angle,
        strokeColor,
        backgroundColor,
        fillStyle,
        strokeWidth,
        strokeStyle,
        roughness,
        opacity,
        groupIds,
        frameId,
        roundness,
        seed: rest.seed ?? randomInteger(),
        version: rest.version || 1,
        versionNonce: rest.versionNonce ?? 0,
        isDeleted: false,
        boundElements,
        updated: getUpdatedTimestamp(),
        link,
        locked,
        customData: rest.customData
      };
      return element;
    };
    newElement = (opts) => _newElementBase(opts.type, opts);
    newEmbeddableElement = (opts) => {
      return _newElementBase("embeddable", opts);
    };
    newIframeElement = (opts) => {
      return {
        ..._newElementBase("iframe", opts)
      };
    };
    newFrameElement = (opts) => {
      const frameElement = newElementWith(
        {
          ..._newElementBase("frame", opts),
          type: "frame",
          name: opts?.name || null
        },
        {}
      );
      return frameElement;
    };
    newMagicFrameElement = (opts) => {
      const frameElement = newElementWith(
        {
          ..._newElementBase("magicframe", opts),
          type: "magicframe",
          name: opts?.name || null
        },
        {}
      );
      return frameElement;
    };
    getTextElementPositionOffsets = (opts, metrics) => {
      return {
        x: opts.textAlign === "center" ? metrics.width / 2 : opts.textAlign === "right" ? metrics.width : 0,
        y: opts.verticalAlign === "middle" ? metrics.height / 2 : 0
      };
    };
    newTextElement = (opts) => {
      const fontFamily = opts.fontFamily || DEFAULT_FONT_FAMILY;
      const fontSize = opts.fontSize || DEFAULT_FONT_SIZE;
      const lineHeight = opts.lineHeight || getDefaultLineHeight(fontFamily);
      const text = normalizeText(opts.text);
      const metrics = measureText(
        text,
        getFontString({ fontFamily, fontSize }),
        lineHeight
      );
      const textAlign = opts.textAlign || DEFAULT_TEXT_ALIGN;
      const verticalAlign = opts.verticalAlign || DEFAULT_VERTICAL_ALIGN;
      const offsets = getTextElementPositionOffsets(
        { textAlign, verticalAlign },
        metrics
      );
      const textElement = newElementWith(
        {
          ..._newElementBase("text", opts),
          text,
          fontSize,
          fontFamily,
          textAlign,
          verticalAlign,
          x: opts.x - offsets.x,
          y: opts.y - offsets.y,
          width: metrics.width,
          height: metrics.height,
          baseline: metrics.baseline,
          containerId: opts.containerId || null,
          originalText: text,
          lineHeight
        },
        {}
      );
      return textElement;
    };
    getAdjustedDimensions = (element, elementsMap, nextText) => {
      const {
        width: nextWidth,
        height: nextHeight,
        baseline: nextBaseline
      } = measureText(nextText, getFontString(element), element.lineHeight);
      const { textAlign, verticalAlign } = element;
      let x;
      let y;
      if (textAlign === "center" && verticalAlign === VERTICAL_ALIGN.MIDDLE && !element.containerId) {
        const prevMetrics = measureText(
          element.text,
          getFontString(element),
          element.lineHeight
        );
        const offsets = getTextElementPositionOffsets(element, {
          width: nextWidth - prevMetrics.width,
          height: nextHeight - prevMetrics.height
        });
        x = element.x - offsets.x;
        y = element.y - offsets.y;
      } else {
        const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);
        const [nextX1, nextY1, nextX2, nextY2] = getResizedElementAbsoluteCoords(
          element,
          nextWidth,
          nextHeight,
          false
        );
        const deltaX1 = (x1 - nextX1) / 2;
        const deltaY1 = (y1 - nextY1) / 2;
        const deltaX2 = (x2 - nextX2) / 2;
        const deltaY2 = (y2 - nextY2) / 2;
        [x, y] = adjustXYWithRotation(
          {
            s: true,
            e: textAlign === "center" || textAlign === "left",
            w: textAlign === "center" || textAlign === "right"
          },
          element.x,
          element.y,
          element.angle,
          deltaX1,
          deltaY1,
          deltaX2,
          deltaY2
        );
      }
      return {
        width: nextWidth,
        height: nextHeight,
        baseline: nextBaseline,
        x: Number.isFinite(x) ? x : element.x,
        y: Number.isFinite(y) ? y : element.y
      };
    };
    refreshTextDimensions = (textElement, container, elementsMap, text = textElement.text) => {
      if (textElement.isDeleted) {
        return;
      }
      if (container) {
        text = wrapText(
          text,
          getFontString(textElement),
          getBoundTextMaxWidth(container, textElement)
        );
      }
      const dimensions = getAdjustedDimensions(textElement, elementsMap, text);
      return { text, ...dimensions };
    };
    updateTextElement = (textElement, container, elementsMap, {
      text,
      isDeleted,
      originalText
    }) => {
      return newElementWith(textElement, {
        originalText,
        isDeleted: isDeleted ?? textElement.isDeleted,
        ...refreshTextDimensions(textElement, container, elementsMap, originalText)
      });
    };
    newFreeDrawElement = (opts) => {
      return {
        ..._newElementBase(opts.type, opts),
        points: opts.points || [],
        pressures: [],
        simulatePressure: opts.simulatePressure,
        lastCommittedPoint: null
      };
    };
    newLinearElement = (opts) => {
      return {
        ..._newElementBase(opts.type, opts),
        points: opts.points || [],
        lastCommittedPoint: null,
        startBinding: null,
        endBinding: null,
        startArrowhead: opts.startArrowhead || null,
        endArrowhead: opts.endArrowhead || null
      };
    };
    newImageElement = (opts) => {
      return {
        ..._newElementBase("image", opts),
        // in the future we'll support changing stroke color for some SVG elements,
        // and `transparent` will likely mean "use original colors of the image"
        strokeColor: "transparent",
        status: opts.status ?? "pending",
        fileId: opts.fileId ?? null,
        scale: opts.scale ?? [1, 1]
      };
    };
    _deepCopyElement = (val, depth = 0) => {
      if (val == null || typeof val !== "object") {
        return val;
      }
      const objectType = Object.prototype.toString.call(val);
      if (objectType === "[object Object]") {
        const tmp = typeof val.constructor === "function" ? Object.create(Object.getPrototypeOf(val)) : {};
        for (const key in val) {
          if (val.hasOwnProperty(key)) {
            if (depth === 0 && (key === "shape" || key === "canvas")) {
              continue;
            }
            tmp[key] = _deepCopyElement(val[key], depth + 1);
          }
        }
        return tmp;
      }
      if (Array.isArray(val)) {
        let k = val.length;
        const arr = new Array(k);
        while (k--) {
          arr[k] = _deepCopyElement(val[k], depth + 1);
        }
        return arr;
      }
      if (define_import_meta_env_default.DEV) {
        if (objectType !== "[object Object]" && objectType !== "[object Array]" && objectType.startsWith("[object ")) {
          console.warn(
            `_deepCloneElement: unexpected object type ${objectType}. This value will not be cloned!`
          );
        }
      }
      return val;
    };
    deepCopyElement = (val) => {
      return _deepCopyElement(val);
    };
    regenerateId = (previousId) => {
      if (isTestEnv() && previousId) {
        let nextId = `${previousId}_copy`;
        if (window.h?.app?.getSceneElementsIncludingDeleted().find((el) => el.id === nextId)) {
          nextId += "_copy";
        }
        return nextId;
      }
      return randomId();
    };
    duplicateElement = (editingGroupId, groupIdMapForOperation, element, overrides) => {
      let copy = deepCopyElement(element);
      copy.id = regenerateId(copy.id);
      copy.boundElements = null;
      copy.updated = getUpdatedTimestamp();
      copy.seed = randomInteger();
      copy.groupIds = getNewGroupIdsForDuplication(
        copy.groupIds,
        editingGroupId,
        (groupId) => {
          if (!groupIdMapForOperation.has(groupId)) {
            groupIdMapForOperation.set(groupId, regenerateId(groupId));
          }
          return groupIdMapForOperation.get(groupId);
        }
      );
      if (overrides) {
        copy = Object.assign(copy, overrides);
      }
      return copy;
    };
    duplicateElements = (elements, opts) => {
      const clonedElements = [];
      const origElementsMap = arrayToMap(elements);
      const elementNewIdsMap = /* @__PURE__ */ new Map();
      const maybeGetNewId = (id) => {
        if (elementNewIdsMap.has(id)) {
          return elementNewIdsMap.get(id);
        }
        if (origElementsMap.has(id)) {
          const newId = regenerateId(id);
          elementNewIdsMap.set(id, newId);
          return newId;
        }
        return null;
      };
      const groupNewIdsMap = /* @__PURE__ */ new Map();
      for (const element of elements) {
        const clonedElement = _deepCopyElement(element);
        clonedElement.id = maybeGetNewId(element.id);
        if (opts?.randomizeSeed) {
          clonedElement.seed = randomInteger();
          bumpVersion(clonedElement);
        }
        if (clonedElement.groupIds) {
          clonedElement.groupIds = clonedElement.groupIds.map((groupId) => {
            if (!groupNewIdsMap.has(groupId)) {
              groupNewIdsMap.set(groupId, regenerateId(groupId));
            }
            return groupNewIdsMap.get(groupId);
          });
        }
        if ("containerId" in clonedElement && clonedElement.containerId) {
          const newContainerId = maybeGetNewId(clonedElement.containerId);
          clonedElement.containerId = newContainerId;
        }
        if ("boundElements" in clonedElement && clonedElement.boundElements) {
          clonedElement.boundElements = clonedElement.boundElements.reduce(
            (acc, binding) => {
              const newBindingId = maybeGetNewId(binding.id);
              if (newBindingId) {
                acc.push({ ...binding, id: newBindingId });
              }
              return acc;
            },
            []
          );
        }
        if ("endBinding" in clonedElement && clonedElement.endBinding) {
          const newEndBindingId = maybeGetNewId(clonedElement.endBinding.elementId);
          clonedElement.endBinding = newEndBindingId ? {
            ...clonedElement.endBinding,
            elementId: newEndBindingId
          } : null;
        }
        if ("startBinding" in clonedElement && clonedElement.startBinding) {
          const newEndBindingId = maybeGetNewId(
            clonedElement.startBinding.elementId
          );
          clonedElement.startBinding = newEndBindingId ? {
            ...clonedElement.startBinding,
            elementId: newEndBindingId
          } : null;
        }
        if (clonedElement.frameId) {
          clonedElement.frameId = maybeGetNewId(clonedElement.frameId);
        }
        clonedElements.push(clonedElement);
      }
      return clonedElements;
    };
  }
});

// element/embeddable.ts
var embeddedLinkCache, RE_YOUTUBE, RE_VIMEO, RE_FIGMA, RE_GH_GIST, RE_GH_GIST_EMBED, RE_TWITTER, RE_TWITTER_EMBED, RE_VALTOWN, RE_GENERIC_EMBED, RE_GIPHY, ALLOWED_DOMAINS, createSrcDoc, getEmbedLink, createPlaceholderEmbeddableLabel, actionSetEmbeddableAsActiveTool, validateHostname, maybeParseEmbedSrc, embeddableURLValidator;
var init_embeddable = __esm({
  "element/embeddable.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_register();
    init_constants();
    init_utils();
    init_cursor();
    init_newElement();
    init_textElement();
    init_typeChecks();
    embeddedLinkCache = /* @__PURE__ */ new Map();
    RE_YOUTUBE = /^(?:http(?:s)?:\/\/)?(?:www\.)?youtu(?:be\.com|\.be)\/(embed\/|watch\?v=|shorts\/|playlist\?list=|embed\/videoseries\?list=)?([a-zA-Z0-9_-]+)(?:\?t=|&t=|\?start=|&start=)?([a-zA-Z0-9_-]+)?[^\s]*$/;
    RE_VIMEO = /^(?:http(?:s)?:\/\/)?(?:(?:w){3}.)?(?:player\.)?vimeo\.com\/(?:video\/)?([^?\s]+)(?:\?.*)?$/;
    RE_FIGMA = /^https:\/\/(?:www\.)?figma\.com/;
    RE_GH_GIST = /^https:\/\/gist\.github\.com/;
    RE_GH_GIST_EMBED = /^<script[\s\S]*?\ssrc=["'](https:\/\/gist.github.com\/.*?)\.js["']/i;
    RE_TWITTER = /(?:http(?:s)?:\/\/)?(?:(?:w){3}.)?(?:twitter|x).com/;
    RE_TWITTER_EMBED = /^<blockquote[\s\S]*?\shref=["'](https:\/\/(?:twitter|x).com\/[^"']*)/i;
    RE_VALTOWN = /^https:\/\/(?:www\.)?val.town\/(v|embed)\/[a-zA-Z_$][0-9a-zA-Z_$]+\.[a-zA-Z_$][0-9a-zA-Z_$]+/;
    RE_GENERIC_EMBED = /^<(?:iframe|blockquote)[\s\S]*?\s(?:src|href)=["']([^"']*)["'][\s\S]*?>$/i;
    RE_GIPHY = /giphy.com\/(?:clips|embed|gifs)\/[a-zA-Z0-9]*?-?([a-zA-Z0-9]+)(?:[^a-zA-Z0-9]|$)/;
    ALLOWED_DOMAINS = /* @__PURE__ */ new Set([
      "youtube.com",
      "youtu.be",
      "vimeo.com",
      "player.vimeo.com",
      "figma.com",
      "link.excalidraw.com",
      "gist.github.com",
      "twitter.com",
      "x.com",
      "*.simplepdf.eu",
      "stackblitz.com",
      "val.town",
      "giphy.com",
      "dddice.com"
    ]);
    createSrcDoc = (body) => {
      return `<html><body>${body}</body></html>`;
    };
    getEmbedLink = (link) => {
      if (!link) {
        return null;
      }
      if (embeddedLinkCache.has(link)) {
        return embeddedLinkCache.get(link);
      }
      const originalLink = link;
      let type = "generic";
      let aspectRatio = { w: 560, h: 840 };
      const ytLink = link.match(RE_YOUTUBE);
      if (ytLink?.[2]) {
        const time = ytLink[3] ? `&start=${ytLink[3]}` : ``;
        const isPortrait = link.includes("shorts");
        type = "video";
        switch (ytLink[1]) {
          case "embed/":
          case "watch?v=":
          case "shorts/":
            link = `https://www.youtube.com/embed/${ytLink[2]}?enablejsapi=1${time}`;
            break;
          case "playlist?list=":
          case "embed/videoseries?list=":
            link = `https://www.youtube.com/embed/videoseries?list=${ytLink[2]}&enablejsapi=1${time}`;
            break;
          default:
            link = `https://www.youtube.com/embed/${ytLink[2]}?enablejsapi=1${time}`;
            break;
        }
        aspectRatio = isPortrait ? { w: 315, h: 560 } : { w: 560, h: 315 };
        embeddedLinkCache.set(originalLink, {
          link,
          intrinsicSize: aspectRatio,
          type
        });
        return { link, intrinsicSize: aspectRatio, type };
      }
      const vimeoLink = link.match(RE_VIMEO);
      if (vimeoLink?.[1]) {
        const target = vimeoLink?.[1];
        const error = !/^\d+$/.test(target) ? new URIError("Invalid embed link format") : void 0;
        type = "video";
        link = `https://player.vimeo.com/video/${target}?api=1`;
        aspectRatio = { w: 560, h: 315 };
        embeddedLinkCache.set(originalLink, {
          link,
          intrinsicSize: aspectRatio,
          type
        });
        return { link, intrinsicSize: aspectRatio, type, error };
      }
      const figmaLink = link.match(RE_FIGMA);
      if (figmaLink) {
        type = "generic";
        link = `https://www.figma.com/embed?embed_host=share&url=${encodeURIComponent(
          link
        )}`;
        aspectRatio = { w: 550, h: 550 };
        embeddedLinkCache.set(originalLink, {
          link,
          intrinsicSize: aspectRatio,
          type
        });
        return { link, intrinsicSize: aspectRatio, type };
      }
      const valLink = link.match(RE_VALTOWN);
      if (valLink) {
        link = valLink[1] === "embed" ? valLink[0] : valLink[0].replace("/v", "/embed");
        embeddedLinkCache.set(originalLink, {
          link,
          intrinsicSize: aspectRatio,
          type
        });
        return { link, intrinsicSize: aspectRatio, type };
      }
      if (RE_TWITTER.test(link)) {
        link = link.replace(/\bx.com\b/, "twitter.com");
        let ret;
        if (/<blockquote/.test(link)) {
          const srcDoc = createSrcDoc(link);
          ret = {
            type: "document",
            srcdoc: () => srcDoc,
            intrinsicSize: { w: 480, h: 480 }
          };
        } else {
          ret = {
            type: "document",
            srcdoc: (theme) => createSrcDoc(
              `<blockquote class="twitter-tweet" data-dnt="true" data-theme="${theme}"><a href="${link}"></a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"><\/script>`
            ),
            intrinsicSize: { w: 480, h: 480 }
          };
        }
        embeddedLinkCache.set(originalLink, ret);
        return ret;
      }
      if (RE_GH_GIST.test(link)) {
        let ret;
        if (/<script>/.test(link)) {
          const srcDoc = createSrcDoc(link);
          ret = {
            type: "document",
            srcdoc: () => srcDoc,
            intrinsicSize: { w: 550, h: 720 }
          };
        } else {
          ret = {
            type: "document",
            srcdoc: () => createSrcDoc(`
          <script src="${link}.js"><\/script>
          <style type="text/css">
            * { margin: 0px; }
            table, .gist { height: 100%; }
            .gist .gist-file { height: calc(100vh - 2px); padding: 0px; display: grid; grid-template-rows: 1fr auto; }
          </style>
        `),
            intrinsicSize: { w: 550, h: 720 }
          };
        }
        embeddedLinkCache.set(link, ret);
        return ret;
      }
      embeddedLinkCache.set(link, { link, intrinsicSize: aspectRatio, type });
      return { link, intrinsicSize: aspectRatio, type };
    };
    createPlaceholderEmbeddableLabel = (element) => {
      let text;
      if (isIframeElement(element)) {
        text = "IFrame element";
      } else {
        text = !element.link || element?.link === "" ? "Empty Web-Embed" : element.link;
      }
      const fontSize = Math.max(
        Math.min(element.width / 2, element.width / text.length),
        element.width / 30
      );
      const fontFamily = FONT_FAMILY.Helvetica;
      const fontString = getFontString({
        fontSize,
        fontFamily
      });
      return newTextElement({
        x: element.x + element.width / 2,
        y: element.y + element.height / 2,
        strokeColor: element.strokeColor !== "transparent" ? element.strokeColor : "black",
        backgroundColor: "transparent",
        fontFamily,
        fontSize,
        text: wrapText(text, fontString, element.width - 20),
        textAlign: "center",
        verticalAlign: VERTICAL_ALIGN.MIDDLE,
        angle: element.angle ?? 0
      });
    };
    actionSetEmbeddableAsActiveTool = register({
      name: "setEmbeddableAsActiveTool",
      trackEvent: { category: "toolbar" },
      perform: (elements, appState, _, app) => {
        const nextActiveTool = updateActiveTool(appState, {
          type: "embeddable"
        });
        setCursorForShape(app.canvas, {
          ...appState,
          activeTool: nextActiveTool
        });
        return {
          elements,
          appState: {
            ...appState,
            activeTool: updateActiveTool(appState, {
              type: "embeddable"
            })
          },
          commitToHistory: false
        };
      }
    });
    validateHostname = (url, allowedHostnames) => {
      try {
        const { hostname } = new URL(url);
        const bareDomain = hostname.replace(/^www\./, "");
        const bareDomainWithFirstSubdomainWildcarded = bareDomain.replace(
          /^([^.]+)/,
          "*"
        );
        if (allowedHostnames instanceof Set) {
          return ALLOWED_DOMAINS.has(bareDomain) || ALLOWED_DOMAINS.has(bareDomainWithFirstSubdomainWildcarded);
        }
        if (bareDomain === allowedHostnames.replace(/^www\./, "")) {
          return true;
        }
      } catch (error) {
      }
      return false;
    };
    maybeParseEmbedSrc = (str) => {
      const twitterMatch = str.match(RE_TWITTER_EMBED);
      if (twitterMatch && twitterMatch.length === 2) {
        return twitterMatch[1];
      }
      const gistMatch = str.match(RE_GH_GIST_EMBED);
      if (gistMatch && gistMatch.length === 2) {
        return gistMatch[1];
      }
      if (RE_GIPHY.test(str)) {
        return `https://giphy.com/embed/${RE_GIPHY.exec(str)[1]}`;
      }
      const match = str.match(RE_GENERIC_EMBED);
      if (match && match.length === 2) {
        return match[1];
      }
      return str;
    };
    embeddableURLValidator = (url, validateEmbeddable) => {
      if (!url) {
        return false;
      }
      if (validateEmbeddable != null) {
        if (typeof validateEmbeddable === "function") {
          const ret = validateEmbeddable(url);
          if (typeof ret === "boolean") {
            return ret;
          }
        } else if (typeof validateEmbeddable === "boolean") {
          return validateEmbeddable;
        } else if (validateEmbeddable instanceof RegExp) {
          return validateEmbeddable.test(url);
        } else if (Array.isArray(validateEmbeddable)) {
          for (const domain of validateEmbeddable) {
            if (domain instanceof RegExp) {
              if (url.match(domain)) {
                return true;
              }
            } else if (validateHostname(url, domain)) {
              return true;
            }
          }
          return false;
        }
      }
      return validateHostname(url, ALLOWED_DOMAINS);
    };
  }
});

// renderer/roundRect.ts
var roundRect;
var init_roundRect = __esm({
  "renderer/roundRect.ts"() {
    "use strict";
    init_define_import_meta_env();
    roundRect = (context, x, y, width, height, radius, strokeColor) => {
      context.beginPath();
      context.moveTo(x + radius, y);
      context.lineTo(x + width - radius, y);
      context.quadraticCurveTo(x + width, y, x + width, y + radius);
      context.lineTo(x + width, y + height - radius);
      context.quadraticCurveTo(
        x + width,
        y + height,
        x + width - radius,
        y + height
      );
      context.lineTo(x + radius, y + height);
      context.quadraticCurveTo(x, y + height, x, y + height - radius);
      context.lineTo(x, y + radius);
      context.quadraticCurveTo(x, y, x + radius, y);
      context.closePath();
      context.fill();
      if (strokeColor) {
        context.strokeStyle = strokeColor;
      }
      context.stroke();
    };
  }
});

// scene/scrollbars.ts
var SCROLLBAR_MARGIN, SCROLLBAR_WIDTH, SCROLLBAR_COLOR, getScrollBars, isOverScrollBars;
var init_scrollbars = __esm({
  "scene/scrollbars.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_element();
    init_utils();
    init_i18n();
    SCROLLBAR_MARGIN = 4;
    SCROLLBAR_WIDTH = 6;
    SCROLLBAR_COLOR = "rgba(0,0,0,0.3)";
    getScrollBars = (elements, viewportWidth, viewportHeight, appState) => {
      if (!elements.length) {
        return {
          horizontal: null,
          vertical: null
        };
      }
      const [elementsMinX, elementsMinY, elementsMaxX, elementsMaxY] = getCommonBounds(elements);
      const viewportWidthWithZoom = viewportWidth / appState.zoom.value;
      const viewportHeightWithZoom = viewportHeight / appState.zoom.value;
      const viewportWidthDiff = viewportWidth - viewportWidthWithZoom;
      const viewportHeightDiff = viewportHeight - viewportHeightWithZoom;
      const safeArea = {
        top: parseInt(getGlobalCSSVariable("sat")) || 0,
        bottom: parseInt(getGlobalCSSVariable("sab")) || 0,
        left: parseInt(getGlobalCSSVariable("sal")) || 0,
        right: parseInt(getGlobalCSSVariable("sar")) || 0
      };
      const isRTL2 = getLanguage().rtl;
      const viewportMinX = -appState.scrollX + viewportWidthDiff / 2 + safeArea.left;
      const viewportMinY = -appState.scrollY + viewportHeightDiff / 2 + safeArea.top;
      const viewportMaxX = viewportMinX + viewportWidthWithZoom - safeArea.right;
      const viewportMaxY = viewportMinY + viewportHeightWithZoom - safeArea.bottom;
      const sceneMinX = Math.min(elementsMinX, viewportMinX);
      const sceneMinY = Math.min(elementsMinY, viewportMinY);
      const sceneMaxX = Math.max(elementsMaxX, viewportMaxX);
      const sceneMaxY = Math.max(elementsMaxY, viewportMaxY);
      return {
        horizontal: viewportMinX === sceneMinX && viewportMaxX === sceneMaxX ? null : {
          x: Math.max(safeArea.left, SCROLLBAR_MARGIN) + (viewportMinX - sceneMinX) / (sceneMaxX - sceneMinX) * viewportWidth,
          y: viewportHeight - SCROLLBAR_WIDTH - Math.max(SCROLLBAR_MARGIN, safeArea.bottom),
          width: (viewportMaxX - viewportMinX) / (sceneMaxX - sceneMinX) * viewportWidth - Math.max(SCROLLBAR_MARGIN * 2, safeArea.left + safeArea.right),
          height: SCROLLBAR_WIDTH
        },
        vertical: viewportMinY === sceneMinY && viewportMaxY === sceneMaxY ? null : {
          x: isRTL2 ? Math.max(safeArea.left, SCROLLBAR_MARGIN) : viewportWidth - SCROLLBAR_WIDTH - Math.max(safeArea.right, SCROLLBAR_MARGIN),
          y: (viewportMinY - sceneMinY) / (sceneMaxY - sceneMinY) * viewportHeight + Math.max(safeArea.top, SCROLLBAR_MARGIN),
          width: SCROLLBAR_WIDTH,
          height: (viewportMaxY - viewportMinY) / (sceneMaxY - sceneMinY) * viewportHeight - Math.max(SCROLLBAR_MARGIN * 2, safeArea.top + safeArea.bottom)
        }
      };
    };
    isOverScrollBars = (scrollBars, x, y) => {
      const [isOverHorizontal, isOverVertical] = [
        scrollBars.horizontal,
        scrollBars.vertical
      ].map((scrollBar) => {
        return scrollBar != null && scrollBar.x <= x && x <= scrollBar.x + scrollBar.width && scrollBar.y <= y && y <= scrollBar.y + scrollBar.height;
      });
      const isOverEither = isOverHorizontal || isOverVertical;
      return { isOverEither, isOverHorizontal, isOverVertical };
    };
  }
});

// clients.ts
function hashToInteger(id) {
  let hash = 0;
  if (id.length === 0) {
    return hash;
  }
  for (let i = 0; i < id.length; i++) {
    const char = id.charCodeAt(i);
    hash = (hash << 5) - hash + char;
  }
  return hash;
}
var getClientColor, getNameInitial;
var init_clients = __esm({
  "clients.ts"() {
    "use strict";
    init_define_import_meta_env();
    getClientColor = (id) => {
      const hash = Math.abs(hashToInteger(id));
      const hue = hash % 37 * 10;
      const saturation = 100;
      const lightness = 83;
      return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
    };
    getNameInitial = (name) => {
      const firstCodePoint = name?.trim()?.codePointAt(0);
      return (firstCodePoint ? String.fromCodePoint(firstCodePoint) : "?").toUpperCase();
    };
  }
});

// types.ts
var init_types = __esm({
  "types.ts"() {
    "use strict";
    init_define_import_meta_env();
  }
});

// components/ToolIcon.scss
var init_ToolIcon = __esm({
  "components/ToolIcon.scss"() {
  }
});

// errors.ts
var CanvasError, AbortError, ImageSceneDataError;
var init_errors = __esm({
  "errors.ts"() {
    "use strict";
    init_define_import_meta_env();
    CanvasError = class extends Error {
      constructor(message = "Couldn't export canvas.", name = "CANVAS_ERROR") {
        super();
        this.name = name;
        this.message = message;
      }
    };
    AbortError = class extends DOMException {
      constructor(message = "Request Aborted") {
        super(message, "AbortError");
      }
    };
    ImageSceneDataError = class extends Error {
      code;
      constructor(message = "Image Scene Data Error", code = "IMAGE_SCENE_DATA_ERROR") {
        super(message);
        this.name = "EncodingError";
        this.code = code;
      }
    };
  }
});

// components/ToolButton.tsx
import React3, { useEffect as useEffect3, useRef, useState as useState3 } from "react";
import clsx2 from "clsx";
import { jsx as jsx4, jsxs as jsxs2 } from "react/jsx-runtime";
var ToolButton;
var init_ToolButton = __esm({
  "components/ToolButton.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_ToolIcon();
    init_App();
    init_errors();
    init_Spinner2();
    init_utils();
    ToolButton = React3.forwardRef((props, ref) => {
      const { id: excalId } = useExcalidrawContainer();
      const innerRef = React3.useRef(null);
      React3.useImperativeHandle(ref, () => innerRef.current);
      const sizeCn = `ToolIcon_size_${props.size}`;
      const [isLoading, setIsLoading] = useState3(false);
      const isMountedRef = useRef(true);
      const onClick = async (event) => {
        const ret = "onClick" in props && props.onClick?.(event);
        if (isPromiseLike(ret)) {
          try {
            setIsLoading(true);
            await ret;
          } catch (error) {
            if (!(error instanceof AbortError)) {
              throw error;
            } else {
              console.warn(error);
            }
          } finally {
            if (isMountedRef.current) {
              setIsLoading(false);
            }
          }
        }
      };
      useEffect3(() => {
        isMountedRef.current = true;
        return () => {
          isMountedRef.current = false;
        };
      }, []);
      const lastPointerTypeRef = useRef(null);
      if (props.type === "button" || props.type === "icon" || props.type === "submit") {
        const type = props.type === "icon" ? "button" : props.type;
        return /* @__PURE__ */ jsxs2(
          "button",
          {
            className: clsx2(
              "ToolIcon_type_button",
              sizeCn,
              props.className,
              props.visible && !props.hidden ? "ToolIcon_type_button--show" : "ToolIcon_type_button--hide",
              {
                ToolIcon: !props.hidden,
                "ToolIcon--selected": props.selected,
                "ToolIcon--plain": props.type === "icon"
              }
            ),
            style: props.style,
            "data-testid": props["data-testid"],
            hidden: props.hidden,
            title: props.title,
            "aria-label": props["aria-label"],
            type,
            onClick,
            ref: innerRef,
            disabled: isLoading || props.isLoading,
            children: [
              (props.icon || props.label) && /* @__PURE__ */ jsxs2("div", { className: "ToolIcon__icon", "aria-hidden": "true", children: [
                props.icon || props.label,
                props.keyBindingLabel && /* @__PURE__ */ jsx4("span", { className: "ToolIcon__keybinding", children: props.keyBindingLabel }),
                props.isLoading && /* @__PURE__ */ jsx4(Spinner_default, {})
              ] }),
              props.showAriaLabel && /* @__PURE__ */ jsxs2("div", { className: "ToolIcon__label", children: [
                props["aria-label"],
                " ",
                isLoading && /* @__PURE__ */ jsx4(Spinner_default, {})
              ] }),
              props.children
            ]
          }
        );
      }
      return /* @__PURE__ */ jsxs2(
        "label",
        {
          className: clsx2("ToolIcon", props.className),
          title: props.title,
          onPointerDown: (event) => {
            lastPointerTypeRef.current = event.pointerType || null;
            props.onPointerDown?.({ pointerType: event.pointerType || null });
          },
          onPointerUp: () => {
            requestAnimationFrame(() => {
              lastPointerTypeRef.current = null;
            });
          },
          children: [
            /* @__PURE__ */ jsx4(
              "input",
              {
                className: `ToolIcon_type_radio ${sizeCn}`,
                type: "radio",
                name: props.name,
                "aria-label": props["aria-label"],
                "aria-keyshortcuts": props["aria-keyshortcuts"],
                "data-testid": props["data-testid"],
                id: `${excalId}-${props.id}`,
                onChange: () => {
                  props.onChange?.({ pointerType: lastPointerTypeRef.current });
                },
                checked: props.checked,
                ref: innerRef
              }
            ),
            /* @__PURE__ */ jsxs2("div", { className: "ToolIcon__icon", children: [
              props.icon,
              props.keyBindingLabel && /* @__PURE__ */ jsx4("span", { className: "ToolIcon__keybinding", children: props.keyBindingLabel })
            ] })
          ]
        }
      );
    });
    ToolButton.defaultProps = {
      visible: true,
      className: "",
      size: "medium"
    };
    ToolButton.displayName = "ToolButton";
  }
});

// components/icons.tsx
import React4 from "react";
import oc2 from "open-color";
import clsx3 from "clsx";
import { Fragment, jsx as jsx5, jsxs as jsxs3 } from "react/jsx-runtime";
var iconFillColor, handlerColor, createIcon, tablerIconProps, modifiedTablerIconProps, PlusPromoIcon, LibraryIcon, PlusIcon, DotsIcon, PinIcon, UnlockedIcon, LockedIcon, WelcomeScreenMenuArrow, WelcomeScreenHelpArrow, WelcomeScreenTopToolbarArrow, ExcalLogo, SelectionIcon, RectangleIcon, DiamondIcon, EllipseIcon, ArrowIcon, LineIcon, PenModeIcon, FreedrawIcon, TextIcon, ImageIcon, EraserIcon, ZoomInIcon, ZoomOutIcon, TrashIcon, EmbedIcon, DuplicateIcon, MoonIcon, SunIcon, HamburgerMenuIcon, ExportIcon, HelpIcon, ExternalLinkIcon, GithubIcon, DiscordIcon, XBrandIcon, checkIcon, LinkIcon, save, saveAs, LoadIcon, clipboard, palette, ExportImageIcon, exportToFileIcon, zoomIn, zoomOut, done, menu, UndoIcon, RedoIcon, questionCircle, share, shareIOS, shareWindows, resetZoom, BringForwardIcon, SendBackwardIcon, BringToFrontIcon, SendToBackIcon, AlignTopIcon, AlignBottomIcon, AlignLeftIcon, AlignRightIcon, DistributeHorizontallyIcon, DistributeVerticallyIcon, CenterVerticallyIcon, CenterHorizontallyIcon, usersIcon, start, stop, CloseIcon, back, clone, shield, file, GroupIcon, UngroupIcon, FillZigZagIcon, FillHachureIcon, FillCrossHatchIcon, FillSolidIcon, StrokeWidthBaseIcon, StrokeWidthBoldIcon, StrokeWidthExtraBoldIcon, StrokeStyleSolidIcon, StrokeStyleDashedIcon, StrokeStyleDottedIcon, SloppinessArchitectIcon, SloppinessArtistIcon, SloppinessCartoonistIcon, EdgeSharpIcon, EdgeRoundIcon, ArrowheadNoneIcon, ArrowheadArrowIcon, ArrowheadCircleIcon, ArrowheadCircleOutlineIcon, ArrowheadBarIcon, ArrowheadTriangleIcon, ArrowheadTriangleOutlineIcon, ArrowheadDiamondIcon, ArrowheadDiamondOutlineIcon, FontSizeSmallIcon, FontSizeMediumIcon, FontSizeLargeIcon, FontSizeExtraLargeIcon, FontFamilyNormalIcon, FontFamilyCodeIcon, TextAlignLeftIcon, TextAlignCenterIcon, TextAlignRightIcon, TextAlignTopIcon, TextAlignBottomIcon, TextAlignMiddleIcon, publishIcon, eraser, handIcon, downloadIcon, copyIcon, helpIcon, playerPlayIcon, playerStopFilledIcon, tablerCheckIcon, alertTriangleIcon, eyeDropperIcon, extraToolsIcon, frameToolIcon, mermaidLogoIcon, ArrowRightIcon, laserPointerToolIcon, MagicIcon, OpenAIIcon, fullscreenIcon, eyeIcon, eyeClosedIcon, brainIcon, searchIcon;
var init_icons = __esm({
  "components/icons.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_constants();
    iconFillColor = (theme) => "var(--icon-fill-color)";
    handlerColor = (theme) => theme === THEME.LIGHT ? oc2.white : "#1e1e1e";
    createIcon = (d, opts = 512) => {
      const {
        width = 512,
        height = width,
        mirror,
        style,
        ...rest
      } = typeof opts === "number" ? { width: opts } : opts;
      return /* @__PURE__ */ jsx5(
        "svg",
        {
          "aria-hidden": "true",
          focusable: "false",
          role: "img",
          viewBox: `0 0 ${width} ${height}`,
          className: clsx3({ "rtl-mirror": mirror }),
          style,
          ...rest,
          children: typeof d === "string" ? /* @__PURE__ */ jsx5("path", { fill: "currentColor", d }) : d
        }
      );
    };
    tablerIconProps = {
      width: 24,
      height: 24,
      fill: "none",
      strokeWidth: 2,
      stroke: "currentColor",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    };
    modifiedTablerIconProps = {
      width: 20,
      height: 20,
      fill: "none",
      stroke: "currentColor",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    };
    PlusPromoIcon = createIcon(
      /* @__PURE__ */ jsxs3("g", { strokeWidth: "1.5", children: [
        /* @__PURE__ */ jsx5("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx5("rect", { x: 3, y: 8, width: 18, height: 4, rx: 1 }),
        /* @__PURE__ */ jsx5("line", { x1: 12, y1: 8, x2: 12, y2: 21 }),
        /* @__PURE__ */ jsx5("path", { d: "M19 12v7a2 2 0 0 1 -2 2h-10a2 2 0 0 1 -2 -2v-7" }),
        /* @__PURE__ */ jsx5("path", { d: "M7.5 8a2.5 2.5 0 0 1 0 -5a4.8 8 0 0 1 4.5 5a4.8 8 0 0 1 4.5 -5a2.5 2.5 0 0 1 0 5" })
      ] }),
      tablerIconProps
    );
    LibraryIcon = createIcon(
      /* @__PURE__ */ jsxs3("g", { strokeWidth: "1.5", children: [
        /* @__PURE__ */ jsx5("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx5("path", { d: "M3 19a9 9 0 0 1 9 0a9 9 0 0 1 9 0" }),
        /* @__PURE__ */ jsx5("path", { d: "M3 6a9 9 0 0 1 9 0a9 9 0 0 1 9 0" }),
        /* @__PURE__ */ jsx5("line", { x1: "3", y1: "6", x2: "3", y2: "19" }),
        /* @__PURE__ */ jsx5("line", { x1: "12", y1: "6", x2: "12", y2: "19" }),
        /* @__PURE__ */ jsx5("line", { x1: "21", y1: "6", x2: "21", y2: "19" })
      ] }),
      tablerIconProps
    );
    PlusIcon = createIcon(
      /* @__PURE__ */ jsxs3("svg", { strokeWidth: "1.5", children: [
        /* @__PURE__ */ jsx5("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx5("line", { x1: "12", y1: "5", x2: "12", y2: "19" }),
        /* @__PURE__ */ jsx5("line", { x1: "5", y1: "12", x2: "19", y2: "12" })
      ] }),
      tablerIconProps
    );
    DotsIcon = createIcon(
      /* @__PURE__ */ jsxs3("g", { strokeWidth: "1.5", children: [
        /* @__PURE__ */ jsx5("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx5("circle", { cx: "12", cy: "12", r: "1" }),
        /* @__PURE__ */ jsx5("circle", { cx: "12", cy: "19", r: "1" }),
        /* @__PURE__ */ jsx5("circle", { cx: "12", cy: "5", r: "1" })
      ] }),
      tablerIconProps
    );
    PinIcon = createIcon(
      /* @__PURE__ */ jsxs3("svg", { strokeWidth: "1.5", children: [
        /* @__PURE__ */ jsx5("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx5("path", { d: "M9 4v6l-2 4v2h10v-2l-2 -4v-6" }),
        /* @__PURE__ */ jsx5("line", { x1: "12", y1: "16", x2: "12", y2: "21" }),
        /* @__PURE__ */ jsx5("line", { x1: "8", y1: "4", x2: "16", y2: "4" })
      ] }),
      tablerIconProps
    );
    UnlockedIcon = createIcon(
      /* @__PURE__ */ jsxs3("g", { children: [
        /* @__PURE__ */ jsx5(
          "path",
          {
            d: "M13.542 8.542H6.458a2.5 2.5 0 0 0-2.5 2.5v3.75a2.5 2.5 0 0 0 2.5 2.5h7.084a2.5 2.5 0 0 0 2.5-2.5v-3.75a2.5 2.5 0 0 0-2.5-2.5Z",
            stroke: "currentColor",
            strokeWidth: "1.25"
          }
        ),
        /* @__PURE__ */ jsx5(
          "path",
          {
            d: "M10 13.958a1.042 1.042 0 1 0 0-2.083 1.042 1.042 0 0 0 0 2.083Z",
            stroke: "currentColor",
            strokeWidth: "1.25"
          }
        ),
        /* @__PURE__ */ jsx5(
          "mask",
          {
            id: "UnlockedIcon",
            style: { maskType: "alpha" },
            maskUnits: "userSpaceOnUse",
            x: 6,
            y: 1,
            width: 9,
            height: 9,
            children: /* @__PURE__ */ jsx5(
              "path",
              {
                stroke: "none",
                d: "M6.399 9.561V5.175c0-.93.401-1.823 1.116-2.48a3.981 3.981 0 0 1 2.693-1.028c1.01 0 1.98.37 2.694 1.027.715.658 1.116 1.55 1.116 2.481",
                fill: "#fff"
              }
            )
          }
        ),
        /* @__PURE__ */ jsx5("g", { mask: "url(#UnlockedIcon)", children: /* @__PURE__ */ jsx5(
          "path",
          {
            stroke: "none",
            d: "M5.149 9.561v1.25h2.5v-1.25h-2.5Zm5.06-7.894V.417v1.25Zm2.559 3.508v1.25h2.5v-1.25h-2.5ZM7.648 8.51V5.175h-2.5V8.51h2.5Zm0-3.334c0-.564.243-1.128.713-1.561L6.668 1.775c-.959.883-1.52 2.104-1.52 3.4h2.5Zm.713-1.561a2.732 2.732 0 0 1 1.847-.697v-2.5c-1.31 0-2.585.478-3.54 1.358L8.36 3.614Zm1.847-.697c.71 0 1.374.26 1.847.697l1.694-1.839a5.231 5.231 0 0 0-3.54-1.358v2.5Zm1.847.697c.47.433.713.997.713 1.561h2.5c0-1.296-.56-2.517-1.52-3.4l-1.693 1.839Z",
            fill: "currentColor"
          }
        ) })
      ] }),
      modifiedTablerIconProps
    );
    LockedIcon = createIcon(
      /* @__PURE__ */ jsxs3("g", { strokeWidth: "1.25", children: [
        /* @__PURE__ */ jsx5("path", { d: "M13.542 8.542H6.458a2.5 2.5 0 0 0-2.5 2.5v3.75a2.5 2.5 0 0 0 2.5 2.5h7.084a2.5 2.5 0 0 0 2.5-2.5v-3.75a2.5 2.5 0 0 0-2.5-2.5Z" }),
        /* @__PURE__ */ jsx5("path", { d: "M10 13.958a1.042 1.042 0 1 0 0-2.083 1.042 1.042 0 0 0 0 2.083Z" }),
        /* @__PURE__ */ jsx5("path", { d: "M6.667 8.333V5.417C6.667 3.806 8.159 2.5 10 2.5c1.841 0 3.333 1.306 3.333 2.917v2.916" })
      ] }),
      modifiedTablerIconProps
    );
    WelcomeScreenMenuArrow = createIcon(
      /* @__PURE__ */ jsxs3(Fragment, { children: [
        /* @__PURE__ */ jsx5(
          "path",
          {
            d: "M38.5 83.5c-14-2-17.833-10.473-21-22.5C14.333 48.984 12 22 12 12.5",
            stroke: "currentColor",
            strokeWidth: 2,
            strokeLinecap: "round"
          }
        ),
        /* @__PURE__ */ jsx5(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "m12.005 10.478 7.905 14.423L6 25.75l6.005-15.273Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ jsx5(
          "path",
          {
            d: "M12.005 10.478c1.92 3.495 3.838 7 7.905 14.423m-7.905-14.423c3.11 5.683 6.23 11.368 7.905 14.423m0 0c-3.68.226-7.35.455-13.91.85m13.91-.85c-5.279.33-10.566.647-13.91.85m0 0c1.936-4.931 3.882-9.86 6.005-15.273M6 25.75c2.069-5.257 4.135-10.505 6.005-15.272",
            stroke: "currentColor",
            strokeWidth: 2,
            strokeLinecap: "round"
          }
        )
      ] }),
      { width: 41, height: 94, fill: "none" }
    );
    WelcomeScreenHelpArrow = createIcon(
      /* @__PURE__ */ jsxs3(Fragment, { children: [
        /* @__PURE__ */ jsx5(
          "path",
          {
            d: "M18.026 1.232c-5.268 13.125-5.548 33.555 3.285 42.311 8.823 8.75 33.31 12.304 42.422 13.523",
            stroke: "currentColor",
            strokeWidth: 2,
            strokeLinecap: "round"
          }
        ),
        /* @__PURE__ */ jsx5(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "m72.181 59.247-13.058-10-2.948 13.62 16.006-3.62Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ jsx5(
          "path",
          {
            d: "M72.181 59.247c-3.163-2.429-6.337-4.856-13.058-10m13.058 10c-5.145-3.936-10.292-7.882-13.058-10m0 0c-.78 3.603-1.563 7.196-2.948 13.62m2.948-13.62c-1.126 5.168-2.24 10.346-2.948 13.62m0 0c5.168-1.166 10.334-2.343 16.006-3.62m-16.006 3.62c5.51-1.248 11.01-2.495 16.006-3.62",
            stroke: "currentColor",
            strokeWidth: 2,
            strokeLinecap: "round"
          }
        )
      ] }),
      { width: 85, height: 71, fill: "none" }
    );
    WelcomeScreenTopToolbarArrow = createIcon(
      /* @__PURE__ */ jsxs3(Fragment, { children: [
        /* @__PURE__ */ jsx5(
          "path",
          {
            d: "M1 77c14-2 31.833-11.973 35-24 3.167-12.016-6-35-9.5-43.5",
            stroke: "currentColor",
            strokeWidth: 2,
            strokeLinecap: "round"
          }
        ),
        /* @__PURE__ */ jsx5(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "m24.165 1.093-2.132 16.309 13.27-4.258-11.138-12.05Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ jsx5(
          "path",
          {
            d: "M24.165 1.093c-.522 3.953-1.037 7.916-2.132 16.309m2.131-16.309c-.835 6.424-1.68 12.854-2.13 16.308m0 0c3.51-1.125 7.013-2.243 13.27-4.257m-13.27 4.257c5.038-1.608 10.08-3.232 13.27-4.257m0 0c-3.595-3.892-7.197-7.777-11.14-12.05m11.14 12.05c-3.837-4.148-7.667-8.287-11.14-12.05",
            stroke: "currentColor",
            strokeWidth: 2,
            strokeLinecap: "round"
          }
        )
      ] }),
      { width: 38, height: 78, fill: "none" }
    );
    ExcalLogo = createIcon(
      /* @__PURE__ */ jsx5("g", { fill: "currentColor", children: /* @__PURE__ */ jsx5(
        "path",
        {
          d: "M39.9 32.889a.326.326 0 0 0-.279-.056c-2.094-3.083-4.774-6-7.343-8.833l-.419-.472a.212.212 0 0 0-.056-.139.586.586 0 0 0-.167-.111l-.084-.083-.056-.056c-.084-.167-.28-.278-.475-.167-.782.39-1.507.973-2.206 1.528-.92.722-1.842 1.445-2.708 2.25a8.405 8.405 0 0 0-.977 1.028c-.14.194-.028.361.14.444-.615.611-1.23 1.223-1.843 1.861a.315.315 0 0 0-.084.223c0 .083.056.166.111.194l1.09.833v.028c1.535 1.528 4.244 3.611 7.12 5.861.418.334.865.667 1.284 1 .195.223.39.473.558.695.084.11.28.139.391.055.056.056.14.111.196.167a.398.398 0 0 0 .167.056.255.255 0 0 0 .224-.111.394.394 0 0 0 .055-.167c.029 0 .028.028.056.028a.318.318 0 0 0 .224-.084l5.082-5.528a.309.309 0 0 0 0-.444Zm-14.63-1.917a.485.485 0 0 0 .111.14c.586.5 1.2 1 1.843 1.555l-2.569-1.945-.251-.166c-.056-.028-.112-.084-.168-.111l-.195-.167.056-.056.055-.055.112-.111c.866-.861 2.346-2.306 3.1-3.028-.81.805-2.43 3.167-2.095 3.944Zm8.767 6.89-2.122-1.612a44.713 44.713 0 0 0-2.625-2.5c1.145.861 2.122 1.611 2.262 1.75 1.117.972 1.06.806 1.815 1.445l.921.666a1.06 1.06 0 0 1-.251.25Zm.558.416-.056-.028c.084-.055.168-.111.252-.194l-.196.222ZM1.089 5.75c.055.361.14.722.195 1.056.335 1.833.67 3.5 1.284 4.75l.252.944c.084.361.223.806.363.917 1.424 1.25 3.602 3.11 5.947 4.889a.295.295 0 0 0 .363 0s0 .027.028.027a.254.254 0 0 0 .196.084.318.318 0 0 0 .223-.084c2.988-3.305 5.221-6.027 6.813-8.305.112-.111.14-.278.14-.417.111-.111.195-.25.307-.333.111-.111.111-.306 0-.39l-.028-.027c0-.055-.028-.139-.084-.167-.698-.666-1.2-1.138-1.731-1.638-.922-.862-1.871-1.75-3.881-3.75l-.028-.028c-.028-.028-.056-.056-.112-.056-.558-.194-1.703-.389-3.127-.639C6.087 2.223 3.21 1.723.614.944c0 0-.168 0-.196.028l-.083.084c-.028.027-.056.055-.224.11h.056-.056c.028.167.028.278.084.473 0 .055.112.5.112.555l.782 3.556Zm15.496 3.278-.335-.334c.084.112.196.195.335.334Zm-3.546 4.666-.056.056c0-.028.028-.056.056-.056Zm-2.038-10c.168.167.866.834 1.033.973-.726-.334-2.54-1.167-3.379-1.445.838.167 1.983.334 2.346.472ZM1.424 2.306c.419.722.754 3.222 1.089 5.666-.196-.778-.335-1.555-.503-2.278-.251-1.277-.503-2.416-.838-3.416.056 0 .14 0 .252.028Zm-.168-.584c-.112 0-.223-.028-.307-.028 0-.027 0-.055-.028-.055.14 0 .223.028.335.083Zm-1.089.222c0-.027 0-.027 0 0ZM39.453 1.333c.028-.11-.558-.61-.363-.639.42-.027.42-.666 0-.666-.558.028-1.144.166-1.675.25-.977.194-1.982.389-2.96.61-2.205.473-4.383.973-6.561 1.557-.67.194-1.424.333-2.066.666-.224.111-.196.333-.084.472-.056.028-.084.028-.14.056-.195.028-.363.056-.558.083-.168.028-.252.167-.224.334 0 .027.028.083.028.11-1.173 1.556-2.485 3.195-3.909 4.945-1.396 1.611-2.876 3.306-4.356 5.056-4.719 5.5-10.052 11.75-15.943 17.25a.268.268 0 0 0 0 .389c.028.027.056.055.084.055-.084.084-.168.14-.252.222-.056.056-.084.111-.084.167a.605.605 0 0 0-.111.139c-.112.111-.112.305.028.389.111.11.307.11.39-.028.029-.028.029-.056.056-.056a.44.44 0 0 1 .615 0c.335.362.67.723.977 1.028l-.698-.583c-.112-.111-.307-.083-.39.028-.113.11-.085.305.027.389l7.427 6.194c.056.056.112.056.196.056s.14-.028.195-.084l.168-.166c.028.027.083.027.111.027.084 0 .14-.027.196-.083 10.052-10.055 18.15-17.639 27.42-24.417.083-.055.111-.166.111-.25.112 0 .196-.083.251-.194 1.704-5.194 2.039-9.806 2.15-12.083v-.028c0-.028.028-.056.028-.083.028-.056.028-.084.028-.084a1.626 1.626 0 0 0-.111-1.028ZM21.472 9.5c.446-.5.893-1.028 1.34-1.5-2.876 3.778-7.65 9.583-14.408 16.5 4.607-5.083 9.242-10.333 13.068-15ZM5.193 35.778h.084-.084Zm3.462 3.194c-.027-.028-.027-.028 0-.028v.028Zm4.16-3.583c.224-.25.448-.472.699-.722 0 0 0 .027.028.027-.252.223-.475.445-.726.695Zm1.146-1.111c.14-.14.279-.334.446-.5l.028-.028c1.648-1.694 3.351-3.389 5.082-5.111l.028-.028c.419-.333.921-.694 1.368-1.028a379.003 379.003 0 0 0-6.952 6.695ZM24.794 6.472c-.921 1.195-1.954 2.778-2.82 4.028-2.736 3.944-11.532 13.583-11.727 13.75a1976.983 1976.983 0 0 1-8.042 7.639l-.167.167c-.14-.167-.14-.417.028-.556C14.49 19.861 22.03 10.167 25.074 5.917c-.084.194-.14.36-.28.555Zm4.83 5.695c-1.116-.64-1.646-1.64-1.34-2.611l.084-.334c.028-.083.084-.194.14-.277.307-.5.754-.917 1.257-1.167.027 0 .055 0 .083-.028-.028-.056-.028-.139-.028-.222.028-.167.14-.278.335-.278.335 0 1.369.306 1.76.639.111.083.223.194.335.305.14.167.363.445.474.667.056.028.112.306.196.445.056.222.111.472.084.694-.028.028 0 .194-.028.194a2.668 2.668 0 0 1-.363 1.028c-.028.028-.028.056-.056.084l-.028.027c-.14.223-.335.417-.53.556-.643.444-1.369.583-2.095.389 0 0-.195-.084-.28-.111Zm8.154-.834a39.098 39.098 0 0 1-.893 3.167c0 .028-.028.083 0 .111-.056 0-.084.028-.14.056-2.206 1.61-4.356 3.305-6.506 5.028 1.843-1.64 3.686-3.306 5.613-4.945.558-.5.949-1.139 1.06-1.861l.28-1.667v-.055c.14-.334.67-.195.586.166Z",
          fill: "currentColor"
        }
      ) }),
      { width: 40, height: 40, fill: "none" }
    );
    SelectionIcon = createIcon(
      /* @__PURE__ */ jsxs3("g", { stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", children: [
        /* @__PURE__ */ jsx5("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx5("path", { d: "M6 6l4.153 11.793a0.365 .365 0 0 0 .331 .207a0.366 .366 0 0 0 .332 -.207l2.184 -4.793l4.787 -1.994a0.355 .355 0 0 0 .213 -.323a0.355 .355 0 0 0 -.213 -.323l-11.787 -4.36z" }),
        /* @__PURE__ */ jsx5("path", { d: "M13.5 13.5l4.5 4.5" })
      ] }),
      { fill: "none", width: 22, height: 22, strokeWidth: 1.25 }
    );
    RectangleIcon = createIcon(
      /* @__PURE__ */ jsxs3("g", { strokeWidth: "1.5", children: [
        /* @__PURE__ */ jsx5("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx5("rect", { x: "4", y: "4", width: "16", height: "16", rx: "2" })
      ] }),
      tablerIconProps
    );
    DiamondIcon = createIcon(
      /* @__PURE__ */ jsxs3("g", { strokeWidth: "1.5", children: [
        /* @__PURE__ */ jsx5("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx5("path", { d: "M10.5 20.4l-6.9 -6.9c-.781 -.781 -.781 -2.219 0 -3l6.9 -6.9c.781 -.781 2.219 -.781 3 0l6.9 6.9c.781 .781 .781 2.219 0 3l-6.9 6.9c-.781 .781 -2.219 .781 -3 0z" })
      ] }),
      tablerIconProps
    );
    EllipseIcon = createIcon(
      /* @__PURE__ */ jsxs3("g", { strokeWidth: "1.5", children: [
        /* @__PURE__ */ jsx5("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx5("circle", { cx: "12", cy: "12", r: "9" })
      ] }),
      tablerIconProps
    );
    ArrowIcon = createIcon(
      /* @__PURE__ */ jsxs3("g", { strokeWidth: "1.5", children: [
        /* @__PURE__ */ jsx5("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx5("line", { x1: "5", y1: "12", x2: "19", y2: "12" }),
        /* @__PURE__ */ jsx5("line", { x1: "15", y1: "16", x2: "19", y2: "12" }),
        /* @__PURE__ */ jsx5("line", { x1: "15", y1: "8", x2: "19", y2: "12" })
      ] }),
      tablerIconProps
    );
    LineIcon = createIcon(
      /* @__PURE__ */ jsx5("path", { d: "M4.167 10h11.666", strokeWidth: "1.5" }),
      modifiedTablerIconProps
    );
    PenModeIcon = createIcon(
      /* @__PURE__ */ jsxs3("g", { strokeWidth: "1.25", children: [
        /* @__PURE__ */ jsx5("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx5("path", { d: "M20 17v-12c0 -1.121 -.879 -2 -2 -2s-2 .879 -2 2v12l2 2l2 -2z" }),
        /* @__PURE__ */ jsx5("path", { d: "M16 7h4" }),
        /* @__PURE__ */ jsx5("path", { d: "M18 19h-13a2 2 0 1 1 0 -4h4a2 2 0 1 0 0 -4h-3" })
      ] }),
      tablerIconProps
    );
    FreedrawIcon = createIcon(
      /* @__PURE__ */ jsxs3("g", { strokeWidth: "1.25", children: [
        /* @__PURE__ */ jsx5(
          "path",
          {
            clipRule: "evenodd",
            d: "m7.643 15.69 7.774-7.773a2.357 2.357 0 1 0-3.334-3.334L4.31 12.357a3.333 3.333 0 0 0-.977 2.357v1.953h1.953c.884 0 1.732-.352 2.357-.977Z"
          }
        ),
        /* @__PURE__ */ jsx5("path", { d: "m11.25 5.417 3.333 3.333" })
      ] }),
      modifiedTablerIconProps
    );
    TextIcon = createIcon(
      /* @__PURE__ */ jsxs3("g", { strokeWidth: "1.5", children: [
        /* @__PURE__ */ jsx5("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx5("line", { x1: "4", y1: "20", x2: "7", y2: "20" }),
        /* @__PURE__ */ jsx5("line", { x1: "14", y1: "20", x2: "21", y2: "20" }),
        /* @__PURE__ */ jsx5("line", { x1: "6.9", y1: "15", x2: "13.8", y2: "15" }),
        /* @__PURE__ */ jsx5("line", { x1: "10.2", y1: "6.3", x2: "16", y2: "20" }),
        /* @__PURE__ */ jsx5("polyline", { points: "5 20 11 4 13 4 20 20" })
      ] }),
      tablerIconProps
    );
    ImageIcon = createIcon(
      /* @__PURE__ */ jsxs3("g", { strokeWidth: "1.25", children: [
        /* @__PURE__ */ jsx5("path", { d: "M12.5 6.667h.01" }),
        /* @__PURE__ */ jsx5("path", { d: "M4.91 2.625h10.18a2.284 2.284 0 0 1 2.285 2.284v10.182a2.284 2.284 0 0 1-2.284 2.284H4.909a2.284 2.284 0 0 1-2.284-2.284V4.909a2.284 2.284 0 0 1 2.284-2.284Z" }),
        /* @__PURE__ */ jsx5("path", { d: "m3.333 12.5 3.334-3.333c.773-.745 1.726-.745 2.5 0l4.166 4.166" }),
        /* @__PURE__ */ jsx5("path", { d: "m11.667 11.667.833-.834c.774-.744 1.726-.744 2.5 0l1.667 1.667" })
      ] }),
      modifiedTablerIconProps
    );
    EraserIcon = createIcon(
      /* @__PURE__ */ jsxs3("g", { strokeWidth: "1.5", children: [
        /* @__PURE__ */ jsx5("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx5("path", { d: "M19 20h-10.5l-4.21 -4.3a1 1 0 0 1 0 -1.41l10 -10a1 1 0 0 1 1.41 0l5 5a1 1 0 0 1 0 1.41l-9.2 9.3" }),
        /* @__PURE__ */ jsx5("path", { d: "M18 13.3l-6.3 -6.3" })
      ] }),
      tablerIconProps
    );
    ZoomInIcon = createIcon(
      /* @__PURE__ */ jsx5("path", { strokeWidth: "1.25", d: "M10 4.167v11.666M4.167 10h11.666" }),
      modifiedTablerIconProps
    );
    ZoomOutIcon = createIcon(
      /* @__PURE__ */ jsx5("path", { d: "M5 10h10", strokeWidth: "1.25" }),
      modifiedTablerIconProps
    );
    TrashIcon = createIcon(
      /* @__PURE__ */ jsx5(
        "path",
        {
          strokeWidth: "1.25",
          d: "M3.333 5.833h13.334M8.333 9.167v5M11.667 9.167v5M4.167 5.833l.833 10c0 .92.746 1.667 1.667 1.667h6.666c.92 0 1.667-.746 1.667-1.667l.833-10M7.5 5.833v-2.5c0-.46.373-.833.833-.833h3.334c.46 0 .833.373.833.833v2.5"
        }
      ),
      modifiedTablerIconProps
    );
    EmbedIcon = createIcon(
      /* @__PURE__ */ jsxs3("g", { strokeWidth: "1.25", children: [
        /* @__PURE__ */ jsx5("polyline", { points: "12 16 18 10 12 4" }),
        /* @__PURE__ */ jsx5("polyline", { points: "8 4 2 10 8 16" })
      ] }),
      modifiedTablerIconProps
    );
    DuplicateIcon = createIcon(
      /* @__PURE__ */ jsxs3("g", { strokeWidth: "1.25", children: [
        /* @__PURE__ */ jsx5("path", { d: "M14.375 6.458H8.958a2.5 2.5 0 0 0-2.5 2.5v5.417a2.5 2.5 0 0 0 2.5 2.5h5.417a2.5 2.5 0 0 0 2.5-2.5V8.958a2.5 2.5 0 0 0-2.5-2.5Z" }),
        /* @__PURE__ */ jsx5(
          "path",
          {
            clipRule: "evenodd",
            d: "M11.667 3.125c.517 0 .986.21 1.325.55.34.338.55.807.55 1.325v1.458H8.333c-.485 0-.927.185-1.26.487-.343.312-.57.75-.609 1.24l-.005 5.357H5a1.87 1.87 0 0 1-1.326-.55 1.87 1.87 0 0 1-.549-1.325V5c0-.518.21-.987.55-1.326.338-.34.807-.549 1.325-.549h6.667Z"
          }
        )
      ] }),
      modifiedTablerIconProps
    );
    MoonIcon = createIcon(
      /* @__PURE__ */ jsx5(
        "path",
        {
          clipRule: "evenodd",
          d: "M10 2.5h.328a6.25 6.25 0 0 0 6.6 10.372A7.5 7.5 0 1 1 10 2.493V2.5Z",
          stroke: "currentColor"
        }
      ),
      modifiedTablerIconProps
    );
    SunIcon = createIcon(
      /* @__PURE__ */ jsx5(
        "g",
        {
          stroke: "currentColor",
          strokeWidth: "1.25",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          children: /* @__PURE__ */ jsx5("path", { d: "M10 12.5a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5ZM10 4.167V2.5M14.167 5.833l1.166-1.166M15.833 10H17.5M14.167 14.167l1.166 1.166M10 15.833V17.5M5.833 14.167l-1.166 1.166M5 10H3.333M5.833 5.833 4.667 4.667" })
        }
      ),
      modifiedTablerIconProps
    );
    HamburgerMenuIcon = createIcon(
      /* @__PURE__ */ jsxs3("g", { strokeWidth: "1.5", children: [
        /* @__PURE__ */ jsx5("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx5("line", { x1: "4", y1: "6", x2: "20", y2: "6" }),
        /* @__PURE__ */ jsx5("line", { x1: "4", y1: "12", x2: "20", y2: "12" }),
        /* @__PURE__ */ jsx5("line", { x1: "4", y1: "18", x2: "20", y2: "18" })
      ] }),
      tablerIconProps
    );
    ExportIcon = createIcon(
      /* @__PURE__ */ jsx5(
        "path",
        {
          strokeWidth: "1.25",
          d: "M3.333 14.167v1.666c0 .92.747 1.667 1.667 1.667h10c.92 0 1.667-.746 1.667-1.667v-1.666M5.833 9.167 10 13.333l4.167-4.166M10 3.333v10"
        }
      ),
      modifiedTablerIconProps
    );
    HelpIcon = createIcon(
      /* @__PURE__ */ jsxs3("g", { strokeWidth: "1.5", children: [
        /* @__PURE__ */ jsx5("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx5("circle", { cx: "12", cy: "12", r: "9" }),
        /* @__PURE__ */ jsx5("line", { x1: "12", y1: "17", x2: "12", y2: "17.01" }),
        /* @__PURE__ */ jsx5("path", { d: "M12 13.5a1.5 1.5 0 0 1 1 -1.5a2.6 2.6 0 1 0 -3 -4" })
      ] }),
      tablerIconProps
    );
    ExternalLinkIcon = createIcon(
      /* @__PURE__ */ jsx5(
        "path",
        {
          strokeWidth: "1.25",
          d: "M9.167 5.833H5.833c-1.254 0-2.5 1.282-2.5 2.5v5.834c0 1.283 1.252 2.5 2.5 2.5h5.834c1.251 0 2.5-1.25 2.5-2.5v-3.334M8.333 11.667l8.334-8.334M12.5 3.333h4.167V7.5"
        }
      ),
      modifiedTablerIconProps
    );
    GithubIcon = createIcon(
      /* @__PURE__ */ jsx5(
        "path",
        {
          d: "M7.5 15.833c-3.583 1.167-3.583-2.083-5-2.5m10 4.167v-2.917c0-.833.083-1.166-.417-1.666 2.334-.25 4.584-1.167 4.584-5a3.833 3.833 0 0 0-1.084-2.667 3.5 3.5 0 0 0-.083-2.667s-.917-.25-2.917 1.084a10.25 10.25 0 0 0-5.166 0C5.417 2.333 4.5 2.583 4.5 2.583a3.5 3.5 0 0 0-.083 2.667 3.833 3.833 0 0 0-1.084 2.667c0 3.833 2.25 4.75 4.584 5-.5.5-.5 1-.417 1.666V17.5",
          strokeWidth: "1.25"
        }
      ),
      modifiedTablerIconProps
    );
    DiscordIcon = createIcon(
      /* @__PURE__ */ jsxs3("g", { strokeWidth: "1.25", children: [
        /* @__PURE__ */ jsx5("path", { d: "M7.5 10.833a.833.833 0 1 0 0-1.666.833.833 0 0 0 0 1.666ZM12.5 10.833a.833.833 0 1 0 0-1.666.833.833 0 0 0 0 1.666ZM6.25 6.25c2.917-.833 4.583-.833 7.5 0M5.833 13.75c2.917.833 5.417.833 8.334 0" }),
        /* @__PURE__ */ jsx5("path", { d: "M12.917 14.167c0 .833 1.25 2.5 1.666 2.5 1.25 0 2.361-1.39 2.917-2.5.556-1.39.417-4.861-1.25-9.584-1.214-.846-2.5-1.116-3.75-1.25l-.833 2.084M7.083 14.167c0 .833-1.13 2.5-1.526 2.5-1.191 0-2.249-1.39-2.778-2.5-.529-1.39-.397-4.861 1.19-9.584 1.157-.846 2.318-1.116 3.531-1.25l.833 2.084" })
      ] }),
      modifiedTablerIconProps
    );
    XBrandIcon = createIcon(
      /* @__PURE__ */ jsxs3("g", { strokeWidth: "1.25", children: [
        /* @__PURE__ */ jsx5("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx5("path", { d: "M4 4l11.733 16h4.267l-11.733 -16z" }),
        /* @__PURE__ */ jsx5("path", { d: "M4 20l6.768 -6.768m2.46 -2.46l6.772 -6.772" })
      ] }),
      tablerIconProps
    );
    checkIcon = createIcon(
      /* @__PURE__ */ jsx5("polyline", { fill: "none", stroke: "currentColor", points: "20 6 9 17 4 12" }),
      {
        width: 24,
        height: 24
      }
    );
    LinkIcon = createIcon(
      /* @__PURE__ */ jsxs3("g", { strokeWidth: "1.25", children: [
        /* @__PURE__ */ jsx5("path", { d: "M8.333 11.667a2.917 2.917 0 0 0 4.167 0l3.333-3.334a2.946 2.946 0 1 0-4.166-4.166l-.417.416" }),
        /* @__PURE__ */ jsx5("path", { d: "M11.667 8.333a2.917 2.917 0 0 0-4.167 0l-3.333 3.334a2.946 2.946 0 0 0 4.166 4.166l.417-.416" })
      ] }),
      modifiedTablerIconProps
    );
    save = createIcon(
      "M433.941 129.941l-83.882-83.882A48 48 0 0 0 316.118 32H48C21.49 32 0 53.49 0 80v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V163.882a48 48 0 0 0-14.059-33.941zM224 416c-35.346 0-64-28.654-64-64 0-35.346 28.654-64 64-64s64 28.654 64 64c0 35.346-28.654 64-64 64zm96-304.52V212c0 6.627-5.373 12-12 12H76c-6.627 0-12-5.373-12-12V108c0-6.627 5.373-12 12-12h228.52c3.183 0 6.235 1.264 8.485 3.515l3.48 3.48A11.996 11.996 0 0 1 320 111.48z",
      { width: 448, height: 512 }
    );
    saveAs = createIcon(
      "M252 54L203 8a28 27 0 00-20-8H28C12 0 0 12 0 27v195c0 15 12 26 28 26h204c15 0 28-11 28-26V73a28 27 0 00-8-19zM130 213c-21 0-37-16-37-36 0-19 16-35 37-35 20 0 37 16 37 35 0 20-17 36-37 36zm56-169v56c0 4-4 6-7 6H44c-4 0-7-2-7-6V42c0-4 3-7 7-7h133l4 2 3 2a7 7 0 012 5z M296 201l87 95-188 205-78 9c-10 1-19-8-18-20l9-84zm141-14l-41-44a31 31 0 00-46 0l-38 41 87 95 38-42c13-14 13-36 0-50z",
      { width: 448, height: 512 }
    );
    LoadIcon = createIcon(
      /* @__PURE__ */ jsx5(
        "path",
        {
          d: "m9.257 6.351.183.183H15.819c.34 0 .727.182 1.051.506.323.323.505.708.505 1.05v5.819c0 .316-.183.7-.52 1.035-.337.338-.723.522-1.037.522H4.182c-.352 0-.74-.181-1.058-.5-.318-.318-.499-.705-.499-1.057V5.182c0-.351.181-.736.5-1.054.32-.321.71-.503 1.057-.503H6.53l2.726 2.726Z",
          strokeWidth: "1.25"
        }
      ),
      modifiedTablerIconProps
    );
    clipboard = createIcon(
      "M384 112v352c0 26.51-21.49 48-48 48H48c-26.51 0-48-21.49-48-48V112c0-26.51 21.49-48 48-48h80c0-35.29 28.71-64 64-64s64 28.71 64 64h80c26.51 0 48 21.49 48 48zM192 40c-13.255 0-24 10.745-24 24s10.745 24 24 24 24-10.745 24-24-10.745-24-24-24m96 114v-20a6 6 0 0 0-6-6H102a6 6 0 0 0-6 6v20a6 6 0 0 0 6 6h180a6 6 0 0 0 6-6z",
      { width: 384, height: 512 }
    );
    palette = createIcon(
      "M204.3 5C104.9 24.4 24.8 104.3 5.2 203.4c-37 187 131.7 326.4 258.8 306.7 41.2-6.4 61.4-54.6 42.5-91.7-23.1-45.4 9.9-98.4 60.9-98.4h79.7c35.8 0 64.8-29.6 64.9-65.3C511.5 97.1 368.1-26.9 204.3 5zM96 320c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm32-128c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm128-64c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm128 64c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32z"
    );
    ExportImageIcon = createIcon(
      /* @__PURE__ */ jsxs3("g", { strokeWidth: "1.25", children: [
        /* @__PURE__ */ jsx5("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx5("path", { d: "M15 8h.01" }),
        /* @__PURE__ */ jsx5("path", { d: "M12 20h-5a3 3 0 0 1 -3 -3v-10a3 3 0 0 1 3 -3h10a3 3 0 0 1 3 3v5" }),
        /* @__PURE__ */ jsx5("path", { d: "M4 15l4 -4c.928 -.893 2.072 -.893 3 0l4 4" }),
        /* @__PURE__ */ jsx5("path", { d: "M14 14l1 -1c.617 -.593 1.328 -.793 2.009 -.598" }),
        /* @__PURE__ */ jsx5("path", { d: "M19 16v6" }),
        /* @__PURE__ */ jsx5("path", { d: "M22 19l-3 3l-3 -3" })
      ] }),
      tablerIconProps
    );
    exportToFileIcon = createIcon(
      "M216 0h80c13.3 0 24 10.7 24 24v168h87.7c17.8 0 26.7 21.5 14.1 34.1L269.7 378.3c-7.5 7.5-19.8 7.5-27.3 0L90.1 226.1c-12.6-12.6-3.7-34.1 14.1-34.1H192V24c0-13.3 10.7-24 24-24zm296 376v112c0 13.3-10.7 24-24 24H24c-13.3 0-24-10.7-24-24V376c0-13.3 10.7-24 24-24h146.7l49 49c20.1 20.1 52.5 20.1 72.6 0l49-49H488c13.3 0 24 10.7 24 24zm-124 88c0-11-9-20-20-20s-20 9-20 20 9 20 20 20 20-9 20-20zm64 0c0-11-9-20-20-20s-20 9-20 20 9 20 20 20 20-9 20-20z",
      { width: 512, height: 512 }
    );
    zoomIn = createIcon(
      "M416 208H272V64c0-17.67-14.33-32-32-32h-32c-17.67 0-32 14.33-32 32v144H32c-17.67 0-32 14.33-32 32v32c0 17.67 14.33 32 32 32h144v144c0 17.67 14.33 32 32 32h32c17.67 0 32-14.33 32-32V304h144c17.67 0 32-14.33 32-32v-32c0-17.67-14.33-32-32-32z",
      { width: 448, height: 512 }
    );
    zoomOut = createIcon(
      "M416 208H32c-17.67 0-32 14.33-32 32v32c0 17.67 14.33 32 32 32h384c17.67 0 32-14.33 32-32v-32c0-17.67-14.33-32-32-32z",
      { width: 448, height: 512 }
    );
    done = createIcon(
      "M173.898 439.404l-166.4-166.4c-9.997-9.997-9.997-26.206 0-36.204l36.203-36.204c9.997-9.998 26.207-9.998 36.204 0L192 312.69 432.095 72.596c9.997-9.997 26.207-9.997 36.204 0l36.203 36.204c9.997 9.997 9.997 26.206 0 36.204l-294.4 294.401c-9.998 9.997-26.207 9.997-36.204-.001z"
    );
    menu = createIcon(
      "M16 132h416c8.837 0 16-7.163 16-16V76c0-8.837-7.163-16-16-16H16C7.163 60 0 67.163 0 76v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16z"
    );
    UndoIcon = createIcon(
      /* @__PURE__ */ jsx5(
        "path",
        {
          d: "M7.5 10.833 4.167 7.5 7.5 4.167M4.167 7.5h9.166a3.333 3.333 0 0 1 0 6.667H12.5",
          strokeWidth: "1.25"
        }
      ),
      modifiedTablerIconProps
    );
    RedoIcon = createIcon(
      /* @__PURE__ */ jsx5(
        "path",
        {
          d: "M12.5 10.833 15.833 7.5 12.5 4.167M15.833 7.5H6.667a3.333 3.333 0 1 0 0 6.667H7.5",
          strokeWidth: "1.25"
        }
      ),
      modifiedTablerIconProps
    );
    questionCircle = createIcon(
      "M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zM262.655 90c-54.497 0-89.255 22.957-116.549 63.758-3.536 5.286-2.353 12.415 2.715 16.258l34.699 26.31c5.205 3.947 12.621 3.008 16.665-2.122 17.864-22.658 30.113-35.797 57.303-35.797 20.429 0 45.698 13.148 45.698 32.958 0 14.976-12.363 22.667-32.534 33.976C247.128 238.528 216 254.941 216 296v4c0 6.627 5.373 12 12 12h56c6.627 0 12-5.373 12-12v-1.333c0-28.462 83.186-29.647 83.186-106.667 0-58.002-60.165-102-116.531-102zM256 338c-25.365 0-46 20.635-46 46 0 25.364 20.635 46 46 46s46-20.636 46-46c0-25.365-20.635-46-46-46z",
      { mirror: true }
    );
    share = createIcon(
      /* @__PURE__ */ jsx5(
        "path",
        {
          d: "M5 12.5a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5ZM15 7.5a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5ZM15 17.5a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5ZM7.25 8.917l5.5-2.834M7.25 11.083l5.5 2.834",
          strokeWidth: "1.5"
        }
      ),
      modifiedTablerIconProps
    );
    shareIOS = createIcon(
      "M16 5l-1.42 1.42-1.59-1.59V16h-1.98V4.83L9.42 6.42 8 5l4-4 4 4zm4 5v11c0 1.1-.9 2-2 2H6c-1.11 0-2-.9-2-2V10c0-1.11.89-2 2-2h3v2H6v11h12V10h-3V8h3c1.1 0 2 .89 2 2z",
      { width: 24, height: 24 }
    );
    shareWindows = createIcon(
      /* @__PURE__ */ jsxs3(Fragment, { children: [
        /* @__PURE__ */ jsx5(
          "path",
          {
            fill: "currentColor",
            d: "M40 5.6v6.1l-4.1.7c-8.9 1.4-16.5 6.9-20.6 15C13 32 10.9 43 12.4 43c.4 0 2.4-1.3 4.4-3 5-3.9 12.1-7 18.2-7.7l5-.6v12.8l11.2-11.3L62.5 22 51.2 10.8 40-.5v6.1zm10.2 22.6L44 34.5v-6.8l-6.9.6c-3.9.3-9.8 1.7-13.2 3.1-3.5 1.4-6.5 2.4-6.7 2.2-.9-1 3-7.5 6.4-10.8C28 18.6 34.4 16 40.1 16c3.7 0 3.9-.1 3.9-3.2V9.5l6.2 6.3 6.3 6.2-6.3 6.2z"
          }
        ),
        /* @__PURE__ */ jsx5(
          "path",
          {
            stroke: "currentColor",
            fill: "currentColor",
            d: "M0 36v20h48v-6.2c0-6 0-6.1-2-4.3-1.1 1-2 2.9-2 4.2V52H4V34c0-17.3-.1-18-2-18s-2 .7-2 20z"
          }
        )
      ] }),
      { width: 64, height: 64 }
    );
    resetZoom = createIcon(
      /* @__PURE__ */ jsx5(
        "path",
        {
          stroke: "currentColor",
          strokeWidth: "40",
          fill: "currentColor",
          d: "M148 560a318 318 0 0 0 522 110 316 316 0 0 0 0-450 316 316 0 0 0-450 0c-11 11-21 22-30 34v4h47c25 0 46 21 46 46s-21 45-46 45H90c-13 0-25-6-33-14-9-9-14-20-14-33V156c0-25 20-45 45-45s45 20 45 45v32l1 1a401 401 0 0 1 623 509l212 212a42 42 0 0 1-59 59L698 757A401 401 0 0 1 65 570a42 42 0 0 1 83-10z"
        }
      ),
      { width: 1024 }
    );
    BringForwardIcon = createIcon(
      /* @__PURE__ */ jsxs3(Fragment, { children: [
        /* @__PURE__ */ jsxs3(
          "g",
          {
            clipPath: "url(#a)",
            stroke: "currentColor",
            strokeWidth: "1.25",
            strokeLinecap: "round",
            strokeLinejoin: "round",
            children: [
              /* @__PURE__ */ jsx5(
                "path",
                {
                  d: "M13.889 4.167H8.333c-.767 0-1.389.622-1.389 1.389v5.555c0 .767.622 1.389 1.39 1.389h5.555c.767 0 1.389-.622 1.389-1.389V5.556c0-.767-.622-1.39-1.39-1.39Z",
                  fill: "currentColor"
                }
              ),
              /* @__PURE__ */ jsx5("path", { d: "M12.5 12.5v1.389a1.389 1.389 0 0 1-1.389 1.389H5.556a1.389 1.389 0 0 1-1.39-1.39V8.334a1.389 1.389 0 0 1 1.39-1.389h1.388" })
            ]
          }
        ),
        /* @__PURE__ */ jsx5("defs", { children: /* @__PURE__ */ jsx5("clipPath", { id: "a", children: /* @__PURE__ */ jsx5("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
      ] }),
      modifiedTablerIconProps
    );
    SendBackwardIcon = createIcon(
      /* @__PURE__ */ jsxs3(Fragment, { children: [
        /* @__PURE__ */ jsxs3(
          "g",
          {
            clipPath: "url(#a)",
            stroke: "currentColor",
            strokeWidth: "1.25",
            strokeLinecap: "round",
            strokeLinejoin: "round",
            children: [
              /* @__PURE__ */ jsx5(
                "path",
                {
                  fillRule: "evenodd",
                  clipRule: "evenodd",
                  d: "M6.944 12.5H12.5v1.389a1.389 1.389 0 0 1-1.389 1.389H5.556a1.389 1.389 0 0 1-1.39-1.39V8.334a1.389 1.389 0 0 1 1.39-1.389h1.388",
                  fill: "currentColor"
                }
              ),
              /* @__PURE__ */ jsx5("path", { d: "M13.889 4.167H8.333c-.767 0-1.389.621-1.389 1.389v5.555c0 .767.622 1.389 1.39 1.389h5.555c.767 0 1.389-.622 1.389-1.389V5.556c0-.768-.622-1.39-1.39-1.39Z" })
            ]
          }
        ),
        /* @__PURE__ */ jsx5("defs", { children: /* @__PURE__ */ jsx5("clipPath", { id: "a", children: /* @__PURE__ */ jsx5("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
      ] }),
      modifiedTablerIconProps
    );
    BringToFrontIcon = createIcon(
      /* @__PURE__ */ jsxs3(Fragment, { children: [
        /* @__PURE__ */ jsxs3("g", { clipPath: "url(#a)", stroke: "currentColor", strokeWidth: "1.25", children: [
          /* @__PURE__ */ jsx5(
            "path",
            {
              d: "M8.775 6.458h2.45a2.316 2.316 0 0 1 2.317 2.316v2.452a2.316 2.316 0 0 1-2.316 2.316H8.774a2.316 2.316 0 0 1-2.317-2.316V8.774a2.316 2.316 0 0 1 2.317-2.316Z",
              fill: "currentColor"
            }
          ),
          /* @__PURE__ */ jsx5("path", { d: "M5.441 9.792h2.451a2.316 2.316 0 0 1 2.316 2.316v2.45a2.316 2.316 0 0 1-2.316 2.317h-2.45a2.316 2.316 0 0 1-2.317-2.316v-2.451a2.316 2.316 0 0 1 2.316-2.316ZM12.108 3.125h2.45a2.316 2.316 0 0 1 2.317 2.316v2.451a2.316 2.316 0 0 1-2.316 2.316h-2.451a2.316 2.316 0 0 1-2.316-2.316v-2.45a2.316 2.316 0 0 1 2.316-2.317Z" })
        ] }),
        /* @__PURE__ */ jsx5("defs", { children: /* @__PURE__ */ jsx5("clipPath", { id: "a", children: /* @__PURE__ */ jsx5("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
      ] }),
      modifiedTablerIconProps
    );
    SendToBackIcon = createIcon(
      /* @__PURE__ */ jsxs3(Fragment, { children: [
        /* @__PURE__ */ jsxs3("g", { clipPath: "url(#a)", children: [
          /* @__PURE__ */ jsx5(
            "path",
            {
              d: "M5.441 9.792h2.451a2.316 2.316 0 0 1 2.316 2.316v2.45a2.316 2.316 0 0 1-2.316 2.317h-2.45a2.316 2.316 0 0 1-2.317-2.316v-2.451a2.316 2.316 0 0 1 2.316-2.316Z",
              stroke: "currentColor",
              strokeWidth: "1.25"
            }
          ),
          /* @__PURE__ */ jsx5(
            "path",
            {
              d: "M5.441 9.792h2.451a2.316 2.316 0 0 1 2.316 2.316v2.45a2.316 2.316 0 0 1-2.316 2.317h-2.45a2.316 2.316 0 0 1-2.317-2.316v-2.451a2.316 2.316 0 0 1 2.316-2.316Z",
              stroke: "currentColor",
              strokeWidth: "1.25"
            }
          ),
          /* @__PURE__ */ jsx5("mask", { id: "SendToBackIcon", fill: "#fff", children: /* @__PURE__ */ jsx5(
            "path",
            {
              fillRule: "evenodd",
              clipRule: "evenodd",
              d: "M9.167 5.833v2.06a2.941 2.941 0 0 0 2.94 2.94h2.06v.393a2.941 2.941 0 0 1-2.941 2.94h-.393v-2.058a2.941 2.941 0 0 0-2.94-2.941h-2.06v-.393a2.941 2.941 0 0 1 2.942-2.94h.392Z"
            }
          ) }),
          /* @__PURE__ */ jsx5(
            "path",
            {
              fillRule: "evenodd",
              clipRule: "evenodd",
              d: "M9.167 5.833v2.06a2.941 2.941 0 0 0 2.94 2.94h2.06v.393a2.941 2.941 0 0 1-2.941 2.94h-.393v-2.058a2.941 2.941 0 0 0-2.94-2.941h-2.06v-.393a2.941 2.941 0 0 1 2.942-2.94h.392Z",
              fill: "currentColor"
            }
          ),
          /* @__PURE__ */ jsx5(
            "path",
            {
              d: "M9.167 5.833h1.25v-1.25h-1.25v1.25Zm5 5h1.25v-1.25h-1.25v1.25Zm-3.334 3.334h-1.25v1.25h1.25v-1.25Zm-5-5h-1.25v1.25h1.25v-1.25Zm2.084-3.334v2.06h2.5v-2.06h-2.5Zm0 2.06a4.191 4.191 0 0 0 4.19 4.19v-2.5a1.691 1.691 0 0 1-1.69-1.69h-2.5Zm4.19 4.19h2.06v-2.5h-2.06v2.5Zm.81-1.25v.393h2.5v-.393h-2.5Zm0 .393c0 .933-.758 1.69-1.691 1.69v2.5a4.191 4.191 0 0 0 4.19-4.19h-2.5Zm-1.691 1.69h-.393v2.5h.393v-2.5Zm.857 1.25v-2.058h-2.5v2.059h2.5Zm0-2.058a4.191 4.191 0 0 0-4.19-4.191v2.5c.933 0 1.69.757 1.69 1.69h2.5Zm-4.19-4.191h-2.06v2.5h2.06v-2.5Zm-.81 1.25v-.393h-2.5v.393h2.5Zm0-.393c0-.934.758-1.69 1.692-1.69v-2.5a4.191 4.191 0 0 0-4.192 4.19h2.5Zm1.692-1.69h.392v-2.5h-.392v2.5Z",
              fill: "currentColor",
              mask: "url(#SendToBackIcon)"
            }
          ),
          /* @__PURE__ */ jsx5(
            "path",
            {
              d: "M12.108 3.125h2.45a2.316 2.316 0 0 1 2.317 2.316v2.451a2.316 2.316 0 0 1-2.316 2.316h-2.451a2.316 2.316 0 0 1-2.316-2.316v-2.45a2.316 2.316 0 0 1 2.316-2.317Z",
              stroke: "currentColor",
              strokeWidth: "1.25"
            }
          )
        ] }),
        /* @__PURE__ */ jsx5("defs", { children: /* @__PURE__ */ jsx5("clipPath", { id: "a", children: /* @__PURE__ */ jsx5("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
      ] }),
      modifiedTablerIconProps
    );
    AlignTopIcon = createIcon(
      /* @__PURE__ */ jsxs3(Fragment, { children: [
        /* @__PURE__ */ jsxs3("g", { clipPath: "url(#a)", stroke: "currentColor", strokeWidth: "1.25", children: [
          /* @__PURE__ */ jsx5(
            "path",
            {
              d: "M3.333 3.333h13.334",
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          ),
          /* @__PURE__ */ jsx5("path", { d: "M13.542 6.458h-.417c-.92 0-1.667.747-1.667 1.667v7.083c0 .92.746 1.667 1.667 1.667h.417c.92 0 1.666-.746 1.666-1.667V8.125c0-.92-.746-1.667-1.666-1.667ZM6.875 6.458h-.417c-.92 0-1.666.747-1.666 1.667v3.75c0 .92.746 1.667 1.666 1.667h.417c.92 0 1.667-.746 1.667-1.667v-3.75c0-.92-.747-1.667-1.667-1.667Z" })
        ] }),
        /* @__PURE__ */ jsx5("defs", { children: /* @__PURE__ */ jsx5("clipPath", { id: "a", children: /* @__PURE__ */ jsx5("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
      ] }),
      modifiedTablerIconProps
    );
    AlignBottomIcon = createIcon(
      /* @__PURE__ */ jsxs3(Fragment, { children: [
        /* @__PURE__ */ jsxs3("g", { clipPath: "url(#a)", stroke: "currentColor", strokeWidth: "1.25", children: [
          /* @__PURE__ */ jsx5(
            "path",
            {
              d: "M3.333 16.667h13.334",
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          ),
          /* @__PURE__ */ jsx5("path", { d: "M6.875 3.125h-.417c-.92 0-1.666.746-1.666 1.667v7.083c0 .92.746 1.667 1.666 1.667h.417c.92 0 1.667-.746 1.667-1.667V4.792c0-.92-.747-1.667-1.667-1.667ZM13.542 5.817h-.417c-.92 0-1.667.747-1.667 1.667v4.391c0 .92.746 1.667 1.667 1.667h.417c.92 0 1.666-.746 1.666-1.667V7.484c0-.92-.746-1.667-1.666-1.667Z" })
        ] }),
        /* @__PURE__ */ jsx5("defs", { children: /* @__PURE__ */ jsx5("clipPath", { id: "a", children: /* @__PURE__ */ jsx5("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
      ] }),
      modifiedTablerIconProps
    );
    AlignLeftIcon = createIcon(
      /* @__PURE__ */ jsxs3(Fragment, { children: [
        /* @__PURE__ */ jsxs3("g", { clipPath: "url(#a)", stroke: "currentColor", strokeWidth: "1.25", children: [
          /* @__PURE__ */ jsx5(
            "path",
            {
              d: "M3.333 3.333v13.334",
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          ),
          /* @__PURE__ */ jsx5("path", { d: "M15.208 4.792H8.125c-.92 0-1.667.746-1.667 1.666v.417c0 .92.747 1.667 1.667 1.667h7.083c.92 0 1.667-.747 1.667-1.667v-.417c0-.92-.746-1.666-1.667-1.666ZM12.516 11.458H8.125c-.92 0-1.667.746-1.667 1.667v.417c0 .92.747 1.666 1.667 1.666h4.391c.92 0 1.667-.746 1.667-1.666v-.417c0-.92-.746-1.667-1.667-1.667Z" })
        ] }),
        /* @__PURE__ */ jsx5("defs", { children: /* @__PURE__ */ jsx5("clipPath", { id: "a", children: /* @__PURE__ */ jsx5("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
      ] }),
      modifiedTablerIconProps
    );
    AlignRightIcon = createIcon(
      /* @__PURE__ */ jsxs3(Fragment, { children: [
        /* @__PURE__ */ jsxs3("g", { clipPath: "url(#a)", stroke: "currentColor", strokeWidth: "1.25", children: [
          /* @__PURE__ */ jsx5(
            "path",
            {
              d: "M16.667 3.333v13.334",
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          ),
          /* @__PURE__ */ jsx5("path", { d: "M11.875 4.792H4.792c-.92 0-1.667.746-1.667 1.666v.417c0 .92.746 1.667 1.667 1.667h7.083c.92 0 1.667-.747 1.667-1.667v-.417c0-.92-.746-1.666-1.667-1.666ZM11.683 11.458H7.292c-.92 0-1.667.746-1.667 1.667v.417c0 .92.746 1.666 1.667 1.666h4.39c.921 0 1.667-.746 1.667-1.666v-.417c0-.92-.746-1.667-1.666-1.667Z" })
        ] }),
        /* @__PURE__ */ jsx5("defs", { children: /* @__PURE__ */ jsx5("clipPath", { id: "a", children: /* @__PURE__ */ jsx5("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
      ] }),
      modifiedTablerIconProps
    );
    DistributeHorizontallyIcon = createIcon(
      /* @__PURE__ */ jsxs3(Fragment, { children: [
        /* @__PURE__ */ jsxs3("g", { clipPath: "url(#a)", stroke: "currentColor", strokeWidth: "1.25", children: [
          /* @__PURE__ */ jsx5(
            "path",
            {
              d: "M16.667 3.333v13.334M3.333 3.333v13.334",
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          ),
          /* @__PURE__ */ jsx5("path", { d: "M14.375 10.208v-.416c0-.92-.746-1.667-1.667-1.667H7.292c-.92 0-1.667.746-1.667 1.667v.416c0 .92.746 1.667 1.667 1.667h5.416c.92 0 1.667-.746 1.667-1.667Z" })
        ] }),
        /* @__PURE__ */ jsx5("defs", { children: /* @__PURE__ */ jsx5("clipPath", { id: "a", children: /* @__PURE__ */ jsx5("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
      ] }),
      modifiedTablerIconProps
    );
    DistributeVerticallyIcon = createIcon(
      /* @__PURE__ */ jsxs3(Fragment, { children: [
        /* @__PURE__ */ jsxs3("g", { clipPath: "url(#a)", stroke: "currentColor", strokeWidth: "1.25", children: [
          /* @__PURE__ */ jsx5(
            "path",
            {
              d: "M3.333 3.333h13.334M3.333 16.667h13.334",
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          ),
          /* @__PURE__ */ jsx5("path", { d: "M10.208 5.625h-.416c-.92 0-1.667.746-1.667 1.667v5.416c0 .92.746 1.667 1.667 1.667h.416c.92 0 1.667-.746 1.667-1.667V7.292c0-.92-.746-1.667-1.667-1.667Z" })
        ] }),
        /* @__PURE__ */ jsx5("defs", { children: /* @__PURE__ */ jsx5("clipPath", { id: "a", children: /* @__PURE__ */ jsx5("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
      ] }),
      modifiedTablerIconProps
    );
    CenterVerticallyIcon = createIcon(
      /* @__PURE__ */ jsxs3("g", { stroke: "currentColor", strokeWidth: "1.25", children: [
        /* @__PURE__ */ jsx5("path", { d: "M1.667 10h2.916", strokeLinecap: "round", strokeLinejoin: "round" }),
        /* @__PURE__ */ jsx5("path", { d: "M8.333 10h3.334", strokeLinejoin: "round" }),
        /* @__PURE__ */ jsx5("path", { d: "M15.417 10h2.916", strokeLinecap: "round", strokeLinejoin: "round" }),
        /* @__PURE__ */ jsx5("path", { d: "M6.875 4.792h-.417c-.92 0-1.666.746-1.666 1.666v7.084c0 .92.746 1.666 1.666 1.666h.417c.92 0 1.667-.746 1.667-1.666V6.458c0-.92-.747-1.666-1.667-1.666ZM13.542 6.458h-.417c-.92 0-1.667.747-1.667 1.667v3.75c0 .92.746 1.667 1.667 1.667h.417c.92 0 1.666-.746 1.666-1.667v-3.75c0-.92-.746-1.667-1.666-1.667Z" })
      ] }),
      modifiedTablerIconProps
    );
    CenterHorizontallyIcon = createIcon(
      /* @__PURE__ */ jsxs3("g", { stroke: "currentColor", strokeWidth: "1.25", children: [
        /* @__PURE__ */ jsx5("path", { d: "M10 18.333v-2.916", strokeLinecap: "round", strokeLinejoin: "round" }),
        /* @__PURE__ */ jsx5("path", { d: "M10 11.667V8.333", strokeLinejoin: "round" }),
        /* @__PURE__ */ jsx5("path", { d: "M10 4.583V1.667", strokeLinecap: "round", strokeLinejoin: "round" }),
        /* @__PURE__ */ jsx5("path", { d: "M4.792 13.125v.417c0 .92.746 1.666 1.666 1.666h7.084c.92 0 1.666-.746 1.666-1.666v-.417c0-.92-.746-1.667-1.666-1.667H6.458c-.92 0-1.666.746-1.666 1.667ZM6.458 6.458v.417c0 .92.747 1.667 1.667 1.667h3.75c.92 0 1.667-.747 1.667-1.667v-.417c0-.92-.746-1.666-1.667-1.666h-3.75c-.92 0-1.667.746-1.667 1.666Z" })
      ] }),
      modifiedTablerIconProps
    );
    usersIcon = createIcon(
      /* @__PURE__ */ jsxs3("g", { strokeWidth: "1.5", children: [
        /* @__PURE__ */ jsx5("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx5("circle", { cx: "9", cy: "7", r: "4" }),
        /* @__PURE__ */ jsx5("path", { d: "M3 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" }),
        /* @__PURE__ */ jsx5("path", { d: "M16 3.13a4 4 0 0 1 0 7.75" }),
        /* @__PURE__ */ jsx5("path", { d: "M21 21v-2a4 4 0 0 0 -3 -3.85" })
      ] }),
      tablerIconProps
    );
    start = createIcon(
      "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm115.7 272l-176 101c-15.8 8.8-35.7-2.5-35.7-21V152c0-18.4 19.8-29.8 35.7-21l176 107c16.4 9.2 16.4 32.9 0 42z"
    );
    stop = createIcon(
      "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm96 328c0 8.8-7.2 16-16 16H176c-8.8 0-16-7.2-16-16V176c0-8.8 7.2-16 16-16h160c8.8 0 16 7.2 16 16v160z"
    );
    CloseIcon = createIcon(
      /* @__PURE__ */ jsxs3(Fragment, { children: [
        /* @__PURE__ */ jsx5(
          "g",
          {
            clipPath: "url(#a)",
            stroke: "currentColor",
            strokeWidth: "1.25",
            strokeLinecap: "round",
            strokeLinejoin: "round",
            children: /* @__PURE__ */ jsx5("path", { d: "M15 5 5 15M5 5l10 10" })
          }
        ),
        /* @__PURE__ */ jsx5("defs", { children: /* @__PURE__ */ jsx5("clipPath", { id: "a", children: /* @__PURE__ */ jsx5("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
      ] }),
      modifiedTablerIconProps
    );
    back = createIcon(
      "M34.52 239.03L228.87 44.69c9.37-9.37 24.57-9.37 33.94 0l22.67 22.67c9.36 9.36 9.37 24.52.04 33.9L131.49 256l154.02 154.75c9.34 9.38 9.32 24.54-.04 33.9l-22.67 22.67c-9.37 9.37-24.57 9.37-33.94 0L34.52 272.97c-9.37-9.37-9.37-24.57 0-33.94z",
      { width: 320, height: 512, style: { marginLeft: "-0.2rem" }, mirror: true }
    );
    clone = createIcon(
      "M464 0c26.51 0 48 21.49 48 48v288c0 26.51-21.49 48-48 48H176c-26.51 0-48-21.49-48-48V48c0-26.51 21.49-48 48-48h288M176 416c-44.112 0-80-35.888-80-80V128H48c-26.51 0-48 21.49-48 48v288c0 26.51 21.49 48 48 48h288c26.51 0 48-21.49 48-48v-48H176z",
      { mirror: true }
    );
    shield = createIcon(
      "M11.553 22.894a.998.998 0 00.894 0s3.037-1.516 5.465-4.097C19.616 16.987 21 14.663 21 12V5a1 1 0 00-.649-.936l-8-3a.998.998 0 00-.702 0l-8 3A1 1 0 003 5v7c0 2.663 1.384 4.987 3.088 6.797 2.428 2.581 5.465 4.097 5.465 4.097zm-1.303-8.481l6.644-6.644a.856.856 0 111.212 1.212l-7.25 7.25a.856.856 0 01-1.212 0l-3.75-3.75a.856.856 0 111.212-1.212l3.144 3.144z",
      { width: 24 }
    );
    file = createIcon(
      "M369.9 97.9L286 14C277 5 264.8-.1 252.1-.1H48C21.5 0 0 21.5 0 48v416c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V131.9c0-12.7-5.1-25-14.1-34zM332.1 128H256V51.9l76.1 76.1zM48 464V48h160v104c0 13.3 10.7 24 24 24h104v288H48zm32-48h224V288l-23.5-23.5c-4.7-4.7-12.3-4.7-17 0L176 352l-39.5-39.5c-4.7-4.7-12.3-4.7-17 0L80 352v64zm48-240c-26.5 0-48 21.5-48 48s21.5 48 48 48 48-21.5 48-48-21.5-48-48-48z",
      { width: 384, height: 512 }
    );
    GroupIcon = React4.memo(
      ({ theme }) => createIcon(
        /* @__PURE__ */ jsxs3(Fragment, { children: [
          /* @__PURE__ */ jsx5("path", { d: "M25 26H111V111H25", fill: iconFillColor(theme) }),
          /* @__PURE__ */ jsx5(
            "path",
            {
              d: "M25 111C25 80.2068 25 49.4135 25 26M25 26C48.6174 26 72.2348 26 111 26H25ZM25 26C53.3671 26 81.7343 26 111 26H25ZM111 26C111 52.303 111 78.606 111 111V26ZM111 26C111 51.2947 111 76.5893 111 111V26ZM111 111C87.0792 111 63.1585 111 25 111H111ZM111 111C87.4646 111 63.9293 111 25 111H111ZM25 111C25 81.1514 25 51.3028 25 26V111Z",
              stroke: iconFillColor(theme),
              strokeWidth: "2"
            }
          ),
          /* @__PURE__ */ jsx5("path", { d: "M100 100H160V160H100", fill: iconFillColor(theme) }),
          /* @__PURE__ */ jsx5(
            "path",
            {
              d: "M100 160C100 144.106 100 128.211 100 100M100 100C117.706 100 135.412 100 160 100H100ZM100 100C114.214 100 128.428 100 160 100H100ZM160 100C160 120.184 160 140.369 160 160V100ZM160 100C160 113.219 160 126.437 160 160V100ZM160 160C145.534 160 131.068 160 100 160H160ZM160 160C143.467 160 126.934 160 100 160H160ZM100 160C100 143.661 100 127.321 100 100V160Z",
              stroke: iconFillColor(theme),
              strokeWidth: "2"
            }
          ),
          /* @__PURE__ */ jsxs3(
            "g",
            {
              fill: handlerColor(theme),
              stroke: iconFillColor(theme),
              strokeWidth: "6",
              children: [
                /* @__PURE__ */ jsx5("rect", { x: "2.5", y: "2.5", width: "30", height: "30" }),
                /* @__PURE__ */ jsx5("rect", { x: "2.5", y: "149.5", width: "30", height: "30" }),
                /* @__PURE__ */ jsx5("rect", { x: "147.5", y: "149.5", width: "30", height: "30" }),
                /* @__PURE__ */ jsx5("rect", { x: "147.5", y: "2.5", width: "30", height: "30" })
              ]
            }
          )
        ] }),
        { width: 182, height: 182, mirror: true }
      )
    );
    UngroupIcon = React4.memo(
      ({ theme }) => createIcon(
        /* @__PURE__ */ jsxs3(Fragment, { children: [
          /* @__PURE__ */ jsx5("path", { d: "M25 26H111V111H25", fill: iconFillColor(theme) }),
          /* @__PURE__ */ jsx5(
            "path",
            {
              d: "M25 111C25 80.2068 25 49.4135 25 26M25 26C48.6174 26 72.2348 26 111 26H25ZM25 26C53.3671 26 81.7343 26 111 26H25ZM111 26C111 52.303 111 78.606 111 111V26ZM111 26C111 51.2947 111 76.5893 111 111V26ZM111 111C87.0792 111 63.1585 111 25 111H111ZM111 111C87.4646 111 63.9293 111 25 111H111ZM25 111C25 81.1514 25 51.3028 25 26V111Z",
              stroke: iconFillColor(theme),
              strokeWidth: "2"
            }
          ),
          /* @__PURE__ */ jsx5("path", { d: "M100 100H160V160H100", fill: iconFillColor(theme) }),
          /* @__PURE__ */ jsx5(
            "path",
            {
              d: "M100 160C100 144.106 100 128.211 100 100M100 100C117.706 100 135.412 100 160 100H100ZM100 100C114.214 100 128.428 100 160 100H100ZM160 100C160 120.184 160 140.369 160 160V100ZM160 100C160 113.219 160 126.437 160 160V100ZM160 160C145.534 160 131.068 160 100 160H160ZM160 160C143.467 160 126.934 160 100 160H160ZM100 160C100 143.661 100 127.321 100 100V160Z",
              stroke: iconFillColor(theme),
              strokeWidth: "2"
            }
          ),
          /* @__PURE__ */ jsxs3(
            "g",
            {
              fill: handlerColor(theme),
              stroke: iconFillColor(theme),
              strokeWidth: "6",
              children: [
                /* @__PURE__ */ jsx5("rect", { x: "2.5", y: "2.5", width: "30", height: "30" }),
                /* @__PURE__ */ jsx5("rect", { x: "78.5", y: "149.5", width: "30", height: "30" }),
                /* @__PURE__ */ jsx5("rect", { x: "147.5", y: "149.5", width: "30", height: "30" }),
                /* @__PURE__ */ jsx5("rect", { x: "147.5", y: "78.5", width: "30", height: "30" }),
                /* @__PURE__ */ jsx5("rect", { x: "105.5", y: "2.5", width: "30", height: "30" }),
                /* @__PURE__ */ jsx5("rect", { x: "2.5", y: "102.5", width: "30", height: "30" })
              ]
            }
          )
        ] }),
        { width: 182, height: 182, mirror: true }
      )
    );
    FillZigZagIcon = createIcon(
      /* @__PURE__ */ jsx5("g", { strokeWidth: 1.25, children: /* @__PURE__ */ jsx5("path", { d: "M5.879 2.625h8.242a3.27 3.27 0 0 1 3.254 3.254v8.242a3.27 3.27 0 0 1-3.254 3.254H5.88a3.27 3.27 0 0 1-3.254-3.254V5.88A3.27 3.27 0 0 1 5.88 2.626l-.001-.001ZM4.518 16.118l7.608-12.83m.198 13.934 5.051-9.897M2.778 9.675l9.348-6.387m-7.608 12.83 12.857-8.793" }) }),
      modifiedTablerIconProps
    );
    FillHachureIcon = createIcon(
      /* @__PURE__ */ jsxs3(Fragment, { children: [
        /* @__PURE__ */ jsx5(
          "path",
          {
            d: "M5.879 2.625h8.242a3.254 3.254 0 0 1 3.254 3.254v8.242a3.254 3.254 0 0 1-3.254 3.254H5.88a3.254 3.254 0 0 1-3.254-3.254V5.88a3.254 3.254 0 0 1 3.254-3.254Z",
            stroke: "currentColor",
            strokeWidth: "1.25"
          }
        ),
        /* @__PURE__ */ jsx5(
          "mask",
          {
            id: "FillHachureIcon",
            style: { maskType: "alpha" },
            maskUnits: "userSpaceOnUse",
            x: 2,
            y: 2,
            width: 16,
            height: 16,
            children: /* @__PURE__ */ jsx5(
              "path",
              {
                d: "M5.879 2.625h8.242a3.254 3.254 0 0 1 3.254 3.254v8.242a3.254 3.254 0 0 1-3.254 3.254H5.88a3.254 3.254 0 0 1-3.254-3.254V5.88a3.254 3.254 0 0 1 3.254-3.254Z",
                fill: "currentColor",
                stroke: "currentColor",
                strokeWidth: "1.25"
              }
            )
          }
        ),
        /* @__PURE__ */ jsx5("g", { mask: "url(#FillHachureIcon)", children: /* @__PURE__ */ jsx5(
          "path",
          {
            d: "M2.258 15.156 15.156 2.258M7.324 20.222 20.222 7.325m-20.444 5.35L12.675-.222m-8.157 18.34L17.416 5.22",
            stroke: "currentColor",
            strokeWidth: "1.25",
            strokeLinecap: "round",
            strokeLinejoin: "round"
          }
        ) })
      ] }),
      modifiedTablerIconProps
    );
    FillCrossHatchIcon = createIcon(
      /* @__PURE__ */ jsxs3(Fragment, { children: [
        /* @__PURE__ */ jsxs3("g", { clipPath: "url(#a)", children: [
          /* @__PURE__ */ jsx5(
            "path",
            {
              d: "M5.879 2.625h8.242a3.254 3.254 0 0 1 3.254 3.254v8.242a3.254 3.254 0 0 1-3.254 3.254H5.88a3.254 3.254 0 0 1-3.254-3.254V5.88a3.254 3.254 0 0 1 3.254-3.254Z",
              stroke: "currentColor",
              strokeWidth: "1.25"
            }
          ),
          /* @__PURE__ */ jsx5(
            "mask",
            {
              id: "FillCrossHatchIcon",
              style: { maskType: "alpha" },
              maskUnits: "userSpaceOnUse",
              x: -1,
              y: -1,
              width: 22,
              height: 22,
              children: /* @__PURE__ */ jsx5(
                "path",
                {
                  d: "M2.426 15.044 15.044 2.426M7.383 20 20 7.383M0 12.617 12.617 0m-7.98 17.941L17.256 5.324m-2.211 12.25L2.426 4.956M20 12.617 7.383 0m5.234 20L0 7.383m17.941 7.98L5.324 2.745",
                  stroke: "currentColor",
                  strokeWidth: "1.25",
                  strokeLinecap: "round",
                  strokeLinejoin: "round"
                }
              )
            }
          ),
          /* @__PURE__ */ jsx5("g", { mask: "url(#FillCrossHatchIcon)", children: /* @__PURE__ */ jsx5(
            "path",
            {
              d: "M14.121 2H5.88A3.879 3.879 0 0 0 2 5.879v8.242A3.879 3.879 0 0 0 5.879 18h8.242A3.879 3.879 0 0 0 18 14.121V5.88A3.879 3.879 0 0 0 14.121 2Z",
              fill: "currentColor"
            }
          ) })
        ] }),
        /* @__PURE__ */ jsx5("defs", { children: /* @__PURE__ */ jsx5("clipPath", { id: "a", children: /* @__PURE__ */ jsx5("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
      ] }),
      modifiedTablerIconProps
    );
    FillSolidIcon = createIcon(
      /* @__PURE__ */ jsxs3(Fragment, { children: [
        /* @__PURE__ */ jsx5("g", { clipPath: "url(#a)", children: /* @__PURE__ */ jsx5(
          "path",
          {
            d: "M4.91 2.625h10.18a2.284 2.284 0 0 1 2.285 2.284v10.182a2.284 2.284 0 0 1-2.284 2.284H4.909a2.284 2.284 0 0 1-2.284-2.284V4.909a2.284 2.284 0 0 1 2.284-2.284Z",
            stroke: "currentColor",
            strokeWidth: "1.25"
          }
        ) }),
        /* @__PURE__ */ jsx5("defs", { children: /* @__PURE__ */ jsx5("clipPath", { id: "a", children: /* @__PURE__ */ jsx5("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
      ] }),
      { ...modifiedTablerIconProps, fill: "currentColor" }
    );
    StrokeWidthBaseIcon = createIcon(
      /* @__PURE__ */ jsx5(Fragment, { children: /* @__PURE__ */ jsx5(
        "path",
        {
          d: "M4.167 10h11.666",
          stroke: "currentColor",
          strokeWidth: "1.25",
          strokeLinecap: "round",
          strokeLinejoin: "round"
        }
      ) }),
      modifiedTablerIconProps
    );
    StrokeWidthBoldIcon = createIcon(
      /* @__PURE__ */ jsx5(
        "path",
        {
          d: "M5 10h10",
          stroke: "currentColor",
          strokeWidth: "2.5",
          strokeLinecap: "round",
          strokeLinejoin: "round"
        }
      ),
      modifiedTablerIconProps
    );
    StrokeWidthExtraBoldIcon = createIcon(
      /* @__PURE__ */ jsx5(
        "path",
        {
          d: "M5 10h10",
          stroke: "currentColor",
          strokeWidth: "3.75",
          strokeLinecap: "round",
          strokeLinejoin: "round"
        }
      ),
      modifiedTablerIconProps
    );
    StrokeStyleSolidIcon = React4.memo(
      ({ theme }) => createIcon(
        /* @__PURE__ */ jsx5(
          "path",
          {
            d: "M6 10H34",
            stroke: iconFillColor(theme),
            strokeWidth: 2,
            fill: "none",
            strokeLinecap: "round"
          }
        ),
        {
          width: 40,
          height: 20
        }
      )
    );
    StrokeStyleDashedIcon = createIcon(
      /* @__PURE__ */ jsxs3("g", { strokeWidth: "2", children: [
        /* @__PURE__ */ jsx5("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx5("path", { d: "M5 12h2" }),
        /* @__PURE__ */ jsx5("path", { d: "M17 12h2" }),
        /* @__PURE__ */ jsx5("path", { d: "M11 12h2" })
      ] }),
      tablerIconProps
    );
    StrokeStyleDottedIcon = createIcon(
      /* @__PURE__ */ jsxs3("g", { strokeWidth: "2", children: [
        /* @__PURE__ */ jsx5("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx5("path", { d: "M4 12v.01" }),
        /* @__PURE__ */ jsx5("path", { d: "M8 12v.01" }),
        /* @__PURE__ */ jsx5("path", { d: "M12 12v.01" }),
        /* @__PURE__ */ jsx5("path", { d: "M16 12v.01" }),
        /* @__PURE__ */ jsx5("path", { d: "M20 12v.01" })
      ] }),
      tablerIconProps
    );
    SloppinessArchitectIcon = createIcon(
      /* @__PURE__ */ jsx5(
        "path",
        {
          d: "M2.5 12.038c1.655-.885 5.9-3.292 8.568-4.354 2.668-1.063.101 2.821 1.32 3.104 1.218.283 5.112-1.814 5.112-1.814",
          strokeWidth: "1.25"
        }
      ),
      modifiedTablerIconProps
    );
    SloppinessArtistIcon = createIcon(
      /* @__PURE__ */ jsx5(
        "path",
        {
          d: "M2.5 12.563c1.655-.886 5.9-3.293 8.568-4.355 2.668-1.062.101 2.822 1.32 3.105 1.218.283 5.112-1.814 5.112-1.814m-13.469 2.23c2.963-1.586 6.13-5.62 7.468-4.998 1.338.623-1.153 4.11-.132 5.595 1.02 1.487 6.133-1.43 6.133-1.43",
          strokeWidth: "1.25"
        }
      ),
      modifiedTablerIconProps
    );
    SloppinessCartoonistIcon = createIcon(
      /* @__PURE__ */ jsx5(
        "path",
        {
          d: "M2.5 11.936c1.737-.879 8.627-5.346 10.42-5.268 1.795.078-.418 5.138.345 5.736.763.598 3.53-1.789 4.235-2.147M2.929 9.788c1.164-.519 5.47-3.28 6.987-3.114 1.519.165 1 3.827 2.121 4.109 1.122.281 3.839-2.016 4.606-2.42",
          strokeWidth: "1.25"
        }
      ),
      modifiedTablerIconProps
    );
    EdgeSharpIcon = createIcon(
      /* @__PURE__ */ jsxs3("svg", { strokeWidth: "1.5", children: [
        /* @__PURE__ */ jsx5("path", { d: "M3.33334 9.99998V6.66665C3.33334 6.04326 3.33403 4.9332 3.33539 3.33646C4.95233 3.33436 6.06276 3.33331 6.66668 3.33331H10" }),
        /* @__PURE__ */ jsx5("path", { d: "M13.3333 3.33331V3.34331" }),
        /* @__PURE__ */ jsx5("path", { d: "M16.6667 3.33331V3.34331" }),
        /* @__PURE__ */ jsx5("path", { d: "M16.6667 6.66669V6.67669" }),
        /* @__PURE__ */ jsx5("path", { d: "M16.6667 10V10.01" }),
        /* @__PURE__ */ jsx5("path", { d: "M3.33334 13.3333V13.3433" }),
        /* @__PURE__ */ jsx5("path", { d: "M16.6667 13.3333V13.3433" }),
        /* @__PURE__ */ jsx5("path", { d: "M3.33334 16.6667V16.6767" }),
        /* @__PURE__ */ jsx5("path", { d: "M6.66666 16.6667V16.6767" }),
        /* @__PURE__ */ jsx5("path", { d: "M10 16.6667V16.6767" }),
        /* @__PURE__ */ jsx5("path", { d: "M13.3333 16.6667V16.6767" }),
        /* @__PURE__ */ jsx5("path", { d: "M16.6667 16.6667V16.6767" })
      ] }),
      modifiedTablerIconProps
    );
    EdgeRoundIcon = createIcon(
      /* @__PURE__ */ jsxs3(
        "g",
        {
          strokeWidth: "1.5",
          stroke: "currentColor",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          children: [
            /* @__PURE__ */ jsx5("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
            /* @__PURE__ */ jsx5("path", { d: "M4 12v-4a4 4 0 0 1 4 -4h4" }),
            /* @__PURE__ */ jsx5("line", { x1: "16", y1: "4", x2: "16", y2: "4.01" }),
            /* @__PURE__ */ jsx5("line", { x1: "20", y1: "4", x2: "20", y2: "4.01" }),
            /* @__PURE__ */ jsx5("line", { x1: "20", y1: "8", x2: "20", y2: "8.01" }),
            /* @__PURE__ */ jsx5("line", { x1: "20", y1: "12", x2: "20", y2: "12.01" }),
            /* @__PURE__ */ jsx5("line", { x1: "4", y1: "16", x2: "4", y2: "16.01" }),
            /* @__PURE__ */ jsx5("line", { x1: "20", y1: "16", x2: "20", y2: "16.01" }),
            /* @__PURE__ */ jsx5("line", { x1: "4", y1: "20", x2: "4", y2: "20.01" }),
            /* @__PURE__ */ jsx5("line", { x1: "8", y1: "20", x2: "8", y2: "20.01" }),
            /* @__PURE__ */ jsx5("line", { x1: "12", y1: "20", x2: "12", y2: "20.01" }),
            /* @__PURE__ */ jsx5("line", { x1: "16", y1: "20", x2: "16", y2: "20.01" }),
            /* @__PURE__ */ jsx5("line", { x1: "20", y1: "20", x2: "20", y2: "20.01" })
          ]
        }
      ),
      tablerIconProps
    );
    ArrowheadNoneIcon = createIcon(
      /* @__PURE__ */ jsx5("path", { d: "M6 10H34", stroke: "currentColor", strokeWidth: 2, fill: "none" }),
      {
        width: 40,
        height: 20
      }
    );
    ArrowheadArrowIcon = React4.memo(
      ({ flip = false }) => createIcon(
        /* @__PURE__ */ jsxs3(
          "g",
          {
            transform: flip ? "translate(40, 0) scale(-1, 1)" : "",
            stroke: "currentColor",
            strokeWidth: 2,
            fill: "none",
            children: [
              /* @__PURE__ */ jsx5("path", { d: "M34 10H6M34 10L27 5M34 10L27 15" }),
              /* @__PURE__ */ jsx5("path", { d: "M27.5 5L34.5 10L27.5 15" })
            ]
          }
        ),
        { width: 40, height: 20 }
      )
    );
    ArrowheadCircleIcon = React4.memo(
      ({ flip = false }) => createIcon(
        /* @__PURE__ */ jsxs3(
          "g",
          {
            stroke: "currentColor",
            fill: "currentColor",
            transform: flip ? "translate(40, 0) scale(-1, 1)" : "",
            children: [
              /* @__PURE__ */ jsx5("path", { d: "M32 10L6 10", strokeWidth: 2 }),
              /* @__PURE__ */ jsx5("circle", { r: "4", transform: "matrix(-1 0 0 1 30 10)" })
            ]
          }
        ),
        { width: 40, height: 20 }
      )
    );
    ArrowheadCircleOutlineIcon = React4.memo(
      ({ flip = false }) => createIcon(
        /* @__PURE__ */ jsxs3(
          "g",
          {
            stroke: "currentColor",
            fill: "none",
            transform: flip ? "translate(40, 0) scale(-1, 1)" : "",
            strokeWidth: 2,
            children: [
              /* @__PURE__ */ jsx5("path", { d: "M26 10L6 10" }),
              /* @__PURE__ */ jsx5("circle", { r: "4", transform: "matrix(-1 0 0 1 30 10)" })
            ]
          }
        ),
        { width: 40, height: 20 }
      )
    );
    ArrowheadBarIcon = React4.memo(
      ({ flip = false }) => createIcon(
        /* @__PURE__ */ jsx5("g", { transform: flip ? "translate(40, 0) scale(-1, 1)" : "", children: /* @__PURE__ */ jsx5(
          "path",
          {
            d: "M34 10H5.99996M34 10L34 5M34 10L34 15",
            stroke: "currentColor",
            strokeWidth: 2,
            fill: "none"
          }
        ) }),
        { width: 40, height: 20 }
      )
    );
    ArrowheadTriangleIcon = React4.memo(
      ({ flip = false }) => createIcon(
        /* @__PURE__ */ jsxs3(
          "g",
          {
            stroke: "currentColor",
            fill: "currentColor",
            transform: flip ? "translate(40, 0) scale(-1, 1)" : "",
            children: [
              /* @__PURE__ */ jsx5("path", { d: "M32 10L6 10", strokeWidth: 2 }),
              /* @__PURE__ */ jsx5("path", { d: "M27.5 5.5L34.5 10L27.5 14.5L27.5 5.5" })
            ]
          }
        ),
        { width: 40, height: 20 }
      )
    );
    ArrowheadTriangleOutlineIcon = React4.memo(
      ({ flip = false }) => createIcon(
        /* @__PURE__ */ jsxs3(
          "g",
          {
            stroke: "currentColor",
            fill: "none",
            transform: flip ? "translate(40, 0) scale(-1, 1)" : "",
            strokeWidth: 2,
            strokeLinejoin: "round",
            children: [
              /* @__PURE__ */ jsx5("path", { d: "M6,9.5H27" }),
              /* @__PURE__ */ jsx5("path", { d: "M27,5L34,10L27,14Z", fill: "none" })
            ]
          }
        ),
        { width: 40, height: 20 }
      )
    );
    ArrowheadDiamondIcon = React4.memo(
      ({ flip = false }) => createIcon(
        /* @__PURE__ */ jsxs3(
          "g",
          {
            stroke: "currentColor",
            fill: "currentColor",
            transform: flip ? "translate(40, 0) scale(-1, 1)" : "",
            strokeLinejoin: "round",
            strokeWidth: 2,
            children: [
              /* @__PURE__ */ jsx5("path", { d: "M6,9.5H20" }),
              /* @__PURE__ */ jsx5("path", { d: "M27,5L34,10L27,14L20,9.5Z" })
            ]
          }
        ),
        { width: 40, height: 20 }
      )
    );
    ArrowheadDiamondOutlineIcon = React4.memo(
      ({ flip = false }) => createIcon(
        /* @__PURE__ */ jsxs3(
          "g",
          {
            stroke: "currentColor",
            fill: "none",
            transform: flip ? "translate(40, 0) scale(-1, 1)" : "",
            strokeLinejoin: "round",
            strokeWidth: 2,
            children: [
              /* @__PURE__ */ jsx5("path", { d: "M6,9.5H20" }),
              /* @__PURE__ */ jsx5("path", { d: "M27,5L34,10L27,14L20,9.5Z" })
            ]
          }
        ),
        { width: 40, height: 20 }
      )
    );
    FontSizeSmallIcon = createIcon(
      /* @__PURE__ */ jsxs3(Fragment, { children: [
        /* @__PURE__ */ jsx5("g", { clipPath: "url(#a)", children: /* @__PURE__ */ jsx5(
          "path",
          {
            d: "M14.167 6.667a3.333 3.333 0 0 0-3.334-3.334H9.167a3.333 3.333 0 0 0 0 6.667h1.666a3.333 3.333 0 0 1 0 6.667H9.167a3.333 3.333 0 0 1-3.334-3.334",
            stroke: "currentColor",
            strokeWidth: "1.25",
            strokeLinecap: "round",
            strokeLinejoin: "round"
          }
        ) }),
        /* @__PURE__ */ jsx5("defs", { children: /* @__PURE__ */ jsx5("clipPath", { id: "a", children: /* @__PURE__ */ jsx5("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
      ] }),
      modifiedTablerIconProps
    );
    FontSizeMediumIcon = createIcon(
      /* @__PURE__ */ jsxs3(Fragment, { children: [
        /* @__PURE__ */ jsx5("g", { clipPath: "url(#a)", children: /* @__PURE__ */ jsx5(
          "path",
          {
            d: "M5 16.667V3.333L10 15l5-11.667v13.334",
            stroke: "currentColor",
            strokeWidth: "1.25",
            strokeLinecap: "round",
            strokeLinejoin: "round"
          }
        ) }),
        /* @__PURE__ */ jsx5("defs", { children: /* @__PURE__ */ jsx5("clipPath", { id: "a", children: /* @__PURE__ */ jsx5("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
      ] }),
      modifiedTablerIconProps
    );
    FontSizeLargeIcon = createIcon(
      /* @__PURE__ */ jsxs3(Fragment, { children: [
        /* @__PURE__ */ jsx5("g", { clipPath: "url(#a)", children: /* @__PURE__ */ jsx5(
          "path",
          {
            d: "M5.833 3.333v13.334h8.334",
            stroke: "currentColor",
            strokeWidth: "1.25",
            strokeLinecap: "round",
            strokeLinejoin: "round"
          }
        ) }),
        /* @__PURE__ */ jsx5("defs", { children: /* @__PURE__ */ jsx5("clipPath", { id: "a", children: /* @__PURE__ */ jsx5("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
      ] }),
      modifiedTablerIconProps
    );
    FontSizeExtraLargeIcon = createIcon(
      /* @__PURE__ */ jsx5(Fragment, { children: /* @__PURE__ */ jsx5(
        "path",
        {
          d: "m1.667 3.333 6.666 13.334M8.333 3.333 1.667 16.667M11.667 3.333v13.334h6.666",
          stroke: "currentColor",
          strokeWidth: "1.25",
          strokeLinecap: "round",
          strokeLinejoin: "round"
        }
      ) }),
      modifiedTablerIconProps
    );
    FontFamilyNormalIcon = createIcon(
      /* @__PURE__ */ jsx5(Fragment, { children: /* @__PURE__ */ jsx5(
        "g",
        {
          stroke: "currentColor",
          strokeWidth: "1.25",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          children: /* @__PURE__ */ jsx5("path", { d: "M5.833 16.667v-10a3.333 3.333 0 0 1 3.334-3.334h1.666a3.333 3.333 0 0 1 3.334 3.334v10M5.833 10.833h8.334" })
        }
      ) }),
      modifiedTablerIconProps
    );
    FontFamilyCodeIcon = createIcon(
      /* @__PURE__ */ jsxs3(Fragment, { children: [
        /* @__PURE__ */ jsx5(
          "g",
          {
            clipPath: "url(#a)",
            stroke: "currentColor",
            strokeWidth: "1.25",
            strokeLinecap: "round",
            strokeLinejoin: "round",
            children: /* @__PURE__ */ jsx5("path", { d: "M5.833 6.667 2.5 10l3.333 3.333M14.167 6.667 17.5 10l-3.333 3.333M11.667 3.333 8.333 16.667" })
          }
        ),
        /* @__PURE__ */ jsx5("defs", { children: /* @__PURE__ */ jsx5("clipPath", { id: "a", children: /* @__PURE__ */ jsx5("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
      ] }),
      modifiedTablerIconProps
    );
    TextAlignLeftIcon = createIcon(
      /* @__PURE__ */ jsxs3(
        "g",
        {
          stroke: "currentColor",
          fill: "none",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          strokeWidth: 2,
          children: [
            /* @__PURE__ */ jsx5("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
            /* @__PURE__ */ jsx5("line", { x1: "4", y1: "8", x2: "20", y2: "8" }),
            /* @__PURE__ */ jsx5("line", { x1: "4", y1: "12", x2: "12", y2: "12" }),
            /* @__PURE__ */ jsx5("line", { x1: "4", y1: "16", x2: "16", y2: "16" })
          ]
        }
      ),
      tablerIconProps
    );
    TextAlignCenterIcon = createIcon(
      /* @__PURE__ */ jsxs3(
        "g",
        {
          stroke: "currentColor",
          fill: "none",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          children: [
            /* @__PURE__ */ jsx5("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
            /* @__PURE__ */ jsx5("line", { x1: "4", y1: "8", x2: "20", y2: "8" }),
            /* @__PURE__ */ jsx5("line", { x1: "8", y1: "12", x2: "16", y2: "12" }),
            /* @__PURE__ */ jsx5("line", { x1: "6", y1: "16", x2: "18", y2: "16" })
          ]
        }
      ),
      tablerIconProps
    );
    TextAlignRightIcon = createIcon(
      /* @__PURE__ */ jsxs3(
        "g",
        {
          stroke: "currentColor",
          fill: "none",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          children: [
            /* @__PURE__ */ jsx5("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
            /* @__PURE__ */ jsx5("line", { x1: "4", y1: "8", x2: "20", y2: "8" }),
            /* @__PURE__ */ jsx5("line", { x1: "10", y1: "12", x2: "20", y2: "12" }),
            /* @__PURE__ */ jsx5("line", { x1: "8", y1: "16", x2: "20", y2: "16" })
          ]
        }
      ),
      tablerIconProps
    );
    TextAlignTopIcon = React4.memo(
      ({ theme }) => createIcon(
        /* @__PURE__ */ jsxs3(
          "g",
          {
            strokeWidth: "1.5",
            stroke: "currentColor",
            fill: "none",
            strokeLinecap: "round",
            strokeLinejoin: "round",
            children: [
              /* @__PURE__ */ jsx5("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
              /* @__PURE__ */ jsx5("line", { x1: "4", y1: "4", x2: "20", y2: "4" }),
              /* @__PURE__ */ jsx5("rect", { x: "9", y: "8", width: "6", height: "12", rx: "2" })
            ]
          }
        ),
        tablerIconProps
      )
    );
    TextAlignBottomIcon = React4.memo(
      ({ theme }) => createIcon(
        /* @__PURE__ */ jsxs3(
          "g",
          {
            strokeWidth: "2",
            stroke: "currentColor",
            fill: "none",
            strokeLinecap: "round",
            strokeLinejoin: "round",
            children: [
              /* @__PURE__ */ jsx5("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
              /* @__PURE__ */ jsx5("line", { x1: "4", y1: "20", x2: "20", y2: "20" }),
              /* @__PURE__ */ jsx5("rect", { x: "9", y: "4", width: "6", height: "12", rx: "2" })
            ]
          }
        ),
        tablerIconProps
      )
    );
    TextAlignMiddleIcon = React4.memo(
      ({ theme }) => createIcon(
        /* @__PURE__ */ jsxs3(
          "g",
          {
            strokeWidth: "1.5",
            stroke: "currentColor",
            fill: "none",
            strokeLinecap: "round",
            strokeLinejoin: "round",
            children: [
              /* @__PURE__ */ jsx5("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
              /* @__PURE__ */ jsx5("line", { x1: "4", y1: "12", x2: "9", y2: "12" }),
              /* @__PURE__ */ jsx5("line", { x1: "15", y1: "12", x2: "20", y2: "12" }),
              /* @__PURE__ */ jsx5("rect", { x: "9", y: "6", width: "6", height: "12", rx: "2" })
            ]
          }
        ),
        tablerIconProps
      )
    );
    publishIcon = createIcon(
      /* @__PURE__ */ jsx5(
        "path",
        {
          d: "M537.6 226.6c4.1-10.7 6.4-22.4 6.4-34.6 0-53-43-96-96-96-19.7 0-38.1 6-53.3 16.2C367 64.2 315.3 32 256 32c-88.4 0-160 71.6-160 160 0 2.7.1 5.4.2 8.1C40.2 219.8 0 273.2 0 336c0 79.5 64.5 144 144 144h368c70.7 0 128-57.3 128-128 0-61.9-44-113.6-102.4-125.4zM393.4 288H328v112c0 8.8-7.2 16-16 16h-48c-8.8 0-16-7.2-16-16V288h-65.4c-14.3 0-21.4-17.2-11.3-27.3l105.4-105.4c6.2-6.2 16.4-6.2 22.6 0l105.4 105.4c10.1 10.1 2.9 27.3-11.3 27.3z",
          fill: "currentColor"
        }
      ),
      { width: 640, height: 512 }
    );
    eraser = createIcon(
      /* @__PURE__ */ jsx5("path", { d: "M480 416C497.7 416 512 430.3 512 448C512 465.7 497.7 480 480 480H150.6C133.7 480 117.4 473.3 105.4 461.3L25.37 381.3C.3786 356.3 .3786 315.7 25.37 290.7L258.7 57.37C283.7 32.38 324.3 32.38 349.3 57.37L486.6 194.7C511.6 219.7 511.6 260.3 486.6 285.3L355.9 416H480zM265.4 416L332.7 348.7L195.3 211.3L70.63 336L150.6 416L265.4 416z" })
    );
    handIcon = createIcon(
      /* @__PURE__ */ jsxs3("g", { strokeWidth: 1.25, children: [
        /* @__PURE__ */ jsx5("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx5("path", { d: "M8 13v-7.5a1.5 1.5 0 0 1 3 0v6.5" }),
        /* @__PURE__ */ jsx5("path", { d: "M11 5.5v-2a1.5 1.5 0 1 1 3 0v8.5" }),
        /* @__PURE__ */ jsx5("path", { d: "M14 5.5a1.5 1.5 0 0 1 3 0v6.5" }),
        /* @__PURE__ */ jsx5("path", { d: "M17 7.5a1.5 1.5 0 0 1 3 0v8.5a6 6 0 0 1 -6 6h-2h.208a6 6 0 0 1 -5.012 -2.7a69.74 69.74 0 0 1 -.196 -.3c-.312 -.479 -1.407 -2.388 -3.286 -5.728a1.5 1.5 0 0 1 .536 -2.022a1.867 1.867 0 0 1 2.28 .28l1.47 1.47" })
      ] }),
      tablerIconProps
    );
    downloadIcon = createIcon(
      /* @__PURE__ */ jsxs3(Fragment, { children: [
        /* @__PURE__ */ jsx5("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx5("path", { d: "M4 17v2a2 2 0 0 0 2 2h12a2 2 0 0 0 2 -2v-2" }),
        /* @__PURE__ */ jsx5("path", { d: "M7 11l5 5l5 -5" }),
        /* @__PURE__ */ jsx5("path", { d: "M12 4l0 12" })
      ] }),
      tablerIconProps
    );
    copyIcon = createIcon(
      /* @__PURE__ */ jsxs3(Fragment, { children: [
        /* @__PURE__ */ jsx5("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx5("path", { d: "M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z" }),
        /* @__PURE__ */ jsx5("path", { d: "M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2" })
      ] }),
      tablerIconProps
    );
    helpIcon = createIcon(
      /* @__PURE__ */ jsxs3(Fragment, { children: [
        /* @__PURE__ */ jsx5("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx5("path", { d: "M12 12m-9 0a9 9 0 1 0 18 0a9 9 0 1 0 -18 0" }),
        /* @__PURE__ */ jsx5("path", { d: "M12 17l0 .01" }),
        /* @__PURE__ */ jsx5("path", { d: "M12 13.5a1.5 1.5 0 0 1 1 -1.5a2.6 2.6 0 1 0 -3 -4" })
      ] }),
      tablerIconProps
    );
    playerPlayIcon = createIcon(
      /* @__PURE__ */ jsxs3(Fragment, { children: [
        /* @__PURE__ */ jsx5("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx5("path", { d: "M7 4v16l13 -8z" })
      ] }),
      tablerIconProps
    );
    playerStopFilledIcon = createIcon(
      /* @__PURE__ */ jsxs3(Fragment, { children: [
        /* @__PURE__ */ jsx5("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx5(
          "path",
          {
            d: "M17 4h-10a3 3 0 0 0 -3 3v10a3 3 0 0 0 3 3h10a3 3 0 0 0 3 -3v-10a3 3 0 0 0 -3 -3z",
            strokeWidth: "0",
            fill: "currentColor"
          }
        )
      ] }),
      tablerIconProps
    );
    tablerCheckIcon = createIcon(
      /* @__PURE__ */ jsxs3(Fragment, { children: [
        /* @__PURE__ */ jsx5("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx5("path", { d: "M5 12l5 5l10 -10" })
      ] }),
      tablerIconProps
    );
    alertTriangleIcon = createIcon(
      /* @__PURE__ */ jsxs3(Fragment, { children: [
        /* @__PURE__ */ jsx5("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx5("path", { d: "M10.24 3.957l-8.422 14.06a1.989 1.989 0 0 0 1.7 2.983h16.845a1.989 1.989 0 0 0 1.7 -2.983l-8.423 -14.06a1.989 1.989 0 0 0 -3.4 0z" }),
        /* @__PURE__ */ jsx5("path", { d: "M12 9v4" }),
        /* @__PURE__ */ jsx5("path", { d: "M12 17h.01" })
      ] }),
      tablerIconProps
    );
    eyeDropperIcon = createIcon(
      /* @__PURE__ */ jsxs3("g", { strokeWidth: 1.25, children: [
        /* @__PURE__ */ jsx5("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx5("path", { d: "M11 7l6 6" }),
        /* @__PURE__ */ jsx5("path", { d: "M4 16l11.7 -11.7a1 1 0 0 1 1.4 0l2.6 2.6a1 1 0 0 1 0 1.4l-11.7 11.7h-4v-4z" })
      ] }),
      tablerIconProps
    );
    extraToolsIcon = createIcon(
      /* @__PURE__ */ jsxs3("g", { strokeWidth: 1.5, children: [
        /* @__PURE__ */ jsx5("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx5("path", { d: "M12 3l-4 7h8z" }),
        /* @__PURE__ */ jsx5("path", { d: "M17 17m-3 0a3 3 0 1 0 6 0a3 3 0 1 0 -6 0" }),
        /* @__PURE__ */ jsx5("path", { d: "M4 14m0 1a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v4a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1z" })
      ] }),
      tablerIconProps
    );
    frameToolIcon = createIcon(
      /* @__PURE__ */ jsxs3("g", { strokeWidth: 1.5, children: [
        /* @__PURE__ */ jsx5("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx5("path", { d: "M4 7l16 0" }),
        /* @__PURE__ */ jsx5("path", { d: "M4 17l16 0" }),
        /* @__PURE__ */ jsx5("path", { d: "M7 4l0 16" }),
        /* @__PURE__ */ jsx5("path", { d: "M17 4l0 16" })
      ] }),
      tablerIconProps
    );
    mermaidLogoIcon = createIcon(
      /* @__PURE__ */ jsx5(
        "path",
        {
          fill: "currentColor",
          d: "M407.48,111.18C335.587,108.103 269.573,152.338 245.08,220C220.587,152.338 154.573,108.103 82.68,111.18C80.285,168.229 107.577,222.632 154.74,254.82C178.908,271.419 193.35,298.951 193.27,328.27L193.27,379.13L296.9,379.13L296.9,328.27C296.816,298.953 311.255,271.42 335.42,254.82C382.596,222.644 409.892,168.233 407.48,111.18Z"
        }
      )
    );
    ArrowRightIcon = createIcon(
      /* @__PURE__ */ jsxs3("g", { strokeWidth: "1.25", children: [
        /* @__PURE__ */ jsx5("path", { d: "M4.16602 10H15.8327" }),
        /* @__PURE__ */ jsx5("path", { d: "M12.5 13.3333L15.8333 10" }),
        /* @__PURE__ */ jsx5("path", { d: "M12.5 6.66666L15.8333 9.99999" })
      ] }),
      modifiedTablerIconProps
    );
    laserPointerToolIcon = createIcon(
      /* @__PURE__ */ jsxs3(
        "g",
        {
          fill: "none",
          stroke: "currentColor",
          strokeWidth: "1.25",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          transform: "rotate(90 10 10)",
          children: [
            /* @__PURE__ */ jsx5(
              "path",
              {
                clipRule: "evenodd",
                d: "m9.644 13.69 7.774-7.773a2.357 2.357 0 0 0-3.334-3.334l-7.773 7.774L8 12l1.643 1.69Z"
              }
            ),
            /* @__PURE__ */ jsx5("path", { d: "m13.25 3.417 3.333 3.333M10 10l2-2M5 15l3-3M2.156 17.894l1-1M5.453 19.029l-.144-1.407M2.377 11.887l.866 1.118M8.354 17.273l-1.194-.758M.953 14.652l1.408.13" })
          ]
        }
      ),
      20
    );
    MagicIcon = createIcon(
      /* @__PURE__ */ jsxs3("g", { stroke: "currentColor", fill: "none", children: [
        /* @__PURE__ */ jsx5("path", { stroke: "none", d: "M0 0h24v24H0z" }),
        /* @__PURE__ */ jsx5("path", { d: "M6 21l15 -15l-3 -3l-15 15l3 3" }),
        /* @__PURE__ */ jsx5("path", { d: "M15 6l3 3" }),
        /* @__PURE__ */ jsx5("path", { d: "M9 3a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2" }),
        /* @__PURE__ */ jsx5("path", { d: "M19 13a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2" })
      ] }),
      tablerIconProps
    );
    OpenAIIcon = createIcon(
      /* @__PURE__ */ jsxs3("g", { stroke: "currentColor", fill: "none", children: [
        /* @__PURE__ */ jsx5("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx5("path", { d: "M11.217 19.384a3.501 3.501 0 0 0 6.783 -1.217v-5.167l-6 -3.35" }),
        /* @__PURE__ */ jsx5("path", { d: "M5.214 15.014a3.501 3.501 0 0 0 4.446 5.266l4.34 -2.534v-6.946" }),
        /* @__PURE__ */ jsx5("path", { d: "M6 7.63c-1.391 -.236 -2.787 .395 -3.534 1.689a3.474 3.474 0 0 0 1.271 4.745l4.263 2.514l6 -3.348" }),
        /* @__PURE__ */ jsx5("path", { d: "M12.783 4.616a3.501 3.501 0 0 0 -6.783 1.217v5.067l6 3.45" }),
        /* @__PURE__ */ jsx5("path", { d: "M18.786 8.986a3.501 3.501 0 0 0 -4.446 -5.266l-4.34 2.534v6.946" }),
        /* @__PURE__ */ jsx5("path", { d: "M18 16.302c1.391 .236 2.787 -.395 3.534 -1.689a3.474 3.474 0 0 0 -1.271 -4.745l-4.308 -2.514l-5.955 3.42" })
      ] }),
      tablerIconProps
    );
    fullscreenIcon = createIcon(
      /* @__PURE__ */ jsxs3("g", { stroke: "currentColor", fill: "none", children: [
        /* @__PURE__ */ jsx5("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx5("path", { d: "M4 8v-2a2 2 0 0 1 2 -2h2" }),
        /* @__PURE__ */ jsx5("path", { d: "M4 16v2a2 2 0 0 0 2 2h2" }),
        /* @__PURE__ */ jsx5("path", { d: "M16 4h2a2 2 0 0 1 2 2v2" }),
        /* @__PURE__ */ jsx5("path", { d: "M16 20h2a2 2 0 0 0 2 -2v-2" })
      ] }),
      tablerIconProps
    );
    eyeIcon = createIcon(
      /* @__PURE__ */ jsxs3("g", { stroke: "currentColor", fill: "none", children: [
        /* @__PURE__ */ jsx5("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx5("path", { d: "M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" }),
        /* @__PURE__ */ jsx5("path", { d: "M21 12c-2.4 4 -5.4 6 -9 6c-3.6 0 -6.6 -2 -9 -6c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6" })
      ] }),
      tablerIconProps
    );
    eyeClosedIcon = createIcon(
      /* @__PURE__ */ jsxs3("g", { stroke: "currentColor", fill: "none", children: [
        /* @__PURE__ */ jsx5("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx5("path", { d: "M10.585 10.587a2 2 0 0 0 2.829 2.828" }),
        /* @__PURE__ */ jsx5("path", { d: "M16.681 16.673a8.717 8.717 0 0 1 -4.681 1.327c-3.6 0 -6.6 -2 -9 -6c1.272 -2.12 2.712 -3.678 4.32 -4.674m2.86 -1.146a9.055 9.055 0 0 1 1.82 -.18c3.6 0 6.6 2 9 6c-.666 1.11 -1.379 2.067 -2.138 2.87" }),
        /* @__PURE__ */ jsx5("path", { d: "M3 3l18 18" })
      ] }),
      tablerIconProps
    );
    brainIcon = createIcon(
      /* @__PURE__ */ jsxs3("g", { stroke: "currentColor", fill: "none", children: [
        /* @__PURE__ */ jsx5("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx5("path", { d: "M15.5 13a3.5 3.5 0 0 0 -3.5 3.5v1a3.5 3.5 0 0 0 7 0v-1.8" }),
        /* @__PURE__ */ jsx5("path", { d: "M8.5 13a3.5 3.5 0 0 1 3.5 3.5v1a3.5 3.5 0 0 1 -7 0v-1.8" }),
        /* @__PURE__ */ jsx5("path", { d: "M17.5 16a3.5 3.5 0 0 0 0 -7h-.5" }),
        /* @__PURE__ */ jsx5("path", { d: "M19 9.3v-2.8a3.5 3.5 0 0 0 -7 0" }),
        /* @__PURE__ */ jsx5("path", { d: "M6.5 16a3.5 3.5 0 0 1 0 -7h.5" }),
        /* @__PURE__ */ jsx5("path", { d: "M5 9.3v-2.8a3.5 3.5 0 0 1 7 0v10" })
      ] }),
      tablerIconProps
    );
    searchIcon = createIcon(
      /* @__PURE__ */ jsxs3("g", { strokeWidth: 1.5, children: [
        /* @__PURE__ */ jsx5("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx5("path", { d: "M10 10m-7 0a7 7 0 1 0 14 0a7 7 0 1 0 -14 0" }),
        /* @__PURE__ */ jsx5("path", { d: "M21 21l-6 -6" })
      ] }),
      tablerIconProps
    );
  }
});

// components/Tooltip.scss
var init_Tooltip = __esm({
  "components/Tooltip.scss"() {
  }
});

// components/Tooltip.tsx
import { useEffect as useEffect4 } from "react";
import { jsx as jsx6 } from "react/jsx-runtime";
var getTooltipDiv, updateTooltipPosition, updateTooltip, Tooltip;
var init_Tooltip2 = __esm({
  "components/Tooltip.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_Tooltip();
    getTooltipDiv = () => {
      const existingDiv = document.querySelector(
        ".excalidraw-tooltip"
      );
      if (existingDiv) {
        return existingDiv;
      }
      const div = document.createElement("div");
      document.body.appendChild(div);
      div.classList.add("excalidraw-tooltip");
      return div;
    };
    updateTooltipPosition = (tooltip, item, position = "bottom") => {
      const tooltipRect = tooltip.getBoundingClientRect();
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      const margin = 5;
      let left = item.left + item.width / 2 - tooltipRect.width / 2;
      if (left < 0) {
        left = margin;
      } else if (left + tooltipRect.width >= viewportWidth) {
        left = viewportWidth - tooltipRect.width - margin;
      }
      let top;
      if (position === "bottom") {
        top = item.top + item.height + margin;
        if (top + tooltipRect.height >= viewportHeight) {
          top = item.top - tooltipRect.height - margin;
        }
      } else {
        top = item.top - tooltipRect.height - margin;
        if (top < 0) {
          top = item.top + item.height + margin;
        }
      }
      Object.assign(tooltip.style, {
        top: `${top}px`,
        left: `${left}px`
      });
    };
    updateTooltip = (item, tooltip, label, long) => {
      tooltip.classList.add("excalidraw-tooltip--visible");
      tooltip.style.minWidth = long ? "50ch" : "10ch";
      tooltip.style.maxWidth = long ? "50ch" : "15ch";
      tooltip.textContent = label;
      const itemRect = item.getBoundingClientRect();
      updateTooltipPosition(tooltip, itemRect);
    };
    Tooltip = ({
      children,
      label,
      long = false,
      style,
      disabled
    }) => {
      useEffect4(() => {
        return () => getTooltipDiv().classList.remove("excalidraw-tooltip--visible");
      }, []);
      if (disabled) {
        return null;
      }
      return /* @__PURE__ */ jsx6(
        "div",
        {
          className: "excalidraw-tooltip-wrapper",
          onPointerEnter: (event) => updateTooltip(
            event.currentTarget,
            getTooltipDiv(),
            label,
            long
          ),
          onPointerLeave: () => getTooltipDiv().classList.remove("excalidraw-tooltip--visible"),
          style,
          children
        }
      );
    };
  }
});

// data/url.ts
import { sanitizeUrl } from "@braintree/sanitize-url";
var normalizeLink, isLocalLink, toValidURL;
var init_url = __esm({
  "data/url.ts"() {
    "use strict";
    init_define_import_meta_env();
    normalizeLink = (link) => {
      link = link.trim();
      if (!link) {
        return link;
      }
      return sanitizeUrl(link);
    };
    isLocalLink = (link) => {
      return !!(link?.includes(location.origin) || link?.startsWith("/"));
    };
    toValidURL = (link) => {
      link = normalizeLink(link);
      if (link.startsWith("/")) {
        return `${location.origin}${link}`;
      }
      try {
        new URL(link);
      } catch {
        return "about:blank";
      }
      return link;
    };
  }
});

// element/Hyperlink.scss
var init_Hyperlink = __esm({
  "element/Hyperlink.scss"() {
  }
});

// analytics.ts
var ALLOWED_CATEGORIES_TO_TRACK, trackEvent;
var init_analytics = __esm({
  "analytics.ts"() {
    "use strict";
    init_define_import_meta_env();
    ALLOWED_CATEGORIES_TO_TRACK = ["ai"];
    trackEvent = (category, action, label, value) => {
      try {
        if (typeof window === "undefined" || define_import_meta_env_default.VITE_WORKER_ID || define_import_meta_env_default.PROD) {
          return;
        }
        if (!ALLOWED_CATEGORIES_TO_TRACK.includes(category)) {
          return;
        }
        if (!define_import_meta_env_default.PROD) {
          console.info("trackEvent", { category, action, label, value });
        }
        if (window.sa_event) {
          window.sa_event(action, {
            category,
            label,
            value
          });
        }
      } catch (error) {
        console.error("error during analytics", error);
      }
    };
  }
});

// element/Hyperlink.tsx
import {
  useCallback,
  useEffect as useEffect5,
  useLayoutEffect as useLayoutEffect2,
  useRef as useRef2,
  useState as useState4
} from "react";
import clsx4 from "clsx";
import { jsx as jsx7, jsxs as jsxs4 } from "react/jsx-runtime";
var CONTAINER_WIDTH, SPACE_BOTTOM, CONTAINER_PADDING, CONTAINER_HEIGHT, AUTO_HIDE_TIMEOUT, EXTERNAL_LINK_IMG, IS_HYPERLINK_TOOLTIP_VISIBLE, embeddableLinkCache, Hyperlink, getCoordsForPopover, actionLink, getContextMenuLabel, getLinkHandleFromCoords, isPointHittingLinkIcon, isPointHittingLink, HYPERLINK_TOOLTIP_TIMEOUT_ID, showHyperlinkTooltip, renderTooltip, hideHyperlinkToolip, shouldHideLinkPopup;
var init_Hyperlink2 = __esm({
  "element/Hyperlink.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_utils();
    init_embeddable();
    init_mutateElement();
    init_register();
    init_ToolButton();
    init_icons();
    init_i18n();
    init_keys();
    init_renderElement();
    init_math();
    init_constants();
    init_Tooltip2();
    init_scene();
    init_collision();
    init_element();
    init_url();
    init_Hyperlink();
    init_analytics();
    init_App();
    init_typeChecks();
    CONTAINER_WIDTH = 320;
    SPACE_BOTTOM = 85;
    CONTAINER_PADDING = 5;
    CONTAINER_HEIGHT = 42;
    AUTO_HIDE_TIMEOUT = 500;
    EXTERNAL_LINK_IMG = document.createElement("img");
    EXTERNAL_LINK_IMG.src = `data:${MIME_TYPES.svg}, ${encodeURIComponent(
      `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#1971c2" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-external-link"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg>`
    )}`;
    IS_HYPERLINK_TOOLTIP_VISIBLE = false;
    embeddableLinkCache = /* @__PURE__ */ new Map();
    Hyperlink = ({
      element,
      elementsMap,
      setAppState,
      onLinkOpen,
      setToast,
      updateEmbedValidationStatus
    }) => {
      const appState = useExcalidrawAppState();
      const appProps = useAppProps();
      const linkVal = element.link || "";
      const [inputVal, setInputVal] = useState4(linkVal);
      const inputRef = useRef2(null);
      const isEditing = appState.showHyperlinkPopup === "editor";
      const handleSubmit = useCallback(() => {
        if (!inputRef.current) {
          return;
        }
        const link = normalizeLink(inputRef.current.value) || null;
        if (!element.link && link) {
          trackEvent("hyperlink", "create");
        }
        if (isEmbeddableElement(element)) {
          if (appState.activeEmbeddable?.element === element) {
            setAppState({ activeEmbeddable: null });
          }
          if (!link) {
            mutateElement(element, {
              link: null
            });
            updateEmbedValidationStatus(element, false);
            return;
          }
          if (!embeddableURLValidator(link, appProps.validateEmbeddable)) {
            if (link) {
              setToast({ message: t("toast.unableToEmbed"), closable: true });
            }
            element.link && embeddableLinkCache.set(element.id, element.link);
            mutateElement(element, {
              link
            });
            updateEmbedValidationStatus(element, false);
          } else {
            const { width, height } = element;
            const embedLink = getEmbedLink(link);
            if (embedLink?.error instanceof URIError) {
              setToast({
                message: t("toast.unrecognizedLinkFormat"),
                closable: true
              });
            }
            const ar = embedLink ? embedLink.intrinsicSize.w / embedLink.intrinsicSize.h : 1;
            const hasLinkChanged = embeddableLinkCache.get(element.id) !== element.link;
            mutateElement(element, {
              ...hasLinkChanged ? {
                width: embedLink?.type === "video" ? width > height ? width : height * ar : width,
                height: embedLink?.type === "video" ? width > height ? width / ar : height : height
              } : {},
              link
            });
            updateEmbedValidationStatus(element, true);
            if (embeddableLinkCache.has(element.id)) {
              embeddableLinkCache.delete(element.id);
            }
          }
        } else {
          mutateElement(element, { link });
        }
      }, [
        element,
        setToast,
        appProps.validateEmbeddable,
        appState.activeEmbeddable,
        setAppState,
        updateEmbedValidationStatus
      ]);
      useLayoutEffect2(() => {
        return () => {
          handleSubmit();
        };
      }, [handleSubmit]);
      useEffect5(() => {
        let timeoutId = null;
        const handlePointerMove = (event) => {
          if (isEditing) {
            return;
          }
          if (timeoutId) {
            clearTimeout(timeoutId);
          }
          const shouldHide = shouldHideLinkPopup(element, elementsMap, appState, [
            event.clientX,
            event.clientY
          ]);
          if (shouldHide) {
            timeoutId = window.setTimeout(() => {
              setAppState({ showHyperlinkPopup: false });
            }, AUTO_HIDE_TIMEOUT);
          }
        };
        window.addEventListener("pointermove" /* POINTER_MOVE */, handlePointerMove, false);
        return () => {
          window.removeEventListener("pointermove" /* POINTER_MOVE */, handlePointerMove, false);
          if (timeoutId) {
            clearTimeout(timeoutId);
          }
        };
      }, [appState, element, isEditing, setAppState, elementsMap]);
      const handleRemove = useCallback(() => {
        trackEvent("hyperlink", "delete");
        mutateElement(element, { link: null });
        if (isEditing) {
          inputRef.current.value = "";
        }
        setAppState({ showHyperlinkPopup: false });
      }, [setAppState, element, isEditing]);
      const onEdit = () => {
        trackEvent("hyperlink", "edit", "popup-ui");
        setAppState({ showHyperlinkPopup: "editor" });
      };
      const { x, y } = getCoordsForPopover(element, appState, elementsMap);
      if (appState.contextMenu || appState.draggingElement || appState.resizingElement || appState.isRotating || appState.openMenu || appState.viewModeEnabled) {
        return null;
      }
      return /* @__PURE__ */ jsxs4(
        "div",
        {
          className: "excalidraw-hyperlinkContainer",
          style: {
            top: `${y}px`,
            left: `${x}px`,
            width: CONTAINER_WIDTH,
            padding: CONTAINER_PADDING
          },
          onClick: () => {
            if (!element.link && !isEditing) {
              setAppState({ showHyperlinkPopup: "editor" });
            }
          },
          children: [
            isEditing ? /* @__PURE__ */ jsx7(
              "input",
              {
                className: clsx4("excalidraw-hyperlinkContainer-input"),
                placeholder: "Type or paste your link here",
                ref: inputRef,
                value: inputVal,
                onChange: (event) => setInputVal(event.target.value),
                autoFocus: true,
                onKeyDown: (event) => {
                  event.stopPropagation();
                  if (event[KEYS.CTRL_OR_CMD] && event.key === KEYS.K) {
                    event.preventDefault();
                  }
                  if (event.key === KEYS.ENTER || event.key === KEYS.ESCAPE) {
                    handleSubmit();
                    setAppState({ showHyperlinkPopup: "info" });
                  }
                }
              }
            ) : element.link ? /* @__PURE__ */ jsx7(
              "a",
              {
                href: normalizeLink(element.link || ""),
                className: "excalidraw-hyperlinkContainer-link",
                target: isLocalLink(element.link) ? "_self" : "_blank",
                onClick: (event) => {
                  if (element.link && onLinkOpen) {
                    const customEvent = wrapEvent(
                      "excalidraw-link" /* EXCALIDRAW_LINK */,
                      event.nativeEvent
                    );
                    onLinkOpen(
                      {
                        ...element,
                        link: normalizeLink(element.link)
                      },
                      customEvent
                    );
                    if (customEvent.defaultPrevented) {
                      event.preventDefault();
                    }
                  }
                },
                rel: "noopener noreferrer",
                children: element.link
              }
            ) : /* @__PURE__ */ jsx7("div", { className: "excalidraw-hyperlinkContainer-link", children: t("labels.link.empty") }),
            /* @__PURE__ */ jsxs4("div", { className: "excalidraw-hyperlinkContainer__buttons", children: [
              !isEditing && /* @__PURE__ */ jsx7(
                ToolButton,
                {
                  type: "button",
                  title: t("buttons.edit"),
                  "aria-label": t("buttons.edit"),
                  label: t("buttons.edit"),
                  onClick: onEdit,
                  className: "excalidraw-hyperlinkContainer--edit",
                  icon: FreedrawIcon
                }
              ),
              linkVal && !isEmbeddableElement(element) && /* @__PURE__ */ jsx7(
                ToolButton,
                {
                  type: "button",
                  title: t("buttons.remove"),
                  "aria-label": t("buttons.remove"),
                  label: t("buttons.remove"),
                  onClick: handleRemove,
                  className: "excalidraw-hyperlinkContainer--remove",
                  icon: TrashIcon
                }
              )
            ] })
          ]
        }
      );
    };
    getCoordsForPopover = (element, appState, elementsMap) => {
      const [x1, y1] = getElementAbsoluteCoords(element, elementsMap);
      const { x: viewportX, y: viewportY } = sceneCoordsToViewportCoords(
        { sceneX: x1 + element.width / 2, sceneY: y1 },
        appState
      );
      const x = viewportX - appState.offsetLeft - CONTAINER_WIDTH / 2;
      const y = viewportY - appState.offsetTop - SPACE_BOTTOM;
      return { x, y };
    };
    actionLink = register({
      name: "hyperlink",
      perform: (elements, appState) => {
        if (appState.showHyperlinkPopup === "editor") {
          return false;
        }
        return {
          elements,
          appState: {
            ...appState,
            showHyperlinkPopup: "editor",
            openMenu: null
          },
          commitToHistory: true
        };
      },
      trackEvent: { category: "hyperlink", action: "click" },
      keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.key === KEYS.K,
      contextItemLabel: (elements, appState) => getContextMenuLabel(elements, appState),
      predicate: (elements, appState) => {
        const selectedElements = getSelectedElements(elements, appState);
        return selectedElements.length === 1;
      },
      PanelComponent: ({ elements, appState, updateData }) => {
        const selectedElements = getSelectedElements(elements, appState);
        return /* @__PURE__ */ jsx7(
          ToolButton,
          {
            type: "button",
            icon: LinkIcon,
            "aria-label": t(getContextMenuLabel(elements, appState)),
            title: `${isEmbeddableElement(elements[0]) ? t("labels.link.labelEmbed") : t("labels.link.label")} - ${getShortcutKey("CtrlOrCmd+K")}`,
            onClick: () => updateData(null),
            selected: selectedElements.length === 1 && !!selectedElements[0].link
          }
        );
      }
    });
    getContextMenuLabel = (elements, appState) => {
      const selectedElements = getSelectedElements(elements, appState);
      const label = selectedElements[0].link ? isEmbeddableElement(selectedElements[0]) ? "labels.link.editEmbed" : "labels.link.edit" : isEmbeddableElement(selectedElements[0]) ? "labels.link.createEmbed" : "labels.link.create";
      return label;
    };
    getLinkHandleFromCoords = ([x1, y1, x2, y2], angle, appState) => {
      const size = DEFAULT_LINK_SIZE;
      const linkWidth = size / appState.zoom.value;
      const linkHeight = size / appState.zoom.value;
      const linkMarginY = size / appState.zoom.value;
      const centerX = (x1 + x2) / 2;
      const centerY = (y1 + y2) / 2;
      const centeringOffset = (size - 8) / (2 * appState.zoom.value);
      const dashedLineMargin = 4 / appState.zoom.value;
      const x = x2 + dashedLineMargin - centeringOffset;
      const y = y1 - dashedLineMargin - linkMarginY + centeringOffset;
      const [rotatedX, rotatedY] = rotate(
        x + linkWidth / 2,
        y + linkHeight / 2,
        centerX,
        centerY,
        angle
      );
      return [
        rotatedX - linkWidth / 2,
        rotatedY - linkHeight / 2,
        linkWidth,
        linkHeight
      ];
    };
    isPointHittingLinkIcon = (element, elementsMap, appState, [x, y]) => {
      const threshold = 4 / appState.zoom.value;
      const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);
      const [linkX, linkY, linkWidth, linkHeight] = getLinkHandleFromCoords(
        [x1, y1, x2, y2],
        element.angle,
        appState
      );
      const hitLink = x > linkX - threshold && x < linkX + threshold + linkWidth && y > linkY - threshold && y < linkY + linkHeight + threshold;
      return hitLink;
    };
    isPointHittingLink = (element, elementsMap, appState, [x, y], isMobile) => {
      if (!element.link || appState.selectedElementIds[element.id]) {
        return false;
      }
      const threshold = 4 / appState.zoom.value;
      if (!isMobile && appState.viewModeEnabled && isPointHittingElementBoundingBox(
        element,
        elementsMap,
        [x, y],
        threshold,
        null
      )) {
        return true;
      }
      return isPointHittingLinkIcon(element, elementsMap, appState, [x, y]);
    };
    HYPERLINK_TOOLTIP_TIMEOUT_ID = null;
    showHyperlinkTooltip = (element, appState, elementsMap) => {
      if (HYPERLINK_TOOLTIP_TIMEOUT_ID) {
        clearTimeout(HYPERLINK_TOOLTIP_TIMEOUT_ID);
      }
      HYPERLINK_TOOLTIP_TIMEOUT_ID = window.setTimeout(
        () => renderTooltip(element, appState, elementsMap),
        HYPERLINK_TOOLTIP_DELAY
      );
    };
    renderTooltip = (element, appState, elementsMap) => {
      if (!element.link) {
        return;
      }
      const tooltipDiv = getTooltipDiv();
      tooltipDiv.classList.add("excalidraw-tooltip--visible");
      tooltipDiv.style.maxWidth = "20rem";
      tooltipDiv.textContent = element.link;
      const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);
      const [linkX, linkY, linkWidth, linkHeight] = getLinkHandleFromCoords(
        [x1, y1, x2, y2],
        element.angle,
        appState
      );
      const linkViewportCoords = sceneCoordsToViewportCoords(
        { sceneX: linkX, sceneY: linkY },
        appState
      );
      updateTooltipPosition(
        tooltipDiv,
        {
          left: linkViewportCoords.x,
          top: linkViewportCoords.y,
          width: linkWidth,
          height: linkHeight
        },
        "top"
      );
      trackEvent("hyperlink", "tooltip", "link-icon");
      IS_HYPERLINK_TOOLTIP_VISIBLE = true;
    };
    hideHyperlinkToolip = () => {
      if (HYPERLINK_TOOLTIP_TIMEOUT_ID) {
        clearTimeout(HYPERLINK_TOOLTIP_TIMEOUT_ID);
      }
      if (IS_HYPERLINK_TOOLTIP_VISIBLE) {
        IS_HYPERLINK_TOOLTIP_VISIBLE = false;
        getTooltipDiv().classList.remove("excalidraw-tooltip--visible");
      }
    };
    shouldHideLinkPopup = (element, elementsMap, appState, [clientX, clientY]) => {
      const { x: sceneX, y: sceneY } = viewportCoordsToSceneCoords(
        { clientX, clientY },
        appState
      );
      const threshold = 15 / appState.zoom.value;
      if (isPointHittingElementBoundingBox(
        element,
        elementsMap,
        [sceneX, sceneY],
        threshold,
        null
      )) {
        return false;
      }
      const [x1, y1, x2] = getElementAbsoluteCoords(element, elementsMap);
      if (sceneX >= x1 && sceneX <= x2 && sceneY >= y1 - SPACE_BOTTOM && sceneY <= y1) {
        return false;
      }
      const { x: popoverX, y: popoverY } = getCoordsForPopover(
        element,
        appState,
        elementsMap
      );
      if (clientX >= popoverX - threshold && clientX <= popoverX + CONTAINER_WIDTH + CONTAINER_PADDING * 2 + threshold && clientY >= popoverY - threshold && clientY <= popoverY + threshold + CONTAINER_PADDING * 2 + CONTAINER_HEIGHT) {
        return false;
      }
      return true;
    };
  }
});

// renderer/renderSnaps.ts
var SNAP_COLOR_LIGHT, SNAP_COLOR_DARK, SNAP_WIDTH, SNAP_CROSS_SIZE, renderSnaps, drawPointsSnapLine, drawPointerSnapLine, drawCross, drawLine, drawGapLine;
var init_renderSnaps = __esm({
  "renderer/renderSnaps.ts"() {
    "use strict";
    init_define_import_meta_env();
    SNAP_COLOR_LIGHT = "#ff6b6b";
    SNAP_COLOR_DARK = "#ff0000";
    SNAP_WIDTH = 1;
    SNAP_CROSS_SIZE = 2;
    renderSnaps = (context, appState) => {
      if (!appState.snapLines.length) {
        return;
      }
      const snapColor = appState.theme === "light" || appState.zenModeEnabled ? SNAP_COLOR_LIGHT : SNAP_COLOR_DARK;
      const snapWidth = (appState.zenModeEnabled ? SNAP_WIDTH * 1.5 : SNAP_WIDTH) / appState.zoom.value;
      context.save();
      context.translate(appState.scrollX, appState.scrollY);
      for (const snapLine of appState.snapLines) {
        if (snapLine.type === "pointer") {
          context.lineWidth = snapWidth;
          context.strokeStyle = snapColor;
          drawPointerSnapLine(snapLine, context, appState);
        } else if (snapLine.type === "gap") {
          context.lineWidth = snapWidth;
          context.strokeStyle = snapColor;
          drawGapLine(
            snapLine.points[0],
            snapLine.points[1],
            snapLine.direction,
            appState,
            context
          );
        } else if (snapLine.type === "points") {
          context.lineWidth = snapWidth;
          context.strokeStyle = snapColor;
          drawPointsSnapLine(snapLine, context, appState);
        }
      }
      context.restore();
    };
    drawPointsSnapLine = (pointSnapLine, context, appState) => {
      if (!appState.zenModeEnabled) {
        const firstPoint = pointSnapLine.points[0];
        const lastPoint = pointSnapLine.points[pointSnapLine.points.length - 1];
        drawLine(firstPoint, lastPoint, context);
      }
      for (const point2 of pointSnapLine.points) {
        drawCross(point2, appState, context);
      }
    };
    drawPointerSnapLine = (pointerSnapLine, context, appState) => {
      drawCross(pointerSnapLine.points[0], appState, context);
      if (!appState.zenModeEnabled) {
        drawLine(pointerSnapLine.points[0], pointerSnapLine.points[1], context);
      }
    };
    drawCross = ([x, y], appState, context) => {
      context.save();
      const size = (appState.zenModeEnabled ? SNAP_CROSS_SIZE * 1.5 : SNAP_CROSS_SIZE) / appState.zoom.value;
      context.beginPath();
      context.moveTo(x - size, y - size);
      context.lineTo(x + size, y + size);
      context.moveTo(x + size, y - size);
      context.lineTo(x - size, y + size);
      context.stroke();
      context.restore();
    };
    drawLine = (from3, to, context) => {
      context.beginPath();
      context.lineTo(...from3);
      context.lineTo(...to);
      context.stroke();
    };
    drawGapLine = (from3, to, direction, appState, context) => {
      const FULL = 8 / appState.zoom.value;
      const HALF = FULL / 2;
      const QUARTER = FULL / 4;
      if (direction === "horizontal") {
        const halfPoint = [(from3[0] + to[0]) / 2, from3[1]];
        if (!appState.zenModeEnabled) {
          drawLine([from3[0], from3[1] - FULL], [from3[0], from3[1] + FULL], context);
        }
        drawLine(
          [halfPoint[0] - QUARTER, halfPoint[1] - HALF],
          [halfPoint[0] - QUARTER, halfPoint[1] + HALF],
          context
        );
        drawLine(
          [halfPoint[0] + QUARTER, halfPoint[1] - HALF],
          [halfPoint[0] + QUARTER, halfPoint[1] + HALF],
          context
        );
        if (!appState.zenModeEnabled) {
          drawLine([to[0], to[1] - FULL], [to[0], to[1] + FULL], context);
          drawLine(from3, to, context);
        }
      } else {
        const halfPoint = [from3[0], (from3[1] + to[1]) / 2];
        if (!appState.zenModeEnabled) {
          drawLine([from3[0] - FULL, from3[1]], [from3[0] + FULL, from3[1]], context);
        }
        drawLine(
          [halfPoint[0] - HALF, halfPoint[1] - QUARTER],
          [halfPoint[0] + HALF, halfPoint[1] - QUARTER],
          context
        );
        drawLine(
          [halfPoint[0] - HALF, halfPoint[1] + QUARTER],
          [halfPoint[0] + HALF, halfPoint[1] + QUARTER],
          context
        );
        if (!appState.zenModeEnabled) {
          drawLine([to[0] - FULL, to[1]], [to[0] + FULL, to[1]], context);
          drawLine(from3, to, context);
        }
      }
    };
  }
});

// renderer/renderScene.ts
import oc3 from "open-color";
var strokeRectWithRotation, strokeDiamondWithRotation, strokeEllipseWithRotation, fillCircle, strokeGrid, renderSingleLinearPoint, renderLinearPointHandles, highlightPoint, renderLinearElementPointHighlight, frameClip, getNormalizedCanvasDimensions, bootstrapCanvas, _renderInteractiveScene, _renderStaticScene, renderInteractiveSceneThrottled, renderInteractiveScene, renderStaticSceneThrottled, renderStaticScene, cancelRender, renderTransformHandles, renderSelectionBorder, renderBindingHighlight, renderBindingHighlightForBindableElement, renderFrameHighlight, renderElementsBoxHighlight, renderBindingHighlightForSuggestedPointBinding, linkCanvasCache, renderLinkIcon, renderSceneToSvg;
var init_renderScene = __esm({
  "renderer/renderScene.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_element();
    init_roundRect();
    init_scrollbars();
    init_renderElement();
    init_clients();
    init_linearElementEditor();
    init_groups();
    init_collision();
    init_transformHandles();
    init_utils();
    init_types();
    init_constants();
    init_Hyperlink2();
    init_renderSnaps();
    init_typeChecks();
    init_embeddable();
    init_frame();
    strokeRectWithRotation = (context, x, y, width, height, cx, cy, angle, fill = false, radius = 0) => {
      context.save();
      context.translate(cx, cy);
      context.rotate(angle);
      if (fill) {
        context.fillRect(x - cx, y - cy, width, height);
      }
      if (radius && context.roundRect) {
        context.beginPath();
        context.roundRect(x - cx, y - cy, width, height, radius);
        context.stroke();
        context.closePath();
      } else {
        context.strokeRect(x - cx, y - cy, width, height);
      }
      context.restore();
    };
    strokeDiamondWithRotation = (context, width, height, cx, cy, angle) => {
      context.save();
      context.translate(cx, cy);
      context.rotate(angle);
      context.beginPath();
      context.moveTo(0, height / 2);
      context.lineTo(width / 2, 0);
      context.lineTo(0, -height / 2);
      context.lineTo(-width / 2, 0);
      context.closePath();
      context.stroke();
      context.restore();
    };
    strokeEllipseWithRotation = (context, width, height, cx, cy, angle) => {
      context.beginPath();
      context.ellipse(cx, cy, width / 2, height / 2, angle, 0, Math.PI * 2);
      context.stroke();
    };
    fillCircle = (context, cx, cy, radius, stroke = true) => {
      context.beginPath();
      context.arc(cx, cy, radius, 0, Math.PI * 2);
      context.fill();
      if (stroke) {
        context.stroke();
      }
    };
    strokeGrid = (context, gridSize, scrollX, scrollY, zoom, width, height) => {
      const BOLD_LINE_FREQUENCY = 5;
      let GridLineColor;
      ((GridLineColor2) => {
        GridLineColor2["Bold"] = "#cccccc";
        GridLineColor2["Regular"] = "#e5e5e5";
      })(GridLineColor || (GridLineColor = {}));
      const offsetX = -Math.round(zoom.value / gridSize) * gridSize + scrollX % gridSize;
      const offsetY = -Math.round(zoom.value / gridSize) * gridSize + scrollY % gridSize;
      const lineWidth = Math.min(1 / zoom.value, 1);
      const spaceWidth = 1 / zoom.value;
      const lineDash = [lineWidth * 3, spaceWidth + (lineWidth + spaceWidth)];
      context.save();
      context.lineWidth = lineWidth;
      for (let x = offsetX; x < offsetX + width + gridSize * 2; x += gridSize) {
        const isBold = Math.round(x - scrollX) % (BOLD_LINE_FREQUENCY * gridSize) === 0;
        context.beginPath();
        context.setLineDash(isBold ? [] : lineDash);
        context.strokeStyle = isBold ? "#cccccc" /* Bold */ : "#e5e5e5" /* Regular */;
        context.moveTo(x, offsetY - gridSize);
        context.lineTo(x, offsetY + height + gridSize * 2);
        context.stroke();
      }
      for (let y = offsetY; y < offsetY + height + gridSize * 2; y += gridSize) {
        const isBold = Math.round(y - scrollY) % (BOLD_LINE_FREQUENCY * gridSize) === 0;
        context.beginPath();
        context.setLineDash(isBold ? [] : lineDash);
        context.strokeStyle = isBold ? "#cccccc" /* Bold */ : "#e5e5e5" /* Regular */;
        context.moveTo(offsetX - gridSize, y);
        context.lineTo(offsetX + width + gridSize * 2, y);
        context.stroke();
      }
      context.restore();
    };
    renderSingleLinearPoint = (context, appState, point2, radius, isSelected, isPhantomPoint = false) => {
      context.strokeStyle = "#5e5ad8";
      context.setLineDash([]);
      context.fillStyle = "rgba(255, 255, 255, 0.9)";
      if (isSelected) {
        context.fillStyle = "rgba(134, 131, 226, 0.9)";
      } else if (isPhantomPoint) {
        context.fillStyle = "rgba(177, 151, 252, 0.7)";
      }
      fillCircle(
        context,
        point2[0],
        point2[1],
        radius / appState.zoom.value,
        !isPhantomPoint
      );
    };
    renderLinearPointHandles = (context, appState, element, elementsMap) => {
      if (!appState.selectedLinearElement) {
        return;
      }
      context.save();
      context.translate(appState.scrollX, appState.scrollY);
      context.lineWidth = 1 / appState.zoom.value;
      const points = LinearElementEditor.getPointsGlobalCoordinates(
        element,
        elementsMap
      );
      const { POINT_HANDLE_SIZE } = LinearElementEditor;
      const radius = appState.editingLinearElement ? POINT_HANDLE_SIZE : POINT_HANDLE_SIZE / 2;
      points.forEach((point2, idx) => {
        const isSelected = !!appState.editingLinearElement?.selectedPointsIndices?.includes(idx);
        renderSingleLinearPoint(context, appState, point2, radius, isSelected);
      });
      const midPoints = LinearElementEditor.getEditorMidPoints(
        element,
        elementsMap,
        appState
      ).filter((midPoint) => midPoint !== null);
      midPoints.forEach((segmentMidPoint) => {
        if (appState?.selectedLinearElement?.segmentMidPointHoveredCoords && LinearElementEditor.arePointsEqual(
          segmentMidPoint,
          appState.selectedLinearElement.segmentMidPointHoveredCoords
        )) {
          if (appState.editingLinearElement) {
            renderSingleLinearPoint(
              context,
              appState,
              segmentMidPoint,
              radius,
              false
            );
            highlightPoint(segmentMidPoint, context, appState);
          } else {
            highlightPoint(segmentMidPoint, context, appState);
            renderSingleLinearPoint(
              context,
              appState,
              segmentMidPoint,
              radius,
              false
            );
          }
        } else if (appState.editingLinearElement || points.length === 2) {
          renderSingleLinearPoint(
            context,
            appState,
            segmentMidPoint,
            POINT_HANDLE_SIZE / 2,
            false,
            true
          );
        }
      });
      context.restore();
    };
    highlightPoint = (point2, context, appState) => {
      context.fillStyle = "rgba(105, 101, 219, 0.4)";
      fillCircle(
        context,
        point2[0],
        point2[1],
        LinearElementEditor.POINT_HANDLE_SIZE / appState.zoom.value,
        false
      );
    };
    renderLinearElementPointHighlight = (context, appState, elementsMap) => {
      const { elementId, hoverPointIndex } = appState.selectedLinearElement;
      if (appState.editingLinearElement?.selectedPointsIndices?.includes(
        hoverPointIndex
      )) {
        return;
      }
      const element = LinearElementEditor.getElement(elementId, elementsMap);
      if (!element) {
        return;
      }
      const point2 = LinearElementEditor.getPointAtIndexGlobalCoordinates(
        element,
        hoverPointIndex,
        elementsMap
      );
      context.save();
      context.translate(appState.scrollX, appState.scrollY);
      highlightPoint(point2, context, appState);
      context.restore();
    };
    frameClip = (frame, context, renderConfig, appState) => {
      context.translate(frame.x + appState.scrollX, frame.y + appState.scrollY);
      context.beginPath();
      if (context.roundRect) {
        context.roundRect(
          0,
          0,
          frame.width,
          frame.height,
          FRAME_STYLE.radius / appState.zoom.value
        );
      } else {
        context.rect(0, 0, frame.width, frame.height);
      }
      context.clip();
      context.translate(
        -(frame.x + appState.scrollX),
        -(frame.y + appState.scrollY)
      );
    };
    getNormalizedCanvasDimensions = (canvas2, scale) => {
      return [canvas2.width / scale, canvas2.height / scale];
    };
    bootstrapCanvas = ({
      canvas: canvas2,
      scale,
      normalizedWidth,
      normalizedHeight,
      theme,
      isExporting,
      viewBackgroundColor
    }) => {
      const context = canvas2.getContext("2d");
      context.setTransform(1, 0, 0, 1, 0, 0);
      context.scale(scale, scale);
      if (isExporting && theme === "dark") {
        context.filter = THEME_FILTER;
      }
      if (typeof viewBackgroundColor === "string") {
        const hasTransparence = viewBackgroundColor === "transparent" || viewBackgroundColor.length === 5 || // #RGBA
        viewBackgroundColor.length === 9 || // #RRGGBBA
        /(hsla|rgba)\(/.test(viewBackgroundColor);
        if (hasTransparence) {
          context.clearRect(0, 0, normalizedWidth, normalizedHeight);
        }
        context.save();
        context.fillStyle = viewBackgroundColor;
        context.fillRect(0, 0, normalizedWidth, normalizedHeight);
        context.restore();
      } else {
        context.clearRect(0, 0, normalizedWidth, normalizedHeight);
      }
      return context;
    };
    _renderInteractiveScene = ({
      canvas: canvas2,
      elementsMap,
      visibleElements,
      selectedElements,
      scale,
      appState,
      renderConfig
    }) => {
      if (canvas2 === null) {
        return { atLeastOneVisibleElement: false, elementsMap };
      }
      const [normalizedWidth, normalizedHeight] = getNormalizedCanvasDimensions(
        canvas2,
        scale
      );
      const context = bootstrapCanvas({
        canvas: canvas2,
        scale,
        normalizedWidth,
        normalizedHeight
      });
      context.save();
      context.scale(appState.zoom.value, appState.zoom.value);
      let editingLinearElement = void 0;
      visibleElements.forEach((element) => {
        if (appState.editingLinearElement?.elementId === element.id) {
          if (element) {
            editingLinearElement = element;
          }
        }
      });
      if (editingLinearElement) {
        renderLinearPointHandles(
          context,
          appState,
          editingLinearElement,
          elementsMap
        );
      }
      if (appState.selectionElement) {
        try {
          renderSelectionElement(appState.selectionElement, context, appState);
        } catch (error) {
          console.error(error);
        }
      }
      if (appState.isBindingEnabled) {
        appState.suggestedBindings.filter((binding) => binding != null).forEach((suggestedBinding) => {
          renderBindingHighlight(
            context,
            appState,
            suggestedBinding,
            elementsMap
          );
        });
      }
      if (appState.frameToHighlight) {
        renderFrameHighlight(
          context,
          appState,
          appState.frameToHighlight,
          elementsMap
        );
      }
      if (appState.elementsToHighlight) {
        renderElementsBoxHighlight(context, appState, appState.elementsToHighlight);
      }
      const isFrameSelected = selectedElements.some(
        (element) => isFrameLikeElement(element)
      );
      if (selectedElements.length === 1 && appState.editingLinearElement?.elementId === selectedElements[0].id) {
        renderLinearPointHandles(
          context,
          appState,
          selectedElements[0],
          elementsMap
        );
      }
      if (appState.selectedLinearElement && appState.selectedLinearElement.hoverPointIndex >= 0) {
        renderLinearElementPointHighlight(context, appState, elementsMap);
      }
      if (!appState.multiElement && !appState.editingLinearElement) {
        const showBoundingBox = shouldShowBoundingBox(selectedElements, appState);
        const isSingleLinearElementSelected = selectedElements.length === 1 && isLinearElement(selectedElements[0]);
        if (isSingleLinearElementSelected && appState.selectedLinearElement?.elementId === selectedElements[0].id && !selectedElements[0].locked) {
          renderLinearPointHandles(
            context,
            appState,
            selectedElements[0],
            elementsMap
          );
        }
        const selectionColor = renderConfig.selectionColor || oc3.black;
        if (showBoundingBox) {
          const locallySelectedIds = arrayToMap(selectedElements);
          const selections = [];
          for (const element of elementsMap.values()) {
            const selectionColors = [];
            if (locallySelectedIds.has(element.id) && !isSelectedViaGroup(appState, element)) {
              selectionColors.push(selectionColor);
            }
            if (renderConfig.remoteSelectedElementIds[element.id]) {
              selectionColors.push(
                ...renderConfig.remoteSelectedElementIds[element.id].map(
                  (socketId) => {
                    const background = getClientColor(socketId);
                    return background;
                  }
                )
              );
            }
            if (selectionColors.length) {
              const [elementX1, elementY1, elementX2, elementY2, cx, cy] = getElementAbsoluteCoords(element, elementsMap, true);
              selections.push({
                angle: element.angle,
                elementX1,
                elementY1,
                elementX2,
                elementY2,
                selectionColors,
                dashed: !!renderConfig.remoteSelectedElementIds[element.id],
                cx,
                cy,
                activeEmbeddable: appState.activeEmbeddable?.element === element && appState.activeEmbeddable.state === "active"
              });
            }
          }
          const addSelectionForGroupId = (groupId) => {
            const groupElements = getElementsInGroup(elementsMap, groupId);
            const [elementX1, elementY1, elementX2, elementY2] = getCommonBounds(groupElements);
            selections.push({
              angle: 0,
              elementX1,
              elementX2,
              elementY1,
              elementY2,
              selectionColors: [oc3.black],
              dashed: true,
              cx: elementX1 + (elementX2 - elementX1) / 2,
              cy: elementY1 + (elementY2 - elementY1) / 2,
              activeEmbeddable: false
            });
          };
          for (const groupId of getSelectedGroupIds(appState)) {
            addSelectionForGroupId(groupId);
          }
          if (appState.editingGroupId) {
            addSelectionForGroupId(appState.editingGroupId);
          }
          selections.forEach(
            (selection) => renderSelectionBorder(context, appState, selection)
          );
        }
        context.save();
        context.translate(appState.scrollX, appState.scrollY);
        if (selectedElements.length === 1) {
          context.fillStyle = oc3.white;
          const transformHandles = getTransformHandles(
            selectedElements[0],
            appState.zoom,
            elementsMap,
            "mouse"
            // when we render we don't know which pointer type so use mouse,
          );
          if (!appState.viewModeEnabled && showBoundingBox) {
            renderTransformHandles(
              context,
              renderConfig,
              appState,
              transformHandles,
              selectedElements[0].angle
            );
          }
        } else if (selectedElements.length > 1 && !appState.isRotating) {
          const dashedLinePadding = DEFAULT_TRANSFORM_HANDLE_SPACING * 2 / appState.zoom.value;
          context.fillStyle = oc3.white;
          const [x1, y1, x2, y2] = getCommonBounds(selectedElements);
          const initialLineDash = context.getLineDash();
          context.setLineDash([2 / appState.zoom.value]);
          const lineWidth = context.lineWidth;
          context.lineWidth = 1 / appState.zoom.value;
          context.strokeStyle = selectionColor;
          strokeRectWithRotation(
            context,
            x1 - dashedLinePadding,
            y1 - dashedLinePadding,
            x2 - x1 + dashedLinePadding * 2,
            y2 - y1 + dashedLinePadding * 2,
            (x1 + x2) / 2,
            (y1 + y2) / 2,
            0
          );
          context.lineWidth = lineWidth;
          context.setLineDash(initialLineDash);
          const transformHandles = getTransformHandlesFromCoords(
            [x1, y1, x2, y2, (x1 + x2) / 2, (y1 + y2) / 2],
            0,
            appState.zoom,
            "mouse",
            isFrameSelected ? OMIT_SIDES_FOR_FRAME : OMIT_SIDES_FOR_MULTIPLE_ELEMENTS
          );
          if (selectedElements.some((element) => !element.locked)) {
            renderTransformHandles(
              context,
              renderConfig,
              appState,
              transformHandles,
              0
            );
          }
        }
        context.restore();
      }
      renderSnaps(context, appState);
      context.restore();
      for (const clientId in renderConfig.remotePointerViewportCoords) {
        let { x, y } = renderConfig.remotePointerViewportCoords[clientId];
        x -= appState.offsetLeft;
        y -= appState.offsetTop;
        const width = 11;
        const height = 14;
        const isOutOfBounds = x < 0 || x > normalizedWidth - width || y < 0 || y > normalizedHeight - height;
        x = Math.max(x, 0);
        x = Math.min(x, normalizedWidth - width);
        y = Math.max(y, 0);
        y = Math.min(y, normalizedHeight - height);
        const background = getClientColor(clientId);
        context.save();
        context.strokeStyle = background;
        context.fillStyle = background;
        const userState = renderConfig.remotePointerUserStates[clientId];
        const isInactive = isOutOfBounds || userState === "idle" /* IDLE */ || userState === "away" /* AWAY */;
        if (isInactive) {
          context.globalAlpha = 0.3;
        }
        if (renderConfig.remotePointerButton && renderConfig.remotePointerButton[clientId] === "down") {
          context.beginPath();
          context.arc(x, y, 15, 0, 2 * Math.PI, false);
          context.lineWidth = 3;
          context.strokeStyle = "#ffffff88";
          context.stroke();
          context.closePath();
          context.beginPath();
          context.arc(x, y, 15, 0, 2 * Math.PI, false);
          context.lineWidth = 1;
          context.strokeStyle = background;
          context.stroke();
          context.closePath();
        }
        context.fillStyle = oc3.white;
        context.strokeStyle = oc3.white;
        context.lineWidth = 6;
        context.lineJoin = "round";
        context.beginPath();
        context.moveTo(x, y);
        context.lineTo(x + 0, y + 14);
        context.lineTo(x + 4, y + 9);
        context.lineTo(x + 11, y + 8);
        context.closePath();
        context.stroke();
        context.fill();
        context.fillStyle = background;
        context.strokeStyle = background;
        context.lineWidth = 2;
        context.lineJoin = "round";
        context.beginPath();
        if (isInactive) {
          context.moveTo(x - 1, y - 1);
          context.lineTo(x - 1, y + 15);
          context.lineTo(x + 5, y + 10);
          context.lineTo(x + 12, y + 9);
          context.closePath();
          context.fill();
        } else {
          context.moveTo(x, y);
          context.lineTo(x + 0, y + 14);
          context.lineTo(x + 4, y + 9);
          context.lineTo(x + 11, y + 8);
          context.closePath();
          context.fill();
          context.stroke();
        }
        const username = renderConfig.remotePointerUsernames[clientId] || "";
        if (!isOutOfBounds && username) {
          context.font = "600 12px sans-serif";
          const offsetX = x + width / 2;
          const offsetY = y + height + 2;
          const paddingHorizontal = 5;
          const paddingVertical = 3;
          const measure = context.measureText(username);
          const measureHeight = measure.actualBoundingBoxDescent + measure.actualBoundingBoxAscent;
          const finalHeight = Math.max(measureHeight, 12);
          const boxX = offsetX - 1;
          const boxY = offsetY - 1;
          const boxWidth = measure.width + 2 + paddingHorizontal * 2 + 2;
          const boxHeight = finalHeight + 2 + paddingVertical * 2 + 2;
          if (context.roundRect) {
            context.beginPath();
            context.roundRect(boxX, boxY, boxWidth, boxHeight, 8);
            context.fillStyle = background;
            context.fill();
            context.strokeStyle = oc3.white;
            context.stroke();
          } else {
            roundRect(context, boxX, boxY, boxWidth, boxHeight, 8, oc3.white);
          }
          context.fillStyle = oc3.black;
          context.fillText(
            username,
            offsetX + paddingHorizontal + 1,
            offsetY + paddingVertical + measure.actualBoundingBoxAscent + Math.floor((finalHeight - measureHeight) / 2) + 2
          );
        }
        context.restore();
        context.closePath();
      }
      let scrollBars;
      if (renderConfig.renderScrollbars) {
        scrollBars = getScrollBars(
          visibleElements,
          normalizedWidth,
          normalizedHeight,
          appState
        );
        context.save();
        context.fillStyle = SCROLLBAR_COLOR;
        context.strokeStyle = "rgba(255,255,255,0.8)";
        [scrollBars.horizontal, scrollBars.vertical].forEach((scrollBar) => {
          if (scrollBar) {
            roundRect(
              context,
              scrollBar.x,
              scrollBar.y,
              scrollBar.width,
              scrollBar.height,
              SCROLLBAR_WIDTH / 2
            );
          }
        });
        context.restore();
      }
      return {
        scrollBars,
        atLeastOneVisibleElement: visibleElements.length > 0,
        elementsMap
      };
    };
    _renderStaticScene = ({
      canvas: canvas2,
      rc,
      elementsMap,
      allElementsMap,
      visibleElements,
      scale,
      appState,
      renderConfig
    }) => {
      if (canvas2 === null) {
        return;
      }
      const { renderGrid = true, isExporting } = renderConfig;
      const [normalizedWidth, normalizedHeight] = getNormalizedCanvasDimensions(
        canvas2,
        scale
      );
      const context = bootstrapCanvas({
        canvas: canvas2,
        scale,
        normalizedWidth,
        normalizedHeight,
        theme: appState.theme,
        isExporting,
        viewBackgroundColor: appState.viewBackgroundColor
      });
      context.scale(appState.zoom.value, appState.zoom.value);
      if (renderGrid && appState.gridSize) {
        strokeGrid(
          context,
          appState.gridSize,
          appState.scrollX,
          appState.scrollY,
          appState.zoom,
          normalizedWidth / appState.zoom.value,
          normalizedHeight / appState.zoom.value
        );
      }
      const groupsToBeAddedToFrame = /* @__PURE__ */ new Set();
      visibleElements.forEach((element) => {
        if (element.groupIds.length > 0 && appState.frameToHighlight && appState.selectedElementIds[element.id] && (elementOverlapsWithFrame(
          element,
          appState.frameToHighlight,
          elementsMap
        ) || element.groupIds.find((groupId) => groupsToBeAddedToFrame.has(groupId)))) {
          element.groupIds.forEach(
            (groupId) => groupsToBeAddedToFrame.add(groupId)
          );
        }
      });
      visibleElements.filter((el) => !isIframeLikeElement(el)).forEach((element) => {
        try {
          const frameId = element.frameId || appState.frameToHighlight?.id;
          if (frameId && appState.frameRendering.enabled && appState.frameRendering.clip) {
            context.save();
            const frame = getTargetFrame(element, elementsMap, appState);
            if (frame && isElementInFrame(element, elementsMap, appState)) {
              frameClip(frame, context, renderConfig, appState);
            }
            renderElement(
              element,
              elementsMap,
              allElementsMap,
              rc,
              context,
              renderConfig,
              appState
            );
            context.restore();
          } else {
            renderElement(
              element,
              elementsMap,
              allElementsMap,
              rc,
              context,
              renderConfig,
              appState
            );
          }
          if (!isExporting) {
            renderLinkIcon(element, context, appState, elementsMap);
          }
        } catch (error) {
          console.error(error);
        }
      });
      visibleElements.filter((el) => isIframeLikeElement(el)).forEach((element) => {
        try {
          const render = () => {
            renderElement(
              element,
              elementsMap,
              allElementsMap,
              rc,
              context,
              renderConfig,
              appState
            );
            if (isIframeLikeElement(element) && (isExporting || isEmbeddableElement(element) && renderConfig.embedsValidationStatus.get(element.id) !== true) && element.width && element.height) {
              const label = createPlaceholderEmbeddableLabel(element);
              renderElement(
                label,
                elementsMap,
                allElementsMap,
                rc,
                context,
                renderConfig,
                appState
              );
            }
            if (!isExporting) {
              renderLinkIcon(element, context, appState, elementsMap);
            }
          };
          const frameId = element.frameId || appState.frameToHighlight?.id;
          if (frameId && appState.frameRendering.enabled && appState.frameRendering.clip) {
            context.save();
            const frame = getTargetFrame(element, elementsMap, appState);
            if (frame && isElementInFrame(element, elementsMap, appState)) {
              frameClip(frame, context, renderConfig, appState);
            }
            render();
            context.restore();
          } else {
            render();
          }
        } catch (error) {
          console.error(error);
        }
      });
    };
    renderInteractiveSceneThrottled = throttleRAF(
      (config) => {
        const ret = _renderInteractiveScene(config);
        config.callback?.(ret);
      },
      { trailing: true }
    );
    renderInteractiveScene = (renderConfig, throttle3) => {
      if (throttle3) {
        renderInteractiveSceneThrottled(renderConfig);
        return void 0;
      }
      const ret = _renderInteractiveScene(renderConfig);
      renderConfig.callback(ret);
      return ret;
    };
    renderStaticSceneThrottled = throttleRAF(
      (config) => {
        _renderStaticScene(config);
      },
      { trailing: true }
    );
    renderStaticScene = (renderConfig, throttle3) => {
      if (throttle3) {
        renderStaticSceneThrottled(renderConfig);
        return;
      }
      _renderStaticScene(renderConfig);
    };
    cancelRender = () => {
      renderInteractiveSceneThrottled.cancel();
      renderStaticSceneThrottled.cancel();
    };
    renderTransformHandles = (context, renderConfig, appState, transformHandles, angle) => {
      Object.keys(transformHandles).forEach((key) => {
        const transformHandle = transformHandles[key];
        if (transformHandle !== void 0) {
          const [x, y, width, height] = transformHandle;
          context.save();
          context.lineWidth = 1 / appState.zoom.value;
          if (renderConfig.selectionColor) {
            context.strokeStyle = renderConfig.selectionColor;
          }
          if (key === "rotation") {
            fillCircle(context, x + width / 2, y + height / 2, width / 2);
          } else if (context.roundRect) {
            context.beginPath();
            context.roundRect(x, y, width, height, 2 / appState.zoom.value);
            context.fill();
            context.stroke();
          } else {
            strokeRectWithRotation(
              context,
              x,
              y,
              width,
              height,
              x + width / 2,
              y + height / 2,
              angle,
              true
              // fill before stroke
            );
          }
          context.restore();
        }
      });
    };
    renderSelectionBorder = (context, appState, elementProperties, padding = DEFAULT_TRANSFORM_HANDLE_SPACING * 2) => {
      const {
        angle,
        elementX1,
        elementY1,
        elementX2,
        elementY2,
        selectionColors,
        cx,
        cy,
        dashed,
        activeEmbeddable
      } = elementProperties;
      const elementWidth = elementX2 - elementX1;
      const elementHeight = elementY2 - elementY1;
      const linePadding = padding / appState.zoom.value;
      const lineWidth = 8 / appState.zoom.value;
      const spaceWidth = 4 / appState.zoom.value;
      context.save();
      context.translate(appState.scrollX, appState.scrollY);
      context.lineWidth = (activeEmbeddable ? 4 : 1) / appState.zoom.value;
      const count = selectionColors.length;
      for (let index = 0; index < count; ++index) {
        context.strokeStyle = selectionColors[index];
        if (dashed) {
          context.setLineDash([
            lineWidth,
            spaceWidth + (lineWidth + spaceWidth) * (count - 1)
          ]);
        }
        context.lineDashOffset = (lineWidth + spaceWidth) * index;
        strokeRectWithRotation(
          context,
          elementX1 - linePadding,
          elementY1 - linePadding,
          elementWidth + linePadding * 2,
          elementHeight + linePadding * 2,
          cx,
          cy,
          angle
        );
      }
      context.restore();
    };
    renderBindingHighlight = (context, appState, suggestedBinding, elementsMap) => {
      const renderHighlight = Array.isArray(suggestedBinding) ? renderBindingHighlightForSuggestedPointBinding : renderBindingHighlightForBindableElement;
      context.save();
      context.translate(appState.scrollX, appState.scrollY);
      renderHighlight(context, suggestedBinding, elementsMap);
      context.restore();
    };
    renderBindingHighlightForBindableElement = (context, element, elementsMap) => {
      const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);
      const width = x2 - x1;
      const height = y2 - y1;
      const threshold = maxBindingGap(element, width, height);
      const strokeOffset = 4;
      context.strokeStyle = "rgba(0,0,0,.05)";
      context.lineWidth = threshold - strokeOffset;
      const padding = strokeOffset / 2 + threshold / 2;
      switch (element.type) {
        case "rectangle":
        case "text":
        case "image":
        case "iframe":
        case "embeddable":
        case "frame":
        case "magicframe":
          strokeRectWithRotation(
            context,
            x1 - padding,
            y1 - padding,
            width + padding * 2,
            height + padding * 2,
            x1 + width / 2,
            y1 + height / 2,
            element.angle
          );
          break;
        case "diamond":
          const side = Math.hypot(width, height);
          const wPadding = padding * side / height;
          const hPadding = padding * side / width;
          strokeDiamondWithRotation(
            context,
            width + wPadding * 2,
            height + hPadding * 2,
            x1 + width / 2,
            y1 + height / 2,
            element.angle
          );
          break;
        case "ellipse":
          strokeEllipseWithRotation(
            context,
            width + padding * 2,
            height + padding * 2,
            x1 + width / 2,
            y1 + height / 2,
            element.angle
          );
          break;
      }
    };
    renderFrameHighlight = (context, appState, frame, elementsMap) => {
      const [x1, y1, x2, y2] = getElementAbsoluteCoords(frame, elementsMap);
      const width = x2 - x1;
      const height = y2 - y1;
      context.strokeStyle = "rgb(0,118,255)";
      context.lineWidth = FRAME_STYLE.strokeWidth / appState.zoom.value;
      context.save();
      context.translate(appState.scrollX, appState.scrollY);
      strokeRectWithRotation(
        context,
        x1,
        y1,
        width,
        height,
        x1 + width / 2,
        y1 + height / 2,
        frame.angle,
        false,
        FRAME_STYLE.radius / appState.zoom.value
      );
      context.restore();
    };
    renderElementsBoxHighlight = (context, appState, elements) => {
      const individualElements = elements.filter(
        (element) => element.groupIds.length === 0
      );
      const elementsInGroups = elements.filter(
        (element) => element.groupIds.length > 0
      );
      const getSelectionFromElements = (elements2) => {
        const [elementX1, elementY1, elementX2, elementY2] = getCommonBounds(elements2);
        return {
          angle: 0,
          elementX1,
          elementX2,
          elementY1,
          elementY2,
          selectionColors: ["rgb(0,118,255)"],
          dashed: false,
          cx: elementX1 + (elementX2 - elementX1) / 2,
          cy: elementY1 + (elementY2 - elementY1) / 2,
          activeEmbeddable: false
        };
      };
      const getSelectionForGroupId = (groupId) => {
        const groupElements = getElementsInGroup(elements, groupId);
        return getSelectionFromElements(groupElements);
      };
      Object.entries(selectGroupsFromGivenElements(elementsInGroups, appState)).filter(([id, isSelected]) => isSelected).map(([id, isSelected]) => id).map((groupId) => getSelectionForGroupId(groupId)).concat(
        individualElements.map((element) => getSelectionFromElements([element]))
      ).forEach(
        (selection) => renderSelectionBorder(context, appState, selection)
      );
    };
    renderBindingHighlightForSuggestedPointBinding = (context, suggestedBinding, elementsMap) => {
      const [element, startOrEnd, bindableElement] = suggestedBinding;
      const threshold = maxBindingGap(
        bindableElement,
        bindableElement.width,
        bindableElement.height
      );
      context.strokeStyle = "rgba(0,0,0,0)";
      context.fillStyle = "rgba(0,0,0,.05)";
      const pointIndices = startOrEnd === "both" ? [0, -1] : startOrEnd === "start" ? [0] : [-1];
      pointIndices.forEach((index) => {
        const [x, y] = LinearElementEditor.getPointAtIndexGlobalCoordinates(
          element,
          index,
          elementsMap
        );
        fillCircle(context, x, y, threshold);
      });
    };
    renderLinkIcon = (element, context, appState, elementsMap) => {
      if (element.link && !appState.selectedElementIds[element.id]) {
        const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);
        const [x, y, width, height] = getLinkHandleFromCoords(
          [x1, y1, x2, y2],
          element.angle,
          appState
        );
        const centerX = x + width / 2;
        const centerY = y + height / 2;
        context.save();
        context.translate(appState.scrollX + centerX, appState.scrollY + centerY);
        context.rotate(element.angle);
        if (!linkCanvasCache || linkCanvasCache.zoom !== appState.zoom.value) {
          linkCanvasCache = document.createElement("canvas");
          linkCanvasCache.zoom = appState.zoom.value;
          linkCanvasCache.width = width * window.devicePixelRatio * appState.zoom.value;
          linkCanvasCache.height = height * window.devicePixelRatio * appState.zoom.value;
          const linkCanvasCacheContext = linkCanvasCache.getContext("2d");
          linkCanvasCacheContext.scale(
            window.devicePixelRatio * appState.zoom.value,
            window.devicePixelRatio * appState.zoom.value
          );
          linkCanvasCacheContext.fillStyle = "#fff";
          linkCanvasCacheContext.fillRect(0, 0, width, height);
          linkCanvasCacheContext.drawImage(EXTERNAL_LINK_IMG, 0, 0, width, height);
          linkCanvasCacheContext.restore();
          context.drawImage(
            linkCanvasCache,
            x - centerX,
            y - centerY,
            width,
            height
          );
        } else {
          context.drawImage(
            linkCanvasCache,
            x - centerX,
            y - centerY,
            width,
            height
          );
        }
        context.restore();
      }
    };
    renderSceneToSvg = (elements, elementsMap, rsvg, svgRoot, files, renderConfig) => {
      if (!svgRoot) {
        return;
      }
      elements.filter((el) => !isIframeLikeElement(el)).forEach((element) => {
        if (!element.isDeleted) {
          try {
            renderElementToSvg(
              element,
              elementsMap,
              rsvg,
              svgRoot,
              files,
              element.x + renderConfig.offsetX,
              element.y + renderConfig.offsetY,
              renderConfig
            );
          } catch (error) {
            console.error(error);
          }
        }
      });
      elements.filter((el) => isIframeLikeElement(el)).forEach((element) => {
        if (!element.isDeleted) {
          try {
            renderElementToSvg(
              element,
              elementsMap,
              rsvg,
              svgRoot,
              files,
              element.x + renderConfig.offsetX,
              element.y + renderConfig.offsetY,
              renderConfig
            );
          } catch (error) {
            console.error(error);
          }
        }
      });
    };
  }
});

// data/filesystem.ts
import {
  fileOpen as _fileOpen,
  fileSave as _fileSave,
  supported as nativeFileSystemSupported
} from "browser-fs-access";
var INPUT_CHANGE_INTERVAL_MS, fileOpen, fileSave;
var init_filesystem = __esm({
  "data/filesystem.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_constants();
    init_errors();
    init_utils();
    INPUT_CHANGE_INTERVAL_MS = 500;
    fileOpen = (opts) => {
      const mimeTypes = opts.extensions?.reduce((mimeTypes2, type) => {
        mimeTypes2.push(MIME_TYPES[type]);
        return mimeTypes2;
      }, []);
      const extensions = opts.extensions?.reduce((acc, ext) => {
        if (ext === "jpg") {
          return acc.concat(".jpg", ".jpeg");
        }
        return acc.concat(`.${ext}`);
      }, []);
      return _fileOpen({
        description: opts.description,
        extensions,
        mimeTypes,
        multiple: opts.multiple ?? false,
        legacySetup: (resolve, reject, input) => {
          const scheduleRejection = debounce(reject, INPUT_CHANGE_INTERVAL_MS);
          const focusHandler = () => {
            checkForFile();
            document.addEventListener("keyup" /* KEYUP */, scheduleRejection);
            document.addEventListener("pointerup" /* POINTER_UP */, scheduleRejection);
            scheduleRejection();
          };
          const checkForFile = () => {
            if (input.files?.length) {
              const ret = opts.multiple ? [...input.files] : input.files[0];
              resolve(ret);
            }
          };
          requestAnimationFrame(() => {
            window.addEventListener("focus" /* FOCUS */, focusHandler);
          });
          const interval = window.setInterval(() => {
            checkForFile();
          }, INPUT_CHANGE_INTERVAL_MS);
          return (rejectPromise) => {
            clearInterval(interval);
            scheduleRejection.cancel();
            window.removeEventListener("focus" /* FOCUS */, focusHandler);
            document.removeEventListener("keyup" /* KEYUP */, scheduleRejection);
            document.removeEventListener("pointerup" /* POINTER_UP */, scheduleRejection);
            if (rejectPromise) {
              console.warn("Opening the file was canceled (legacy-fs).");
              rejectPromise(new AbortError());
            }
          };
        }
      });
    };
    fileSave = (blob, opts) => {
      return _fileSave(
        blob,
        {
          fileName: `${opts.name}.${opts.extension}`,
          description: opts.description,
          extensions: [`.${opts.extension}`]
        },
        opts.fileHandle
      );
    };
  }
});

// data/restore.ts
var AllowedExcalidrawActiveTools, getFontFamilyByName, repairBinding, restoreElementWithProperties, restoreElement, repairContainerElement, repairBoundElement, repairFrameMembership, restoreElements, coalesceAppStateValue, LegacyAppStateMigrations, restoreAppState, restore, restoreLibraryItem, restoreLibraryItems;
var init_restore = __esm({
  "data/restore.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_element();
    init_typeChecks();
    init_random();
    init_constants();
    init_appState();
    init_linearElementEditor();
    init_mutateElement();
    init_utils();
    init_utils();
    init_textElement();
    init_url();
    AllowedExcalidrawActiveTools = {
      selection: true,
      text: true,
      rectangle: true,
      diamond: true,
      ellipse: true,
      line: true,
      image: true,
      arrow: true,
      freedraw: true,
      eraser: false,
      custom: true,
      frame: true,
      embeddable: true,
      hand: true,
      laser: false,
      magicframe: false
    };
    getFontFamilyByName = (fontFamilyName) => {
      if (Object.keys(FONT_FAMILY).includes(fontFamilyName)) {
        return FONT_FAMILY[fontFamilyName];
      }
      return DEFAULT_FONT_FAMILY;
    };
    repairBinding = (binding) => {
      if (!binding) {
        return null;
      }
      return { ...binding, focus: binding.focus || 0 };
    };
    restoreElementWithProperties = (element, extra) => {
      const base = {
        type: extra.type || element.type,
        // all elements must have version > 0 so getSceneVersion() will pick up
        // newly added elements
        version: element.version || 1,
        versionNonce: element.versionNonce ?? 0,
        isDeleted: element.isDeleted ?? false,
        id: element.id || randomId(),
        fillStyle: element.fillStyle || DEFAULT_ELEMENT_PROPS.fillStyle,
        strokeWidth: element.strokeWidth || DEFAULT_ELEMENT_PROPS.strokeWidth,
        strokeStyle: element.strokeStyle ?? DEFAULT_ELEMENT_PROPS.strokeStyle,
        roughness: element.roughness ?? DEFAULT_ELEMENT_PROPS.roughness,
        opacity: element.opacity == null ? DEFAULT_ELEMENT_PROPS.opacity : element.opacity,
        angle: element.angle || 0,
        x: extra.x ?? element.x ?? 0,
        y: extra.y ?? element.y ?? 0,
        strokeColor: element.strokeColor || DEFAULT_ELEMENT_PROPS.strokeColor,
        backgroundColor: element.backgroundColor || DEFAULT_ELEMENT_PROPS.backgroundColor,
        width: element.width || 0,
        height: element.height || 0,
        seed: element.seed ?? 1,
        groupIds: element.groupIds ?? [],
        frameId: element.frameId ?? null,
        roundness: element.roundness ? element.roundness : element.strokeSharpness === "round" ? {
          // for old elements that would now use adaptive radius algo,
          // use legacy algo instead
          type: isUsingAdaptiveRadius(element.type) ? ROUNDNESS.LEGACY : ROUNDNESS.PROPORTIONAL_RADIUS
        } : null,
        boundElements: element.boundElementIds ? element.boundElementIds.map((id) => ({ type: "arrow", id })) : element.boundElements ?? [],
        updated: element.updated ?? getUpdatedTimestamp(),
        link: element.link ? normalizeLink(element.link) : null,
        locked: element.locked ?? false
      };
      if ("customData" in element || "customData" in extra) {
        base.customData = "customData" in extra ? extra.customData : element.customData;
      }
      if (PRECEDING_ELEMENT_KEY in element) {
        base[PRECEDING_ELEMENT_KEY] = element[PRECEDING_ELEMENT_KEY];
      }
      return {
        ...base,
        ...getNormalizedDimensions(base),
        ...extra
      };
    };
    restoreElement = (element) => {
      switch (element.type) {
        case "text":
          let fontSize = element.fontSize;
          let fontFamily = element.fontFamily;
          if ("font" in element) {
            const [fontPx, _fontFamily] = element.font.split(" ");
            fontSize = parseFloat(fontPx);
            fontFamily = getFontFamilyByName(_fontFamily);
          }
          const text = typeof element.text === "string" && element.text || "";
          const lineHeight = element.lineHeight || (element.height ? (
            // detect line-height from current element height and font-size
            detectLineHeight(element)
          ) : (
            // no element height likely means programmatic use, so default
            // to a fixed line height
            getDefaultLineHeight(element.fontFamily)
          ));
          const baseline = measureBaseline(
            element.text,
            getFontString(element),
            lineHeight
          );
          element = restoreElementWithProperties(element, {
            fontSize,
            fontFamily,
            text,
            textAlign: element.textAlign || DEFAULT_TEXT_ALIGN,
            verticalAlign: element.verticalAlign || DEFAULT_VERTICAL_ALIGN,
            containerId: element.containerId ?? null,
            originalText: element.originalText || text,
            lineHeight,
            baseline
          });
          if (!text && !element.isDeleted) {
            element = { ...element, originalText: text, isDeleted: true };
            element = bumpVersion(element);
          }
          return element;
        case "freedraw": {
          return restoreElementWithProperties(element, {
            points: element.points,
            lastCommittedPoint: null,
            simulatePressure: element.simulatePressure,
            pressures: element.pressures
          });
        }
        case "image":
          return restoreElementWithProperties(element, {
            status: element.status || "pending",
            fileId: element.fileId,
            scale: element.scale || [1, 1]
          });
        case "line":
        case "draw":
        case "arrow": {
          const {
            startArrowhead = null,
            endArrowhead = element.type === "arrow" ? "arrow" : null
          } = element;
          let x = element.x;
          let y = element.y;
          let points = (
            // migrate old arrow model to new one
            !Array.isArray(element.points) || element.points.length < 2 ? [
              [0, 0],
              [element.width, element.height]
            ] : element.points
          );
          if (points[0][0] !== 0 || points[0][1] !== 0) {
            ({ points, x, y } = LinearElementEditor.getNormalizedPoints(element));
          }
          return restoreElementWithProperties(element, {
            type: element.type === "draw" ? "line" : element.type,
            startBinding: repairBinding(element.startBinding),
            endBinding: repairBinding(element.endBinding),
            lastCommittedPoint: null,
            startArrowhead,
            endArrowhead,
            points,
            x,
            y
          });
        }
        case "ellipse":
        case "rectangle":
        case "diamond":
        case "iframe":
        case "embeddable":
          return restoreElementWithProperties(element, {});
        case "magicframe":
        case "frame":
          return restoreElementWithProperties(element, {
            name: element.name ?? null
          });
      }
      return null;
    };
    repairContainerElement = (container, elementsMap) => {
      if (container.boundElements) {
        const boundElements = container.boundElements.slice();
        const boundIds = /* @__PURE__ */ new Set();
        container.boundElements = boundElements.reduce(
          (acc, binding) => {
            const boundElement = elementsMap.get(binding.id);
            if (boundElement && !boundIds.has(binding.id)) {
              boundIds.add(binding.id);
              if (boundElement.isDeleted) {
                return acc;
              }
              acc.push(binding);
              if (isTextElement(boundElement) && // being slightly conservative here, preserving existing containerId
              // if defined, lest boundElements is stale
              !boundElement.containerId) {
                boundElement.containerId = container.id;
              }
            }
            return acc;
          },
          []
        );
      }
    };
    repairBoundElement = (boundElement, elementsMap) => {
      const container = boundElement.containerId ? elementsMap.get(boundElement.containerId) : null;
      if (!container) {
        boundElement.containerId = null;
        return;
      }
      if (boundElement.isDeleted) {
        return;
      }
      if (container.boundElements && !container.boundElements.find((binding) => binding.id === boundElement.id)) {
        const boundElements = (container.boundElements || (container.boundElements = [])).slice();
        boundElements.push({ type: "text", id: boundElement.id });
        container.boundElements = boundElements;
      }
    };
    repairFrameMembership = (element, elementsMap) => {
      if (element.frameId) {
        const containingFrame = elementsMap.get(element.frameId);
        if (!containingFrame) {
          element.frameId = null;
        }
      }
    };
    restoreElements = (elements, localElements, opts) => {
      const existingIds = /* @__PURE__ */ new Set();
      const localElementsMap = localElements ? arrayToMap(localElements) : null;
      const restoredElements = (elements || []).reduce((elements2, element) => {
        if (element.type !== "selection" && !isInvisiblySmallElement(element)) {
          let migratedElement = restoreElement(element);
          if (migratedElement) {
            const localElement = localElementsMap?.get(element.id);
            if (localElement && localElement.version > migratedElement.version) {
              migratedElement = bumpVersion(migratedElement, localElement.version);
            }
            if (existingIds.has(migratedElement.id)) {
              migratedElement = { ...migratedElement, id: randomId() };
            }
            existingIds.add(migratedElement.id);
            elements2.push(migratedElement);
          }
        }
        return elements2;
      }, []);
      if (!opts?.repairBindings) {
        return restoredElements;
      }
      const restoredElementsMap = arrayToMap(restoredElements);
      for (const element of restoredElements) {
        if (element.frameId) {
          repairFrameMembership(element, restoredElementsMap);
        }
        if (isTextElement(element) && element.containerId) {
          repairBoundElement(element, restoredElementsMap);
        } else if (element.boundElements) {
          repairContainerElement(element, restoredElementsMap);
        }
        if (opts.refreshDimensions && isTextElement(element)) {
          Object.assign(
            element,
            refreshTextDimensions(
              element,
              getContainerElement(element, restoredElementsMap),
              restoredElementsMap
            )
          );
        }
      }
      return restoredElements;
    };
    coalesceAppStateValue = (key, appState, defaultAppState2) => {
      const value = appState[key];
      return value !== void 0 ? value : defaultAppState2[key];
    };
    LegacyAppStateMigrations = {
      isSidebarDocked: (appState, defaultAppState2) => {
        return [
          "defaultSidebarDockedPreference",
          appState.isSidebarDocked ?? coalesceAppStateValue(
            "defaultSidebarDockedPreference",
            appState,
            defaultAppState2
          )
        ];
      }
    };
    restoreAppState = (appState, localAppState) => {
      appState = appState || {};
      const defaultAppState2 = getDefaultAppState();
      const nextAppState = {};
      for (const legacyKey of Object.keys(
        LegacyAppStateMigrations
      )) {
        if (legacyKey in appState) {
          const [nextKey, nextValue] = LegacyAppStateMigrations[legacyKey](
            appState,
            defaultAppState2
          );
          nextAppState[nextKey] = nextValue;
        }
      }
      for (const [key, defaultValue] of Object.entries(defaultAppState2)) {
        const suppliedValue = appState[key];
        const localValue = localAppState ? localAppState[key] : void 0;
        nextAppState[key] = suppliedValue !== void 0 ? suppliedValue : localValue !== void 0 ? localValue : defaultValue;
      }
      return {
        ...nextAppState,
        cursorButton: localAppState?.cursorButton || "up",
        // reset on fresh restore so as to hide the UI button if penMode not active
        penDetected: localAppState?.penDetected ?? (appState.penMode ? appState.penDetected ?? false : false),
        activeTool: {
          ...updateActiveTool(
            defaultAppState2,
            nextAppState.activeTool.type && AllowedExcalidrawActiveTools[nextAppState.activeTool.type] ? nextAppState.activeTool : { type: "selection" }
          ),
          lastActiveTool: null,
          locked: nextAppState.activeTool.locked ?? false
        },
        // Migrates from previous version where appState.zoom was a number
        zoom: typeof appState.zoom === "number" ? {
          value: appState.zoom
        } : appState.zoom?.value ? appState.zoom : defaultAppState2.zoom,
        openSidebar: (
          // string (legacy)
          typeof appState.openSidebar === "string" ? { name: DEFAULT_SIDEBAR.name } : nextAppState.openSidebar
        )
      };
    };
    restore = (data, localAppState, localElements, elementsConfig) => {
      return {
        elements: restoreElements(data?.elements, localElements, elementsConfig),
        appState: restoreAppState(data?.appState, localAppState || null),
        files: data?.files || {}
      };
    };
    restoreLibraryItem = (libraryItem) => {
      const elements = restoreElements(
        getNonDeletedElements3(libraryItem.elements),
        null
      );
      return elements.length ? { ...libraryItem, elements } : null;
    };
    restoreLibraryItems = (libraryItems = [], defaultStatus) => {
      const restoredItems = [];
      for (const item of libraryItems) {
        if (Array.isArray(item)) {
          const restoredItem = restoreLibraryItem({
            status: defaultStatus,
            elements: item,
            id: randomId(),
            created: Date.now()
          });
          if (restoredItem) {
            restoredItems.push(restoredItem);
          }
        } else {
          const _item = item;
          const restoredItem = restoreLibraryItem({
            ..._item,
            id: _item.id || randomId(),
            status: _item.status || defaultStatus,
            created: _item.created || Date.now()
          });
          if (restoredItem) {
            restoredItems.push(restoredItem);
          }
        }
      }
      return restoredItems;
    };
  }
});

// data/encryption.ts
var init_encryption = __esm({
  "data/encryption.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_constants();
    init_blob();
  }
});

// data/encode.ts
import { deflate, inflate } from "pako";
var toByteString, byteStringToArrayBuffer, byteStringToString, stringToBase64, base64ToString, encode, decode;
var init_encode = __esm({
  "data/encode.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_encryption();
    toByteString = (data) => {
      return new Promise((resolve, reject) => {
        const blob = typeof data === "string" ? new Blob([new TextEncoder().encode(data)]) : new Blob([data instanceof Uint8Array ? data : new Uint8Array(data)]);
        const reader = new FileReader();
        reader.onload = (event) => {
          if (!event.target || typeof event.target.result !== "string") {
            return reject(new Error("couldn't convert to byte string"));
          }
          resolve(event.target.result);
        };
        reader.readAsBinaryString(blob);
      });
    };
    byteStringToArrayBuffer = (byteString) => {
      const buffer = new ArrayBuffer(byteString.length);
      const bufferView = new Uint8Array(buffer);
      for (let i = 0, len = byteString.length; i < len; i++) {
        bufferView[i] = byteString.charCodeAt(i);
      }
      return buffer;
    };
    byteStringToString = (byteString) => {
      return new TextDecoder("utf-8").decode(byteStringToArrayBuffer(byteString));
    };
    stringToBase64 = async (str, isByteString = false) => {
      return isByteString ? window.btoa(str) : window.btoa(await toByteString(str));
    };
    base64ToString = async (base64, isByteString = false) => {
      return isByteString ? window.atob(base64) : byteStringToString(window.atob(base64));
    };
    encode = async ({
      text,
      compress
    }) => {
      let deflated;
      if (compress !== false) {
        try {
          deflated = await toByteString(deflate(text));
        } catch (error) {
          console.error("encode: cannot deflate", error);
        }
      }
      return {
        version: "1",
        encoding: "bstring",
        compressed: !!deflated,
        encoded: deflated || await toByteString(text)
      };
    };
    decode = async (data) => {
      let decoded;
      switch (data.encoding) {
        case "bstring":
          decoded = data.compressed ? data.encoded : await byteStringToString(data.encoded);
          break;
        default:
          throw new Error(`decode: unknown encoding "${data.encoding}"`);
      }
      if (data.compressed) {
        return inflate(new Uint8Array(byteStringToArrayBuffer(decoded)), {
          to: "string"
        });
      }
      return decoded;
    };
  }
});

// data/image.ts
var image_exports = {};
__export(image_exports, {
  decodePngMetadata: () => decodePngMetadata,
  decodeSvgMetadata: () => decodeSvgMetadata,
  encodePngMetadata: () => encodePngMetadata,
  encodeSvgMetadata: () => encodeSvgMetadata,
  getTEXtChunk: () => getTEXtChunk
});
import decodePng from "png-chunks-extract";
import tEXt from "png-chunk-text";
import encodePng from "png-chunks-encode";
var getTEXtChunk, encodePngMetadata, decodePngMetadata, encodeSvgMetadata, decodeSvgMetadata;
var init_image = __esm({
  "data/image.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_encode();
    init_constants();
    init_blob();
    getTEXtChunk = async (blob) => {
      const chunks = decodePng(new Uint8Array(await blobToArrayBuffer(blob)));
      const metadataChunk = chunks.find((chunk2) => chunk2.name === "tEXt");
      if (metadataChunk) {
        return tEXt.decode(metadataChunk.data);
      }
      return null;
    };
    encodePngMetadata = async ({
      blob,
      metadata
    }) => {
      const chunks = decodePng(new Uint8Array(await blobToArrayBuffer(blob)));
      const metadataChunk = tEXt.encode(
        MIME_TYPES.excalidraw,
        JSON.stringify(
          await encode({
            text: metadata,
            compress: true
          })
        )
      );
      chunks.splice(-1, 0, metadataChunk);
      return new Blob([encodePng(chunks)], { type: MIME_TYPES.png });
    };
    decodePngMetadata = async (blob) => {
      const metadata = await getTEXtChunk(blob);
      if (metadata?.keyword === MIME_TYPES.excalidraw) {
        try {
          const encodedData = JSON.parse(metadata.text);
          if (!("encoded" in encodedData)) {
            if ("type" in encodedData && encodedData.type === EXPORT_DATA_TYPES.excalidraw) {
              return metadata.text;
            }
            throw new Error("FAILED");
          }
          return await decode(encodedData);
        } catch (error) {
          console.error(error);
          throw new Error("FAILED");
        }
      }
      throw new Error("INVALID");
    };
    encodeSvgMetadata = async ({ text }) => {
      const base64 = await stringToBase64(
        JSON.stringify(await encode({ text })),
        true
      );
      let metadata = "";
      metadata += `<!-- payload-type:${MIME_TYPES.excalidraw} -->`;
      metadata += `<!-- payload-version:2 -->`;
      metadata += "<!-- payload-start -->";
      metadata += base64;
      metadata += "<!-- payload-end -->";
      return metadata;
    };
    decodeSvgMetadata = async ({ svg }) => {
      if (svg.includes(`payload-type:${MIME_TYPES.excalidraw}`)) {
        const match = svg.match(
          /<!-- payload-start -->\s*(.+?)\s*<!-- payload-end -->/
        );
        if (!match) {
          throw new Error("INVALID");
        }
        const versionMatch = svg.match(/<!-- payload-version:(\d+) -->/);
        const version = versionMatch?.[1] || "1";
        const isByteString = version !== "1";
        try {
          const json = await base64ToString(match[1], isByteString);
          const encodedData = JSON.parse(json);
          if (!("encoded" in encodedData)) {
            if ("type" in encodedData && encodedData.type === EXPORT_DATA_TYPES.excalidraw) {
              return json;
            }
            throw new Error("FAILED");
          }
          return await decode(encodedData);
        } catch (error) {
          console.error(error);
          throw new Error("FAILED");
        }
      }
      throw new Error("INVALID");
    };
  }
});

// data/blob.ts
import { nanoid as nanoid2 } from "nanoid";
var parseFileContents, getFileHandleType, isImageFileHandleType, isImageFileHandle, isSupportedImageFile, loadSceneOrLibraryFromBlob, loadFromBlob, parseLibraryJSON, loadLibraryFromBlob, canvasToBlob, generateIdFromFile, getDataURL, dataURLToFile, resizeImageFile, SVGStringToFile, ImageURLToFile, getFileFromEvent, getFileHandle, getActualMimeTypeFromImage, createFile, normalizeFile, blobToArrayBuffer;
var init_blob = __esm({
  "data/blob.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_appState();
    init_constants();
    init_element();
    init_errors();
    init_i18n();
    init_scene();
    init_utils();
    init_filesystem();
    init_json();
    init_restore();
    parseFileContents = async (blob) => {
      let contents;
      if (blob.type === MIME_TYPES.png) {
        try {
          return await (await Promise.resolve().then(() => (init_image(), image_exports))).decodePngMetadata(blob);
        } catch (error) {
          if (error.message === "INVALID") {
            throw new ImageSceneDataError(
              t("alerts.imageDoesNotContainScene"),
              "IMAGE_NOT_CONTAINS_SCENE_DATA"
            );
          } else {
            throw new ImageSceneDataError(t("alerts.cannotRestoreFromImage"));
          }
        }
      } else {
        if ("text" in Blob) {
          contents = await blob.text();
        } else {
          contents = await new Promise((resolve) => {
            const reader = new FileReader();
            reader.readAsText(blob, "utf8");
            reader.onloadend = () => {
              if (reader.readyState === FileReader.DONE) {
                resolve(reader.result);
              }
            };
          });
        }
        if (blob.type === MIME_TYPES.svg) {
          try {
            return await (await Promise.resolve().then(() => (init_image(), image_exports))).decodeSvgMetadata({
              svg: contents
            });
          } catch (error) {
            if (error.message === "INVALID") {
              throw new ImageSceneDataError(
                t("alerts.imageDoesNotContainScene"),
                "IMAGE_NOT_CONTAINS_SCENE_DATA"
              );
            } else {
              throw new ImageSceneDataError(t("alerts.cannotRestoreFromImage"));
            }
          }
        }
      }
      return contents;
    };
    getFileHandleType = (handle) => {
      if (!handle) {
        return null;
      }
      return handle.name.match(/\.(json|excalidraw|png|svg)$/)?.[1] || null;
    };
    isImageFileHandleType = (type) => {
      return type === "png" || type === "svg";
    };
    isImageFileHandle = (handle) => {
      const type = getFileHandleType(handle);
      return type === "png" || type === "svg";
    };
    isSupportedImageFile = (blob) => {
      const { type } = blob || {};
      return !!type && Object.values(IMAGE_MIME_TYPES).includes(type);
    };
    loadSceneOrLibraryFromBlob = async (blob, localAppState, localElements, fileHandle) => {
      const contents = await parseFileContents(blob);
      let data;
      try {
        try {
          data = JSON.parse(contents);
        } catch (error) {
          if (isSupportedImageFile(blob)) {
            throw new ImageSceneDataError(
              t("alerts.imageDoesNotContainScene"),
              "IMAGE_NOT_CONTAINS_SCENE_DATA"
            );
          }
          throw error;
        }
        if (isValidExcalidrawData(data)) {
          return {
            type: MIME_TYPES.excalidraw,
            data: restore(
              {
                elements: clearElementsForExport(data.elements || []),
                appState: {
                  theme: localAppState?.theme,
                  fileHandle: fileHandle || blob.handle || null,
                  ...cleanAppStateForExport(data.appState || {}),
                  ...localAppState ? calculateScrollCenter(data.elements || [], localAppState) : {}
                },
                files: data.files
              },
              localAppState,
              localElements,
              { repairBindings: true, refreshDimensions: false }
            )
          };
        } else if (isValidLibrary(data)) {
          return {
            type: MIME_TYPES.excalidrawlib,
            data
          };
        }
        throw new Error(t("alerts.couldNotLoadInvalidFile"));
      } catch (error) {
        if (error instanceof ImageSceneDataError) {
          throw error;
        }
        throw new Error(t("alerts.couldNotLoadInvalidFile"));
      }
    };
    loadFromBlob = async (blob, localAppState, localElements, fileHandle) => {
      const ret = await loadSceneOrLibraryFromBlob(
        blob,
        localAppState,
        localElements,
        fileHandle
      );
      if (ret.type !== MIME_TYPES.excalidraw) {
        throw new Error(t("alerts.couldNotLoadInvalidFile"));
      }
      return ret.data;
    };
    parseLibraryJSON = (json, defaultStatus = "unpublished") => {
      const data = JSON.parse(json);
      if (!isValidLibrary(data)) {
        throw new Error("Invalid library");
      }
      const libraryItems = data.libraryItems || data.library;
      return restoreLibraryItems(libraryItems, defaultStatus);
    };
    loadLibraryFromBlob = async (blob, defaultStatus = "unpublished") => {
      return parseLibraryJSON(await parseFileContents(blob), defaultStatus);
    };
    canvasToBlob = async (canvas2) => {
      return new Promise(async (resolve, reject) => {
        try {
          if (isPromiseLike(canvas2)) {
            canvas2 = await canvas2;
          }
          canvas2.toBlob((blob) => {
            if (!blob) {
              return reject(
                new CanvasError(
                  t("canvasError.canvasTooBig"),
                  "CANVAS_POSSIBLY_TOO_BIG"
                )
              );
            }
            resolve(blob);
          });
        } catch (error) {
          reject(error);
        }
      });
    };
    generateIdFromFile = async (file2) => {
      try {
        const hashBuffer = await window.crypto.subtle.digest(
          "SHA-1",
          await blobToArrayBuffer(file2)
        );
        return bytesToHexString(new Uint8Array(hashBuffer));
      } catch (error) {
        console.error(error);
        return nanoid2(40);
      }
    };
    getDataURL = async (file2) => {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => {
          const dataURL = reader.result;
          resolve(dataURL);
        };
        reader.onerror = (error) => reject(error);
        reader.readAsDataURL(file2);
      });
    };
    dataURLToFile = (dataURL, filename = "") => {
      const dataIndexStart = dataURL.indexOf(",");
      const byteString = atob(dataURL.slice(dataIndexStart + 1));
      const mimeType = dataURL.slice(0, dataIndexStart).split(":")[1].split(";")[0];
      const ab = new ArrayBuffer(byteString.length);
      const ia = new Uint8Array(ab);
      for (let i = 0; i < byteString.length; i++) {
        ia[i] = byteString.charCodeAt(i);
      }
      return new File([ab], filename, { type: mimeType });
    };
    resizeImageFile = async (file2, opts) => {
      if (file2.type === MIME_TYPES.svg) {
        return file2;
      }
      const [pica, imageBlobReduce] = await Promise.all([
        import("pica").then((res) => res.default),
        // a wrapper for pica for better API
        import("image-blob-reduce").then((res) => res.default)
      ]);
      const reduce = imageBlobReduce({
        pica: pica({ features: ["js", "wasm"] })
      });
      if (opts.outputType) {
        const { outputType } = opts;
        reduce._create_blob = function(env) {
          return this.pica.toBlob(env.out_canvas, outputType, 0.8).then((blob) => {
            env.out_blob = blob;
            return env;
          });
        };
      }
      if (!isSupportedImageFile(file2)) {
        throw new Error(t("errors.unsupportedFileType"));
      }
      return new File(
        [await reduce.toBlob(file2, { max: opts.maxWidthOrHeight })],
        file2.name,
        {
          type: opts.outputType || file2.type
        }
      );
    };
    SVGStringToFile = (SVGString, filename = "") => {
      return new File([new TextEncoder().encode(SVGString)], filename, {
        type: MIME_TYPES.svg
      });
    };
    ImageURLToFile = async (imageUrl, filename = "") => {
      let response;
      try {
        response = await fetch(imageUrl);
      } catch (error) {
        throw new Error(t("errors.failedToFetchImage"));
      }
      if (!response.ok) {
        throw new Error(t("errors.failedToFetchImage"));
      }
      const blob = await response.blob();
      if (blob.type && isSupportedImageFile(blob)) {
        const name = filename || blob.name || "";
        return new File([blob], name, { type: blob.type });
      }
      throw new Error(t("errors.unsupportedFileType"));
    };
    getFileFromEvent = async (event) => {
      const file2 = event.dataTransfer.files.item(0);
      const fileHandle = await getFileHandle(event);
      return { file: file2 ? await normalizeFile(file2) : null, fileHandle };
    };
    getFileHandle = async (event) => {
      if (nativeFileSystemSupported) {
        try {
          const item = event.dataTransfer.items[0];
          const handle = await item.getAsFileSystemHandle() || null;
          return handle;
        } catch (error) {
          console.warn(error.name, error.message);
          return null;
        }
      }
      return null;
    };
    getActualMimeTypeFromImage = (buffer) => {
      let mimeType = null;
      const first8Bytes = `${[...new Uint8Array(buffer).slice(0, 8)].join(" ")} `;
      const headerBytes = {
        // https://en.wikipedia.org/wiki/Portable_Network_Graphics#File_header
        png: "137 80 78 71 13 10 26 10 ",
        // https://en.wikipedia.org/wiki/JPEG#Syntax_and_structure
        // jpg is a bit wonky. Checking the first three bytes should be enough,
        // but may yield false positives. (https://stackoverflow.com/a/23360709/927631)
        jpg: "255 216 255 ",
        // https://en.wikipedia.org/wiki/GIF#Example_GIF_file
        gif: "71 73 70 56 57 97 "
      };
      if (first8Bytes === headerBytes.png) {
        mimeType = MIME_TYPES.png;
      } else if (first8Bytes.startsWith(headerBytes.jpg)) {
        mimeType = MIME_TYPES.jpg;
      } else if (first8Bytes.startsWith(headerBytes.gif)) {
        mimeType = MIME_TYPES.gif;
      }
      return mimeType;
    };
    createFile = (blob, mimeType, name) => {
      return new File([blob], name || "", {
        type: mimeType
      });
    };
    normalizeFile = async (file2) => {
      if (!file2.type) {
        if (file2?.name?.endsWith(".excalidrawlib")) {
          file2 = createFile(
            await blobToArrayBuffer(file2),
            MIME_TYPES.excalidrawlib,
            file2.name
          );
        } else if (file2?.name?.endsWith(".excalidraw")) {
          file2 = createFile(
            await blobToArrayBuffer(file2),
            MIME_TYPES.excalidraw,
            file2.name
          );
        } else {
          const buffer = await blobToArrayBuffer(file2);
          const mimeType = getActualMimeTypeFromImage(buffer);
          if (mimeType) {
            file2 = createFile(buffer, mimeType, file2.name);
          }
        }
      } else if (isSupportedImageFile(file2)) {
        const buffer = await blobToArrayBuffer(file2);
        const mimeType = getActualMimeTypeFromImage(buffer);
        if (mimeType && mimeType !== file2.type) {
          file2 = createFile(buffer, mimeType, file2.name);
        }
      }
      return file2;
    };
    blobToArrayBuffer = (blob) => {
      if ("arrayBuffer" in blob) {
        return blob.arrayBuffer();
      }
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (event) => {
          if (!event.target?.result) {
            return reject(new Error("Couldn't convert blob to ArrayBuffer"));
          }
          resolve(event.target.result);
        };
        reader.readAsArrayBuffer(blob);
      });
    };
  }
});

// data/json.ts
var filterOutDeletedFiles, serializeAsJSON, saveAsJSON, loadFromJSON, isValidExcalidrawData, isValidLibrary, serializeLibraryAsJSON, saveLibraryAsJSON;
var init_json = __esm({
  "data/json.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_filesystem();
    init_appState();
    init_constants();
    init_element();
    init_blob();
    filterOutDeletedFiles = (elements, files) => {
      const nextFiles = {};
      for (const element of elements) {
        if (!element.isDeleted && "fileId" in element && element.fileId && files[element.fileId]) {
          nextFiles[element.fileId] = files[element.fileId];
        }
      }
      return nextFiles;
    };
    serializeAsJSON = (elements, appState, files, type) => {
      const data = {
        type: EXPORT_DATA_TYPES.excalidraw,
        version: VERSIONS.excalidraw,
        source: EXPORT_SOURCE,
        elements: type === "local" ? clearElementsForExport(elements) : clearElementsForDatabase(elements),
        appState: type === "local" ? cleanAppStateForExport(appState) : clearAppStateForDatabase(appState),
        files: type === "local" ? filterOutDeletedFiles(elements, files) : (
          // will be stripped from JSON
          void 0
        )
      };
      return JSON.stringify(data, null, 2);
    };
    saveAsJSON = async (elements, appState, files, name = appState.name || DEFAULT_FILENAME) => {
      const serialized = serializeAsJSON(elements, appState, files, "local");
      const blob = new Blob([serialized], {
        type: MIME_TYPES.excalidraw
      });
      const fileHandle = await fileSave(blob, {
        name,
        extension: "excalidraw",
        description: "Excalidraw file",
        fileHandle: isImageFileHandle(appState.fileHandle) ? null : appState.fileHandle
      });
      return { fileHandle };
    };
    loadFromJSON = async (localAppState, localElements) => {
      const file2 = await fileOpen({
        description: "Excalidraw files"
        // ToDo: Be over-permissive until https://bugs.webkit.org/show_bug.cgi?id=34442
        // gets resolved. Else, iOS users cannot open `.excalidraw` files.
        // extensions: ["json", "excalidraw", "png", "svg"],
      });
      return loadFromBlob(
        await normalizeFile(file2),
        localAppState,
        localElements,
        file2.handle
      );
    };
    isValidExcalidrawData = (data) => {
      return data?.type === EXPORT_DATA_TYPES.excalidraw && (!data.elements || Array.isArray(data.elements) && (!data.appState || typeof data.appState === "object"));
    };
    isValidLibrary = (json) => {
      return typeof json === "object" && json && json.type === EXPORT_DATA_TYPES.excalidrawLibrary && (json.version === 1 || json.version === 2);
    };
    serializeLibraryAsJSON = (libraryItems) => {
      const data = {
        type: EXPORT_DATA_TYPES.excalidrawLibrary,
        version: VERSIONS.excalidrawLibrary,
        source: EXPORT_SOURCE,
        libraryItems
      };
      return JSON.stringify(data, null, 2);
    };
    saveLibraryAsJSON = async (libraryItems) => {
      const serialized = serializeLibraryAsJSON(libraryItems);
      await fileSave(
        new Blob([serialized], {
          type: MIME_TYPES.excalidrawlib
        }),
        {
          name: "library",
          extension: "excalidrawlib",
          description: "Excalidraw library file"
        }
      );
    };
  }
});

// element/image.ts
var loadHTMLImageElement, updateImageCache, getInitializedImageElements, isHTMLSVGElement, normalizeSVG;
var init_image2 = __esm({
  "element/image.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_constants();
    init_i18n();
    init_typeChecks();
    loadHTMLImageElement = (dataURL) => {
      return new Promise((resolve, reject) => {
        const image = new Image();
        image.onload = () => {
          resolve(image);
        };
        image.onerror = (error) => {
          reject(error);
        };
        image.src = dataURL;
      });
    };
    updateImageCache = async ({
      fileIds,
      files,
      imageCache
    }) => {
      const updatedFiles = /* @__PURE__ */ new Map();
      const erroredFiles = /* @__PURE__ */ new Map();
      await Promise.all(
        fileIds.reduce((promises, fileId) => {
          const fileData = files[fileId];
          if (fileData && !updatedFiles.has(fileId)) {
            updatedFiles.set(fileId, true);
            return promises.concat(
              (async () => {
                try {
                  if (fileData.mimeType === MIME_TYPES.binary) {
                    throw new Error("Only images can be added to ImageCache");
                  }
                  const imagePromise = loadHTMLImageElement(fileData.dataURL);
                  const data = {
                    image: imagePromise,
                    mimeType: fileData.mimeType
                  };
                  imageCache.set(fileId, data);
                  const image = await imagePromise;
                  imageCache.set(fileId, { ...data, image });
                } catch (error) {
                  erroredFiles.set(fileId, true);
                }
              })()
            );
          }
          return promises;
        }, [])
      );
      return {
        imageCache,
        /** includes errored files because they cache was updated nonetheless */
        updatedFiles,
        /** files that failed when creating HTMLImageElement */
        erroredFiles
      };
    };
    getInitializedImageElements = (elements) => elements.filter(
      (element) => isInitializedImageElement(element)
    );
    isHTMLSVGElement = (node) => {
      return node?.nodeName.toLowerCase() === "svg";
    };
    normalizeSVG = async (SVGString) => {
      const doc = new DOMParser().parseFromString(SVGString, MIME_TYPES.svg);
      const svg = doc.querySelector("svg");
      const errorNode = doc.querySelector("parsererror");
      if (errorNode || !isHTMLSVGElement(svg)) {
        throw new Error(t("errors.invalidSVGString"));
      } else {
        if (!svg.hasAttribute("xmlns")) {
          svg.setAttribute("xmlns", SVG_NS);
        }
        if (!svg.hasAttribute("width") || !svg.hasAttribute("height")) {
          const viewBox = svg.getAttribute("viewBox");
          let width = svg.getAttribute("width") || "50";
          let height = svg.getAttribute("height") || "50";
          if (viewBox) {
            const match = viewBox.match(/\d+ +\d+ +(\d+) +(\d+)/);
            if (match) {
              [, width, height] = match;
            }
          }
          svg.setAttribute("width", width);
          svg.setAttribute("height", height);
        }
        return svg.outerHTML;
      }
    };
  }
});

// scene/export.ts
import rough2 from "roughjs/bin/rough";
var SVG_EXPORT_TAG, __createSceneForElementsHack__, truncateText, addFrameLabelsAsTextElements, getFrameRenderingConfig, prepareElementsForRender, exportToCanvas, exportToSvg, getCanvasSize, getExportSize;
var init_export = __esm({
  "scene/export.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_bounds();
    init_renderScene();
    init_utils();
    init_constants();
    init_appState();
    init_json();
    init_image2();
    init_frame();
    init_element();
    init_mutateElement();
    init_Scene();
    init_typeChecks();
    SVG_EXPORT_TAG = `<!-- svg-source:excalidraw -->`;
    __createSceneForElementsHack__ = (elements) => {
      const scene = new Scene_default();
      scene.replaceAllElements(cloneJSON(elements), false);
      return scene;
    };
    truncateText = (element, maxWidth) => {
      if (element.width <= maxWidth) {
        return element;
      }
      const canvas2 = document.createElement("canvas");
      const ctx = canvas2.getContext("2d");
      ctx.font = getFontString({
        fontFamily: element.fontFamily,
        fontSize: element.fontSize
      });
      let text = element.text;
      const metrics = ctx.measureText(text);
      if (metrics.width > maxWidth) {
        for (let i = text.length; i > 0; i--) {
          const newText = `${text.slice(0, i)}...`;
          if (ctx.measureText(newText).width <= maxWidth) {
            text = newText;
            break;
          }
        }
      }
      return newElementWith(element, { text, width: maxWidth });
    };
    addFrameLabelsAsTextElements = (elements, opts) => {
      const nextElements = [];
      let frameIndex = 0;
      let magicFrameIndex = 0;
      for (const element of elements) {
        if (isFrameLikeElement(element)) {
          if (isFrameElement(element)) {
            frameIndex++;
          } else {
            magicFrameIndex++;
          }
          let textElement = newTextElement({
            x: element.x,
            y: element.y - FRAME_STYLE.nameOffsetY,
            fontFamily: FONT_FAMILY.Assistant,
            fontSize: FRAME_STYLE.nameFontSize,
            lineHeight: FRAME_STYLE.nameLineHeight,
            strokeColor: opts.exportWithDarkMode ? FRAME_STYLE.nameColorDarkTheme : FRAME_STYLE.nameColorLightTheme,
            text: getFrameLikeTitle(
              element,
              isFrameElement(element) ? frameIndex : magicFrameIndex
            )
          });
          textElement.y -= textElement.height;
          textElement = truncateText(textElement, element.width);
          nextElements.push(textElement);
        }
        nextElements.push(element);
      }
      return nextElements;
    };
    getFrameRenderingConfig = (exportingFrame, frameRendering) => {
      frameRendering = frameRendering || getDefaultAppState().frameRendering;
      return {
        enabled: exportingFrame ? true : frameRendering.enabled,
        outline: exportingFrame ? false : frameRendering.outline,
        name: exportingFrame ? false : frameRendering.name,
        clip: exportingFrame ? true : frameRendering.clip
      };
    };
    prepareElementsForRender = ({
      elements,
      exportingFrame,
      frameRendering,
      exportWithDarkMode
    }) => {
      let nextElements;
      if (exportingFrame) {
        nextElements = getElementsOverlappingFrame(elements, exportingFrame);
      } else if (frameRendering.enabled && frameRendering.name) {
        nextElements = addFrameLabelsAsTextElements(elements, {
          exportWithDarkMode
        });
      } else {
        nextElements = elements;
      }
      return nextElements;
    };
    exportToCanvas = async (elements, appState, files, {
      exportBackground,
      exportPadding = DEFAULT_EXPORT_PADDING,
      viewBackgroundColor,
      exportingFrame
    }, createCanvas = (width, height) => {
      const canvas2 = document.createElement("canvas");
      canvas2.width = width * appState.exportScale;
      canvas2.height = height * appState.exportScale;
      return { canvas: canvas2, scale: appState.exportScale };
    }) => {
      const tempScene = __createSceneForElementsHack__(elements);
      elements = tempScene.getNonDeletedElements();
      const frameRendering = getFrameRenderingConfig(
        exportingFrame ?? null,
        appState.frameRendering ?? null
      );
      const elementsForRender = prepareElementsForRender({
        elements,
        exportingFrame,
        exportWithDarkMode: appState.exportWithDarkMode,
        frameRendering
      });
      if (exportingFrame) {
        exportPadding = 0;
      }
      const [minX, minY, width, height] = getCanvasSize(
        exportingFrame ? [exportingFrame] : getRootElements(elementsForRender),
        exportPadding
      );
      const { canvas: canvas2, scale = 1 } = createCanvas(width, height);
      const defaultAppState2 = getDefaultAppState();
      const { imageCache } = await updateImageCache({
        imageCache: /* @__PURE__ */ new Map(),
        fileIds: getInitializedImageElements(elementsForRender).map(
          (element) => element.fileId
        ),
        files
      });
      renderStaticScene({
        canvas: canvas2,
        rc: rough2.canvas(canvas2),
        elementsMap: toBrandedType(
          arrayToMap(elementsForRender)
        ),
        allElementsMap: toBrandedType(
          arrayToMap(elements)
        ),
        visibleElements: elementsForRender,
        scale,
        appState: {
          ...appState,
          frameRendering,
          viewBackgroundColor: exportBackground ? viewBackgroundColor : null,
          scrollX: -minX + exportPadding,
          scrollY: -minY + exportPadding,
          zoom: defaultAppState2.zoom,
          shouldCacheIgnoreZoom: false,
          theme: appState.exportWithDarkMode ? "dark" : "light"
        },
        renderConfig: {
          canvasBackgroundColor: viewBackgroundColor,
          imageCache,
          renderGrid: false,
          isExporting: true,
          // empty disables embeddable rendering
          embedsValidationStatus: /* @__PURE__ */ new Map(),
          elementsPendingErasure: /* @__PURE__ */ new Set()
        }
      });
      tempScene.destroy();
      return canvas2;
    };
    exportToSvg = async (elements, appState, files, opts) => {
      const tempScene = __createSceneForElementsHack__(elements);
      elements = tempScene.getNonDeletedElements();
      const frameRendering = getFrameRenderingConfig(
        opts?.exportingFrame ?? null,
        appState.frameRendering ?? null
      );
      let {
        exportPadding = DEFAULT_EXPORT_PADDING,
        exportWithDarkMode = false,
        viewBackgroundColor,
        exportScale = 1,
        exportEmbedScene
      } = appState;
      const { exportingFrame = null } = opts || {};
      const elementsForRender = prepareElementsForRender({
        elements,
        exportingFrame,
        exportWithDarkMode,
        frameRendering
      });
      if (exportingFrame) {
        exportPadding = 0;
      }
      let metadata = "";
      if (exportEmbedScene) {
        try {
          metadata = await (await Promise.resolve().then(() => (init_image(), image_exports))).encodeSvgMetadata({
            // when embedding scene, we want to embed the origionally supplied
            // elements which don't contain the temp frame labels.
            // But it also requires that the exportToSvg is being supplied with
            // only the elements that we're exporting, and no extra.
            text: serializeAsJSON(elements, appState, files || {}, "local")
          });
        } catch (error) {
          console.error(error);
        }
      }
      const [minX, minY, width, height] = getCanvasSize(
        exportingFrame ? [exportingFrame] : getRootElements(elementsForRender),
        exportPadding
      );
      const svgRoot = document.createElementNS(SVG_NS, "svg");
      svgRoot.setAttribute("version", "1.1");
      svgRoot.setAttribute("xmlns", SVG_NS);
      svgRoot.setAttribute("viewBox", `0 0 ${width} ${height}`);
      svgRoot.setAttribute("width", `${width * exportScale}`);
      svgRoot.setAttribute("height", `${height * exportScale}`);
      if (exportWithDarkMode) {
        svgRoot.setAttribute("filter", THEME_FILTER);
      }
      let assetPath = "https://excalidraw.com/";
      if (define_import_meta_env_default.VITE_IS_EXCALIDRAW_NPM_PACKAGE) {
        assetPath = window.EXCALIDRAW_ASSET_PATH || `https://unpkg.com/${define_import_meta_env_default.VITE_PKG_NAME}@${define_import_meta_env_default.PKG_VERSION}`;
        if (assetPath?.startsWith("/")) {
          assetPath = assetPath.replace("/", `${window.location.origin}/`);
        }
        assetPath = `${assetPath}/dist/excalidraw-assets/`;
      }
      const offsetX = -minX + exportPadding;
      const offsetY = -minY + exportPadding;
      const frameElements = getFrameLikeElements(elements);
      let exportingFrameClipPath = "";
      const elementsMap = arrayToMap(elements);
      for (const frame of frameElements) {
        const [x1, y1, x2, y2] = getElementAbsoluteCoords(frame, elementsMap);
        const cx = (x2 - x1) / 2 - (frame.x - x1);
        const cy = (y2 - y1) / 2 - (frame.y - y1);
        exportingFrameClipPath += `<clipPath id=${frame.id}>
            <rect transform="translate(${frame.x + offsetX} ${frame.y + offsetY}) rotate(${frame.angle} ${cx} ${cy})"
          width="${frame.width}"
          height="${frame.height}"
          >
          </rect>
        </clipPath>`;
      }
      svgRoot.innerHTML = `
  ${SVG_EXPORT_TAG}
  ${metadata}
  <defs>
    <style class="style-fonts">
      @font-face {
        font-family: "Virgil";
        src: url("${assetPath}Virgil.woff2");
      }
      @font-face {
        font-family: "Cascadia";
        src: url("${assetPath}Cascadia.woff2");
      }
      @font-face {
        font-family: "Assistant";
        src: url("${assetPath}Assistant-Regular.woff2");
      }
    </style>
    ${exportingFrameClipPath}
  </defs>
  `;
      if (appState.exportBackground && viewBackgroundColor) {
        const rect = svgRoot.ownerDocument.createElementNS(SVG_NS, "rect");
        rect.setAttribute("x", "0");
        rect.setAttribute("y", "0");
        rect.setAttribute("width", `${width}`);
        rect.setAttribute("height", `${height}`);
        rect.setAttribute("fill", viewBackgroundColor);
        svgRoot.appendChild(rect);
      }
      const rsvg = rough2.svg(svgRoot);
      const renderEmbeddables = opts?.renderEmbeddables ?? false;
      renderSceneToSvg(
        elementsForRender,
        toBrandedType(arrayToMap(elementsForRender)),
        rsvg,
        svgRoot,
        files || {},
        {
          offsetX,
          offsetY,
          isExporting: true,
          exportWithDarkMode,
          renderEmbeddables,
          frameRendering,
          canvasBackgroundColor: viewBackgroundColor,
          embedsValidationStatus: renderEmbeddables ? new Map(
            elementsForRender.filter((element) => isFrameLikeElement(element)).map((element) => [element.id, true])
          ) : /* @__PURE__ */ new Map()
        }
      );
      tempScene.destroy();
      return svgRoot;
    };
    getCanvasSize = (elements, exportPadding) => {
      const [minX, minY, maxX, maxY] = getCommonBounds(elements);
      const width = distance(minX, maxX) + exportPadding * 2;
      const height = distance(minY, maxY) + exportPadding * 2;
      return [minX, minY, width, height];
    };
    getExportSize = (elements, exportPadding, scale) => {
      const [, , width, height] = getCanvasSize(elements, exportPadding).map(
        (dimension) => Math.trunc(dimension * scale)
      );
      return [width, height];
    };
  }
});

// charts.ts
var BAR_WIDTH, BAR_GAP, BAR_HEIGHT, GRID_OPACITY, NOT_SPREADSHEET, VALID_SPREADSHEET, tryParseNumber, isNumericColumn, tryParseCells, transposeCells, tryParseSpreadsheet, bgColors, commonProps, getChartDimensions, chartXLabels, chartYLabels, chartLines, chartBaseElements, chartTypeBar, chartTypeLine, renderSpreadsheet;
var init_charts = __esm({
  "charts.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_colors();
    init_constants();
    init_element();
    init_random();
    BAR_WIDTH = 32;
    BAR_GAP = 12;
    BAR_HEIGHT = 256;
    GRID_OPACITY = 50;
    NOT_SPREADSHEET = "NOT_SPREADSHEET";
    VALID_SPREADSHEET = "VALID_SPREADSHEET";
    tryParseNumber = (s) => {
      const match = /^([-+]?)[$]?([-+]?)([\d.,]+)[%]?$/.exec(s);
      if (!match) {
        return null;
      }
      return parseFloat(`${(match[1] || match[2]) + match[3]}`.replace(/,/g, ""));
    };
    isNumericColumn = (lines, columnIndex) => lines.slice(1).every((line) => tryParseNumber(line[columnIndex]) !== null);
    tryParseCells = (cells) => {
      const numCols = cells[0].length;
      if (numCols > 2) {
        return { type: NOT_SPREADSHEET, reason: "More than 2 columns" };
      }
      if (numCols === 1) {
        if (!isNumericColumn(cells, 0)) {
          return { type: NOT_SPREADSHEET, reason: "Value is not numeric" };
        }
        const hasHeader2 = tryParseNumber(cells[0][0]) === null;
        const values = (hasHeader2 ? cells.slice(1) : cells).map(
          (line) => tryParseNumber(line[0])
        );
        if (values.length < 2) {
          return { type: NOT_SPREADSHEET, reason: "Less than two rows" };
        }
        return {
          type: VALID_SPREADSHEET,
          spreadsheet: {
            title: hasHeader2 ? cells[0][0] : null,
            labels: null,
            values
          }
        };
      }
      const labelColumnNumeric = isNumericColumn(cells, 0);
      const valueColumnNumeric = isNumericColumn(cells, 1);
      if (!labelColumnNumeric && !valueColumnNumeric) {
        return { type: NOT_SPREADSHEET, reason: "Value is not numeric" };
      }
      const [labelColumnIndex, valueColumnIndex] = valueColumnNumeric ? [0, 1] : [1, 0];
      const hasHeader = tryParseNumber(cells[0][valueColumnIndex]) === null;
      const rows = hasHeader ? cells.slice(1) : cells;
      if (rows.length < 2) {
        return { type: NOT_SPREADSHEET, reason: "Less than 2 rows" };
      }
      return {
        type: VALID_SPREADSHEET,
        spreadsheet: {
          title: hasHeader ? cells[0][valueColumnIndex] : null,
          labels: rows.map((row) => row[labelColumnIndex]),
          values: rows.map((row) => tryParseNumber(row[valueColumnIndex]))
        }
      };
    };
    transposeCells = (cells) => {
      const nextCells = [];
      for (let col = 0; col < cells[0].length; col++) {
        const nextCellRow = [];
        for (let row = 0; row < cells.length; row++) {
          nextCellRow.push(cells[row][col]);
        }
        nextCells.push(nextCellRow);
      }
      return nextCells;
    };
    tryParseSpreadsheet = (text) => {
      let lines = text.trim().split("\n").map((line) => line.trim().split("	"));
      if (lines.length && lines[0].length !== 2) {
        lines = text.trim().split("\n").map((line) => line.trim().split(","));
      }
      if (lines.length === 0) {
        return { type: NOT_SPREADSHEET, reason: "No values" };
      }
      const numColsFirstLine = lines[0].length;
      const isSpreadsheet = lines.every((line) => line.length === numColsFirstLine);
      if (!isSpreadsheet) {
        return {
          type: NOT_SPREADSHEET,
          reason: "All rows don't have same number of columns"
        };
      }
      const result = tryParseCells(lines);
      if (result.type !== VALID_SPREADSHEET) {
        const transposedResults = tryParseCells(transposeCells(lines));
        if (transposedResults.type === VALID_SPREADSHEET) {
          return transposedResults;
        }
      }
      return result;
    };
    bgColors = getAllColorsSpecificShade(DEFAULT_CHART_COLOR_INDEX);
    commonProps = {
      fillStyle: "hachure",
      fontFamily: DEFAULT_FONT_FAMILY,
      fontSize: DEFAULT_FONT_SIZE,
      opacity: 100,
      roughness: 1,
      strokeColor: COLOR_PALETTE.black,
      roundness: null,
      strokeStyle: "solid",
      strokeWidth: 1,
      verticalAlign: VERTICAL_ALIGN.MIDDLE,
      locked: false
    };
    getChartDimensions = (spreadsheet) => {
      const chartWidth = (BAR_WIDTH + BAR_GAP) * spreadsheet.values.length + BAR_GAP;
      const chartHeight = BAR_HEIGHT + BAR_GAP * 2;
      return { chartWidth, chartHeight };
    };
    chartXLabels = (spreadsheet, x, y, groupId, backgroundColor) => {
      return spreadsheet.labels?.map((label, index) => {
        return newTextElement({
          groupIds: [groupId],
          backgroundColor,
          ...commonProps,
          text: label.length > 8 ? `${label.slice(0, 5)}...` : label,
          x: x + index * (BAR_WIDTH + BAR_GAP) + BAR_GAP * 2,
          y: y + BAR_GAP / 2,
          width: BAR_WIDTH,
          angle: 5.87,
          fontSize: 16,
          textAlign: "center",
          verticalAlign: "top"
        });
      }) || [];
    };
    chartYLabels = (spreadsheet, x, y, groupId, backgroundColor) => {
      const minYLabel = newTextElement({
        groupIds: [groupId],
        backgroundColor,
        ...commonProps,
        x: x - BAR_GAP,
        y: y - BAR_GAP,
        text: "0",
        textAlign: "right"
      });
      const maxYLabel = newTextElement({
        groupIds: [groupId],
        backgroundColor,
        ...commonProps,
        x: x - BAR_GAP,
        y: y - BAR_HEIGHT - minYLabel.height / 2,
        text: Math.max(...spreadsheet.values).toLocaleString(),
        textAlign: "right"
      });
      return [minYLabel, maxYLabel];
    };
    chartLines = (spreadsheet, x, y, groupId, backgroundColor) => {
      const { chartWidth, chartHeight } = getChartDimensions(spreadsheet);
      const xLine = newLinearElement({
        backgroundColor,
        groupIds: [groupId],
        ...commonProps,
        type: "line",
        x,
        y,
        startArrowhead: null,
        endArrowhead: null,
        width: chartWidth,
        points: [
          [0, 0],
          [chartWidth, 0]
        ]
      });
      const yLine = newLinearElement({
        backgroundColor,
        groupIds: [groupId],
        ...commonProps,
        type: "line",
        x,
        y,
        startArrowhead: null,
        endArrowhead: null,
        height: chartHeight,
        points: [
          [0, 0],
          [0, -chartHeight]
        ]
      });
      const maxLine = newLinearElement({
        backgroundColor,
        groupIds: [groupId],
        ...commonProps,
        type: "line",
        x,
        y: y - BAR_HEIGHT - BAR_GAP,
        startArrowhead: null,
        endArrowhead: null,
        strokeStyle: "dotted",
        width: chartWidth,
        opacity: GRID_OPACITY,
        points: [
          [0, 0],
          [chartWidth, 0]
        ]
      });
      return [xLine, yLine, maxLine];
    };
    chartBaseElements = (spreadsheet, x, y, groupId, backgroundColor, debug) => {
      const { chartWidth, chartHeight } = getChartDimensions(spreadsheet);
      const title = spreadsheet.title ? newTextElement({
        backgroundColor,
        groupIds: [groupId],
        ...commonProps,
        text: spreadsheet.title,
        x: x + chartWidth / 2,
        y: y - BAR_HEIGHT - BAR_GAP * 2 - DEFAULT_FONT_SIZE,
        roundness: null,
        textAlign: "center"
      }) : null;
      const debugRect = debug ? newElement({
        backgroundColor,
        groupIds: [groupId],
        ...commonProps,
        type: "rectangle",
        x,
        y: y - chartHeight,
        width: chartWidth,
        height: chartHeight,
        strokeColor: COLOR_PALETTE.black,
        fillStyle: "solid",
        opacity: 6
      }) : null;
      return [
        ...debugRect ? [debugRect] : [],
        ...title ? [title] : [],
        ...chartXLabels(spreadsheet, x, y, groupId, backgroundColor),
        ...chartYLabels(spreadsheet, x, y, groupId, backgroundColor),
        ...chartLines(spreadsheet, x, y, groupId, backgroundColor)
      ];
    };
    chartTypeBar = (spreadsheet, x, y) => {
      const max = Math.max(...spreadsheet.values);
      const groupId = randomId();
      const backgroundColor = bgColors[Math.floor(Math.random() * bgColors.length)];
      const bars = spreadsheet.values.map((value, index) => {
        const barHeight = value / max * BAR_HEIGHT;
        return newElement({
          backgroundColor,
          groupIds: [groupId],
          ...commonProps,
          type: "rectangle",
          x: x + index * (BAR_WIDTH + BAR_GAP) + BAR_GAP,
          y: y - barHeight - BAR_GAP,
          width: BAR_WIDTH,
          height: barHeight
        });
      });
      return [
        ...bars,
        ...chartBaseElements(
          spreadsheet,
          x,
          y,
          groupId,
          backgroundColor,
          define_import_meta_env_default.DEV
        )
      ];
    };
    chartTypeLine = (spreadsheet, x, y) => {
      const max = Math.max(...spreadsheet.values);
      const groupId = randomId();
      const backgroundColor = bgColors[Math.floor(Math.random() * bgColors.length)];
      let index = 0;
      const points = [];
      for (const value of spreadsheet.values) {
        const cx = index * (BAR_WIDTH + BAR_GAP);
        const cy = -(value / max) * BAR_HEIGHT;
        points.push([cx, cy]);
        index++;
      }
      const maxX = Math.max(...points.map((element) => element[0]));
      const maxY = Math.max(...points.map((element) => element[1]));
      const minX = Math.min(...points.map((element) => element[0]));
      const minY = Math.min(...points.map((element) => element[1]));
      const line = newLinearElement({
        backgroundColor,
        groupIds: [groupId],
        ...commonProps,
        type: "line",
        x: x + BAR_GAP + BAR_WIDTH / 2,
        y: y - BAR_GAP,
        startArrowhead: null,
        endArrowhead: null,
        height: maxY - minY,
        width: maxX - minX,
        strokeWidth: 2,
        points
      });
      const dots = spreadsheet.values.map((value, index2) => {
        const cx = index2 * (BAR_WIDTH + BAR_GAP) + BAR_GAP / 2;
        const cy = -(value / max) * BAR_HEIGHT + BAR_GAP / 2;
        return newElement({
          backgroundColor,
          groupIds: [groupId],
          ...commonProps,
          fillStyle: "solid",
          strokeWidth: 2,
          type: "ellipse",
          x: x + cx + BAR_WIDTH / 2,
          y: y + cy - BAR_GAP * 2,
          width: BAR_GAP,
          height: BAR_GAP
        });
      });
      const lines = spreadsheet.values.map((value, index2) => {
        const cx = index2 * (BAR_WIDTH + BAR_GAP) + BAR_GAP / 2;
        const cy = value / max * BAR_HEIGHT + BAR_GAP / 2 + BAR_GAP;
        return newLinearElement({
          backgroundColor,
          groupIds: [groupId],
          ...commonProps,
          type: "line",
          x: x + cx + BAR_WIDTH / 2 + BAR_GAP / 2,
          y: y - cy,
          startArrowhead: null,
          endArrowhead: null,
          height: cy,
          strokeStyle: "dotted",
          opacity: GRID_OPACITY,
          points: [
            [0, 0],
            [0, cy]
          ]
        });
      });
      return [
        ...chartBaseElements(
          spreadsheet,
          x,
          y,
          groupId,
          backgroundColor,
          define_import_meta_env_default.DEV
        ),
        line,
        ...lines,
        ...dots
      ];
    };
    renderSpreadsheet = (chartType, spreadsheet, x, y) => {
      if (chartType === "line") {
        return chartTypeLine(spreadsheet, x, y);
      }
      return chartTypeBar(spreadsheet, x, y);
    };
  }
});

// clipboard.ts
function parseHTMLTree(el) {
  let result = [];
  for (const node of el.childNodes) {
    if (node.nodeType === 3) {
      const text = node.textContent?.trim();
      if (text) {
        result.push({ type: "text", value: text });
      }
    } else if (node instanceof HTMLImageElement) {
      const url = node.getAttribute("src");
      if (url && url.startsWith("http")) {
        result.push({ type: "imageUrl", value: url });
      }
    } else {
      result = result.concat(parseHTMLTree(node));
    }
  }
  return result;
}
var probablySupportsClipboardReadText, probablySupportsClipboardWriteText, probablySupportsClipboardBlob, clipboardContainsElements, createPasteEvent, serializeAsClipboardJSON, copyToClipboard, parsePotentialSpreadsheet, maybeParseHTMLPaste, readSystemClipboard, parseClipboardEvent, parseClipboard, copyBlobToClipboardAsPng, copyTextToSystemClipboard, copyTextViaExecCommand;
var init_clipboard = __esm({
  "clipboard.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_charts();
    init_constants();
    init_typeChecks();
    init_newElement();
    init_mutateElement();
    init_frame();
    init_utils();
    init_i18n();
    probablySupportsClipboardReadText = "clipboard" in navigator && "readText" in navigator.clipboard;
    probablySupportsClipboardWriteText = "clipboard" in navigator && "writeText" in navigator.clipboard;
    probablySupportsClipboardBlob = "clipboard" in navigator && "write" in navigator.clipboard && "ClipboardItem" in window && "toBlob" in HTMLCanvasElement.prototype;
    clipboardContainsElements = (contents) => {
      if ([
        EXPORT_DATA_TYPES.excalidraw,
        EXPORT_DATA_TYPES.excalidrawClipboard,
        EXPORT_DATA_TYPES.excalidrawClipboardWithAPI
      ].includes(contents?.type) && Array.isArray(contents.elements)) {
        return true;
      }
      return false;
    };
    createPasteEvent = ({
      types,
      files
    }) => {
      if (!types && !files) {
        console.warn("createPasteEvent: no types or files provided");
      }
      const event = new ClipboardEvent("paste", {
        clipboardData: new DataTransfer()
      });
      if (types) {
        for (const [type, value] of Object.entries(types)) {
          try {
            event.clipboardData?.setData(type, value);
            if (event.clipboardData?.getData(type) !== value) {
              throw new Error(`Failed to set "${type}" as clipboardData item`);
            }
          } catch (error) {
            throw new Error(error.message);
          }
        }
      }
      if (files) {
        let idx = -1;
        for (const file2 of files) {
          idx++;
          try {
            event.clipboardData?.items.add(file2);
            if (event.clipboardData?.files[idx] !== file2) {
              throw new Error(
                `Failed to set file "${file2.name}" as clipboardData item`
              );
            }
          } catch (error) {
            throw new Error(error.message);
          }
        }
      }
      return event;
    };
    serializeAsClipboardJSON = ({
      elements,
      files
    }) => {
      const framesToCopy = new Set(
        elements.filter((element) => isFrameLikeElement(element))
      );
      let foundFile = false;
      const _files = elements.reduce((acc, element) => {
        if (isInitializedImageElement(element)) {
          foundFile = true;
          if (files && files[element.fileId]) {
            acc[element.fileId] = files[element.fileId];
          }
        }
        return acc;
      }, {});
      if (foundFile && !files) {
        console.warn(
          "copyToClipboard: attempting to file element(s) without providing associated `files` object."
        );
      }
      const contents = {
        type: EXPORT_DATA_TYPES.excalidrawClipboard,
        elements: elements.map((element) => {
          if (getContainingFrame(element) && !framesToCopy.has(getContainingFrame(element))) {
            const copiedElement = deepCopyElement(element);
            mutateElement(copiedElement, {
              frameId: null
            });
            return copiedElement;
          }
          return element;
        }),
        files: files ? _files : void 0
      };
      return JSON.stringify(contents);
    };
    copyToClipboard = async (elements, files, clipboardEvent) => {
      await copyTextToSystemClipboard(
        serializeAsClipboardJSON({ elements, files }),
        clipboardEvent
      );
    };
    parsePotentialSpreadsheet = (text) => {
      const result = tryParseSpreadsheet(text);
      if (result.type === VALID_SPREADSHEET) {
        return { spreadsheet: result.spreadsheet };
      }
      return null;
    };
    maybeParseHTMLPaste = (event) => {
      const html = event.clipboardData?.getData("text/html");
      if (!html) {
        return null;
      }
      try {
        const doc = new DOMParser().parseFromString(html, "text/html");
        const content = parseHTMLTree(doc.body);
        if (content.length) {
          return { type: "mixedContent", value: content };
        }
      } catch (error) {
        console.error(`error in parseHTMLFromPaste: ${error.message}`);
      }
      return null;
    };
    readSystemClipboard = async () => {
      const types = {};
      try {
        if (navigator.clipboard?.readText) {
          return { "text/plain": await navigator.clipboard?.readText() };
        }
      } catch (error) {
        if (navigator.clipboard?.read) {
          console.warn(
            `navigator.clipboard.readText() failed (${error.message}). Failling back to navigator.clipboard.read()`
          );
        } else {
          throw error;
        }
      }
      let clipboardItems;
      try {
        clipboardItems = await navigator.clipboard?.read();
      } catch (error) {
        if (error.name === "DataError") {
          console.warn(
            `navigator.clipboard.read() error, clipboard is probably empty: ${error.message}`
          );
          return types;
        }
        throw error;
      }
      for (const item of clipboardItems) {
        for (const type of item.types) {
          if (!isMemberOf(ALLOWED_PASTE_MIME_TYPES, type)) {
            continue;
          }
          try {
            types[type] = await (await item.getType(type)).text();
          } catch (error) {
            console.warn(
              `Cannot retrieve ${type} from clipboardItem: ${error.message}`
            );
          }
        }
      }
      if (Object.keys(types).length === 0) {
        console.warn("No clipboard data found from clipboard.read().");
        return types;
      }
      return types;
    };
    parseClipboardEvent = async (event, isPlainPaste = false) => {
      try {
        const mixedContent = !isPlainPaste && event && maybeParseHTMLPaste(event);
        if (mixedContent) {
          if (mixedContent.value.every((item) => item.type === "text")) {
            return {
              type: "text",
              value: event.clipboardData?.getData("text/plain") || mixedContent.value.map((item) => item.value).join("\n").trim()
            };
          }
          return mixedContent;
        }
        const text = event.clipboardData?.getData("text/plain");
        return { type: "text", value: (text || "").trim() };
      } catch {
        return { type: "text", value: "" };
      }
    };
    parseClipboard = async (event, isPlainPaste = false) => {
      const parsedEventData = await parseClipboardEvent(event, isPlainPaste);
      if (parsedEventData.type === "mixedContent") {
        return {
          mixedContent: parsedEventData.value
        };
      }
      try {
        const spreadsheetResult = !isPlainPaste && parsePotentialSpreadsheet(parsedEventData.value);
        if (spreadsheetResult) {
          return spreadsheetResult;
        }
      } catch (error) {
        console.error(error);
      }
      try {
        const systemClipboardData = JSON.parse(parsedEventData.value);
        const programmaticAPI = systemClipboardData.type === EXPORT_DATA_TYPES.excalidrawClipboardWithAPI;
        if (clipboardContainsElements(systemClipboardData)) {
          return {
            elements: systemClipboardData.elements,
            files: systemClipboardData.files,
            text: isPlainPaste ? JSON.stringify(systemClipboardData.elements, null, 2) : void 0,
            programmaticAPI
          };
        }
      } catch {
      }
      return { text: parsedEventData.value };
    };
    copyBlobToClipboardAsPng = async (blob) => {
      try {
        await navigator.clipboard.write([
          new window.ClipboardItem({
            [MIME_TYPES.png]: blob
          })
        ]);
      } catch (error) {
        if (isPromiseLike(blob)) {
          await navigator.clipboard.write([
            new window.ClipboardItem({
              [MIME_TYPES.png]: await blob
            })
          ]);
        } else {
          throw error;
        }
      }
    };
    copyTextToSystemClipboard = async (text, clipboardEvent) => {
      if (probablySupportsClipboardWriteText) {
        try {
          await navigator.clipboard.writeText(text || "");
          return;
        } catch (error) {
          console.error(error);
        }
      }
      try {
        if (clipboardEvent) {
          clipboardEvent.clipboardData?.setData("text/plain", text || "");
          if (clipboardEvent.clipboardData?.getData("text/plain") !== text) {
            throw new Error("Failed to setData on clipboardEvent");
          }
          return;
        }
      } catch (error) {
        console.error(error);
      }
      if (!copyTextViaExecCommand(text)) {
        throw new Error(t("errors.copyToSystemClipboardFailed"));
      }
    };
    copyTextViaExecCommand = (text) => {
      if (!text) {
        text = " ";
      }
      const isRTL2 = document.documentElement.getAttribute("dir") === "rtl";
      const textarea = document.createElement("textarea");
      textarea.style.border = "0";
      textarea.style.padding = "0";
      textarea.style.margin = "0";
      textarea.style.position = "absolute";
      textarea.style[isRTL2 ? "right" : "left"] = "-9999px";
      const yPosition = window.pageYOffset || document.documentElement.scrollTop;
      textarea.style.top = `${yPosition}px`;
      textarea.style.fontSize = "12pt";
      textarea.setAttribute("readonly", "");
      textarea.value = text;
      document.body.appendChild(textarea);
      let success = false;
      try {
        textarea.select();
        textarea.setSelectionRange(0, textarea.value.length);
        success = document.execCommand("copy");
      } catch (error) {
        console.error(error);
      }
      textarea.remove();
      return success;
    };
  }
});

// ../utils/bbox.ts
function getBBox(line) {
  return [
    Math.min(line[0][0], line[1][0]),
    Math.min(line[0][1], line[1][1]),
    Math.max(line[0][0], line[1][0]),
    Math.max(line[0][1], line[1][1])
  ];
}
function crossProduct(a, b) {
  return a[0] * b[1] - b[0] * a[1];
}
function doBBoxesIntersect(a, b) {
  return a[0] <= b[2] && a[2] >= b[0] && a[1] <= b[3] && a[3] >= b[1];
}
function translate(a, b) {
  return [a[0] - b[0], a[1] - b[1]];
}
function isPointOnLine(l, p) {
  const p1 = translate(l[1], l[0]);
  const p2 = translate(p, l[0]);
  const r = crossProduct(p1, p2);
  return Math.abs(r) < EPSILON;
}
function isPointRightOfLine(l, p) {
  const p1 = translate(l[1], l[0]);
  const p2 = translate(p, l[0]);
  return crossProduct(p1, p2) < 0;
}
function isLineSegmentTouchingOrCrossingLine(a, b) {
  return isPointOnLine(a, b[0]) || isPointOnLine(a, b[1]) || (isPointRightOfLine(a, b[0]) ? !isPointRightOfLine(a, b[1]) : isPointRightOfLine(a, b[1]));
}
function doLineSegmentsIntersect(a, b) {
  return doBBoxesIntersect(getBBox(a), getBBox(b)) && isLineSegmentTouchingOrCrossingLine(a, b) && isLineSegmentTouchingOrCrossingLine(b, a);
}
var EPSILON;
var init_bbox = __esm({
  "../utils/bbox.ts"() {
    "use strict";
    init_define_import_meta_env();
    EPSILON = 1e-6;
  }
});

// ../utils/withinBounds.ts
var getNonLinearElementRelativePoints, getElementRelativePoints, getMinMaxPoints, getRotatedBBox, isElementInsideBBox, elementPartiallyOverlapsWithOrContainsBBox, elementsOverlappingBBox;
var init_withinBounds = __esm({
  "../utils/withinBounds.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_typeChecks();
    init_math();
    init_bounds();
    init_utils();
    getNonLinearElementRelativePoints = (element) => {
      if (element.type === "diamond") {
        return [
          [element.width / 2, 0],
          [element.width, element.height / 2],
          [element.width / 2, element.height],
          [0, element.height / 2]
        ];
      }
      return [
        [0, 0],
        [0 + element.width, 0],
        [0 + element.width, element.height],
        [0, element.height]
      ];
    };
    getElementRelativePoints = (element) => {
      if (isLinearElement(element) || isFreeDrawElement(element)) {
        return element.points;
      }
      return getNonLinearElementRelativePoints(element);
    };
    getMinMaxPoints = (points) => {
      const ret = points.reduce(
        (limits, [x, y]) => {
          limits.minY = Math.min(limits.minY, y);
          limits.minX = Math.min(limits.minX, x);
          limits.maxX = Math.max(limits.maxX, x);
          limits.maxY = Math.max(limits.maxY, y);
          return limits;
        },
        {
          minX: Infinity,
          minY: Infinity,
          maxX: -Infinity,
          maxY: -Infinity,
          cx: 0,
          cy: 0
        }
      );
      ret.cx = (ret.maxX + ret.minX) / 2;
      ret.cy = (ret.maxY + ret.minY) / 2;
      return ret;
    };
    getRotatedBBox = (element) => {
      const points = getElementRelativePoints(element);
      const { cx, cy } = getMinMaxPoints(points);
      const centerPoint2 = [cx, cy];
      const rotatedPoints = points.map(
        (point2) => rotatePoint([point2[0], point2[1]], centerPoint2, element.angle)
      );
      const { minX, minY, maxX, maxY } = getMinMaxPoints(rotatedPoints);
      return [
        minX + element.x,
        minY + element.y,
        maxX + element.x,
        maxY + element.y
      ];
    };
    isElementInsideBBox = (element, bbox, eitherDirection = false) => {
      const elementBBox = getRotatedBBox(element);
      const elementInsideBbox = bbox[0] <= elementBBox[0] && bbox[2] >= elementBBox[2] && bbox[1] <= elementBBox[1] && bbox[3] >= elementBBox[3];
      if (!eitherDirection) {
        return elementInsideBbox;
      }
      if (elementInsideBbox) {
        return true;
      }
      return elementBBox[0] <= bbox[0] && elementBBox[2] >= bbox[2] && elementBBox[1] <= bbox[1] && elementBBox[3] >= bbox[3];
    };
    elementPartiallyOverlapsWithOrContainsBBox = (element, bbox) => {
      const elementBBox = getRotatedBBox(element);
      return (isValueInRange(elementBBox[0], bbox[0], bbox[2]) || isValueInRange(bbox[0], elementBBox[0], elementBBox[2])) && (isValueInRange(elementBBox[1], bbox[1], bbox[3]) || isValueInRange(bbox[1], elementBBox[1], elementBBox[3]));
    };
    elementsOverlappingBBox = ({
      elements,
      bounds,
      type,
      errorMargin = 0
    }) => {
      if (isExcalidrawElement(bounds)) {
        bounds = getElementBounds(bounds, arrayToMap(elements));
      }
      const adjustedBBox = [
        bounds[0] - errorMargin,
        bounds[1] - errorMargin,
        bounds[2] + errorMargin,
        bounds[3] + errorMargin
      ];
      const includedElementSet = /* @__PURE__ */ new Set();
      for (const element of elements) {
        if (includedElementSet.has(element.id)) {
          continue;
        }
        const isOverlaping = type === "overlap" ? elementPartiallyOverlapsWithOrContainsBBox(element, adjustedBBox) : type === "inside" ? isElementInsideBBox(element, adjustedBBox) : isElementInsideBBox(element, adjustedBBox, true);
        if (isOverlaping) {
          includedElementSet.add(element.id);
          if (element.boundElements) {
            for (const boundElement of element.boundElements) {
              includedElementSet.add(boundElement.id);
            }
          }
          if (isTextElement(element) && element.containerId) {
            includedElementSet.add(element.containerId);
          }
          if (isArrowElement(element)) {
            if (element.startBinding) {
              includedElementSet.add(element.startBinding.elementId);
            }
            if (element.endBinding) {
              includedElementSet.add(element.endBinding?.elementId);
            }
          }
        }
      }
      return elements.filter((element) => includedElementSet.has(element.id));
    };
  }
});

// hooks/useLibraryItemSvg.ts
import { atom as atom2, useAtom as useAtom2 } from "jotai";
import { useEffect as useEffect6, useState as useState5 } from "react";
var libraryItemSvgsCache, exportLibraryItemToSvg, useLibraryItemSvg, useLibraryCache;
var init_useLibraryItemSvg = __esm({
  "hooks/useLibraryItemSvg.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_colors();
    init_jotai();
    init_export2();
    libraryItemSvgsCache = atom2(/* @__PURE__ */ new Map());
    exportLibraryItemToSvg = async (elements) => {
      return await exportToSvg2({
        elements,
        appState: {
          exportBackground: false,
          viewBackgroundColor: COLOR_PALETTE.white
        },
        files: null,
        renderEmbeddables: false
      });
    };
    useLibraryItemSvg = (id, elements, svgCache) => {
      const [svg, setSvg] = useState5();
      useEffect6(() => {
        if (elements) {
          if (id) {
            const cachedSvg = svgCache.get(id);
            if (cachedSvg) {
              setSvg(cachedSvg);
            } else {
              (async () => {
                const exportedSvg = await exportLibraryItemToSvg(elements);
                exportedSvg.querySelector(".style-fonts")?.remove();
                if (exportedSvg) {
                  svgCache.set(id, exportedSvg);
                  setSvg(exportedSvg);
                }
              })();
            }
          } else {
            (async () => {
              const exportedSvg = await exportLibraryItemToSvg(elements);
              setSvg(exportedSvg);
            })();
          }
        }
      }, [id, elements, svgCache, setSvg]);
      return svg;
    };
    useLibraryCache = () => {
      const [svgCache] = useAtom2(libraryItemSvgsCache, jotaiScope);
      const clearLibraryCache = () => svgCache.clear();
      const deleteItemsFromLibraryCache = (items) => {
        items.forEach((item) => svgCache.delete(item));
      };
      return {
        clearLibraryCache,
        deleteItemsFromLibraryCache,
        svgCache
      };
    };
  }
});

// data/library.ts
import { atom as atom3 } from "jotai";
import { useEffect as useEffect7, useRef as useRef3 } from "react";
var libraryItemsAtom, cloneLibraryItems, isUniqueItem, mergeLibraryItems, Library, library_default, distributeLibraryItemsOnSquareGrid, parseLibraryTokensFromUrl, useHandleLibrary;
var init_library = __esm({
  "data/library.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_blob();
    init_restore();
    init_jotai();
    init_bounds();
    init_errors();
    init_i18n();
    init_constants();
    init_useLibraryItemSvg();
    init_utils();
    libraryItemsAtom = atom3({ status: "loaded", isInitialized: true, libraryItems: [] });
    cloneLibraryItems = (libraryItems) => cloneJSON(libraryItems);
    isUniqueItem = (existingLibraryItems, targetLibraryItem) => {
      return !existingLibraryItems.find((libraryItem) => {
        if (libraryItem.elements.length !== targetLibraryItem.elements.length) {
          return false;
        }
        return libraryItem.elements.every((libItemExcalidrawItem, idx) => {
          return libItemExcalidrawItem.id === targetLibraryItem.elements[idx].id && libItemExcalidrawItem.versionNonce === targetLibraryItem.elements[idx].versionNonce;
        });
      });
    };
    mergeLibraryItems = (localItems, otherItems) => {
      const newItems = [];
      for (const item of otherItems) {
        if (isUniqueItem(localItems, item)) {
          newItems.push(item);
        }
      }
      return [...newItems, ...localItems];
    };
    Library = class {
      /** latest libraryItems */
      lastLibraryItems = [];
      /** indicates whether library is initialized with library items (has gone
       * though at least one update) */
      isInitialized = false;
      app;
      constructor(app) {
        this.app = app;
      }
      updateQueue = [];
      getLastUpdateTask = () => {
        return this.updateQueue[this.updateQueue.length - 1];
      };
      notifyListeners = () => {
        if (this.updateQueue.length > 0) {
          jotaiStore.set(libraryItemsAtom, {
            status: "loading",
            libraryItems: this.lastLibraryItems,
            isInitialized: this.isInitialized
          });
        } else {
          this.isInitialized = true;
          jotaiStore.set(libraryItemsAtom, {
            status: "loaded",
            libraryItems: this.lastLibraryItems,
            isInitialized: this.isInitialized
          });
          try {
            this.app.props.onLibraryChange?.(
              cloneLibraryItems(this.lastLibraryItems)
            );
          } catch (error) {
            console.error(error);
          }
        }
      };
      /** call on excalidraw instance unmount */
      destroy = () => {
        this.isInitialized = false;
        this.updateQueue = [];
        this.lastLibraryItems = [];
        jotaiStore.set(libraryItemSvgsCache, /* @__PURE__ */ new Map());
      };
      resetLibrary = () => {
        return this.setLibrary([]);
      };
      /**
       * @returns latest cloned libraryItems. Awaits all in-progress updates first.
       */
      getLatestLibrary = () => {
        return new Promise(async (resolve) => {
          try {
            const libraryItems = await (this.getLastUpdateTask() || this.lastLibraryItems);
            if (this.updateQueue.length > 0) {
              resolve(this.getLatestLibrary());
            } else {
              resolve(cloneLibraryItems(libraryItems));
            }
          } catch (error) {
            return resolve(this.lastLibraryItems);
          }
        });
      };
      // NOTE this is a high-level public API (exposed on ExcalidrawAPI) with
      // a slight overhead (always restoring library items). For internal use
      // where merging isn't needed, use `library.setLibrary()` directly.
      updateLibrary = async ({
        libraryItems,
        prompt = false,
        merge = false,
        openLibraryMenu = false,
        defaultStatus = "unpublished"
      }) => {
        if (openLibraryMenu) {
          this.app.setState({
            openSidebar: { name: DEFAULT_SIDEBAR.name, tab: LIBRARY_SIDEBAR_TAB }
          });
        }
        return this.setLibrary(() => {
          return new Promise(async (resolve, reject) => {
            try {
              const source = await (typeof libraryItems === "function" && !(libraryItems instanceof Blob) ? libraryItems(this.lastLibraryItems) : libraryItems);
              let nextItems;
              if (source instanceof Blob) {
                nextItems = await loadLibraryFromBlob(source, defaultStatus);
              } else {
                nextItems = restoreLibraryItems(source, defaultStatus);
              }
              if (!prompt || window.confirm(
                t("alerts.confirmAddLibrary", {
                  numShapes: nextItems.length
                })
              )) {
                if (prompt) {
                  this.app.focusContainer();
                }
                if (merge) {
                  resolve(mergeLibraryItems(this.lastLibraryItems, nextItems));
                } else {
                  resolve(nextItems);
                }
              } else {
                reject(new AbortError());
              }
            } catch (error) {
              reject(error);
            }
          });
        });
      };
      setLibrary = (libraryItems) => {
        const task = new Promise(async (resolve, reject) => {
          try {
            await this.getLastUpdateTask();
            if (typeof libraryItems === "function") {
              libraryItems = libraryItems(this.lastLibraryItems);
            }
            this.lastLibraryItems = cloneLibraryItems(await libraryItems);
            resolve(this.lastLibraryItems);
          } catch (error) {
            reject(error);
          }
        }).catch((error) => {
          if (error.name === "AbortError") {
            console.warn("Library update aborted by user");
            return this.lastLibraryItems;
          }
          throw error;
        }).finally(() => {
          this.updateQueue = this.updateQueue.filter((_task) => _task !== task);
          this.notifyListeners();
        });
        this.updateQueue.push(task);
        this.notifyListeners();
        return task;
      };
    };
    library_default = Library;
    distributeLibraryItemsOnSquareGrid = (libraryItems) => {
      const PADDING = 50;
      const ITEMS_PER_ROW = Math.ceil(Math.sqrt(libraryItems.length));
      const resElements = [];
      const getMaxHeightPerRow = (row2) => {
        const maxHeight = libraryItems.slice(row2 * ITEMS_PER_ROW, row2 * ITEMS_PER_ROW + ITEMS_PER_ROW).reduce((acc, item) => {
          const { height } = getCommonBoundingBox(item.elements);
          return Math.max(acc, height);
        }, 0);
        return maxHeight;
      };
      const getMaxWidthPerCol = (targetCol) => {
        let index2 = 0;
        let currCol = 0;
        let maxWidth = 0;
        for (const item of libraryItems) {
          if (index2 % ITEMS_PER_ROW === 0) {
            currCol = 0;
          }
          if (currCol === targetCol) {
            const { width } = getCommonBoundingBox(item.elements);
            maxWidth = Math.max(maxWidth, width);
          }
          index2++;
          currCol++;
        }
        return maxWidth;
      };
      let colOffsetX = 0;
      let rowOffsetY = 0;
      let maxHeightCurrRow = 0;
      let maxWidthCurrCol = 0;
      let index = 0;
      let col = 0;
      let row = 0;
      for (const item of libraryItems) {
        if (index && index % ITEMS_PER_ROW === 0) {
          rowOffsetY += maxHeightCurrRow + PADDING;
          colOffsetX = 0;
          col = 0;
          row++;
        }
        if (col === 0) {
          maxHeightCurrRow = getMaxHeightPerRow(row);
        }
        maxWidthCurrCol = getMaxWidthPerCol(col);
        const { minX, minY, width, height } = getCommonBoundingBox(item.elements);
        const offsetCenterX = (maxWidthCurrCol - width) / 2;
        const offsetCenterY = (maxHeightCurrRow - height) / 2;
        resElements.push(
          ...item.elements.map((element) => ({
            ...element,
            x: element.x + // offset for column
            colOffsetX + // offset to center in given square grid
            offsetCenterX - // subtract minX so that given item starts at 0 coord
            minX,
            y: element.y + // offset for row
            rowOffsetY + // offset to center in given square grid
            offsetCenterY - // subtract minY so that given item starts at 0 coord
            minY
          }))
        );
        colOffsetX += maxWidthCurrCol + PADDING;
        index++;
        col++;
      }
      return resElements;
    };
    parseLibraryTokensFromUrl = () => {
      const libraryUrl = (
        // current
        new URLSearchParams(window.location.hash.slice(1)).get(
          URL_HASH_KEYS.addLibrary
        ) || // legacy, kept for compat reasons
        new URLSearchParams(window.location.search).get(URL_QUERY_KEYS.addLibrary)
      );
      const idToken = libraryUrl ? new URLSearchParams(window.location.hash.slice(1)).get("token") : null;
      return libraryUrl ? { libraryUrl, idToken } : null;
    };
    useHandleLibrary = ({
      excalidrawAPI,
      getInitialLibraryItems
    }) => {
      const getInitialLibraryRef = useRef3(getInitialLibraryItems);
      useEffect7(() => {
        if (!excalidrawAPI) {
          return;
        }
        const importLibraryFromURL = async ({
          libraryUrl,
          idToken
        }) => {
          const libraryPromise = new Promise(async (resolve, reject) => {
            try {
              const request = await fetch(decodeURIComponent(libraryUrl));
              const blob = await request.blob();
              resolve(blob);
            } catch (error) {
              reject(error);
            }
          });
          const shouldPrompt = idToken !== excalidrawAPI.id;
          await (shouldPrompt && document.hidden ? new Promise((resolve) => {
            window.addEventListener("focus", () => resolve(), {
              once: true
            });
          }) : null);
          try {
            await excalidrawAPI.updateLibrary({
              libraryItems: libraryPromise,
              prompt: shouldPrompt,
              merge: true,
              defaultStatus: "published",
              openLibraryMenu: true
            });
          } catch (error) {
            throw error;
          } finally {
            if (window.location.hash.includes(URL_HASH_KEYS.addLibrary)) {
              const hash = new URLSearchParams(window.location.hash.slice(1));
              hash.delete(URL_HASH_KEYS.addLibrary);
              window.history.replaceState({}, APP_NAME, `#${hash.toString()}`);
            } else if (window.location.search.includes(URL_QUERY_KEYS.addLibrary)) {
              const query = new URLSearchParams(window.location.search);
              query.delete(URL_QUERY_KEYS.addLibrary);
              window.history.replaceState({}, APP_NAME, `?${query.toString()}`);
            }
          }
        };
        const onHashChange = (event) => {
          event.preventDefault();
          const libraryUrlTokens2 = parseLibraryTokensFromUrl();
          if (libraryUrlTokens2) {
            event.stopImmediatePropagation();
            window.history.replaceState({}, "", event.oldURL);
            importLibraryFromURL(libraryUrlTokens2);
          }
        };
        if (getInitialLibraryRef.current) {
          excalidrawAPI.updateLibrary({
            libraryItems: getInitialLibraryRef.current()
          });
        }
        const libraryUrlTokens = parseLibraryTokensFromUrl();
        if (libraryUrlTokens) {
          importLibraryFromURL(libraryUrlTokens);
        }
        window.addEventListener("hashchange" /* HASHCHANGE */, onHashChange);
        return () => {
          window.removeEventListener("hashchange" /* HASHCHANGE */, onHashChange);
        };
      }, [excalidrawAPI]);
    };
  }
});

// ../utils/export.ts
var exportToCanvas2, exportToBlob, exportToSvg2, exportToClipboard;
var init_export2 = __esm({
  "../utils/export.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_export();
    init_appState();
    init_restore();
    init_constants();
    init_image();
    init_json();
    init_clipboard();
    init_bbox();
    init_withinBounds();
    init_json();
    init_blob();
    init_renderElement();
    init_library();
    exportToCanvas2 = ({
      elements,
      appState,
      files,
      maxWidthOrHeight,
      getDimensions,
      exportPadding,
      exportingFrame
    }) => {
      const { elements: restoredElements, appState: restoredAppState } = restore(
        { elements, appState },
        null,
        null
      );
      const { exportBackground, viewBackgroundColor } = restoredAppState;
      return exportToCanvas(
        restoredElements,
        { ...restoredAppState, offsetTop: 0, offsetLeft: 0, width: 0, height: 0 },
        files || {},
        { exportBackground, exportPadding, viewBackgroundColor, exportingFrame },
        (width, height) => {
          const canvas2 = document.createElement("canvas");
          if (maxWidthOrHeight) {
            if (typeof getDimensions === "function") {
              console.warn(
                "`getDimensions()` is ignored when `maxWidthOrHeight` is supplied."
              );
            }
            const max = Math.max(width, height);
            const scale = maxWidthOrHeight < max ? maxWidthOrHeight / max : appState?.exportScale ?? 1;
            canvas2.width = width * scale;
            canvas2.height = height * scale;
            return {
              canvas: canvas2,
              scale
            };
          }
          const ret = getDimensions?.(width, height) || { width, height };
          canvas2.width = ret.width;
          canvas2.height = ret.height;
          return {
            canvas: canvas2,
            scale: ret.scale ?? 1
          };
        }
      );
    };
    exportToBlob = async (opts) => {
      let { mimeType = MIME_TYPES.png, quality } = opts;
      if (mimeType === MIME_TYPES.png && typeof quality === "number") {
        console.warn(`"quality" will be ignored for "${MIME_TYPES.png}" mimeType`);
      }
      if (mimeType === "image/jpg") {
        mimeType = MIME_TYPES.jpg;
      }
      if (mimeType === MIME_TYPES.jpg && !opts.appState?.exportBackground) {
        console.warn(
          `Defaulting "exportBackground" to "true" for "${MIME_TYPES.jpg}" mimeType`
        );
        opts = {
          ...opts,
          appState: { ...opts.appState, exportBackground: true }
        };
      }
      const canvas2 = await exportToCanvas2(opts);
      quality = quality ? quality : /image\/jpe?g/.test(mimeType) ? 0.92 : 0.8;
      return new Promise((resolve, reject) => {
        canvas2.toBlob(
          async (blob) => {
            if (!blob) {
              return reject(new Error("couldn't export to blob"));
            }
            if (blob && mimeType === MIME_TYPES.png && opts.appState?.exportEmbedScene) {
              blob = await encodePngMetadata({
                blob,
                metadata: serializeAsJSON(
                  // NOTE as long as we're using the Scene hack, we need to ensure
                  // we pass the original, uncloned elements when serializing
                  // so that we keep ids stable
                  opts.elements,
                  opts.appState,
                  opts.files || {},
                  "local"
                )
              });
            }
            resolve(blob);
          },
          mimeType,
          quality
        );
      });
    };
    exportToSvg2 = async ({
      elements,
      appState = getDefaultAppState(),
      files = {},
      exportPadding,
      renderEmbeddables,
      exportingFrame
    }) => {
      const { elements: restoredElements, appState: restoredAppState } = restore(
        { elements, appState },
        null,
        null
      );
      const exportAppState = {
        ...restoredAppState,
        exportPadding
      };
      return exportToSvg(restoredElements, exportAppState, files, {
        exportingFrame,
        renderEmbeddables
      });
    };
    exportToClipboard = async (opts) => {
      if (opts.type === "svg") {
        const svg = await exportToSvg2(opts);
        await copyTextToSystemClipboard(svg.outerHTML);
      } else if (opts.type === "png") {
        await copyBlobToClipboardAsPng(exportToBlob(opts));
      } else if (opts.type === "json") {
        await copyToClipboard(opts.elements, opts.files);
      } else {
        throw new Error("Invalid export type");
      }
    };
  }
});

// frame.ts
function isElementIntersectingFrame(element, frame, elementsMap) {
  const frameLineSegments = getElementLineSegments(frame, elementsMap);
  const elementLineSegments = getElementLineSegments(element, elementsMap);
  const intersecting = frameLineSegments.some(
    (frameLineSegment) => elementLineSegments.some(
      (elementLineSegment) => doLineSegmentsIntersect(frameLineSegment, elementLineSegment)
    )
  );
  return intersecting;
}
var bindElementsToFramesAfterDuplication, getElementsCompletelyInFrame, isElementContainingFrame, elementsAreInFrameBounds, elementOverlapsWithFrame, isCursorInFrame, groupByFrameLikes, getFrameChildren, getFrameLikeElements, getRootElements, getElementsInResizingFrame, getElementsInNewFrame, getContainingFrame, filterElementsEligibleAsFrameChildren, addElementsToFrame, removeElementsFromFrame, removeAllElementsFromFrame, replaceAllElementsInFrame, updateFrameMembershipOfSelectedElements, omitGroupsContainingFrameLikes, getTargetFrame, isElementInFrame, getFrameLikeTitle, getElementsOverlappingFrame;
var init_frame = __esm({
  "frame.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_element();
    init_math();
    init_textElement();
    init_utils();
    init_mutateElement();
    init_scene();
    init_groups();
    init_Scene();
    init_bounds();
    init_export2();
    init_typeChecks();
    bindElementsToFramesAfterDuplication = (nextElements, oldElements, oldIdToDuplicatedId) => {
      const nextElementMap = arrayToMap(nextElements);
      for (const element of oldElements) {
        if (element.frameId) {
          const nextElementId = oldIdToDuplicatedId.get(element.id);
          const nextFrameId = oldIdToDuplicatedId.get(element.frameId);
          if (nextElementId) {
            const nextElement = nextElementMap.get(nextElementId);
            if (nextElement) {
              mutateElement(
                nextElement,
                {
                  frameId: nextFrameId ?? element.frameId
                },
                false
              );
            }
          }
        }
      }
    };
    getElementsCompletelyInFrame = (elements, frame, elementsMap) => omitGroupsContainingFrameLikes(
      getElementsWithinSelection(elements, frame, elementsMap, false)
    ).filter(
      (element) => !isFrameLikeElement(element) && !element.frameId || element.frameId === frame.id
    );
    isElementContainingFrame = (elements, element, frame, elementsMap) => {
      return getElementsWithinSelection(elements, element, elementsMap).some(
        (e) => e.id === frame.id
      );
    };
    elementsAreInFrameBounds = (elements, frame, elementsMap) => {
      const [frameX1, frameY1, frameX2, frameY2] = getElementAbsoluteCoords(
        frame,
        elementsMap
      );
      const [elementX1, elementY1, elementX2, elementY2] = getCommonBounds(elements);
      return frameX1 <= elementX1 && frameY1 <= elementY1 && frameX2 >= elementX2 && frameY2 >= elementY2;
    };
    elementOverlapsWithFrame = (element, frame, elementsMap) => {
      return elementsAreInFrameBounds([element], frame, elementsMap) || isElementIntersectingFrame(element, frame, elementsMap) || isElementContainingFrame([frame], element, frame, elementsMap);
    };
    isCursorInFrame = (cursorCoords, frame, elementsMap) => {
      const [fx1, fy1, fx2, fy2] = getElementAbsoluteCoords(frame, elementsMap);
      return isPointWithinBounds(
        [fx1, fy1],
        [cursorCoords.x, cursorCoords.y],
        [fx2, fy2]
      );
    };
    groupByFrameLikes = (elements) => {
      const frameElementsMap = /* @__PURE__ */ new Map();
      for (const element of elements) {
        const frameId = isFrameLikeElement(element) ? element.id : element.frameId;
        if (frameId && !frameElementsMap.has(frameId)) {
          frameElementsMap.set(frameId, getFrameChildren(elements, frameId));
        }
      }
      return frameElementsMap;
    };
    getFrameChildren = (allElements, frameId) => {
      const frameChildren = [];
      for (const element of allElements.values()) {
        if (element.frameId === frameId) {
          frameChildren.push(element);
        }
      }
      return frameChildren;
    };
    getFrameLikeElements = (allElements) => {
      return allElements.filter(
        (element) => isFrameLikeElement(element)
      );
    };
    getRootElements = (allElements) => {
      const frameElements = arrayToMap(getFrameLikeElements(allElements));
      return allElements.filter(
        (element) => frameElements.has(element.id) || !element.frameId || !frameElements.has(element.frameId)
      );
    };
    getElementsInResizingFrame = (allElements, frame, appState, elementsMap) => {
      const prevElementsInFrame = getFrameChildren(allElements, frame.id);
      const nextElementsInFrame = new Set(prevElementsInFrame);
      const elementsCompletelyInFrame = /* @__PURE__ */ new Set([
        ...getElementsCompletelyInFrame(allElements, frame, elementsMap),
        ...prevElementsInFrame.filter(
          (element) => isElementContainingFrame(allElements, element, frame, elementsMap)
        )
      ]);
      const elementsNotCompletelyInFrame = prevElementsInFrame.filter(
        (element) => !elementsCompletelyInFrame.has(element)
      );
      const groupsToKeep = new Set(
        Array.from(elementsCompletelyInFrame).flatMap(
          (element) => element.groupIds
        )
      );
      for (const element of elementsNotCompletelyInFrame) {
        if (!isElementIntersectingFrame(element, frame, elementsMap)) {
          if (element.groupIds.length === 0) {
            nextElementsInFrame.delete(element);
          }
        } else if (element.groupIds.length > 0) {
          for (const id of element.groupIds) {
            groupsToKeep.add(id);
          }
        }
      }
      for (const element of elementsNotCompletelyInFrame) {
        if (element.groupIds.length > 0) {
          let shouldRemoveElement = true;
          for (const id of element.groupIds) {
            if (groupsToKeep.has(id)) {
              shouldRemoveElement = false;
            }
          }
          if (shouldRemoveElement) {
            nextElementsInFrame.delete(element);
          }
        }
      }
      const individualElementsCompletelyInFrame = Array.from(
        elementsCompletelyInFrame
      ).filter((element) => element.groupIds.length === 0);
      for (const element of individualElementsCompletelyInFrame) {
        nextElementsInFrame.add(element);
      }
      const newGroupElementsCompletelyInFrame = Array.from(
        elementsCompletelyInFrame
      ).filter((element) => element.groupIds.length > 0);
      const groupIds = selectGroupsFromGivenElements(
        newGroupElementsCompletelyInFrame,
        appState
      );
      for (const [id, isSelected] of Object.entries(groupIds)) {
        if (isSelected) {
          const elementsInGroup = getElementsInGroup(allElements, id);
          if (elementsAreInFrameBounds(elementsInGroup, frame, elementsMap)) {
            for (const element of elementsInGroup) {
              nextElementsInFrame.add(element);
            }
          }
        }
      }
      return [...nextElementsInFrame].filter((element) => {
        return !(isTextElement(element) && element.containerId);
      });
    };
    getElementsInNewFrame = (elements, frame, elementsMap) => {
      return omitGroupsContainingFrameLikes(
        elements,
        getElementsCompletelyInFrame(elements, frame, elementsMap)
      );
    };
    getContainingFrame = (element, elementsMap) => {
      if (element.frameId) {
        if (elementsMap) {
          return elementsMap.get(element.frameId) || null;
        }
        return Scene_default.getScene(element)?.getElement(
          element.frameId
        ) || null;
      }
      return null;
    };
    filterElementsEligibleAsFrameChildren = (elements, frame) => {
      const otherFrames = /* @__PURE__ */ new Set();
      const elementsMap = arrayToMap(elements);
      elements = omitGroupsContainingFrameLikes(elements);
      for (const element of elements) {
        if (isFrameLikeElement(element) && element.id !== frame.id) {
          otherFrames.add(element.id);
        }
      }
      const processedGroups = /* @__PURE__ */ new Set();
      const eligibleElements = [];
      for (const element of elements) {
        if (isFrameLikeElement(element) || element.frameId && otherFrames.has(element.frameId)) {
          continue;
        }
        if (element.groupIds.length) {
          const shallowestGroupId = element.groupIds.at(-1);
          if (!processedGroups.has(shallowestGroupId)) {
            processedGroups.add(shallowestGroupId);
            const groupElements = getElementsInGroup(elements, shallowestGroupId);
            if (groupElements.some(
              (el) => elementOverlapsWithFrame(el, frame, elementsMap)
            )) {
              for (const child of groupElements) {
                eligibleElements.push(child);
              }
            }
          }
        } else {
          const overlaps = elementOverlapsWithFrame(element, frame, elementsMap);
          if (overlaps) {
            eligibleElements.push(element);
          }
        }
      }
      return eligibleElements;
    };
    addElementsToFrame = (allElements, elementsToAdd, frame) => {
      const elementsMap = arrayToMap(allElements);
      const currTargetFrameChildrenMap = /* @__PURE__ */ new Map();
      for (const element of allElements.values()) {
        if (element.frameId === frame.id) {
          currTargetFrameChildrenMap.set(element.id, true);
        }
      }
      const suppliedElementsToAddSet = new Set(elementsToAdd.map((el) => el.id));
      const finalElementsToAdd = [];
      const otherFrames = /* @__PURE__ */ new Set();
      for (const element of elementsToAdd) {
        if (isFrameLikeElement(element) && element.id !== frame.id) {
          otherFrames.add(element.id);
        }
      }
      for (const element of omitGroupsContainingFrameLikes(
        allElements,
        elementsToAdd
      )) {
        if (isFrameLikeElement(element) || element.frameId && otherFrames.has(element.frameId)) {
          continue;
        }
        if (!currTargetFrameChildrenMap.has(element.id)) {
          finalElementsToAdd.push(element);
        }
        const boundTextElement = getBoundTextElement(element, elementsMap);
        if (boundTextElement && !suppliedElementsToAddSet.has(boundTextElement.id) && !currTargetFrameChildrenMap.has(boundTextElement.id)) {
          finalElementsToAdd.push(boundTextElement);
        }
      }
      for (const element of finalElementsToAdd) {
        mutateElement(
          element,
          {
            frameId: frame.id
          },
          false
        );
      }
      return allElements;
    };
    removeElementsFromFrame = (elementsToRemove, elementsMap) => {
      const _elementsToRemove = /* @__PURE__ */ new Map();
      const toRemoveElementsByFrame = /* @__PURE__ */ new Map();
      for (const element of elementsToRemove) {
        if (element.frameId) {
          _elementsToRemove.set(element.id, element);
          const arr = toRemoveElementsByFrame.get(element.frameId) || [];
          arr.push(element);
          const boundTextElement = getBoundTextElement(element, elementsMap);
          if (boundTextElement) {
            _elementsToRemove.set(boundTextElement.id, boundTextElement);
            arr.push(boundTextElement);
          }
          toRemoveElementsByFrame.set(element.frameId, arr);
        }
      }
      for (const [, element] of _elementsToRemove) {
        mutateElement(
          element,
          {
            frameId: null
          },
          false
        );
      }
    };
    removeAllElementsFromFrame = (allElements, frame) => {
      const elementsInFrame = getFrameChildren(allElements, frame.id);
      removeElementsFromFrame(elementsInFrame, arrayToMap(allElements));
      return allElements;
    };
    replaceAllElementsInFrame = (allElements, nextElementsInFrame, frame, app) => {
      return addElementsToFrame(
        removeAllElementsFromFrame(allElements, frame),
        nextElementsInFrame,
        frame
      ).slice();
    };
    updateFrameMembershipOfSelectedElements = (allElements, appState, app) => {
      const selectedElements = app.scene.getSelectedElements({
        selectedElementIds: appState.selectedElementIds,
        // supplying elements explicitly in case we're passed non-state elements
        elements: allElements
      });
      const elementsToFilter = new Set(selectedElements);
      if (appState.editingGroupId) {
        for (const element of selectedElements) {
          if (element.groupIds.length === 0) {
            elementsToFilter.add(element);
          } else {
            element.groupIds.flatMap((gid) => getElementsInGroup(allElements, gid)).forEach((element2) => elementsToFilter.add(element2));
          }
        }
      }
      const elementsToRemove = /* @__PURE__ */ new Set();
      const elementsMap = arrayToMap(allElements);
      elementsToFilter.forEach((element) => {
        if (element.frameId && !isFrameLikeElement(element) && !isElementInFrame(element, elementsMap, appState)) {
          elementsToRemove.add(element);
        }
      });
      if (elementsToRemove.size > 0) {
        removeElementsFromFrame(elementsToRemove, elementsMap);
      }
      return allElements;
    };
    omitGroupsContainingFrameLikes = (allElements, selectedElements) => {
      const uniqueGroupIds = /* @__PURE__ */ new Set();
      const elements = selectedElements || allElements;
      for (const el of elements.values()) {
        const topMostGroupId = el.groupIds[el.groupIds.length - 1];
        if (topMostGroupId) {
          uniqueGroupIds.add(topMostGroupId);
        }
      }
      const rejectedGroupIds = /* @__PURE__ */ new Set();
      for (const groupId of uniqueGroupIds) {
        if (getElementsInGroup(allElements, groupId).some(
          (el) => isFrameLikeElement(el)
        )) {
          rejectedGroupIds.add(groupId);
        }
      }
      const ret = [];
      for (const element of elements.values()) {
        if (!rejectedGroupIds.has(element.groupIds[element.groupIds.length - 1])) {
          ret.push(element);
        }
      }
      return ret;
    };
    getTargetFrame = (element, elementsMap, appState) => {
      const _element = isTextElement(element) ? getContainerElement(element, elementsMap) || element : element;
      return appState.selectedElementIds[_element.id] && appState.selectedElementsAreBeingDragged ? appState.frameToHighlight : getContainingFrame(_element);
    };
    isElementInFrame = (element, allElementsMap, appState) => {
      const frame = getTargetFrame(element, allElementsMap, appState);
      const _element = isTextElement(element) ? getContainerElement(element, allElementsMap) || element : element;
      if (frame) {
        if (!appState.selectedElementIds[element.id] || !appState.selectedElementsAreBeingDragged) {
          return true;
        }
        if (_element.groupIds.length === 0) {
          return elementOverlapsWithFrame(_element, frame, allElementsMap);
        }
        const allElementsInGroup = new Set(
          _element.groupIds.flatMap(
            (gid) => getElementsInGroup(allElementsMap, gid)
          )
        );
        if (appState.editingGroupId && appState.selectedElementsAreBeingDragged) {
          const selectedElements = new Set(
            getSelectedElements(allElementsMap, appState)
          );
          const editingGroupOverlapsFrame = appState.frameToHighlight !== null;
          if (editingGroupOverlapsFrame) {
            return true;
          }
          selectedElements.forEach((selectedElement) => {
            allElementsInGroup.delete(selectedElement);
          });
        }
        for (const elementInGroup of allElementsInGroup) {
          if (isFrameLikeElement(elementInGroup)) {
            return false;
          }
        }
        for (const elementInGroup of allElementsInGroup) {
          if (elementOverlapsWithFrame(elementInGroup, frame, allElementsMap)) {
            return true;
          }
        }
      }
      return false;
    };
    getFrameLikeTitle = (element, frameIdx) => {
      return element.name === null ? isFrameElement(element) ? `Frame ${frameIdx}` : `AI Frame $${frameIdx}` : element.name;
    };
    getElementsOverlappingFrame = (elements, frame) => {
      return elementsOverlappingBBox({
        elements,
        bounds: frame,
        type: "overlap"
      }).filter((el) => !el.frameId || el.frameId === frame.id);
    };
  }
});

// renderer/renderElement.ts
import rough3 from "roughjs/bin/rough";
import { getStroke } from "perfect-freehand";
function generateFreeDrawShape(element) {
  const svgPathData = getFreeDrawSvgPath(element);
  const path = new Path2D(svgPathData);
  pathsCache.set(element, path);
  return path;
}
function getFreeDrawPath2D(element) {
  return pathsCache.get(element);
}
function getFreeDrawSvgPath(element) {
  const inputPoints = element.simulatePressure ? element.points : element.points.length ? element.points.map(([x, y], i) => [x, y, element.pressures[i]]) : [[0, 0, 0.5]];
  const options = {
    simulatePressure: element.simulatePressure,
    size: element.strokeWidth * 4.25,
    thinning: 0.6,
    smoothing: 0.5,
    streamline: 0.5,
    easing: (t2) => Math.sin(t2 * Math.PI / 2),
    // https://easings.net/#easeOutSine
    last: !!element.lastCommittedPoint
    // LastCommittedPoint is added on pointerup
  };
  return getSvgPathFromStroke2(getStroke(inputPoints, options));
}
function med(A, B) {
  return [(A[0] + B[0]) / 2, (A[1] + B[1]) / 2];
}
function getSvgPathFromStroke2(points) {
  if (!points.length) {
    return "";
  }
  const max = points.length - 1;
  return points.reduce(
    (acc, point2, i, arr) => {
      if (i === max) {
        acc.push(point2, med(point2, arr[0]), "L", arr[0], "Z");
      } else {
        acc.push(point2, med(point2, arr[i + 1]));
      }
      return acc;
    },
    ["M", points[0], "Q"]
  ).join(" ").replace(TO_FIXED_PRECISION, "$1");
}
var IMAGE_INVERT_FILTER, defaultAppState, isPendingImageElement, shouldResetImageFilter, getCanvasPadding, getRenderOpacity, cappedElementCanvasSize, generateElementCanvas, DEFAULT_LINK_SIZE, IMAGE_PLACEHOLDER_IMG, IMAGE_ERROR_PLACEHOLDER_IMG, drawImagePlaceholder, drawElementOnCanvas, elementWithCanvasCache, generateElementWithCanvas, drawElementFromCanvas, renderSelectionElement, renderElement, roughSVGDrawWithPrecision, maybeWrapNodesInFrameClipPath, renderElementToSvg, pathsCache, TO_FIXED_PRECISION;
var init_renderElement = __esm({
  "renderer/renderElement.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_typeChecks();
    init_bounds();
    init_utils();
    init_math();
    init_appState();
    init_constants();
    init_textElement();
    init_linearElementEditor();
    init_embeddable();
    init_frame();
    init_url();
    init_ShapeCache();
    IMAGE_INVERT_FILTER = "invert(100%) hue-rotate(180deg) saturate(1.25)";
    defaultAppState = getDefaultAppState();
    isPendingImageElement = (element, renderConfig) => isInitializedImageElement(element) && !renderConfig.imageCache.has(element.fileId);
    shouldResetImageFilter = (element, renderConfig, appState) => {
      return appState.theme === "dark" && isInitializedImageElement(element) && !isPendingImageElement(element, renderConfig) && renderConfig.imageCache.get(element.fileId)?.mimeType !== MIME_TYPES.svg;
    };
    getCanvasPadding = (element) => element.type === "freedraw" ? element.strokeWidth * 12 : 20;
    getRenderOpacity = (element, containingFrame, elementsPendingErasure) => {
      let opacity = (containingFrame?.opacity ?? 100) * element.opacity / 1e4;
      if (elementsPendingErasure.has(element.id) || containingFrame && elementsPendingErasure.has(containingFrame.id)) {
        opacity *= ELEMENT_READY_TO_ERASE_OPACITY / 100;
      }
      return opacity;
    };
    cappedElementCanvasSize = (element, elementsMap, zoom) => {
      const AREA_LIMIT = 16777216;
      const WIDTH_HEIGHT_LIMIT = 32767;
      const padding = getCanvasPadding(element);
      const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);
      const elementWidth = isLinearElement(element) || isFreeDrawElement(element) ? distance(x1, x2) : element.width;
      const elementHeight = isLinearElement(element) || isFreeDrawElement(element) ? distance(y1, y2) : element.height;
      let width = elementWidth * window.devicePixelRatio + padding * 2;
      let height = elementHeight * window.devicePixelRatio + padding * 2;
      let scale = zoom.value;
      if (width * scale > WIDTH_HEIGHT_LIMIT || height * scale > WIDTH_HEIGHT_LIMIT) {
        scale = Math.min(WIDTH_HEIGHT_LIMIT / width, WIDTH_HEIGHT_LIMIT / height);
      }
      if (width * height * scale * scale > AREA_LIMIT) {
        scale = Math.sqrt(AREA_LIMIT / (width * height));
      }
      width = Math.floor(width * scale);
      height = Math.floor(height * scale);
      return { width, height, scale };
    };
    generateElementCanvas = (element, elementsMap, zoom, renderConfig, appState) => {
      const canvas2 = document.createElement("canvas");
      const context = canvas2.getContext("2d");
      const padding = getCanvasPadding(element);
      const { width, height, scale } = cappedElementCanvasSize(
        element,
        elementsMap,
        zoom
      );
      canvas2.width = width;
      canvas2.height = height;
      let canvasOffsetX = 0;
      let canvasOffsetY = 0;
      if (isLinearElement(element) || isFreeDrawElement(element)) {
        const [x1, y1] = getElementAbsoluteCoords(element, elementsMap);
        canvasOffsetX = element.x > x1 ? distance(element.x, x1) * window.devicePixelRatio * scale : 0;
        canvasOffsetY = element.y > y1 ? distance(element.y, y1) * window.devicePixelRatio * scale : 0;
        context.translate(canvasOffsetX, canvasOffsetY);
      }
      context.save();
      context.translate(padding * scale, padding * scale);
      context.scale(
        window.devicePixelRatio * scale,
        window.devicePixelRatio * scale
      );
      const rc = rough3.canvas(canvas2);
      if (shouldResetImageFilter(element, renderConfig, appState)) {
        context.filter = IMAGE_INVERT_FILTER;
      }
      drawElementOnCanvas(element, rc, context, renderConfig, appState);
      context.restore();
      return {
        element,
        canvas: canvas2,
        theme: appState.theme,
        scale,
        zoomValue: zoom.value,
        canvasOffsetX,
        canvasOffsetY,
        boundTextElementVersion: getBoundTextElement(element, elementsMap)?.version || null,
        containingFrameOpacity: getContainingFrame(element)?.opacity || 100
      };
    };
    DEFAULT_LINK_SIZE = 14;
    IMAGE_PLACEHOLDER_IMG = document.createElement("img");
    IMAGE_PLACEHOLDER_IMG.src = `data:${MIME_TYPES.svg},${encodeURIComponent(
      `<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="image" class="svg-inline--fa fa-image fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="#888" d="M464 448H48c-26.51 0-48-21.49-48-48V112c0-26.51 21.49-48 48-48h416c26.51 0 48 21.49 48 48v288c0 26.51-21.49 48-48 48zM112 120c-30.928 0-56 25.072-56 56s25.072 56 56 56 56-25.072 56-56-25.072-56-56-56zM64 384h384V272l-87.515-87.515c-4.686-4.686-12.284-4.686-16.971 0L208 320l-55.515-55.515c-4.686-4.686-12.284-4.686-16.971 0L64 336v48z"></path></svg>`
    )}`;
    IMAGE_ERROR_PLACEHOLDER_IMG = document.createElement("img");
    IMAGE_ERROR_PLACEHOLDER_IMG.src = `data:${MIME_TYPES.svg},${encodeURIComponent(
      `<svg viewBox="0 0 668 668" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2"><path d="M464 448H48c-26.51 0-48-21.49-48-48V112c0-26.51 21.49-48 48-48h416c26.51 0 48 21.49 48 48v288c0 26.51-21.49 48-48 48ZM112 120c-30.928 0-56 25.072-56 56s25.072 56 56 56 56-25.072 56-56-25.072-56-56-56ZM64 384h384V272l-87.515-87.515c-4.686-4.686-12.284-4.686-16.971 0L208 320l-55.515-55.515c-4.686-4.686-12.284-4.686-16.971 0L64 336v48Z" style="fill:#888;fill-rule:nonzero" transform="matrix(.81709 0 0 .81709 124.825 145.825)"/><path d="M256 8C119.034 8 8 119.033 8 256c0 136.967 111.034 248 248 248s248-111.034 248-248S392.967 8 256 8Zm130.108 117.892c65.448 65.448 70 165.481 20.677 235.637L150.47 105.216c70.204-49.356 170.226-44.735 235.638 20.676ZM125.892 386.108c-65.448-65.448-70-165.481-20.677-235.637L361.53 406.784c-70.203 49.356-170.226 44.736-235.638-20.676Z" style="fill:#888;fill-rule:nonzero" transform="matrix(.30366 0 0 .30366 506.822 60.065)"/></svg>`
    )}`;
    drawImagePlaceholder = (element, context, zoomValue) => {
      context.fillStyle = "#E7E7E7";
      context.fillRect(0, 0, element.width, element.height);
      const imageMinWidthOrHeight = Math.min(element.width, element.height);
      const size = Math.min(
        imageMinWidthOrHeight,
        Math.min(imageMinWidthOrHeight * 0.4, 100)
      );
      context.drawImage(
        element.status === "error" ? IMAGE_ERROR_PLACEHOLDER_IMG : IMAGE_PLACEHOLDER_IMG,
        element.width / 2 - size / 2,
        element.height / 2 - size / 2,
        size,
        size
      );
    };
    drawElementOnCanvas = (element, rc, context, renderConfig, appState) => {
      switch (element.type) {
        case "rectangle":
        case "iframe":
        case "embeddable":
        case "diamond":
        case "ellipse": {
          context.lineJoin = "round";
          context.lineCap = "round";
          rc.draw(ShapeCache.get(element));
          break;
        }
        case "arrow":
        case "line": {
          context.lineJoin = "round";
          context.lineCap = "round";
          ShapeCache.get(element).forEach((shape) => {
            rc.draw(shape);
          });
          break;
        }
        case "freedraw": {
          context.save();
          context.fillStyle = element.strokeColor;
          const path = getFreeDrawPath2D(element);
          const fillShape = ShapeCache.get(element);
          if (fillShape) {
            rc.draw(fillShape);
          }
          context.fillStyle = element.strokeColor;
          context.fill(path);
          context.restore();
          break;
        }
        case "image": {
          const img = isInitializedImageElement(element) ? renderConfig.imageCache.get(element.fileId)?.image : void 0;
          if (img != null && !(img instanceof Promise)) {
            if (element.roundness && context.roundRect) {
              context.beginPath();
              context.roundRect(
                0,
                0,
                element.width,
                element.height,
                getCornerRadius(Math.min(element.width, element.height), element)
              );
              context.clip();
            }
            context.drawImage(
              img,
              0,
              0,
              element.width,
              element.height
            );
          } else {
            drawImagePlaceholder(element, context, appState.zoom.value);
          }
          break;
        }
        default: {
          if (isTextElement(element)) {
            const rtl = isRTL(element.text);
            const shouldTemporarilyAttach = rtl && !context.canvas.isConnected;
            if (shouldTemporarilyAttach) {
              document.body.appendChild(context.canvas);
            }
            context.canvas.setAttribute("dir", rtl ? "rtl" : "ltr");
            context.save();
            context.font = getFontString(element);
            context.fillStyle = element.strokeColor;
            context.textAlign = element.textAlign;
            const lines = element.text.replace(/\r\n?/g, "\n").split("\n");
            const horizontalOffset = element.textAlign === "center" ? element.width / 2 : element.textAlign === "right" ? element.width : 0;
            const lineHeightPx = getLineHeightInPx(
              element.fontSize,
              element.lineHeight
            );
            const verticalOffset = element.height - element.baseline;
            for (let index = 0; index < lines.length; index++) {
              context.fillText(
                lines[index],
                horizontalOffset,
                (index + 1) * lineHeightPx - verticalOffset
              );
            }
            context.restore();
            if (shouldTemporarilyAttach) {
              context.canvas.remove();
            }
          } else {
            throw new Error(`Unimplemented type ${element.type}`);
          }
        }
      }
    };
    elementWithCanvasCache = /* @__PURE__ */ new WeakMap();
    generateElementWithCanvas = (element, elementsMap, renderConfig, appState) => {
      const zoom = renderConfig ? appState.zoom : defaultAppState.zoom;
      const prevElementWithCanvas = elementWithCanvasCache.get(element);
      const shouldRegenerateBecauseZoom = prevElementWithCanvas && prevElementWithCanvas.zoomValue !== zoom.value && !appState?.shouldCacheIgnoreZoom;
      const boundTextElementVersion = getBoundTextElement(element, elementsMap)?.version || null;
      const containingFrameOpacity = getContainingFrame(element)?.opacity || 100;
      if (!prevElementWithCanvas || shouldRegenerateBecauseZoom || prevElementWithCanvas.theme !== appState.theme || prevElementWithCanvas.boundTextElementVersion !== boundTextElementVersion || prevElementWithCanvas.containingFrameOpacity !== containingFrameOpacity) {
        const elementWithCanvas = generateElementCanvas(
          element,
          elementsMap,
          zoom,
          renderConfig,
          appState
        );
        elementWithCanvasCache.set(element, elementWithCanvas);
        return elementWithCanvas;
      }
      return prevElementWithCanvas;
    };
    drawElementFromCanvas = (elementWithCanvas, context, renderConfig, appState, allElementsMap) => {
      const element = elementWithCanvas.element;
      const padding = getCanvasPadding(element);
      const zoom = elementWithCanvas.scale;
      let [x1, y1, x2, y2] = getElementAbsoluteCoords(element, allElementsMap);
      if (isFreeDrawElement(element)) {
        x1 = Math.floor(x1);
        x2 = Math.ceil(x2);
        y1 = Math.floor(y1);
        y2 = Math.ceil(y2);
      }
      const cx = ((x1 + x2) / 2 + appState.scrollX) * window.devicePixelRatio;
      const cy = ((y1 + y2) / 2 + appState.scrollY) * window.devicePixelRatio;
      context.save();
      context.scale(1 / window.devicePixelRatio, 1 / window.devicePixelRatio);
      const boundTextElement = getBoundTextElement(element, allElementsMap);
      if (isArrowElement(element) && boundTextElement) {
        const tempCanvas = document.createElement("canvas");
        const tempCanvasContext = tempCanvas.getContext("2d");
        const maxDim = Math.max(distance(x1, x2), distance(y1, y2));
        tempCanvas.width = maxDim * window.devicePixelRatio * zoom + padding * elementWithCanvas.scale * 10;
        tempCanvas.height = maxDim * window.devicePixelRatio * zoom + padding * elementWithCanvas.scale * 10;
        const offsetX = (tempCanvas.width - elementWithCanvas.canvas.width) / 2;
        const offsetY = (tempCanvas.height - elementWithCanvas.canvas.height) / 2;
        tempCanvasContext.translate(tempCanvas.width / 2, tempCanvas.height / 2);
        tempCanvasContext.rotate(element.angle);
        tempCanvasContext.drawImage(
          elementWithCanvas.canvas,
          -elementWithCanvas.canvas.width / 2,
          -elementWithCanvas.canvas.height / 2,
          elementWithCanvas.canvas.width,
          elementWithCanvas.canvas.height
        );
        const [, , , , boundTextCx, boundTextCy] = getElementAbsoluteCoords(
          boundTextElement,
          allElementsMap
        );
        tempCanvasContext.rotate(-element.angle);
        const shiftX = tempCanvas.width / 2 - (boundTextCx - x1) * window.devicePixelRatio * zoom - offsetX - padding * zoom;
        const shiftY = tempCanvas.height / 2 - (boundTextCy - y1) * window.devicePixelRatio * zoom - offsetY - padding * zoom;
        tempCanvasContext.translate(-shiftX, -shiftY);
        tempCanvasContext.clearRect(
          -(boundTextElement.width / 2 + BOUND_TEXT_PADDING) * window.devicePixelRatio * zoom,
          -(boundTextElement.height / 2 + BOUND_TEXT_PADDING) * window.devicePixelRatio * zoom,
          (boundTextElement.width + BOUND_TEXT_PADDING * 2) * window.devicePixelRatio * zoom,
          (boundTextElement.height + BOUND_TEXT_PADDING * 2) * window.devicePixelRatio * zoom
        );
        context.translate(cx, cy);
        context.drawImage(
          tempCanvas,
          -(x2 - x1) / 2 * window.devicePixelRatio - offsetX / zoom - padding,
          -(y2 - y1) / 2 * window.devicePixelRatio - offsetY / zoom - padding,
          tempCanvas.width / zoom,
          tempCanvas.height / zoom
        );
      } else {
        context.translate(cx, cy);
        context.rotate(element.angle);
        if ("scale" in elementWithCanvas.element && !isPendingImageElement(element, renderConfig)) {
          context.scale(
            elementWithCanvas.element.scale[0],
            elementWithCanvas.element.scale[1]
          );
        }
        context.translate(-cx, -cy);
        context.drawImage(
          elementWithCanvas.canvas,
          (x1 + appState.scrollX) * window.devicePixelRatio - padding * elementWithCanvas.scale / elementWithCanvas.scale,
          (y1 + appState.scrollY) * window.devicePixelRatio - padding * elementWithCanvas.scale / elementWithCanvas.scale,
          elementWithCanvas.canvas.width / elementWithCanvas.scale,
          elementWithCanvas.canvas.height / elementWithCanvas.scale
        );
        if (define_import_meta_env_default.VITE_APP_DEBUG_ENABLE_TEXT_CONTAINER_BOUNDING_BOX === "true" && hasBoundTextElement(element)) {
          const textElement = getBoundTextElement(
            element,
            allElementsMap
          );
          const coords = getContainerCoords(element);
          context.strokeStyle = "#c92a2a";
          context.lineWidth = 3;
          context.strokeRect(
            (coords.x + appState.scrollX) * window.devicePixelRatio,
            (coords.y + appState.scrollY) * window.devicePixelRatio,
            getBoundTextMaxWidth(element, textElement) * window.devicePixelRatio,
            getBoundTextMaxHeight(element, textElement) * window.devicePixelRatio
          );
        }
      }
      context.restore();
    };
    renderSelectionElement = (element, context, appState) => {
      context.save();
      context.translate(element.x + appState.scrollX, element.y + appState.scrollY);
      context.fillStyle = "rgba(0, 0, 200, 0.04)";
      const offset2 = 0.5 / appState.zoom.value;
      context.fillRect(offset2, offset2, element.width, element.height);
      context.lineWidth = 1 / appState.zoom.value;
      context.strokeStyle = " rgb(105, 101, 219)";
      context.strokeRect(offset2, offset2, element.width, element.height);
      context.restore();
    };
    renderElement = (element, elementsMap, allElementsMap, rc, context, renderConfig, appState) => {
      context.globalAlpha = getRenderOpacity(
        element,
        getContainingFrame(element),
        renderConfig.elementsPendingErasure
      );
      switch (element.type) {
        case "magicframe":
        case "frame": {
          if (appState.frameRendering.enabled && appState.frameRendering.outline) {
            context.save();
            context.translate(
              element.x + appState.scrollX,
              element.y + appState.scrollY
            );
            context.fillStyle = "rgba(0, 0, 200, 0.04)";
            context.lineWidth = FRAME_STYLE.strokeWidth / appState.zoom.value;
            context.strokeStyle = FRAME_STYLE.strokeColor;
            if (isMagicFrameElement(element)) {
              context.strokeStyle = appState.theme === "light" ? "#7affd7" : "#1d8264";
            }
            if (FRAME_STYLE.radius && context.roundRect) {
              context.beginPath();
              context.roundRect(
                0,
                0,
                element.width,
                element.height,
                FRAME_STYLE.radius / appState.zoom.value
              );
              context.stroke();
              context.closePath();
            } else {
              context.strokeRect(0, 0, element.width, element.height);
            }
            context.restore();
          }
          break;
        }
        case "freedraw": {
          ShapeCache.generateElementShape(element, null);
          if (renderConfig.isExporting) {
            const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);
            const cx = (x1 + x2) / 2 + appState.scrollX;
            const cy = (y1 + y2) / 2 + appState.scrollY;
            const shiftX = (x2 - x1) / 2 - (element.x - x1);
            const shiftY = (y2 - y1) / 2 - (element.y - y1);
            context.save();
            context.translate(cx, cy);
            context.rotate(element.angle);
            context.translate(-shiftX, -shiftY);
            drawElementOnCanvas(element, rc, context, renderConfig, appState);
            context.restore();
          } else {
            const elementWithCanvas = generateElementWithCanvas(
              element,
              elementsMap,
              renderConfig,
              appState
            );
            drawElementFromCanvas(
              elementWithCanvas,
              context,
              renderConfig,
              appState,
              allElementsMap
            );
          }
          break;
        }
        case "rectangle":
        case "diamond":
        case "ellipse":
        case "line":
        case "arrow":
        case "image":
        case "text":
        case "iframe":
        case "embeddable": {
          ShapeCache.generateElementShape(element, renderConfig);
          if (renderConfig.isExporting) {
            const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);
            const cx = (x1 + x2) / 2 + appState.scrollX;
            const cy = (y1 + y2) / 2 + appState.scrollY;
            let shiftX = (x2 - x1) / 2 - (element.x - x1);
            let shiftY = (y2 - y1) / 2 - (element.y - y1);
            if (isTextElement(element)) {
              const container = getContainerElement(element, elementsMap);
              if (isArrowElement(container)) {
                const boundTextCoords = LinearElementEditor.getBoundTextElementPosition(
                  container,
                  element,
                  elementsMap
                );
                shiftX = (x2 - x1) / 2 - (boundTextCoords.x - x1);
                shiftY = (y2 - y1) / 2 - (boundTextCoords.y - y1);
              }
            }
            context.save();
            context.translate(cx, cy);
            if (shouldResetImageFilter(element, renderConfig, appState)) {
              context.filter = "none";
            }
            const boundTextElement = getBoundTextElement(element, elementsMap);
            if (isArrowElement(element) && boundTextElement) {
              const tempCanvas = document.createElement("canvas");
              const tempCanvasContext = tempCanvas.getContext("2d");
              const maxDim = Math.max(distance(x1, x2), distance(y1, y2));
              const padding = getCanvasPadding(element);
              tempCanvas.width = maxDim * appState.exportScale + padding * 10 * appState.exportScale;
              tempCanvas.height = maxDim * appState.exportScale + padding * 10 * appState.exportScale;
              tempCanvasContext.translate(
                tempCanvas.width / 2,
                tempCanvas.height / 2
              );
              tempCanvasContext.scale(appState.exportScale, appState.exportScale);
              shiftX = element.width / 2 - (element.x - x1);
              shiftY = element.height / 2 - (element.y - y1);
              tempCanvasContext.rotate(element.angle);
              const tempRc = rough3.canvas(tempCanvas);
              tempCanvasContext.translate(-shiftX, -shiftY);
              drawElementOnCanvas(
                element,
                tempRc,
                tempCanvasContext,
                renderConfig,
                appState
              );
              tempCanvasContext.translate(shiftX, shiftY);
              tempCanvasContext.rotate(-element.angle);
              const [, , , , boundTextCx, boundTextCy] = getElementAbsoluteCoords(
                boundTextElement,
                elementsMap
              );
              const boundTextShiftX = (x1 + x2) / 2 - boundTextCx;
              const boundTextShiftY = (y1 + y2) / 2 - boundTextCy;
              tempCanvasContext.translate(-boundTextShiftX, -boundTextShiftY);
              tempCanvasContext.clearRect(
                -boundTextElement.width / 2,
                -boundTextElement.height / 2,
                boundTextElement.width,
                boundTextElement.height
              );
              context.scale(1 / appState.exportScale, 1 / appState.exportScale);
              context.drawImage(
                tempCanvas,
                -tempCanvas.width / 2,
                -tempCanvas.height / 2,
                tempCanvas.width,
                tempCanvas.height
              );
            } else {
              context.rotate(element.angle);
              if (element.type === "image") {
                context.scale(element.scale[0], element.scale[1]);
              }
              context.translate(-shiftX, -shiftY);
              drawElementOnCanvas(element, rc, context, renderConfig, appState);
            }
            context.restore();
          } else {
            const elementWithCanvas = generateElementWithCanvas(
              element,
              elementsMap,
              renderConfig,
              appState
            );
            const currentImageSmoothingStatus = context.imageSmoothingEnabled;
            if (
              // do not disable smoothing during zoom as blurry shapes look better
              // on low resolution (while still zooming in) than sharp ones
              !appState?.shouldCacheIgnoreZoom && // angle is 0 -> always disable smoothing
              (!element.angle || // or check if angle is a right angle in which case we can still
              // disable smoothing without adversely affecting the result
              isRightAngle(element.angle))
            ) {
              context.imageSmoothingEnabled = false;
            }
            drawElementFromCanvas(
              elementWithCanvas,
              context,
              renderConfig,
              appState,
              allElementsMap
            );
            context.imageSmoothingEnabled = currentImageSmoothingStatus;
          }
          break;
        }
        default: {
          throw new Error(`Unimplemented type ${element.type}`);
        }
      }
      context.globalAlpha = 1;
    };
    roughSVGDrawWithPrecision = (rsvg, drawable, precision) => {
      if (typeof precision === "undefined") {
        return rsvg.draw(drawable);
      }
      const pshape = {
        sets: drawable.sets,
        shape: drawable.shape,
        options: { ...drawable.options, fixedDecimalPlaceDigits: precision }
      };
      return rsvg.draw(pshape);
    };
    maybeWrapNodesInFrameClipPath = (element, root, nodes, frameRendering) => {
      if (!frameRendering.enabled || !frameRendering.clip) {
        return null;
      }
      const frame = getContainingFrame(element);
      if (frame) {
        const g = root.ownerDocument.createElementNS(SVG_NS, "g");
        g.setAttributeNS(SVG_NS, "clip-path", `url(#${frame.id})`);
        nodes.forEach((node) => g.appendChild(node));
        return g;
      }
      return null;
    };
    renderElementToSvg = (element, elementsMap, rsvg, svgRoot, files, offsetX, offsetY, renderConfig) => {
      const offset2 = { x: offsetX, y: offsetY };
      const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);
      let cx = (x2 - x1) / 2 - (element.x - x1);
      let cy = (y2 - y1) / 2 - (element.y - y1);
      if (isTextElement(element)) {
        const container = getContainerElement(element, elementsMap);
        if (isArrowElement(container)) {
          const [x12, y12, x22, y22] = getElementAbsoluteCoords(container, elementsMap);
          const boundTextCoords = LinearElementEditor.getBoundTextElementPosition(
            container,
            element,
            elementsMap
          );
          cx = (x22 - x12) / 2 - (boundTextCoords.x - x12);
          cy = (y22 - y12) / 2 - (boundTextCoords.y - y12);
          offsetX = offsetX + boundTextCoords.x - element.x;
          offsetY = offsetY + boundTextCoords.y - element.y;
        }
      }
      const degree = 180 * element.angle / Math.PI;
      let root = svgRoot;
      if (element.link) {
        const anchorTag = svgRoot.ownerDocument.createElementNS(SVG_NS, "a");
        anchorTag.setAttribute("href", normalizeLink(element.link));
        root.appendChild(anchorTag);
        root = anchorTag;
      }
      const addToRoot = (node, element2) => {
        if (isTestEnv()) {
          node.setAttribute("data-id", element2.id);
        }
        root.appendChild(node);
      };
      const opacity = (getContainingFrame(element)?.opacity ?? 100) * element.opacity / 1e4;
      switch (element.type) {
        case "selection": {
          throw new Error("Selection rendering is not supported for SVG");
        }
        case "rectangle":
        case "diamond":
        case "ellipse": {
          const shape = ShapeCache.generateElementShape(element, null);
          const node = roughSVGDrawWithPrecision(
            rsvg,
            shape,
            MAX_DECIMALS_FOR_SVG_EXPORT
          );
          if (opacity !== 1) {
            node.setAttribute("stroke-opacity", `${opacity}`);
            node.setAttribute("fill-opacity", `${opacity}`);
          }
          node.setAttribute("stroke-linecap", "round");
          node.setAttribute(
            "transform",
            `translate(${offsetX || 0} ${offsetY || 0}) rotate(${degree} ${cx} ${cy})`
          );
          const g = maybeWrapNodesInFrameClipPath(
            element,
            root,
            [node],
            renderConfig.frameRendering
          );
          addToRoot(g || node, element);
          break;
        }
        case "iframe":
        case "embeddable": {
          const shape = ShapeCache.generateElementShape(element, renderConfig);
          const node = roughSVGDrawWithPrecision(
            rsvg,
            shape,
            MAX_DECIMALS_FOR_SVG_EXPORT
          );
          const opacity2 = element.opacity / 100;
          if (opacity2 !== 1) {
            node.setAttribute("stroke-opacity", `${opacity2}`);
            node.setAttribute("fill-opacity", `${opacity2}`);
          }
          node.setAttribute("stroke-linecap", "round");
          node.setAttribute(
            "transform",
            `translate(${offsetX || 0} ${offsetY || 0}) rotate(${degree} ${cx} ${cy})`
          );
          addToRoot(node, element);
          const label = createPlaceholderEmbeddableLabel(element);
          renderElementToSvg(
            label,
            elementsMap,
            rsvg,
            root,
            files,
            label.x + offset2.x - element.x,
            label.y + offset2.y - element.y,
            renderConfig
          );
          const embeddableNode = roughSVGDrawWithPrecision(
            rsvg,
            shape,
            MAX_DECIMALS_FOR_SVG_EXPORT
          );
          embeddableNode.setAttribute("stroke-linecap", "round");
          embeddableNode.setAttribute(
            "transform",
            `translate(${offsetX || 0} ${offsetY || 0}) rotate(${degree} ${cx} ${cy})`
          );
          while (embeddableNode.firstChild) {
            embeddableNode.removeChild(embeddableNode.firstChild);
          }
          const radius = getCornerRadius(
            Math.min(element.width, element.height),
            element
          );
          const embedLink = getEmbedLink(toValidURL(element.link || ""));
          if (renderConfig.renderEmbeddables === false || embedLink?.type === "document") {
            const anchorTag = svgRoot.ownerDocument.createElementNS(SVG_NS, "a");
            anchorTag.setAttribute("href", normalizeLink(element.link || ""));
            anchorTag.setAttribute("target", "_blank");
            anchorTag.setAttribute("rel", "noopener noreferrer");
            anchorTag.style.borderRadius = `${radius}px`;
            embeddableNode.appendChild(anchorTag);
          } else {
            const foreignObject = svgRoot.ownerDocument.createElementNS(
              SVG_NS,
              "foreignObject"
            );
            foreignObject.style.width = `${element.width}px`;
            foreignObject.style.height = `${element.height}px`;
            foreignObject.style.border = "none";
            const div = foreignObject.ownerDocument.createElementNS(SVG_NS, "div");
            div.setAttribute("xmlns", "http://www.w3.org/1999/xhtml");
            div.style.width = "100%";
            div.style.height = "100%";
            const iframe = div.ownerDocument.createElement("iframe");
            iframe.src = embedLink?.link ?? "";
            iframe.style.width = "100%";
            iframe.style.height = "100%";
            iframe.style.border = "none";
            iframe.style.borderRadius = `${radius}px`;
            iframe.style.top = "0";
            iframe.style.left = "0";
            iframe.allowFullscreen = true;
            div.appendChild(iframe);
            foreignObject.appendChild(div);
            embeddableNode.appendChild(foreignObject);
          }
          addToRoot(embeddableNode, element);
          break;
        }
        case "line":
        case "arrow": {
          const boundText = getBoundTextElement(element, elementsMap);
          const maskPath = svgRoot.ownerDocument.createElementNS(SVG_NS, "mask");
          if (boundText) {
            maskPath.setAttribute("id", `mask-${element.id}`);
            const maskRectVisible = svgRoot.ownerDocument.createElementNS(
              SVG_NS,
              "rect"
            );
            offsetX = offsetX || 0;
            offsetY = offsetY || 0;
            maskRectVisible.setAttribute("x", "0");
            maskRectVisible.setAttribute("y", "0");
            maskRectVisible.setAttribute("fill", "#fff");
            maskRectVisible.setAttribute(
              "width",
              `${element.width + 100 + offsetX}`
            );
            maskRectVisible.setAttribute(
              "height",
              `${element.height + 100 + offsetY}`
            );
            maskPath.appendChild(maskRectVisible);
            const maskRectInvisible = svgRoot.ownerDocument.createElementNS(
              SVG_NS,
              "rect"
            );
            const boundTextCoords = LinearElementEditor.getBoundTextElementPosition(
              element,
              boundText,
              elementsMap
            );
            const maskX = offsetX + boundTextCoords.x - element.x;
            const maskY = offsetY + boundTextCoords.y - element.y;
            maskRectInvisible.setAttribute("x", maskX.toString());
            maskRectInvisible.setAttribute("y", maskY.toString());
            maskRectInvisible.setAttribute("fill", "#000");
            maskRectInvisible.setAttribute("width", `${boundText.width}`);
            maskRectInvisible.setAttribute("height", `${boundText.height}`);
            maskRectInvisible.setAttribute("opacity", "1");
            maskPath.appendChild(maskRectInvisible);
          }
          const group = svgRoot.ownerDocument.createElementNS(SVG_NS, "g");
          if (boundText) {
            group.setAttribute("mask", `url(#mask-${element.id})`);
          }
          group.setAttribute("stroke-linecap", "round");
          const shapes = ShapeCache.generateElementShape(element, renderConfig);
          shapes.forEach((shape) => {
            const node = roughSVGDrawWithPrecision(
              rsvg,
              shape,
              MAX_DECIMALS_FOR_SVG_EXPORT
            );
            if (opacity !== 1) {
              node.setAttribute("stroke-opacity", `${opacity}`);
              node.setAttribute("fill-opacity", `${opacity}`);
            }
            node.setAttribute(
              "transform",
              `translate(${offsetX || 0} ${offsetY || 0}) rotate(${degree} ${cx} ${cy})`
            );
            if (element.type === "line" && isPathALoop(element.points) && element.backgroundColor !== "transparent") {
              node.setAttribute("fill-rule", "evenodd");
            }
            group.appendChild(node);
          });
          const g = maybeWrapNodesInFrameClipPath(
            element,
            root,
            [group, maskPath],
            renderConfig.frameRendering
          );
          if (g) {
            addToRoot(g, element);
            root.appendChild(g);
          } else {
            addToRoot(group, element);
            root.append(maskPath);
          }
          break;
        }
        case "freedraw": {
          const backgroundFillShape = ShapeCache.generateElementShape(
            element,
            renderConfig
          );
          const node = backgroundFillShape ? roughSVGDrawWithPrecision(
            rsvg,
            backgroundFillShape,
            MAX_DECIMALS_FOR_SVG_EXPORT
          ) : svgRoot.ownerDocument.createElementNS(SVG_NS, "g");
          if (opacity !== 1) {
            node.setAttribute("stroke-opacity", `${opacity}`);
            node.setAttribute("fill-opacity", `${opacity}`);
          }
          node.setAttribute(
            "transform",
            `translate(${offsetX || 0} ${offsetY || 0}) rotate(${degree} ${cx} ${cy})`
          );
          node.setAttribute("stroke", "none");
          const path = svgRoot.ownerDocument.createElementNS(SVG_NS, "path");
          path.setAttribute("fill", element.strokeColor);
          path.setAttribute("d", getFreeDrawSvgPath(element));
          node.appendChild(path);
          const g = maybeWrapNodesInFrameClipPath(
            element,
            root,
            [node],
            renderConfig.frameRendering
          );
          addToRoot(g || node, element);
          break;
        }
        case "image": {
          const width = Math.round(element.width);
          const height = Math.round(element.height);
          const fileData = isInitializedImageElement(element) && files[element.fileId];
          if (fileData) {
            const symbolId = `image-${fileData.id}`;
            let symbol = svgRoot.querySelector(`#${symbolId}`);
            if (!symbol) {
              symbol = svgRoot.ownerDocument.createElementNS(SVG_NS, "symbol");
              symbol.id = symbolId;
              const image = svgRoot.ownerDocument.createElementNS(SVG_NS, "image");
              image.setAttribute("width", "100%");
              image.setAttribute("height", "100%");
              image.setAttribute("href", fileData.dataURL);
              symbol.appendChild(image);
              root.prepend(symbol);
            }
            const use = svgRoot.ownerDocument.createElementNS(SVG_NS, "use");
            use.setAttribute("href", `#${symbolId}`);
            if (renderConfig.exportWithDarkMode && fileData.mimeType !== MIME_TYPES.svg) {
              use.setAttribute("filter", IMAGE_INVERT_FILTER);
            }
            use.setAttribute("width", `${width}`);
            use.setAttribute("height", `${height}`);
            use.setAttribute("opacity", `${opacity}`);
            if (element.scale[0] !== 1 || element.scale[1] !== 1) {
              const translateX = element.scale[0] !== 1 ? -width : 0;
              const translateY = element.scale[1] !== 1 ? -height : 0;
              use.setAttribute(
                "transform",
                `scale(${element.scale[0]}, ${element.scale[1]}) translate(${translateX} ${translateY})`
              );
            }
            const g = svgRoot.ownerDocument.createElementNS(SVG_NS, "g");
            g.appendChild(use);
            g.setAttribute(
              "transform",
              `translate(${offsetX || 0} ${offsetY || 0}) rotate(${degree} ${cx} ${cy})`
            );
            if (element.roundness) {
              const clipPath = svgRoot.ownerDocument.createElementNS(
                SVG_NS,
                "clipPath"
              );
              clipPath.id = `image-clipPath-${element.id}`;
              const clipRect = svgRoot.ownerDocument.createElementNS(
                SVG_NS,
                "rect"
              );
              const radius = getCornerRadius(
                Math.min(element.width, element.height),
                element
              );
              clipRect.setAttribute("width", `${element.width}`);
              clipRect.setAttribute("height", `${element.height}`);
              clipRect.setAttribute("rx", `${radius}`);
              clipRect.setAttribute("ry", `${radius}`);
              clipPath.appendChild(clipRect);
              addToRoot(clipPath, element);
              g.setAttributeNS(SVG_NS, "clip-path", `url(#${clipPath.id})`);
            }
            const clipG = maybeWrapNodesInFrameClipPath(
              element,
              root,
              [g],
              renderConfig.frameRendering
            );
            addToRoot(clipG || g, element);
          }
          break;
        }
        case "frame":
        case "magicframe": {
          if (renderConfig.frameRendering.enabled && renderConfig.frameRendering.outline) {
            const rect = document.createElementNS(SVG_NS, "rect");
            rect.setAttribute(
              "transform",
              `translate(${offsetX || 0} ${offsetY || 0}) rotate(${degree} ${cx} ${cy})`
            );
            rect.setAttribute("width", `${element.width}px`);
            rect.setAttribute("height", `${element.height}px`);
            rect.setAttribute("rx", FRAME_STYLE.radius.toString());
            rect.setAttribute("ry", FRAME_STYLE.radius.toString());
            rect.setAttribute("fill", "none");
            rect.setAttribute("stroke", FRAME_STYLE.strokeColor);
            rect.setAttribute("stroke-width", FRAME_STYLE.strokeWidth.toString());
            addToRoot(rect, element);
          }
          break;
        }
        default: {
          if (isTextElement(element)) {
            const node = svgRoot.ownerDocument.createElementNS(SVG_NS, "g");
            if (opacity !== 1) {
              node.setAttribute("stroke-opacity", `${opacity}`);
              node.setAttribute("fill-opacity", `${opacity}`);
            }
            node.setAttribute(
              "transform",
              `translate(${offsetX || 0} ${offsetY || 0}) rotate(${degree} ${cx} ${cy})`
            );
            const lines = element.text.replace(/\r\n?/g, "\n").split("\n");
            const lineHeightPx = getLineHeightInPx(
              element.fontSize,
              element.lineHeight
            );
            const horizontalOffset = element.textAlign === "center" ? element.width / 2 : element.textAlign === "right" ? element.width : 0;
            const direction = isRTL(element.text) ? "rtl" : "ltr";
            const textAnchor = element.textAlign === "center" ? "middle" : element.textAlign === "right" || direction === "rtl" ? "end" : "start";
            for (let i = 0; i < lines.length; i++) {
              const text = svgRoot.ownerDocument.createElementNS(SVG_NS, "text");
              text.textContent = lines[i];
              text.setAttribute("x", `${horizontalOffset}`);
              text.setAttribute("y", `${i * lineHeightPx}`);
              text.setAttribute("font-family", getFontFamilyString(element));
              text.setAttribute("font-size", `${element.fontSize}px`);
              text.setAttribute("fill", element.strokeColor);
              text.setAttribute("text-anchor", textAnchor);
              text.setAttribute("style", "white-space: pre;");
              text.setAttribute("direction", direction);
              text.setAttribute("dominant-baseline", "text-before-edge");
              node.appendChild(text);
            }
            const g = maybeWrapNodesInFrameClipPath(
              element,
              root,
              [node],
              renderConfig.frameRendering
            );
            addToRoot(g || node, element);
          } else {
            throw new Error(`Unimplemented type ${element.type}`);
          }
        }
      }
    };
    pathsCache = /* @__PURE__ */ new WeakMap([]);
    TO_FIXED_PRECISION = /(\s?[A-Z]?,?-?[0-9]*\.[0-9]{0,2})(([0-9]|e|-)*)/g;
  }
});

// scene/ShapeCache.ts
import { RoughGenerator } from "roughjs/bin/generator";
var ShapeCache;
var init_ShapeCache = __esm({
  "scene/ShapeCache.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_renderElement();
    init_Shape();
    init_colors();
    ShapeCache = class _ShapeCache {
      static rg = new RoughGenerator();
      static cache = /* @__PURE__ */ new WeakMap();
      /**
       * Retrieves shape from cache if available. Use this only if shape
       * is optional and you have a fallback in case it's not cached.
       */
      static get = (element) => {
        return _ShapeCache.cache.get(
          element
        );
      };
      static set = (element, shape) => _ShapeCache.cache.set(element, shape);
      static delete = (element) => _ShapeCache.cache.delete(element);
      static destroy = () => {
        _ShapeCache.cache = /* @__PURE__ */ new WeakMap();
      };
      /**
       * Generates & caches shape for element if not already cached, otherwise
       * returns cached shape.
       */
      static generateElementShape = (element, renderConfig) => {
        const cachedShape = renderConfig?.isExporting ? void 0 : _ShapeCache.get(element);
        if (cachedShape !== void 0) {
          return cachedShape;
        }
        elementWithCanvasCache.delete(element);
        const shape = _generateElementShape(
          element,
          _ShapeCache.rg,
          renderConfig || {
            isExporting: false,
            canvasBackgroundColor: COLOR_PALETTE.white,
            embedsValidationStatus: null
          }
        );
        _ShapeCache.cache.set(element, shape);
        return shape;
      };
    };
  }
});

// element/mutateElement.ts
var mutateElement, newElementWith, bumpVersion;
var init_mutateElement = __esm({
  "element/mutateElement.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_Scene();
    init_points();
    init_random();
    init_utils();
    init_ShapeCache();
    mutateElement = (element, updates, informMutation = true) => {
      let didChange = false;
      const { points, fileId } = updates;
      if (typeof points !== "undefined") {
        updates = { ...getSizeFromPoints(points), ...updates };
      }
      for (const key in updates) {
        const value = updates[key];
        if (typeof value !== "undefined") {
          if (element[key] === value && // if object, always update because its attrs could have changed
          // (except for specific keys we handle below)
          (typeof value !== "object" || value === null || key === "groupIds" || key === "scale")) {
            continue;
          }
          if (key === "scale") {
            const prevScale = element[key];
            const nextScale = value;
            if (prevScale[0] === nextScale[0] && prevScale[1] === nextScale[1]) {
              continue;
            }
          } else if (key === "points") {
            const prevPoints = element[key];
            const nextPoints = value;
            if (prevPoints.length === nextPoints.length) {
              let didChangePoints = false;
              let index = prevPoints.length;
              while (--index) {
                const prevPoint = prevPoints[index];
                const nextPoint = nextPoints[index];
                if (prevPoint[0] !== nextPoint[0] || prevPoint[1] !== nextPoint[1]) {
                  didChangePoints = true;
                  break;
                }
              }
              if (!didChangePoints) {
                continue;
              }
            }
          }
          element[key] = value;
          didChange = true;
        }
      }
      if (!didChange) {
        return element;
      }
      if (typeof updates.height !== "undefined" || typeof updates.width !== "undefined" || typeof fileId != "undefined" || typeof points !== "undefined") {
        ShapeCache.delete(element);
      }
      element.version++;
      element.versionNonce = randomInteger();
      element.updated = getUpdatedTimestamp();
      if (informMutation) {
        Scene_default.getScene(element)?.informMutation();
      }
      return element;
    };
    newElementWith = (element, updates) => {
      let didChange = false;
      for (const key in updates) {
        const value = updates[key];
        if (typeof value !== "undefined") {
          if (element[key] === value && // if object, always update because its attrs could have changed
          (typeof value !== "object" || value === null)) {
            continue;
          }
          didChange = true;
        }
      }
      if (!didChange) {
        return element;
      }
      return {
        ...element,
        ...updates,
        updated: getUpdatedTimestamp(),
        version: element.version + 1,
        versionNonce: randomInteger()
      };
    };
    bumpVersion = (element, version) => {
      element.version = (version ?? element.version) + 1;
      element.versionNonce = randomInteger();
      element.updated = getUpdatedTimestamp();
      return element;
    };
  }
});

// element/sizeHelpers.ts
var isInvisiblySmallElement, isElementInViewport, getPerfectElementSize, getLockedLinearCursorAlignSize, getNormalizedDimensions;
var init_sizeHelpers = __esm({
  "element/sizeHelpers.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_mutateElement();
    init_typeChecks();
    init_constants();
    init_bounds();
    init_utils();
    isInvisiblySmallElement = (element) => {
      if (isLinearElement(element) || isFreeDrawElement(element)) {
        return element.points.length < 2;
      }
      return element.width === 0 && element.height === 0;
    };
    isElementInViewport = (element, width, height, viewTransformations, elementsMap) => {
      const [x1, y1, x2, y2] = getElementBounds(element, elementsMap);
      const topLeftSceneCoords = viewportCoordsToSceneCoords(
        {
          clientX: viewTransformations.offsetLeft,
          clientY: viewTransformations.offsetTop
        },
        viewTransformations
      );
      const bottomRightSceneCoords = viewportCoordsToSceneCoords(
        {
          clientX: viewTransformations.offsetLeft + width,
          clientY: viewTransformations.offsetTop + height
        },
        viewTransformations
      );
      return topLeftSceneCoords.x <= x2 && topLeftSceneCoords.y <= y2 && bottomRightSceneCoords.x >= x1 && bottomRightSceneCoords.y >= y1;
    };
    getPerfectElementSize = (elementType, width, height) => {
      const absWidth = Math.abs(width);
      const absHeight = Math.abs(height);
      if (elementType === "line" || elementType === "arrow" || elementType === "freedraw") {
        const lockedAngle = Math.round(Math.atan(absHeight / absWidth) / SHIFT_LOCKING_ANGLE) * SHIFT_LOCKING_ANGLE;
        if (lockedAngle === 0) {
          height = 0;
        } else if (lockedAngle === Math.PI / 2) {
          width = 0;
        } else {
          height = absWidth * Math.tan(lockedAngle) * Math.sign(height) || height;
        }
      } else if (elementType !== "selection") {
        height = absWidth * Math.sign(height);
      }
      return { width, height };
    };
    getLockedLinearCursorAlignSize = (originX, originY, x, y) => {
      let width = x - originX;
      let height = y - originY;
      const lockedAngle = Math.round(Math.atan(height / width) / SHIFT_LOCKING_ANGLE) * SHIFT_LOCKING_ANGLE;
      if (lockedAngle === 0) {
        height = 0;
      } else if (lockedAngle === Math.PI / 2) {
        width = 0;
      } else {
        const a1 = Math.tan(lockedAngle);
        const b1 = -1;
        const c1 = originY - a1 * originX;
        const a2 = -1 / a1;
        const b2 = -1;
        const c2 = y - a2 * x;
        const intersectX = (b1 * c2 - b2 * c1) / (a1 * b2 - a2 * b1);
        const intersectY = (c1 * a2 - c2 * a1) / (a1 * b2 - a2 * b1);
        width = intersectX - originX;
        height = intersectY - originY;
      }
      return { width, height };
    };
    getNormalizedDimensions = (element) => {
      const ret = {
        width: element.width,
        height: element.height,
        x: element.x,
        y: element.y
      };
      if (element.width < 0) {
        const nextWidth = Math.abs(element.width);
        ret.width = nextWidth;
        ret.x = element.x - nextWidth;
      }
      if (element.height < 0) {
        const nextHeight = Math.abs(element.height);
        ret.height = nextHeight;
        ret.y = element.y - nextHeight;
      }
      return ret;
    };
  }
});

// element/resizeTest.ts
var isInsideTransformHandle, resizeTest, getElementWithTransformHandleType, getTransformHandleTypeFromCoords, RESIZE_CURSORS, rotateResizeCursor, getCursorForResizingElement;
var init_resizeTest = __esm({
  "element/resizeTest.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_transformHandles();
    isInsideTransformHandle = (transformHandle, x, y) => x >= transformHandle[0] && x <= transformHandle[0] + transformHandle[2] && y >= transformHandle[1] && y <= transformHandle[1] + transformHandle[3];
    resizeTest = (element, elementsMap, appState, x, y, zoom, pointerType) => {
      if (!appState.selectedElementIds[element.id]) {
        return false;
      }
      const { rotation: rotationTransformHandle, ...transformHandles } = getTransformHandles(element, zoom, elementsMap, pointerType);
      if (rotationTransformHandle && isInsideTransformHandle(rotationTransformHandle, x, y)) {
        return "rotation";
      }
      const filter = Object.keys(transformHandles).filter((key) => {
        const transformHandle = transformHandles[key];
        if (!transformHandle) {
          return false;
        }
        return isInsideTransformHandle(transformHandle, x, y);
      });
      if (filter.length > 0) {
        return filter[0];
      }
      return false;
    };
    getElementWithTransformHandleType = (elements, appState, scenePointerX, scenePointerY, zoom, pointerType, elementsMap) => {
      return elements.reduce((result, element) => {
        if (result) {
          return result;
        }
        const transformHandleType = resizeTest(
          element,
          elementsMap,
          appState,
          scenePointerX,
          scenePointerY,
          zoom,
          pointerType
        );
        return transformHandleType ? { element, transformHandleType } : null;
      }, null);
    };
    getTransformHandleTypeFromCoords = ([x1, y1, x2, y2], scenePointerX, scenePointerY, zoom, pointerType) => {
      const transformHandles = getTransformHandlesFromCoords(
        [x1, y1, x2, y2, (x1 + x2) / 2, (y1 + y2) / 2],
        0,
        zoom,
        pointerType,
        OMIT_SIDES_FOR_MULTIPLE_ELEMENTS
      );
      const found = Object.keys(transformHandles).find((key) => {
        const transformHandle = transformHandles[key];
        return transformHandle && isInsideTransformHandle(transformHandle, scenePointerX, scenePointerY);
      });
      return found || false;
    };
    RESIZE_CURSORS = ["ns", "nesw", "ew", "nwse"];
    rotateResizeCursor = (cursor, angle) => {
      const index = RESIZE_CURSORS.indexOf(cursor);
      if (index >= 0) {
        const a = Math.round(angle / (Math.PI / 4));
        cursor = RESIZE_CURSORS[(index + a) % RESIZE_CURSORS.length];
      }
      return cursor;
    };
    getCursorForResizingElement = (resizingElement) => {
      const { element, transformHandleType } = resizingElement;
      const shouldSwapCursors = element && Math.sign(element.height) * Math.sign(element.width) === -1;
      let cursor = null;
      switch (transformHandleType) {
        case "n":
        case "s":
          cursor = "ns";
          break;
        case "w":
        case "e":
          cursor = "ew";
          break;
        case "nw":
        case "se":
          if (shouldSwapCursors) {
            cursor = "nesw";
          } else {
            cursor = "nwse";
          }
          break;
        case "ne":
        case "sw":
          if (shouldSwapCursors) {
            cursor = "nwse";
          } else {
            cursor = "nesw";
          }
          break;
        case "rotation":
          return "grab";
      }
      if (cursor && element) {
        cursor = rotateResizeCursor(cursor, element.angle);
      }
      return cursor ? `${cursor}-resize` : "";
    };
  }
});

// element/resizeElements.ts
var normalizeAngle, transformElements, rotateSingleElement, rescalePointsInElement, measureFontSizeFromWidth, getSidesForTransformHandle, resizeSingleTextElement, resizeSingleElement, resizeMultipleElements, rotateMultipleElements, getResizeOffsetXY, getResizeArrowDirection;
var init_resizeElements = __esm({
  "element/resizeElements.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_constants();
    init_points();
    init_math();
    init_bounds();
    init_typeChecks();
    init_mutateElement();
    init_utils();
    init_binding();
    init_Scene();
    init_textElement();
    init_linearElementEditor();
    normalizeAngle = (angle) => {
      if (angle < 0) {
        return angle + 2 * Math.PI;
      }
      if (angle >= 2 * Math.PI) {
        return angle - 2 * Math.PI;
      }
      return angle;
    };
    transformElements = (originalElements, transformHandleType, selectedElements, elementsMap, shouldRotateWithDiscreteAngle2, shouldResizeFromCenter2, shouldMaintainAspectRatio2, pointerX, pointerY, centerX, centerY) => {
      if (selectedElements.length === 1) {
        const [element] = selectedElements;
        if (transformHandleType === "rotation") {
          rotateSingleElement(
            element,
            elementsMap,
            pointerX,
            pointerY,
            shouldRotateWithDiscreteAngle2
          );
          updateBoundElements(element, elementsMap);
        } else if (isTextElement(element) && (transformHandleType === "nw" || transformHandleType === "ne" || transformHandleType === "sw" || transformHandleType === "se")) {
          resizeSingleTextElement(
            element,
            elementsMap,
            transformHandleType,
            shouldResizeFromCenter2,
            pointerX,
            pointerY
          );
          updateBoundElements(element, elementsMap);
        } else if (transformHandleType) {
          resizeSingleElement(
            originalElements,
            shouldMaintainAspectRatio2,
            element,
            elementsMap,
            transformHandleType,
            shouldResizeFromCenter2,
            pointerX,
            pointerY
          );
        }
        return true;
      } else if (selectedElements.length > 1) {
        if (transformHandleType === "rotation") {
          rotateMultipleElements(
            originalElements,
            selectedElements,
            elementsMap,
            pointerX,
            pointerY,
            shouldRotateWithDiscreteAngle2,
            centerX,
            centerY
          );
          return true;
        } else if (transformHandleType === "nw" || transformHandleType === "ne" || transformHandleType === "sw" || transformHandleType === "se") {
          resizeMultipleElements(
            originalElements,
            selectedElements,
            elementsMap,
            transformHandleType,
            shouldResizeFromCenter2,
            pointerX,
            pointerY
          );
          return true;
        }
      }
      return false;
    };
    rotateSingleElement = (element, elementsMap, pointerX, pointerY, shouldRotateWithDiscreteAngle2) => {
      const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);
      const cx = (x1 + x2) / 2;
      const cy = (y1 + y2) / 2;
      let angle;
      if (isFrameLikeElement(element)) {
        angle = 0;
      } else {
        angle = 5 * Math.PI / 2 + Math.atan2(pointerY - cy, pointerX - cx);
        if (shouldRotateWithDiscreteAngle2) {
          angle += SHIFT_LOCKING_ANGLE / 2;
          angle -= angle % SHIFT_LOCKING_ANGLE;
        }
        angle = normalizeAngle(angle);
      }
      const boundTextElementId = getBoundTextElementId(element);
      mutateElement(element, { angle });
      if (boundTextElementId) {
        const textElement = Scene_default.getScene(element)?.getElement(
          boundTextElementId
        );
        if (textElement && !isArrowElement(element)) {
          mutateElement(textElement, { angle });
        }
      }
    };
    rescalePointsInElement = (element, width, height, normalizePoints) => isLinearElement(element) || isFreeDrawElement(element) ? {
      points: rescalePoints(
        0,
        width,
        rescalePoints(1, height, element.points, normalizePoints),
        normalizePoints
      )
    } : {};
    measureFontSizeFromWidth = (element, elementsMap, nextWidth, nextHeight) => {
      let width = element.width;
      const hasContainer = isBoundToContainer(element);
      if (hasContainer) {
        const container = getContainerElement(element, elementsMap);
        if (container) {
          width = getBoundTextMaxWidth(container, element);
        }
      }
      const nextFontSize = element.fontSize * (nextWidth / width);
      if (nextFontSize < MIN_FONT_SIZE) {
        return null;
      }
      const metrics = measureText(
        element.text,
        getFontString({ fontSize: nextFontSize, fontFamily: element.fontFamily }),
        element.lineHeight
      );
      return {
        size: nextFontSize,
        baseline: metrics.baseline + (nextHeight - metrics.height)
      };
    };
    getSidesForTransformHandle = (transformHandleType, shouldResizeFromCenter2) => {
      return {
        n: /^(n|ne|nw)$/.test(transformHandleType) || shouldResizeFromCenter2 && /^(s|se|sw)$/.test(transformHandleType),
        s: /^(s|se|sw)$/.test(transformHandleType) || shouldResizeFromCenter2 && /^(n|ne|nw)$/.test(transformHandleType),
        w: /^(w|nw|sw)$/.test(transformHandleType) || shouldResizeFromCenter2 && /^(e|ne|se)$/.test(transformHandleType),
        e: /^(e|ne|se)$/.test(transformHandleType) || shouldResizeFromCenter2 && /^(w|nw|sw)$/.test(transformHandleType)
      };
    };
    resizeSingleTextElement = (element, elementsMap, transformHandleType, shouldResizeFromCenter2, pointerX, pointerY) => {
      const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);
      const cx = (x1 + x2) / 2;
      const cy = (y1 + y2) / 2;
      const [rotatedX, rotatedY] = rotate(
        pointerX,
        pointerY,
        cx,
        cy,
        -element.angle
      );
      let scale;
      switch (transformHandleType) {
        case "se":
          scale = Math.max(
            (rotatedX - x1) / (x2 - x1),
            (rotatedY - y1) / (y2 - y1)
          );
          break;
        case "nw":
          scale = Math.max(
            (x2 - rotatedX) / (x2 - x1),
            (y2 - rotatedY) / (y2 - y1)
          );
          break;
        case "ne":
          scale = Math.max(
            (rotatedX - x1) / (x2 - x1),
            (y2 - rotatedY) / (y2 - y1)
          );
          break;
        case "sw":
          scale = Math.max(
            (x2 - rotatedX) / (x2 - x1),
            (rotatedY - y1) / (y2 - y1)
          );
          break;
      }
      if (scale > 0) {
        const nextWidth = element.width * scale;
        const nextHeight = element.height * scale;
        const metrics = measureFontSizeFromWidth(
          element,
          elementsMap,
          nextWidth,
          nextHeight
        );
        if (metrics === null) {
          return;
        }
        const [nextX1, nextY1, nextX2, nextY2] = getResizedElementAbsoluteCoords(
          element,
          nextWidth,
          nextHeight,
          false
        );
        const deltaX1 = (x1 - nextX1) / 2;
        const deltaY1 = (y1 - nextY1) / 2;
        const deltaX2 = (x2 - nextX2) / 2;
        const deltaY2 = (y2 - nextY2) / 2;
        const [nextElementX, nextElementY] = adjustXYWithRotation(
          getSidesForTransformHandle(transformHandleType, shouldResizeFromCenter2),
          element.x,
          element.y,
          element.angle,
          deltaX1,
          deltaY1,
          deltaX2,
          deltaY2
        );
        mutateElement(element, {
          fontSize: metrics.size,
          width: nextWidth,
          height: nextHeight,
          baseline: metrics.baseline,
          x: nextElementX,
          y: nextElementY
        });
      }
    };
    resizeSingleElement = (originalElements, shouldMaintainAspectRatio2, element, elementsMap, transformHandleDirection, shouldResizeFromCenter2, pointerX, pointerY) => {
      const stateAtResizeStart = originalElements.get(element.id);
      const [x1, y1, x2, y2] = getResizedElementAbsoluteCoords(
        stateAtResizeStart,
        stateAtResizeStart.width,
        stateAtResizeStart.height,
        true
      );
      const startTopLeft = [x1, y1];
      const startBottomRight = [x2, y2];
      const startCenter = centerPoint(startTopLeft, startBottomRight);
      const rotatedPointer = rotatePoint(
        [pointerX, pointerY],
        startCenter,
        -stateAtResizeStart.angle
      );
      const [esx1, esy1, esx2, esy2] = getResizedElementAbsoluteCoords(
        element,
        element.width,
        element.height,
        true
      );
      const boundsCurrentWidth = esx2 - esx1;
      const boundsCurrentHeight = esy2 - esy1;
      const atStartBoundsWidth = startBottomRight[0] - startTopLeft[0];
      const atStartBoundsHeight = startBottomRight[1] - startTopLeft[1];
      let scaleX = atStartBoundsWidth / boundsCurrentWidth;
      let scaleY = atStartBoundsHeight / boundsCurrentHeight;
      let boundTextFont = {};
      const boundTextElement = getBoundTextElement(element, elementsMap);
      if (transformHandleDirection.includes("e")) {
        scaleX = (rotatedPointer[0] - startTopLeft[0]) / boundsCurrentWidth;
      }
      if (transformHandleDirection.includes("s")) {
        scaleY = (rotatedPointer[1] - startTopLeft[1]) / boundsCurrentHeight;
      }
      if (transformHandleDirection.includes("w")) {
        scaleX = (startBottomRight[0] - rotatedPointer[0]) / boundsCurrentWidth;
      }
      if (transformHandleDirection.includes("n")) {
        scaleY = (startBottomRight[1] - rotatedPointer[1]) / boundsCurrentHeight;
      }
      const eleInitialWidth = stateAtResizeStart.width;
      const eleInitialHeight = stateAtResizeStart.height;
      let eleNewWidth = element.width * scaleX;
      let eleNewHeight = element.height * scaleY;
      if (shouldResizeFromCenter2) {
        eleNewWidth = 2 * eleNewWidth - eleInitialWidth;
        eleNewHeight = 2 * eleNewHeight - eleInitialHeight;
      }
      if (shouldMaintainAspectRatio2) {
        const widthRatio = Math.abs(eleNewWidth) / eleInitialWidth;
        const heightRatio = Math.abs(eleNewHeight) / eleInitialHeight;
        if (transformHandleDirection.length === 1) {
          eleNewHeight *= widthRatio;
          eleNewWidth *= heightRatio;
        }
        if (transformHandleDirection.length === 2) {
          const ratio = Math.max(widthRatio, heightRatio);
          eleNewWidth = eleInitialWidth * ratio * Math.sign(eleNewWidth);
          eleNewHeight = eleInitialHeight * ratio * Math.sign(eleNewHeight);
        }
      }
      if (boundTextElement) {
        const stateOfBoundTextElementAtResize = originalElements.get(
          boundTextElement.id
        );
        if (stateOfBoundTextElementAtResize) {
          boundTextFont = {
            fontSize: stateOfBoundTextElementAtResize.fontSize,
            baseline: stateOfBoundTextElementAtResize.baseline
          };
        }
        if (shouldMaintainAspectRatio2) {
          const updatedElement = {
            ...element,
            width: eleNewWidth,
            height: eleNewHeight
          };
          const nextFont = measureFontSizeFromWidth(
            boundTextElement,
            elementsMap,
            getBoundTextMaxWidth(updatedElement, boundTextElement),
            getBoundTextMaxHeight(updatedElement, boundTextElement)
          );
          if (nextFont === null) {
            return;
          }
          boundTextFont = {
            fontSize: nextFont.size,
            baseline: nextFont.baseline
          };
        } else {
          const minWidth = getApproxMinLineWidth(
            getFontString(boundTextElement),
            boundTextElement.lineHeight
          );
          const minHeight = getApproxMinLineHeight(
            boundTextElement.fontSize,
            boundTextElement.lineHeight
          );
          eleNewWidth = Math.max(eleNewWidth, minWidth);
          eleNewHeight = Math.max(eleNewHeight, minHeight);
        }
      }
      const [newBoundsX1, newBoundsY1, newBoundsX2, newBoundsY2] = getResizedElementAbsoluteCoords(
        stateAtResizeStart,
        eleNewWidth,
        eleNewHeight,
        true
      );
      const newBoundsWidth = newBoundsX2 - newBoundsX1;
      const newBoundsHeight = newBoundsY2 - newBoundsY1;
      let newTopLeft = [...startTopLeft];
      if (["n", "w", "nw"].includes(transformHandleDirection)) {
        newTopLeft = [
          startBottomRight[0] - Math.abs(newBoundsWidth),
          startBottomRight[1] - Math.abs(newBoundsHeight)
        ];
      }
      if (transformHandleDirection === "ne") {
        const bottomLeft = [startTopLeft[0], startBottomRight[1]];
        newTopLeft = [bottomLeft[0], bottomLeft[1] - Math.abs(newBoundsHeight)];
      }
      if (transformHandleDirection === "sw") {
        const topRight = [startBottomRight[0], startTopLeft[1]];
        newTopLeft = [topRight[0] - Math.abs(newBoundsWidth), topRight[1]];
      }
      if (shouldMaintainAspectRatio2) {
        if (["s", "n"].includes(transformHandleDirection)) {
          newTopLeft[0] = startCenter[0] - newBoundsWidth / 2;
        }
        if (["e", "w"].includes(transformHandleDirection)) {
          newTopLeft[1] = startCenter[1] - newBoundsHeight / 2;
        }
      }
      const flipX = eleNewWidth < 0;
      const flipY = eleNewHeight < 0;
      if (flipX) {
        if (transformHandleDirection.includes("e")) {
          newTopLeft[0] -= Math.abs(newBoundsWidth);
        }
        if (transformHandleDirection.includes("w")) {
          newTopLeft[0] += Math.abs(newBoundsWidth);
        }
      }
      if (flipY) {
        if (transformHandleDirection.includes("s")) {
          newTopLeft[1] -= Math.abs(newBoundsHeight);
        }
        if (transformHandleDirection.includes("n")) {
          newTopLeft[1] += Math.abs(newBoundsHeight);
        }
      }
      if (shouldResizeFromCenter2) {
        newTopLeft[0] = startCenter[0] - Math.abs(newBoundsWidth) / 2;
        newTopLeft[1] = startCenter[1] - Math.abs(newBoundsHeight) / 2;
      }
      const angle = stateAtResizeStart.angle;
      const rotatedTopLeft = rotatePoint(newTopLeft, startCenter, angle);
      const newCenter = [
        newTopLeft[0] + Math.abs(newBoundsWidth) / 2,
        newTopLeft[1] + Math.abs(newBoundsHeight) / 2
      ];
      const rotatedNewCenter = rotatePoint(newCenter, startCenter, angle);
      newTopLeft = rotatePoint(rotatedTopLeft, rotatedNewCenter, -angle);
      const newOrigin = [...newTopLeft];
      const linearElementXOffset = stateAtResizeStart.x - newBoundsX1;
      const linearElementYOffset = stateAtResizeStart.y - newBoundsY1;
      newOrigin[0] += linearElementXOffset;
      newOrigin[1] += linearElementYOffset;
      const nextX = newOrigin[0];
      const nextY = newOrigin[1];
      let rescaledElementPointsY;
      let rescaledPoints;
      if (isLinearElement(element) || isFreeDrawElement(element)) {
        rescaledElementPointsY = rescalePoints(
          1,
          eleNewHeight,
          stateAtResizeStart.points,
          true
        );
        rescaledPoints = rescalePoints(
          0,
          eleNewWidth,
          rescaledElementPointsY,
          true
        );
      }
      const resizedElement = {
        width: Math.abs(eleNewWidth),
        height: Math.abs(eleNewHeight),
        x: nextX,
        y: nextY,
        points: rescaledPoints
      };
      if ("scale" in element && "scale" in stateAtResizeStart) {
        mutateElement(element, {
          scale: [
            // defaulting because scaleX/Y can be 0/-0
            (Math.sign(newBoundsX2 - stateAtResizeStart.x) || stateAtResizeStart.scale[0]) * stateAtResizeStart.scale[0],
            (Math.sign(newBoundsY2 - stateAtResizeStart.y) || stateAtResizeStart.scale[1]) * stateAtResizeStart.scale[1]
          ]
        });
      }
      if (isArrowElement(element) && boundTextElement && shouldMaintainAspectRatio2) {
        const fontSize = resizedElement.width / element.width * boundTextElement.fontSize;
        if (fontSize < MIN_FONT_SIZE) {
          return;
        }
        boundTextFont.fontSize = fontSize;
      }
      if (resizedElement.width !== 0 && resizedElement.height !== 0 && Number.isFinite(resizedElement.x) && Number.isFinite(resizedElement.y)) {
        mutateElement(element, resizedElement);
        updateBoundElements(element, elementsMap, {
          newSize: { width: resizedElement.width, height: resizedElement.height }
        });
        if (boundTextElement && boundTextFont != null) {
          mutateElement(boundTextElement, {
            fontSize: boundTextFont.fontSize,
            baseline: boundTextFont.baseline
          });
        }
        handleBindTextResize(
          element,
          elementsMap,
          transformHandleDirection,
          shouldMaintainAspectRatio2
        );
      }
    };
    resizeMultipleElements = (originalElements, selectedElements, elementsMap, transformHandleType, shouldResizeFromCenter2, pointerX, pointerY) => {
      const targetElements = selectedElements.reduce(
        (acc, element) => {
          const origElement = originalElements.get(element.id);
          if (origElement) {
            acc.push({ orig: origElement, latest: element });
          }
          return acc;
        },
        []
      );
      const boundTextElements = targetElements.reduce((acc, { orig }) => {
        if (!isLinearElement(orig)) {
          return acc;
        }
        const textId = getBoundTextElementId(orig);
        if (!textId) {
          return acc;
        }
        const text = originalElements.get(textId) ?? null;
        if (!isBoundToContainer(text)) {
          return acc;
        }
        const xy = LinearElementEditor.getBoundTextElementPosition(
          orig,
          text,
          elementsMap
        );
        return [...acc, { ...text, ...xy }];
      }, []);
      const { minX, minY, maxX, maxY, midX, midY } = getCommonBoundingBox(
        targetElements.map(({ orig }) => orig).concat(boundTextElements)
      );
      const direction = transformHandleType;
      const mapDirectionsToAnchors = {
        ne: [minX, maxY],
        se: [minX, minY],
        sw: [maxX, minY],
        nw: [maxX, maxY]
      };
      const [anchorX, anchorY] = shouldResizeFromCenter2 ? [midX, midY] : mapDirectionsToAnchors[direction];
      const scale = Math.max(
        Math.abs(pointerX - anchorX) / (maxX - minX) || 0,
        Math.abs(pointerY - anchorY) / (maxY - minY) || 0
      ) * (shouldResizeFromCenter2 ? 2 : 1);
      if (scale === 0) {
        return;
      }
      const mapDirectionsToPointerPositions = {
        ne: [pointerX >= anchorX, pointerY <= anchorY],
        se: [pointerX >= anchorX, pointerY >= anchorY],
        sw: [pointerX <= anchorX, pointerY >= anchorY],
        nw: [pointerX <= anchorX, pointerY <= anchorY]
      };
      const [flipFactorX, flipFactorY] = mapDirectionsToPointerPositions[direction].map((condition) => condition ? 1 : -1);
      const isFlippedByX = flipFactorX < 0;
      const isFlippedByY = flipFactorY < 0;
      const elementsAndUpdates = [];
      for (const { orig, latest } of targetElements) {
        if (isTextElement(orig) && isBoundToContainer(orig)) {
          continue;
        }
        const width = orig.width * scale;
        const height = orig.height * scale;
        const angle = normalizeAngle(orig.angle * flipFactorX * flipFactorY);
        const isLinearOrFreeDraw = isLinearElement(orig) || isFreeDrawElement(orig);
        const offsetX = orig.x - anchorX;
        const offsetY = orig.y - anchorY;
        const shiftX = isFlippedByX && !isLinearOrFreeDraw ? width : 0;
        const shiftY = isFlippedByY && !isLinearOrFreeDraw ? height : 0;
        const x = anchorX + flipFactorX * (offsetX * scale + shiftX);
        const y = anchorY + flipFactorY * (offsetY * scale + shiftY);
        const rescaledPoints = rescalePointsInElement(
          orig,
          width * flipFactorX,
          height * flipFactorY,
          false
        );
        const update = {
          x,
          y,
          width,
          height,
          angle,
          ...rescaledPoints
        };
        if (isImageElement(orig) && targetElements.length === 1) {
          update.scale = [orig.scale[0] * flipFactorX, orig.scale[1] * flipFactorY];
        }
        if (isLinearElement(orig) && (isFlippedByX || isFlippedByY)) {
          const origBounds = getElementPointsCoords(orig, orig.points);
          const newBounds = getElementPointsCoords(
            { ...orig, x, y },
            rescaledPoints.points
          );
          const origXY = [orig.x, orig.y];
          const newXY = [x, y];
          const linearShift = (axis) => {
            const i = axis === "x" ? 0 : 1;
            return (newBounds[i + 2] - newXY[i] - (origXY[i] - origBounds[i]) * scale + (origBounds[i + 2] - origXY[i]) * scale - (newXY[i] - newBounds[i])) / 2;
          };
          if (isFlippedByX) {
            update.x -= linearShift("x");
          }
          if (isFlippedByY) {
            update.y -= linearShift("y");
          }
        }
        if (isTextElement(orig)) {
          const metrics = measureFontSizeFromWidth(
            orig,
            elementsMap,
            width,
            height
          );
          if (!metrics) {
            return;
          }
          update.fontSize = metrics.size;
          update.baseline = metrics.baseline;
        }
        const boundTextElement = originalElements.get(
          getBoundTextElementId(orig) ?? ""
        );
        if (boundTextElement) {
          const newFontSize = boundTextElement.fontSize * scale;
          if (newFontSize < MIN_FONT_SIZE) {
            return;
          }
          update.boundTextFontSize = newFontSize;
        }
        elementsAndUpdates.push({
          element: latest,
          update
        });
      }
      const elementsToUpdate = elementsAndUpdates.map(({ element }) => element);
      for (const {
        element,
        update: { boundTextFontSize, ...update }
      } of elementsAndUpdates) {
        const { width, height, angle } = update;
        mutateElement(element, update, false);
        updateBoundElements(element, elementsMap, {
          simultaneouslyUpdated: elementsToUpdate,
          newSize: { width, height }
        });
        const boundTextElement = getBoundTextElement(element, elementsMap);
        if (boundTextElement && boundTextFontSize) {
          mutateElement(
            boundTextElement,
            {
              fontSize: boundTextFontSize,
              angle: isLinearElement(element) ? void 0 : angle
            },
            false
          );
          handleBindTextResize(element, elementsMap, transformHandleType, true);
        }
      }
      Scene_default.getScene(elementsAndUpdates[0].element)?.informMutation();
    };
    rotateMultipleElements = (originalElements, elements, elementsMap, pointerX, pointerY, shouldRotateWithDiscreteAngle2, centerX, centerY) => {
      let centerAngle = 5 * Math.PI / 2 + Math.atan2(pointerY - centerY, pointerX - centerX);
      if (shouldRotateWithDiscreteAngle2) {
        centerAngle += SHIFT_LOCKING_ANGLE / 2;
        centerAngle -= centerAngle % SHIFT_LOCKING_ANGLE;
      }
      elements.filter((element) => !isFrameLikeElement(element)).forEach((element) => {
        const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);
        const cx = (x1 + x2) / 2;
        const cy = (y1 + y2) / 2;
        const origAngle = originalElements.get(element.id)?.angle ?? element.angle;
        const [rotatedCX, rotatedCY] = rotate(
          cx,
          cy,
          centerX,
          centerY,
          centerAngle + origAngle - element.angle
        );
        mutateElement(
          element,
          {
            x: element.x + (rotatedCX - cx),
            y: element.y + (rotatedCY - cy),
            angle: normalizeAngle(centerAngle + origAngle)
          },
          false
        );
        updateBoundElements(element, elementsMap, {
          simultaneouslyUpdated: elements
        });
        const boundText = getBoundTextElement(element, elementsMap);
        if (boundText && !isArrowElement(element)) {
          mutateElement(
            boundText,
            {
              x: boundText.x + (rotatedCX - cx),
              y: boundText.y + (rotatedCY - cy),
              angle: normalizeAngle(centerAngle + origAngle)
            },
            false
          );
        }
      });
      Scene_default.getScene(elements[0])?.informMutation();
    };
    getResizeOffsetXY = (transformHandleType, selectedElements, elementsMap, x, y) => {
      const [x1, y1, x2, y2] = selectedElements.length === 1 ? getElementAbsoluteCoords(selectedElements[0], elementsMap) : getCommonBounds(selectedElements);
      const cx = (x1 + x2) / 2;
      const cy = (y1 + y2) / 2;
      const angle = selectedElements.length === 1 ? selectedElements[0].angle : 0;
      [x, y] = rotate(x, y, cx, cy, -angle);
      switch (transformHandleType) {
        case "n":
          return rotate(x - (x1 + x2) / 2, y - y1, 0, 0, angle);
        case "s":
          return rotate(x - (x1 + x2) / 2, y - y2, 0, 0, angle);
        case "w":
          return rotate(x - x1, y - (y1 + y2) / 2, 0, 0, angle);
        case "e":
          return rotate(x - x2, y - (y1 + y2) / 2, 0, 0, angle);
        case "nw":
          return rotate(x - x1, y - y1, 0, 0, angle);
        case "ne":
          return rotate(x - x2, y - y1, 0, 0, angle);
        case "sw":
          return rotate(x - x1, y - y2, 0, 0, angle);
        case "se":
          return rotate(x - x2, y - y2, 0, 0, angle);
        default:
          return [0, 0];
      }
    };
    getResizeArrowDirection = (transformHandleType, element) => {
      const [, [px, py]] = element.points;
      const isResizeEnd = transformHandleType === "nw" && (px < 0 || py < 0) || transformHandleType === "ne" && px >= 0 || transformHandleType === "sw" && px <= 0 || transformHandleType === "se" && (px > 0 || py > 0);
      return isResizeEnd ? "end" : "origin";
    };
  }
});

// element/dragElements.ts
var dragSelectedElements, calculateOffset, updateElementCoords, getDragOffsetXY, dragNewElement;
var init_dragElements = __esm({
  "element/dragElements.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_binding();
    init_bounds();
    init_mutateElement();
    init_sizeHelpers();
    init_textElement();
    init_math();
    init_typeChecks();
    dragSelectedElements = (pointerDownState, selectedElements, offset2, appState, scene, snapOffset, gridSize) => {
      const elementsToUpdate = new Set(
        selectedElements
      );
      const frames = selectedElements.filter((e) => isFrameLikeElement(e)).map((f) => f.id);
      if (frames.length > 0) {
        for (const element of scene.getNonDeletedElements()) {
          if (element.frameId !== null && frames.includes(element.frameId)) {
            elementsToUpdate.add(element);
          }
        }
      }
      const commonBounds = getCommonBounds(
        Array.from(elementsToUpdate).map(
          (el) => pointerDownState.originalElements.get(el.id) ?? el
        )
      );
      const adjustedOffset = calculateOffset(
        commonBounds,
        offset2,
        snapOffset,
        gridSize
      );
      elementsToUpdate.forEach((element) => {
        updateElementCoords(pointerDownState, element, adjustedOffset);
        if (
          // skip arrow labels since we calculate its position during render
          !isArrowElement(element)
        ) {
          const textElement = getBoundTextElement(
            element,
            scene.getNonDeletedElementsMap()
          );
          if (textElement) {
            updateElementCoords(pointerDownState, textElement, adjustedOffset);
          }
        }
        updateBoundElements(element, scene.getElementsMapIncludingDeleted(), {
          simultaneouslyUpdated: Array.from(elementsToUpdate)
        });
      });
    };
    calculateOffset = (commonBounds, dragOffset, snapOffset, gridSize) => {
      const [x, y] = commonBounds;
      let nextX = x + dragOffset.x + snapOffset.x;
      let nextY = y + dragOffset.y + snapOffset.y;
      if (snapOffset.x === 0 || snapOffset.y === 0) {
        const [nextGridX, nextGridY] = getGridPoint(
          x + dragOffset.x,
          y + dragOffset.y,
          gridSize
        );
        if (snapOffset.x === 0) {
          nextX = nextGridX;
        }
        if (snapOffset.y === 0) {
          nextY = nextGridY;
        }
      }
      return {
        x: nextX - x,
        y: nextY - y
      };
    };
    updateElementCoords = (pointerDownState, element, dragOffset) => {
      const originalElement = pointerDownState.originalElements.get(element.id) ?? element;
      const nextX = originalElement.x + dragOffset.x;
      const nextY = originalElement.y + dragOffset.y;
      mutateElement(element, {
        x: nextX,
        y: nextY
      });
    };
    getDragOffsetXY = (selectedElements, x, y) => {
      const [x1, y1] = getCommonBounds(selectedElements);
      return [x - x1, y - y1];
    };
    dragNewElement = (draggingElement, elementType, originX, originY, x, y, width, height, shouldMaintainAspectRatio2, shouldResizeFromCenter2, widthAspectRatio, originOffset = null) => {
      if (shouldMaintainAspectRatio2 && draggingElement.type !== "selection") {
        if (widthAspectRatio) {
          height = width / widthAspectRatio;
        } else {
          if (Math.abs(y - originY) > Math.abs(x - originX)) {
            ({ width, height } = getPerfectElementSize(
              elementType,
              height,
              x < originX ? -width : width
            ));
          } else {
            ({ width, height } = getPerfectElementSize(
              elementType,
              width,
              y < originY ? -height : height
            ));
          }
          if (height < 0) {
            height = -height;
          }
        }
      }
      let newX = x < originX ? originX - width : originX;
      let newY = y < originY ? originY - height : originY;
      if (shouldResizeFromCenter2) {
        width += width;
        height += height;
        newX = originX - width / 2;
        newY = originY - height / 2;
      }
      if (width !== 0 && height !== 0) {
        mutateElement(draggingElement, {
          x: newX + (originOffset?.x ?? 0),
          y: newY + (originOffset?.y ?? 0),
          width,
          height
        });
      }
    };
  }
});

// element/showSelectedShapeActions.ts
var showSelectedShapeActions;
var init_showSelectedShapeActions = __esm({
  "element/showSelectedShapeActions.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_scene();
    showSelectedShapeActions = (appState, elements) => Boolean(
      !appState.viewModeEnabled && (appState.activeTool.type !== "custom" && (appState.editingElement || appState.activeTool.type !== "selection" && appState.activeTool.type !== "eraser" && appState.activeTool.type !== "hand" && appState.activeTool.type !== "laser") || getSelectedElements(elements, appState).length)
    );
  }
});

// element/index.ts
var getSceneVersion, getVisibleElements, getNonDeletedElements3, isNonDeletedElement, _clearElements, clearElementsForDatabase, clearElementsForExport;
var init_element = __esm({
  "element/index.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_sizeHelpers();
    init_typeChecks();
    init_newElement();
    init_bounds();
    init_transformHandles();
    init_collision();
    init_resizeTest();
    init_resizeElements();
    init_dragElements();
    init_typeChecks();
    init_textElement();
    init_sizeHelpers();
    init_showSelectedShapeActions();
    getSceneVersion = (elements) => elements.reduce((acc, el) => acc + el.version, 0);
    getVisibleElements = (elements) => elements.filter(
      (el) => !el.isDeleted && !isInvisiblySmallElement(el)
    );
    getNonDeletedElements3 = (elements) => elements.filter((element) => !element.isDeleted);
    isNonDeletedElement = (element) => !element.isDeleted;
    _clearElements = (elements) => getNonDeletedElements3(elements).map(
      (element) => isLinearElementType(element.type) ? { ...element, lastCommittedPoint: null } : element
    );
    clearElementsForDatabase = (elements) => _clearElements(elements);
    clearElementsForExport = (elements) => _clearElements(elements);
  }
});

// scene/selection.ts
var excludeElementsInFramesFromSelection, getElementsWithinSelection, getVisibleAndNonSelectedElements, isSomeElementSelected, getCommonAttributeOfSelectedElements, getSelectedElements, getTargetElements, makeNextSelectedElementIds;
var init_selection = __esm({
  "scene/selection.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_element();
    init_typeChecks();
    init_frame();
    init_utils();
    init_sizeHelpers();
    excludeElementsInFramesFromSelection = (selectedElements) => {
      const framesInSelection = /* @__PURE__ */ new Set();
      selectedElements.forEach((element) => {
        if (isFrameLikeElement(element)) {
          framesInSelection.add(element.id);
        }
      });
      return selectedElements.filter((element) => {
        if (element.frameId && framesInSelection.has(element.frameId)) {
          return false;
        }
        return true;
      });
    };
    getElementsWithinSelection = (elements, selection, elementsMap, excludeElementsInFrames = true) => {
      const [selectionX1, selectionY1, selectionX2, selectionY2] = getElementAbsoluteCoords(selection, elementsMap);
      let elementsInSelection = elements.filter((element) => {
        let [elementX1, elementY1, elementX2, elementY2] = getElementBounds(
          element,
          elementsMap
        );
        const containingFrame = getContainingFrame(element);
        if (containingFrame) {
          const [fx1, fy1, fx2, fy2] = getElementBounds(
            containingFrame,
            elementsMap
          );
          elementX1 = Math.max(fx1, elementX1);
          elementY1 = Math.max(fy1, elementY1);
          elementX2 = Math.min(fx2, elementX2);
          elementY2 = Math.min(fy2, elementY2);
        }
        return element.locked === false && element.type !== "selection" && !isBoundToContainer(element) && selectionX1 <= elementX1 && selectionY1 <= elementY1 && selectionX2 >= elementX2 && selectionY2 >= elementY2;
      });
      elementsInSelection = excludeElementsInFrames ? excludeElementsInFramesFromSelection(elementsInSelection) : elementsInSelection;
      elementsInSelection = elementsInSelection.filter((element) => {
        const containingFrame = getContainingFrame(element);
        if (containingFrame) {
          return elementOverlapsWithFrame(element, containingFrame, elementsMap);
        }
        return true;
      });
      return elementsInSelection;
    };
    getVisibleAndNonSelectedElements = (elements, selectedElements, appState, elementsMap) => {
      const selectedElementsSet = new Set(
        selectedElements.map((element) => element.id)
      );
      return elements.filter((element) => {
        const isVisible = isElementInViewport(
          element,
          appState.width,
          appState.height,
          appState,
          elementsMap
        );
        return !selectedElementsSet.has(element.id) && isVisible;
      });
    };
    isSomeElementSelected = function() {
      let lastElements = null;
      let lastSelectedElementIds = null;
      let isSelected = null;
      const ret = (elements, appState) => {
        if (isSelected != null && elements === lastElements && appState.selectedElementIds === lastSelectedElementIds) {
          return isSelected;
        }
        isSelected = elements.some(
          (element) => appState.selectedElementIds[element.id]
        );
        lastElements = elements;
        lastSelectedElementIds = appState.selectedElementIds;
        return isSelected;
      };
      ret.clearCache = () => {
        lastElements = null;
        lastSelectedElementIds = null;
        isSelected = null;
      };
      return ret;
    }();
    getCommonAttributeOfSelectedElements = (elements, appState, getAttribute) => {
      const attributes = Array.from(
        new Set(
          getSelectedElements(elements, appState).map(
            (element) => getAttribute(element)
          )
        )
      );
      return attributes.length === 1 ? attributes[0] : null;
    };
    getSelectedElements = (elements, appState, opts) => {
      const selectedElements = [];
      for (const element of elements.values()) {
        if (appState.selectedElementIds[element.id]) {
          selectedElements.push(element);
          continue;
        }
        if (opts?.includeBoundTextElement && isBoundToContainer(element) && appState.selectedElementIds[element?.containerId]) {
          selectedElements.push(element);
          continue;
        }
      }
      if (opts?.includeElementsInFrames) {
        const elementsToInclude = [];
        selectedElements.forEach((element) => {
          if (isFrameLikeElement(element)) {
            getFrameChildren(elements, element.id).forEach(
              (e) => elementsToInclude.push(e)
            );
          }
          elementsToInclude.push(element);
        });
        return elementsToInclude;
      }
      return selectedElements;
    };
    getTargetElements = (elements, appState) => appState.editingElement ? [appState.editingElement] : getSelectedElements(elements, appState, {
      includeBoundTextElement: true
    });
    makeNextSelectedElementIds = (nextSelectedElementIds, prevState) => {
      if (isShallowEqual(prevState.selectedElementIds, nextSelectedElementIds)) {
        return prevState.selectedElementIds;
      }
      return nextSelectedElementIds;
    };
  }
});

// scene/scroll.ts
var isOutsideViewPort, centerScrollOn, calculateScrollCenter;
var init_scroll = __esm({
  "scene/scroll.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_element();
    init_utils();
    isOutsideViewPort = (appState, cords) => {
      const [x1, y1, x2, y2] = cords;
      const { x: viewportX1, y: viewportY1 } = sceneCoordsToViewportCoords(
        { sceneX: x1, sceneY: y1 },
        appState
      );
      const { x: viewportX2, y: viewportY2 } = sceneCoordsToViewportCoords(
        { sceneX: x2, sceneY: y2 },
        appState
      );
      return viewportX2 - viewportX1 > appState.width || viewportY2 - viewportY1 > appState.height;
    };
    centerScrollOn = ({
      scenePoint,
      viewportDimensions,
      zoom
    }) => {
      return {
        scrollX: viewportDimensions.width / 2 / zoom.value - scenePoint.x,
        scrollY: viewportDimensions.height / 2 / zoom.value - scenePoint.y
      };
    };
    calculateScrollCenter = (elements, appState) => {
      elements = getVisibleElements(elements);
      if (!elements.length) {
        return {
          scrollX: 0,
          scrollY: 0
        };
      }
      let [x1, y1, x2, y2] = getCommonBounds(elements);
      if (isOutsideViewPort(appState, [x1, y1, x2, y2])) {
        [x1, y1, x2, y2] = getClosestElementBounds(
          elements,
          viewportCoordsToSceneCoords(
            { clientX: appState.scrollX, clientY: appState.scrollY },
            appState
          )
        );
      }
      const centerX = (x1 + x2) / 2;
      const centerY = (y1 + y2) / 2;
      return centerScrollOn({
        scenePoint: { x: centerX, y: centerY },
        viewportDimensions: { width: appState.width, height: appState.height },
        zoom: appState.zoom
      });
    };
  }
});

// scene/zoom.ts
var getNormalizedZoom, getStateForZoom;
var init_zoom = __esm({
  "scene/zoom.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_constants();
    getNormalizedZoom = (zoom) => {
      return Math.max(MIN_ZOOM, Math.min(zoom, 30));
    };
    getStateForZoom = ({
      viewportX,
      viewportY,
      nextZoom
    }, appState) => {
      const appLayerX = viewportX - appState.offsetLeft;
      const appLayerY = viewportY - appState.offsetTop;
      const currentZoom = appState.zoom.value;
      const baseScrollX = appState.scrollX + (appLayerX - appLayerX / currentZoom);
      const baseScrollY = appState.scrollY + (appLayerY - appLayerY / currentZoom);
      const zoomOffsetScrollX = -(appLayerX - appLayerX / nextZoom);
      const zoomOffsetScrollY = -(appLayerY - appLayerY / nextZoom);
      return {
        scrollX: baseScrollX + zoomOffsetScrollX,
        scrollY: baseScrollY + zoomOffsetScrollY,
        zoom: {
          value: nextZoom
        }
      };
    };
  }
});

// scene/index.ts
var init_scene = __esm({
  "scene/index.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_selection();
    init_scroll();
    init_comparisons();
    init_zoom();
  }
});

// actions/actionDeleteSelected.tsx
import { jsx as jsx8 } from "react/jsx-runtime";
var deleteSelectedElements, handleGroupEditingState, actionDeleteSelected;
var init_actionDeleteSelected = __esm({
  "actions/actionDeleteSelected.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_scene();
    init_keys();
    init_ToolButton();
    init_i18n();
    init_register();
    init_element();
    init_mutateElement();
    init_groups();
    init_linearElementEditor();
    init_binding();
    init_typeChecks();
    init_utils();
    init_icons();
    deleteSelectedElements = (elements, appState) => {
      const framesToBeDeleted = new Set(
        getSelectedElements(
          elements.filter((el) => isFrameLikeElement(el)),
          appState
        ).map((el) => el.id)
      );
      return {
        elements: elements.map((el) => {
          if (appState.selectedElementIds[el.id]) {
            return newElementWith(el, { isDeleted: true });
          }
          if (el.frameId && framesToBeDeleted.has(el.frameId)) {
            return newElementWith(el, { isDeleted: true });
          }
          if (isBoundToContainer(el) && appState.selectedElementIds[el.containerId]) {
            return newElementWith(el, { isDeleted: true });
          }
          return el;
        }),
        appState: {
          ...appState,
          selectedElementIds: {},
          selectedGroupIds: {}
        }
      };
    };
    handleGroupEditingState = (appState, elements) => {
      if (appState.editingGroupId) {
        const siblingElements = getElementsInGroup(
          getNonDeletedElements3(elements),
          appState.editingGroupId
        );
        if (siblingElements.length) {
          return {
            ...appState,
            selectedElementIds: { [siblingElements[0].id]: true }
          };
        }
      }
      return appState;
    };
    actionDeleteSelected = register({
      name: "deleteSelectedElements",
      trackEvent: { category: "element", action: "delete" },
      perform: (elements, appState, formData, app) => {
        if (appState.editingLinearElement) {
          const {
            elementId,
            selectedPointsIndices,
            startBindingElement,
            endBindingElement
          } = appState.editingLinearElement;
          const elementsMap = app.scene.getNonDeletedElementsMap();
          const element = LinearElementEditor.getElement(elementId, elementsMap);
          if (!element) {
            return false;
          }
          if (selectedPointsIndices == null) {
            return false;
          }
          if (element.points.length < 2) {
            const nextElements2 = elements.map((el) => {
              if (el.id === element.id) {
                return newElementWith(el, { isDeleted: true });
              }
              return el;
            });
            const nextAppState2 = handleGroupEditingState(appState, nextElements2);
            return {
              elements: nextElements2,
              appState: {
                ...nextAppState2,
                editingLinearElement: null
              },
              commitToHistory: false
            };
          }
          const binding = {
            startBindingElement: selectedPointsIndices?.includes(0) ? null : startBindingElement,
            endBindingElement: selectedPointsIndices?.includes(
              element.points.length - 1
            ) ? null : endBindingElement
          };
          LinearElementEditor.deletePoints(element, selectedPointsIndices);
          return {
            elements,
            appState: {
              ...appState,
              editingLinearElement: {
                ...appState.editingLinearElement,
                ...binding,
                selectedPointsIndices: selectedPointsIndices?.[0] > 0 ? [selectedPointsIndices[0] - 1] : [0]
              }
            },
            commitToHistory: true
          };
        }
        let { elements: nextElements, appState: nextAppState } = deleteSelectedElements(elements, appState);
        fixBindingsAfterDeletion(
          nextElements,
          elements.filter(({ id }) => appState.selectedElementIds[id])
        );
        nextAppState = handleGroupEditingState(nextAppState, nextElements);
        return {
          elements: nextElements,
          appState: {
            ...nextAppState,
            activeTool: updateActiveTool(appState, { type: "selection" }),
            multiElement: null,
            activeEmbeddable: null
          },
          commitToHistory: isSomeElementSelected(
            getNonDeletedElements3(elements),
            appState
          )
        };
      },
      contextItemLabel: "labels.delete",
      keyTest: (event, appState, elements) => (event.key === KEYS.BACKSPACE || event.key === KEYS.DELETE) && !event[KEYS.CTRL_OR_CMD],
      PanelComponent: ({ elements, appState, updateData }) => /* @__PURE__ */ jsx8(
        ToolButton,
        {
          type: "button",
          icon: TrashIcon,
          title: t("labels.delete"),
          "aria-label": t("labels.delete"),
          onClick: () => updateData(null),
          visible: isSomeElementSelected(getNonDeletedElements3(elements), appState)
        }
      )
    });
  }
});

// zindex.ts
function shiftElementsAccountingForFrames(allElements, appState, direction, shiftFunction) {
  const elementsToMove = arrayToMap(
    getSelectedElements(allElements, appState, {
      includeBoundTextElement: true,
      includeElementsInFrames: true
    })
  );
  const frameAwareContiguousElementsToMove = { regularElements: [], frameChildren: /* @__PURE__ */ new Map() };
  const fullySelectedFrames = /* @__PURE__ */ new Set();
  for (const element of allElements) {
    if (elementsToMove.has(element.id) && isFrameLikeElement(element)) {
      fullySelectedFrames.add(element.id);
    }
  }
  for (const element of allElements) {
    if (elementsToMove.has(element.id)) {
      if (isFrameLikeElement(element) || element.frameId && fullySelectedFrames.has(element.frameId)) {
        frameAwareContiguousElementsToMove.regularElements.push(element);
      } else if (!element.frameId) {
        frameAwareContiguousElementsToMove.regularElements.push(element);
      } else {
        const frameChildren = frameAwareContiguousElementsToMove.frameChildren.get(
          element.frameId
        ) || [];
        frameChildren.push(element);
        frameAwareContiguousElementsToMove.frameChildren.set(
          element.frameId,
          frameChildren
        );
      }
    }
  }
  let nextElements = allElements;
  const frameChildrenSets = Array.from(
    frameAwareContiguousElementsToMove.frameChildren.entries()
  );
  for (const [frameId, children] of frameChildrenSets) {
    nextElements = shiftFunction(
      allElements,
      appState,
      direction,
      frameId,
      children
    );
  }
  return shiftFunction(
    nextElements,
    appState,
    direction,
    null,
    frameAwareContiguousElementsToMove.regularElements
  );
}
var isOfTargetFrame, getIndicesToMove, toContiguousGroups, getTargetIndexAccountingForBinding, getContiguousFrameRangeElements, getTargetIndex, getTargetElementsMap, shiftElementsByOne, shiftElementsToEnd, moveOneLeft, moveOneRight, moveAllLeft, moveAllRight;
var init_zindex = __esm({
  "zindex.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_mutateElement();
    init_typeChecks();
    init_groups();
    init_scene();
    init_Scene();
    init_utils();
    isOfTargetFrame = (element, frameId) => {
      return element.frameId === frameId || element.id === frameId;
    };
    getIndicesToMove = (elements, appState, elementsToBeMoved) => {
      let selectedIndices = [];
      let deletedIndices = [];
      let includeDeletedIndex = null;
      let index = -1;
      const selectedElementIds = arrayToMap(
        elementsToBeMoved ? elementsToBeMoved : getSelectedElements(elements, appState, {
          includeBoundTextElement: true,
          includeElementsInFrames: true
        })
      );
      while (++index < elements.length) {
        const element = elements[index];
        if (selectedElementIds.get(element.id)) {
          if (deletedIndices.length) {
            selectedIndices = selectedIndices.concat(deletedIndices);
            deletedIndices = [];
          }
          selectedIndices.push(index);
          includeDeletedIndex = index + 1;
        } else if (element.isDeleted && includeDeletedIndex === index) {
          includeDeletedIndex = index + 1;
          deletedIndices.push(index);
        } else {
          deletedIndices = [];
        }
      }
      return selectedIndices;
    };
    toContiguousGroups = (array) => {
      let cursor = 0;
      return array.reduce((acc, value, index) => {
        if (index > 0 && array[index - 1] !== value - 1) {
          cursor = ++cursor;
        }
        (acc[cursor] || (acc[cursor] = [])).push(value);
        return acc;
      }, []);
    };
    getTargetIndexAccountingForBinding = (nextElement, elements, direction) => {
      if ("containerId" in nextElement && nextElement.containerId) {
        if (direction === "left") {
          const containerElement = Scene_default.getScene(nextElement).getElement(
            nextElement.containerId
          );
          if (containerElement) {
            return elements.indexOf(containerElement);
          }
        } else {
          return elements.indexOf(nextElement);
        }
      } else {
        const boundElementId = nextElement.boundElements?.find(
          (binding) => binding.type !== "arrow"
        )?.id;
        if (boundElementId) {
          if (direction === "left") {
            return elements.indexOf(nextElement);
          }
          const boundTextElement = Scene_default.getScene(nextElement).getElement(boundElementId);
          if (boundTextElement) {
            return elements.indexOf(boundTextElement);
          }
        }
      }
    };
    getContiguousFrameRangeElements = (allElements, frameId) => {
      let rangeStart = -1;
      let rangeEnd = -1;
      allElements.forEach((element, index) => {
        if (isOfTargetFrame(element, frameId)) {
          if (rangeStart === -1) {
            rangeStart = index;
          }
          rangeEnd = index;
        }
      });
      if (rangeStart === -1) {
        return [];
      }
      return allElements.slice(rangeStart, rangeEnd + 1);
    };
    getTargetIndex = (appState, elements, boundaryIndex, direction, containingFrame) => {
      const sourceElement = elements[boundaryIndex];
      const indexFilter = (element) => {
        if (element.isDeleted) {
          return false;
        }
        if (containingFrame) {
          return element.frameId === containingFrame;
        }
        if (appState.editingGroupId) {
          return element.groupIds.includes(appState.editingGroupId);
        }
        return true;
      };
      const candidateIndex = direction === "left" ? findLastIndex(
        elements,
        (el) => indexFilter(el),
        Math.max(0, boundaryIndex - 1)
      ) : findIndex(elements, (el) => indexFilter(el), boundaryIndex + 1);
      const nextElement = elements[candidateIndex];
      if (!nextElement) {
        return -1;
      }
      if (appState.editingGroupId) {
        if (
          // candidate element is a sibling in current editing group  return
          sourceElement?.groupIds.join("") === nextElement?.groupIds.join("")
        ) {
          return getTargetIndexAccountingForBinding(nextElement, elements, direction) ?? candidateIndex;
        } else if (!nextElement?.groupIds.includes(appState.editingGroupId)) {
          return -1;
        }
      }
      if (!containingFrame && (nextElement.frameId || isFrameLikeElement(nextElement))) {
        const frameElements = getContiguousFrameRangeElements(
          elements,
          nextElement.frameId || nextElement.id
        );
        return direction === "left" ? elements.indexOf(frameElements[0]) : elements.indexOf(frameElements[frameElements.length - 1]);
      }
      if (!nextElement.groupIds.length) {
        return getTargetIndexAccountingForBinding(nextElement, elements, direction) ?? candidateIndex;
      }
      const siblingGroupId = appState.editingGroupId ? nextElement.groupIds[nextElement.groupIds.indexOf(appState.editingGroupId) - 1] : nextElement.groupIds[nextElement.groupIds.length - 1];
      const elementsInSiblingGroup = getElementsInGroup(elements, siblingGroupId);
      if (elementsInSiblingGroup.length) {
        return direction === "left" ? elements.indexOf(elementsInSiblingGroup[0]) : elements.indexOf(
          elementsInSiblingGroup[elementsInSiblingGroup.length - 1]
        );
      }
      return candidateIndex;
    };
    getTargetElementsMap = (elements, indices) => {
      return indices.reduce((acc, index) => {
        const element = elements[index];
        acc[element.id] = element;
        return acc;
      }, {});
    };
    shiftElementsByOne = (elements, appState, direction) => {
      const indicesToMove = getIndicesToMove(elements, appState);
      const targetElementsMap = getTargetElementsMap(elements, indicesToMove);
      let groupedIndices = toContiguousGroups(indicesToMove);
      if (direction === "right") {
        groupedIndices = groupedIndices.reverse();
      }
      const selectedFrames = new Set(
        indicesToMove.filter((idx) => isFrameLikeElement(elements[idx])).map((idx) => elements[idx].id)
      );
      groupedIndices.forEach((indices, i) => {
        const leadingIndex = indices[0];
        const trailingIndex = indices[indices.length - 1];
        const boundaryIndex = direction === "left" ? leadingIndex : trailingIndex;
        const containingFrame = indices.some((idx) => {
          const el = elements[idx];
          return el.frameId && selectedFrames.has(el.frameId);
        }) ? null : elements[boundaryIndex]?.frameId;
        const targetIndex = getTargetIndex(
          appState,
          elements,
          boundaryIndex,
          direction,
          containingFrame
        );
        if (targetIndex === -1 || boundaryIndex === targetIndex) {
          return;
        }
        const leadingElements = direction === "left" ? elements.slice(0, targetIndex) : elements.slice(0, leadingIndex);
        const targetElements = elements.slice(leadingIndex, trailingIndex + 1);
        const displacedElements = direction === "left" ? elements.slice(targetIndex, leadingIndex) : elements.slice(trailingIndex + 1, targetIndex + 1);
        const trailingElements = direction === "left" ? elements.slice(trailingIndex + 1) : elements.slice(targetIndex + 1);
        elements = direction === "left" ? [
          ...leadingElements,
          ...targetElements,
          ...displacedElements,
          ...trailingElements
        ] : [
          ...leadingElements,
          ...displacedElements,
          ...targetElements,
          ...trailingElements
        ];
      });
      return elements.map((element) => {
        if (targetElementsMap[element.id]) {
          return bumpVersion(element);
        }
        return element;
      });
    };
    shiftElementsToEnd = (elements, appState, direction, containingFrame, elementsToBeMoved) => {
      const indicesToMove = getIndicesToMove(elements, appState, elementsToBeMoved);
      const targetElementsMap = getTargetElementsMap(elements, indicesToMove);
      const displacedElements = [];
      let leadingIndex;
      let trailingIndex;
      if (direction === "left") {
        if (containingFrame) {
          leadingIndex = findIndex(
            elements,
            (el) => isOfTargetFrame(el, containingFrame)
          );
        } else if (appState.editingGroupId) {
          const groupElements = getElementsInGroup(
            elements,
            appState.editingGroupId
          );
          if (!groupElements.length) {
            return elements;
          }
          leadingIndex = elements.indexOf(groupElements[0]);
        } else {
          leadingIndex = 0;
        }
        trailingIndex = indicesToMove[indicesToMove.length - 1];
      } else {
        if (containingFrame) {
          trailingIndex = findLastIndex(
            elements,
            (el) => isOfTargetFrame(el, containingFrame)
          );
        } else if (appState.editingGroupId) {
          const groupElements = getElementsInGroup(
            elements,
            appState.editingGroupId
          );
          if (!groupElements.length) {
            return elements;
          }
          trailingIndex = elements.indexOf(groupElements[groupElements.length - 1]);
        } else {
          trailingIndex = elements.length - 1;
        }
        leadingIndex = indicesToMove[0];
      }
      if (leadingIndex === -1) {
        leadingIndex = 0;
      }
      for (let index = leadingIndex; index < trailingIndex + 1; index++) {
        if (!indicesToMove.includes(index)) {
          displacedElements.push(elements[index]);
        }
      }
      const targetElements = Object.values(targetElementsMap).map((element) => {
        return bumpVersion(element);
      });
      const leadingElements = elements.slice(0, leadingIndex);
      const trailingElements = elements.slice(trailingIndex + 1);
      return direction === "left" ? [
        ...leadingElements,
        ...targetElements,
        ...displacedElements,
        ...trailingElements
      ] : [
        ...leadingElements,
        ...displacedElements,
        ...targetElements,
        ...trailingElements
      ];
    };
    moveOneLeft = (allElements, appState) => {
      return shiftElementsByOne(allElements, appState, "left");
    };
    moveOneRight = (allElements, appState) => {
      return shiftElementsByOne(allElements, appState, "right");
    };
    moveAllLeft = (allElements, appState) => {
      return shiftElementsAccountingForFrames(
        allElements,
        appState,
        "left",
        shiftElementsToEnd
      );
    };
    moveAllRight = (allElements, appState) => {
      return shiftElementsAccountingForFrames(
        allElements,
        appState,
        "right",
        shiftElementsToEnd
      );
    };
  }
});

// actions/actionZindex.tsx
import { jsx as jsx9 } from "react/jsx-runtime";
var actionSendBackward, actionBringForward, actionSendToBack, actionBringToFront;
var init_actionZindex = __esm({
  "actions/actionZindex.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_zindex();
    init_keys();
    init_i18n();
    init_utils();
    init_register();
    init_icons();
    init_constants();
    actionSendBackward = register({
      name: "sendBackward",
      trackEvent: { category: "element" },
      perform: (elements, appState) => {
        return {
          elements: moveOneLeft(elements, appState),
          appState,
          commitToHistory: true
        };
      },
      contextItemLabel: "labels.sendBackward",
      keyPriority: 40,
      keyTest: (event) => event[KEYS.CTRL_OR_CMD] && !event.shiftKey && event.code === CODES.BRACKET_LEFT,
      PanelComponent: ({ updateData, appState }) => /* @__PURE__ */ jsx9(
        "button",
        {
          type: "button",
          className: "zIndexButton",
          onClick: () => updateData(null),
          title: `${t("labels.sendBackward")} \u2014 ${getShortcutKey("CtrlOrCmd+[")}`,
          children: SendBackwardIcon
        }
      )
    });
    actionBringForward = register({
      name: "bringForward",
      trackEvent: { category: "element" },
      perform: (elements, appState) => {
        return {
          elements: moveOneRight(elements, appState),
          appState,
          commitToHistory: true
        };
      },
      contextItemLabel: "labels.bringForward",
      keyPriority: 40,
      keyTest: (event) => event[KEYS.CTRL_OR_CMD] && !event.shiftKey && event.code === CODES.BRACKET_RIGHT,
      PanelComponent: ({ updateData, appState }) => /* @__PURE__ */ jsx9(
        "button",
        {
          type: "button",
          className: "zIndexButton",
          onClick: () => updateData(null),
          title: `${t("labels.bringForward")} \u2014 ${getShortcutKey("CtrlOrCmd+]")}`,
          children: BringForwardIcon
        }
      )
    });
    actionSendToBack = register({
      name: "sendToBack",
      trackEvent: { category: "element" },
      perform: (elements, appState) => {
        return {
          elements: moveAllLeft(elements, appState),
          appState,
          commitToHistory: true
        };
      },
      contextItemLabel: "labels.sendToBack",
      keyTest: (event) => isDarwin ? event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.BRACKET_LEFT : event[KEYS.CTRL_OR_CMD] && event.shiftKey && event.code === CODES.BRACKET_LEFT,
      PanelComponent: ({ updateData, appState }) => /* @__PURE__ */ jsx9(
        "button",
        {
          type: "button",
          className: "zIndexButton",
          onClick: () => updateData(null),
          title: `${t("labels.sendToBack")} \u2014 ${isDarwin ? getShortcutKey("CtrlOrCmd+Alt+[") : getShortcutKey("CtrlOrCmd+Shift+[")}`,
          children: SendToBackIcon
        }
      )
    });
    actionBringToFront = register({
      name: "bringToFront",
      trackEvent: { category: "element" },
      perform: (elements, appState) => {
        return {
          elements: moveAllRight(elements, appState),
          appState,
          commitToHistory: true
        };
      },
      contextItemLabel: "labels.bringToFront",
      keyTest: (event) => isDarwin ? event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.BRACKET_RIGHT : event[KEYS.CTRL_OR_CMD] && event.shiftKey && event.code === CODES.BRACKET_RIGHT,
      PanelComponent: ({ updateData, appState }) => /* @__PURE__ */ jsx9(
        "button",
        {
          type: "button",
          className: "zIndexButton",
          onClick: (event) => updateData(null),
          title: `${t("labels.bringToFront")} \u2014 ${isDarwin ? getShortcutKey("CtrlOrCmd+Alt+]") : getShortcutKey("CtrlOrCmd+Shift+]")}`,
          children: BringToFrontIcon
        }
      )
    });
  }
});

// actions/actionSelectAll.ts
var actionSelectAll;
var init_actionSelectAll = __esm({
  "actions/actionSelectAll.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_keys();
    init_register();
    init_groups();
    init_element();
    init_typeChecks();
    init_linearElementEditor();
    init_selection();
    actionSelectAll = register({
      name: "selectAll",
      trackEvent: { category: "canvas" },
      perform: (elements, appState, value, app) => {
        if (appState.editingLinearElement) {
          return false;
        }
        const selectedElementIds = excludeElementsInFramesFromSelection(
          elements.filter(
            (element) => !element.isDeleted && !(isTextElement(element) && element.containerId) && !element.locked
          )
        ).reduce((map, element) => {
          map[element.id] = true;
          return map;
        }, {});
        return {
          appState: {
            ...appState,
            ...selectGroupsForSelectedElements(
              {
                editingGroupId: null,
                selectedElementIds
              },
              getNonDeletedElements3(elements),
              appState,
              app
            ),
            selectedLinearElement: (
              // single linear element selected
              Object.keys(selectedElementIds).length === 1 && isLinearElement(elements[0]) ? new LinearElementEditor(elements[0]) : null
            )
          },
          commitToHistory: true
        };
      },
      contextItemLabel: "labels.selectAll",
      keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.key === KEYS.A
    });
  }
});

// element/sortElements.ts
var normalizeGroupElementOrder, normalizeBoundElementsOrder, normalizeElementOrder;
var init_sortElements = __esm({
  "element/sortElements.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_utils();
    normalizeGroupElementOrder = (elements) => {
      const origElements = elements.slice();
      const sortedElements = /* @__PURE__ */ new Set();
      const orderInnerGroups = (elements2) => {
        const firstGroupSig = elements2[0]?.groupIds?.join("");
        const aGroup = [elements2[0]];
        const bGroup = [];
        for (const element of elements2.slice(1)) {
          if (element.groupIds?.join("") === firstGroupSig) {
            aGroup.push(element);
          } else {
            bGroup.push(element);
          }
        }
        return bGroup.length ? [...aGroup, ...orderInnerGroups(bGroup)] : aGroup;
      };
      const groupHandledElements = /* @__PURE__ */ new Map();
      origElements.forEach((element, idx) => {
        if (groupHandledElements.has(element.id)) {
          return;
        }
        if (element.groupIds?.length) {
          const topGroup = element.groupIds[element.groupIds.length - 1];
          const groupElements = origElements.slice(idx).filter((element2) => {
            const ret = element2?.groupIds?.some((id) => id === topGroup);
            if (ret) {
              groupHandledElements.set(element2.id, true);
            }
            return ret;
          });
          for (const elem of orderInnerGroups(groupElements)) {
            sortedElements.add(elem);
          }
        } else {
          sortedElements.add(element);
        }
      });
      if (sortedElements.size !== elements.length) {
        console.error("normalizeGroupElementOrder: lost some elements... bailing!");
        return elements;
      }
      return [...sortedElements];
    };
    normalizeBoundElementsOrder = (elements) => {
      const elementsMap = arrayToMapWithIndex(elements);
      const origElements = elements.slice();
      const sortedElements = /* @__PURE__ */ new Set();
      origElements.forEach((element, idx) => {
        if (!element) {
          return;
        }
        if (element.boundElements?.length) {
          sortedElements.add(element);
          origElements[idx] = null;
          element.boundElements.forEach((boundElement) => {
            const child = elementsMap.get(boundElement.id);
            if (child && boundElement.type === "text") {
              sortedElements.add(child[0]);
              origElements[child[1]] = null;
            }
          });
        } else if (element.type === "text" && element.containerId) {
          const parent = elementsMap.get(element.containerId);
          if (!parent?.[0].boundElements?.find((x) => x.id === element.id)) {
            sortedElements.add(element);
            origElements[idx] = null;
          }
        } else {
          sortedElements.add(element);
          origElements[idx] = null;
        }
      });
      if (sortedElements.size !== elements.length) {
        console.error(
          "normalizeBoundElementsOrder: lost some elements... bailing!"
        );
        return elements;
      }
      return [...sortedElements];
    };
    normalizeElementOrder = (elements) => {
      const ret = normalizeBoundElementsOrder(normalizeGroupElementOrder(elements));
      return ret;
    };
  }
});

// actions/actionDuplicateSelection.tsx
import { jsx as jsx10 } from "react/jsx-runtime";
var actionDuplicateSelection, duplicateElements2;
var init_actionDuplicateSelection = __esm({
  "actions/actionDuplicateSelection.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_keys();
    init_register();
    init_element();
    init_scene();
    init_ToolButton();
    init_i18n();
    init_utils();
    init_linearElementEditor();
    init_groups();
    init_binding();
    init_constants();
    init_textElement();
    init_typeChecks();
    init_sortElements();
    init_icons();
    init_frame();
    init_selection();
    actionDuplicateSelection = register({
      name: "duplicateSelection",
      trackEvent: { category: "element" },
      perform: (elements, appState, formData, app) => {
        const elementsMap = app.scene.getNonDeletedElementsMap();
        if (appState.editingLinearElement) {
          const ret = LinearElementEditor.duplicateSelectedPoints(
            appState,
            elementsMap
          );
          if (!ret) {
            return false;
          }
          return {
            elements,
            appState: ret.appState,
            commitToHistory: true
          };
        }
        return {
          ...duplicateElements2(elements, appState),
          commitToHistory: true
        };
      },
      contextItemLabel: "labels.duplicateSelection",
      keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.key === KEYS.D,
      PanelComponent: ({ elements, appState, updateData }) => /* @__PURE__ */ jsx10(
        ToolButton,
        {
          type: "button",
          icon: DuplicateIcon,
          title: `${t("labels.duplicateSelection")} \u2014 ${getShortcutKey(
            "CtrlOrCmd+D"
          )}`,
          "aria-label": t("labels.duplicateSelection"),
          onClick: () => updateData(null),
          visible: isSomeElementSelected(getNonDeletedElements3(elements), appState)
        }
      )
    });
    duplicateElements2 = (elements, appState) => {
      const sortedElements = normalizeElementOrder(elements);
      const groupIdMap = /* @__PURE__ */ new Map();
      const newElements = [];
      const oldElements = [];
      const oldIdToDuplicatedId = /* @__PURE__ */ new Map();
      const duplicateAndOffsetElement = (element) => {
        const newElement2 = duplicateElement(
          appState.editingGroupId,
          groupIdMap,
          element,
          {
            x: element.x + GRID_SIZE / 2,
            y: element.y + GRID_SIZE / 2
          }
        );
        oldIdToDuplicatedId.set(element.id, newElement2.id);
        oldElements.push(element);
        newElements.push(newElement2);
        return newElement2;
      };
      const idsOfElementsToDuplicate = arrayToMap(
        getSelectedElements(sortedElements, appState, {
          includeBoundTextElement: true,
          includeElementsInFrames: true
        })
      );
      const processedIds = /* @__PURE__ */ new Map();
      const markAsProcessed = (elements2) => {
        for (const element of elements2) {
          processedIds.set(element.id, true);
        }
        return elements2;
      };
      const elementsWithClones = [];
      let index = -1;
      while (++index < sortedElements.length) {
        const element = sortedElements[index];
        if (processedIds.get(element.id)) {
          continue;
        }
        const boundTextElement = getBoundTextElement(element, arrayToMap(elements));
        const isElementAFrameLike = isFrameLikeElement(element);
        if (idsOfElementsToDuplicate.get(element.id)) {
          if (element.groupIds.length || boundTextElement || isElementAFrameLike) {
            const groupId = getSelectedGroupForElement(appState, element);
            if (groupId) {
              const groupElements = getElementsInGroup(
                sortedElements,
                groupId
              ).flatMap(
                (element2) => isFrameLikeElement(element2) ? [...getFrameChildren(elements, element2.id), element2] : [element2]
              );
              elementsWithClones.push(
                ...markAsProcessed([
                  ...groupElements,
                  ...groupElements.map(
                    (element2) => duplicateAndOffsetElement(element2)
                  )
                ])
              );
              continue;
            }
            if (boundTextElement) {
              elementsWithClones.push(
                ...markAsProcessed([
                  element,
                  boundTextElement,
                  duplicateAndOffsetElement(element),
                  duplicateAndOffsetElement(boundTextElement)
                ])
              );
              continue;
            }
            if (isElementAFrameLike) {
              const elementsInFrame = getFrameChildren(sortedElements, element.id);
              elementsWithClones.push(
                ...markAsProcessed([
                  ...elementsInFrame,
                  element,
                  ...elementsInFrame.map((e) => duplicateAndOffsetElement(e)),
                  duplicateAndOffsetElement(element)
                ])
              );
              continue;
            }
          }
          if (!element.frameId || !idsOfElementsToDuplicate.has(element.frameId)) {
            elementsWithClones.push(
              ...markAsProcessed([element, duplicateAndOffsetElement(element)])
            );
          }
        } else {
          elementsWithClones.push(...markAsProcessed([element]));
        }
      }
      const finalElementsReversed = [];
      const finalElementIds = /* @__PURE__ */ new Map();
      index = elementsWithClones.length;
      while (--index >= 0) {
        const element = elementsWithClones[index];
        if (!finalElementIds.get(element.id)) {
          finalElementIds.set(element.id, true);
          finalElementsReversed.push(element);
        }
      }
      const finalElements = finalElementsReversed.reverse();
      bindTextToShapeAfterDuplication(
        elementsWithClones,
        oldElements,
        oldIdToDuplicatedId
      );
      fixBindingsAfterDuplication(
        elementsWithClones,
        oldElements,
        oldIdToDuplicatedId
      );
      bindElementsToFramesAfterDuplication(
        finalElements,
        oldElements,
        oldIdToDuplicatedId
      );
      const nextElementsToSelect = excludeElementsInFramesFromSelection(newElements);
      return {
        elements: finalElements,
        appState: {
          ...appState,
          ...selectGroupsForSelectedElements(
            {
              editingGroupId: appState.editingGroupId,
              selectedElementIds: nextElementsToSelect.reduce(
                (acc, element) => {
                  if (!isBoundToContainer(element)) {
                    acc[element.id] = true;
                  }
                  return acc;
                },
                {}
              )
            },
            getNonDeletedElements3(finalElements),
            appState,
            null
          )
        }
      };
    };
  }
});

// components/ButtonIconSelect.tsx
import clsx5 from "clsx";
import { jsx as jsx11, jsxs as jsxs5 } from "react/jsx-runtime";
var ButtonIconSelect;
var init_ButtonIconSelect = __esm({
  "components/ButtonIconSelect.tsx"() {
    "use strict";
    init_define_import_meta_env();
    ButtonIconSelect = (props) => /* @__PURE__ */ jsx11("div", { className: "buttonList buttonListIcon", children: props.options.map(
      (option) => props.type === "button" ? /* @__PURE__ */ jsx11(
        "button",
        {
          onClick: (event) => props.onClick(option.value, event),
          className: clsx5({
            active: option.active ?? props.value === option.value
          }),
          "data-testid": option.testId,
          title: option.text,
          children: option.icon
        },
        option.text
      ) : /* @__PURE__ */ jsxs5(
        "label",
        {
          className: clsx5({ active: props.value === option.value }),
          title: option.text,
          children: [
            /* @__PURE__ */ jsx11(
              "input",
              {
                type: "radio",
                name: props.group,
                onChange: () => props.onChange(option.value),
                checked: props.value === option.value,
                "data-testid": option.testId
              }
            ),
            option.icon
          ]
        },
        option.text
      )
    ) });
  }
});

// components/ColorPicker/TopPicks.tsx
import clsx6 from "clsx";
import { jsx as jsx12 } from "react/jsx-runtime";
var TopPicks;
var init_TopPicks = __esm({
  "components/ColorPicker/TopPicks.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_colors();
    TopPicks = ({
      onChange,
      type,
      activeColor,
      topPicks
    }) => {
      let colors;
      if (type === "elementStroke") {
        colors = DEFAULT_ELEMENT_STROKE_PICKS;
      }
      if (type === "elementBackground") {
        colors = DEFAULT_ELEMENT_BACKGROUND_PICKS;
      }
      if (type === "canvasBackground") {
        colors = DEFAULT_CANVAS_BACKGROUND_PICKS;
      }
      if (topPicks) {
        colors = topPicks;
      }
      if (!colors) {
        console.error("Invalid type for TopPicks");
        return null;
      }
      return /* @__PURE__ */ jsx12("div", { className: "color-picker__top-picks", children: colors.map((color) => /* @__PURE__ */ jsx12(
        "button",
        {
          className: clsx6("color-picker__button", {
            active: color === activeColor,
            "is-transparent": color === "transparent" || !color
          }),
          style: { "--swatch-color": color },
          type: "button",
          title: color,
          onClick: () => onChange(color),
          "data-testid": `color-top-pick-${color}`,
          children: /* @__PURE__ */ jsx12("div", { className: "color-picker__button-outline" })
        },
        color
      )) });
    };
  }
});

// components/ColorPicker/colorPickerUtils.ts
import { atom as atom4 } from "jotai";
var getColorNameAndShadeFromColor, colorPickerHotkeyBindings, isCustomColor, getMostUsedCustomColors, activeColorPickerSectionAtom, calculateContrast, getContrastYIQ;
var init_colorPickerUtils = __esm({
  "components/ColorPicker/colorPickerUtils.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_colors();
    getColorNameAndShadeFromColor = ({
      palette: palette2,
      color
    }) => {
      for (const [colorName, colorVal] of Object.entries(palette2)) {
        if (Array.isArray(colorVal)) {
          const shade = colorVal.indexOf(color);
          if (shade > -1) {
            return { colorName, shade };
          }
        } else if (colorVal === color) {
          return { colorName, shade: null };
        }
      }
      return null;
    };
    colorPickerHotkeyBindings = [
      ["q", "w", "e", "r", "t"],
      ["a", "s", "d", "f", "g"],
      ["z", "x", "c", "v", "b"]
    ].flat();
    isCustomColor = ({
      color,
      palette: palette2
    }) => {
      const paletteValues = Object.values(palette2).flat();
      return !paletteValues.includes(color);
    };
    getMostUsedCustomColors = (elements, type, palette2) => {
      const elementColorTypeMap = {
        elementBackground: "backgroundColor",
        elementStroke: "strokeColor"
      };
      const colors = elements.filter((element) => {
        if (element.isDeleted) {
          return false;
        }
        const color = element[elementColorTypeMap[type]];
        return isCustomColor({ color, palette: palette2 });
      });
      const colorCountMap = /* @__PURE__ */ new Map();
      colors.forEach((element) => {
        const color = element[elementColorTypeMap[type]];
        if (colorCountMap.has(color)) {
          colorCountMap.set(color, colorCountMap.get(color) + 1);
        } else {
          colorCountMap.set(color, 1);
        }
      });
      return [...colorCountMap.entries()].sort((a, b) => b[1] - a[1]).map((c) => c[0]).slice(0, MAX_CUSTOM_COLORS_USED_IN_CANVAS);
    };
    activeColorPickerSectionAtom = atom4(null);
    calculateContrast = (r, g, b) => {
      const yiq = (r * 299 + g * 587 + b * 114) / 1e3;
      return yiq >= 160 ? "black" : "white";
    };
    getContrastYIQ = (bgHex, isCustomColor2) => {
      if (isCustomColor2) {
        const style = new Option().style;
        style.color = bgHex;
        if (style.color) {
          const rgb = style.color.replace(/^(rgb|rgba)\(/, "").replace(/\)$/, "").replace(/\s/g, "").split(",");
          const r2 = parseInt(rgb[0]);
          const g2 = parseInt(rgb[1]);
          const b2 = parseInt(rgb[2]);
          return calculateContrast(r2, g2, b2);
        }
      }
      if (bgHex === "transparent") {
        return "black";
      }
      const r = parseInt(bgHex.substring(1, 3), 16);
      const g = parseInt(bgHex.substring(3, 5), 16);
      const b = parseInt(bgHex.substring(5, 7), 16);
      return calculateContrast(r, g, b);
    };
  }
});

// components/ColorPicker/HotkeyLabel.tsx
import { jsxs as jsxs6 } from "react/jsx-runtime";
var HotkeyLabel, HotkeyLabel_default;
var init_HotkeyLabel = __esm({
  "components/ColorPicker/HotkeyLabel.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_colorPickerUtils();
    HotkeyLabel = ({
      color,
      keyLabel,
      isCustomColor: isCustomColor2 = false,
      isShade = false
    }) => {
      return /* @__PURE__ */ jsxs6(
        "div",
        {
          className: "color-picker__button__hotkey-label",
          style: {
            color: getContrastYIQ(color, isCustomColor2)
          },
          children: [
            isShade && "\u21E7",
            keyLabel
          ]
        }
      );
    };
    HotkeyLabel_default = HotkeyLabel;
  }
});

// components/ColorPicker/ShadeList.tsx
import clsx7 from "clsx";
import { useAtom as useAtom3 } from "jotai";
import { useEffect as useEffect8, useRef as useRef4 } from "react";
import { jsx as jsx13, jsxs as jsxs7 } from "react/jsx-runtime";
var ShadeList;
var init_ShadeList = __esm({
  "components/ColorPicker/ShadeList.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_colorPickerUtils();
    init_HotkeyLabel();
    init_i18n();
    ShadeList = ({ hex, onChange, palette: palette2 }) => {
      const colorObj = getColorNameAndShadeFromColor({
        color: hex || "transparent",
        palette: palette2
      });
      const [activeColorPickerSection, setActiveColorPickerSection] = useAtom3(
        activeColorPickerSectionAtom
      );
      const btnRef = useRef4(null);
      useEffect8(() => {
        if (btnRef.current && activeColorPickerSection === "shades") {
          btnRef.current.focus();
        }
      }, [colorObj, activeColorPickerSection]);
      if (colorObj) {
        const { colorName, shade } = colorObj;
        const shades = palette2[colorName];
        if (Array.isArray(shades)) {
          return /* @__PURE__ */ jsx13("div", { className: "color-picker-content--default shades", children: shades.map((color, i) => /* @__PURE__ */ jsxs7(
            "button",
            {
              ref: i === shade && activeColorPickerSection === "shades" ? btnRef : void 0,
              tabIndex: -1,
              type: "button",
              className: clsx7(
                "color-picker__button color-picker__button--large",
                { active: i === shade }
              ),
              "aria-label": "Shade",
              title: `${colorName} - ${i + 1}`,
              style: color ? { "--swatch-color": color } : void 0,
              onClick: () => {
                onChange(color);
                setActiveColorPickerSection("shades");
              },
              children: [
                /* @__PURE__ */ jsx13("div", { className: "color-picker__button-outline" }),
                /* @__PURE__ */ jsx13(HotkeyLabel_default, { color, keyLabel: i + 1, isShade: true })
              ]
            },
            i
          )) });
        }
      }
      return /* @__PURE__ */ jsxs7(
        "div",
        {
          className: "color-picker-content--default",
          style: { position: "relative" },
          tabIndex: -1,
          children: [
            /* @__PURE__ */ jsx13(
              "button",
              {
                type: "button",
                tabIndex: -1,
                className: "color-picker__button color-picker__button--large color-picker__button--no-focus-visible"
              }
            ),
            /* @__PURE__ */ jsx13(
              "div",
              {
                tabIndex: -1,
                style: {
                  position: "absolute",
                  top: 0,
                  left: 0,
                  right: 0,
                  bottom: 0,
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "center",
                  textAlign: "center",
                  fontSize: "0.75rem"
                },
                children: t("colorPicker.noShades")
              }
            )
          ]
        }
      );
    };
  }
});

// components/ColorPicker/PickerColorList.tsx
import clsx8 from "clsx";
import { useAtom as useAtom4 } from "jotai";
import { useEffect as useEffect9, useRef as useRef5 } from "react";
import { jsx as jsx14, jsxs as jsxs8 } from "react/jsx-runtime";
var PickerColorList, PickerColorList_default;
var init_PickerColorList = __esm({
  "components/ColorPicker/PickerColorList.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_colorPickerUtils();
    init_HotkeyLabel();
    init_i18n();
    PickerColorList = ({
      palette: palette2,
      color,
      onChange,
      label,
      activeShade
    }) => {
      const colorObj = getColorNameAndShadeFromColor({
        color: color || "transparent",
        palette: palette2
      });
      const [activeColorPickerSection, setActiveColorPickerSection] = useAtom4(
        activeColorPickerSectionAtom
      );
      const btnRef = useRef5(null);
      useEffect9(() => {
        if (btnRef.current && activeColorPickerSection === "baseColors") {
          btnRef.current.focus();
        }
      }, [colorObj?.colorName, activeColorPickerSection]);
      return /* @__PURE__ */ jsx14("div", { className: "color-picker-content--default", children: Object.entries(palette2).map(([key, value], index) => {
        const color2 = (Array.isArray(value) ? value[activeShade] : value) || "transparent";
        const keybinding = colorPickerHotkeyBindings[index];
        const label2 = t(
          `colors.${key.replace(/\d+/, "")}`,
          null,
          ""
        );
        return /* @__PURE__ */ jsxs8(
          "button",
          {
            ref: colorObj?.colorName === key ? btnRef : void 0,
            tabIndex: -1,
            type: "button",
            className: clsx8(
              "color-picker__button color-picker__button--large",
              {
                active: colorObj?.colorName === key,
                "is-transparent": color2 === "transparent" || !color2
              }
            ),
            onClick: () => {
              onChange(color2);
              setActiveColorPickerSection("baseColors");
            },
            title: `${label2}${color2.startsWith("#") ? ` ${color2}` : ""} \u2014 ${keybinding}`,
            "aria-label": `${label2} \u2014 ${keybinding}`,
            style: color2 ? { "--swatch-color": color2 } : void 0,
            "data-testid": `color-${key}`,
            children: [
              /* @__PURE__ */ jsx14("div", { className: "color-picker__button-outline" }),
              /* @__PURE__ */ jsx14(HotkeyLabel_default, { color: color2, keyLabel: keybinding })
            ]
          },
          key
        );
      }) });
    };
    PickerColorList_default = PickerColorList;
  }
});

// components/ColorPicker/CustomColorList.tsx
import clsx9 from "clsx";
import { useAtom as useAtom5 } from "jotai";
import { useEffect as useEffect10, useRef as useRef6 } from "react";
import { jsx as jsx15, jsxs as jsxs9 } from "react/jsx-runtime";
var CustomColorList;
var init_CustomColorList = __esm({
  "components/ColorPicker/CustomColorList.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_colorPickerUtils();
    init_HotkeyLabel();
    CustomColorList = ({
      colors,
      color,
      onChange,
      label
    }) => {
      const [activeColorPickerSection, setActiveColorPickerSection] = useAtom5(
        activeColorPickerSectionAtom
      );
      const btnRef = useRef6(null);
      useEffect10(() => {
        if (btnRef.current) {
          btnRef.current.focus();
        }
      }, [color, activeColorPickerSection]);
      return /* @__PURE__ */ jsx15("div", { className: "color-picker-content--default", children: colors.map((c, i) => {
        return /* @__PURE__ */ jsxs9(
          "button",
          {
            ref: color === c ? btnRef : void 0,
            tabIndex: -1,
            type: "button",
            className: clsx9(
              "color-picker__button color-picker__button--large",
              {
                active: color === c,
                "is-transparent": c === "transparent" || !c
              }
            ),
            onClick: () => {
              onChange(c);
              setActiveColorPickerSection("custom");
            },
            title: c,
            "aria-label": label,
            style: { "--swatch-color": c },
            children: [
              /* @__PURE__ */ jsx15("div", { className: "color-picker__button-outline" }),
              /* @__PURE__ */ jsx15(HotkeyLabel_default, { color: c, keyLabel: i + 1, isCustomColor: true })
            ]
          },
          i
        );
      }) });
    };
  }
});

// components/ColorPicker/keyboardNavHandlers.ts
var arrowHandler, hotkeyHandler, colorPickerKeyNavHandler;
var init_keyboardNavHandlers = __esm({
  "components/ColorPicker/keyboardNavHandlers.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_keys();
    init_colors();
    init_colorPickerUtils();
    arrowHandler = (eventKey, currentIndex, length) => {
      const rows = Math.ceil(length / COLORS_PER_ROW);
      currentIndex = currentIndex ?? -1;
      switch (eventKey) {
        case "ArrowLeft": {
          const prevIndex = currentIndex - 1;
          return prevIndex < 0 ? length - 1 : prevIndex;
        }
        case "ArrowRight": {
          return (currentIndex + 1) % length;
        }
        case "ArrowDown": {
          const nextIndex = currentIndex + COLORS_PER_ROW;
          return nextIndex >= length ? currentIndex % COLORS_PER_ROW : nextIndex;
        }
        case "ArrowUp": {
          const prevIndex = currentIndex - COLORS_PER_ROW;
          const newIndex = prevIndex < 0 ? COLORS_PER_ROW * rows + prevIndex : prevIndex;
          return newIndex >= length ? void 0 : newIndex;
        }
      }
    };
    hotkeyHandler = ({
      e,
      colorObj,
      onChange,
      palette: palette2,
      customColors,
      setActiveColorPickerSection,
      activeShade
    }) => {
      if (colorObj?.shade != null) {
        if (["Digit1", "Digit2", "Digit3", "Digit4", "Digit5"].includes(e.code) && e.shiftKey) {
          const newShade = Number(e.code.slice(-1)) - 1;
          onChange(palette2[colorObj.colorName][newShade]);
          setActiveColorPickerSection("shades");
          return true;
        }
      }
      if (["1", "2", "3", "4", "5"].includes(e.key)) {
        const c = customColors[Number(e.key) - 1];
        if (c) {
          onChange(customColors[Number(e.key) - 1]);
          setActiveColorPickerSection("custom");
          return true;
        }
      }
      if (colorPickerHotkeyBindings.includes(e.key)) {
        const index = colorPickerHotkeyBindings.indexOf(e.key);
        const paletteKey = Object.keys(palette2)[index];
        const paletteValue = palette2[paletteKey];
        const r = Array.isArray(paletteValue) ? paletteValue[activeShade] : paletteValue;
        onChange(r);
        setActiveColorPickerSection("baseColors");
        return true;
      }
      return false;
    };
    colorPickerKeyNavHandler = ({
      event,
      activeColorPickerSection,
      palette: palette2,
      color,
      onChange,
      customColors,
      setActiveColorPickerSection,
      updateData,
      activeShade,
      onEyeDropperToggle,
      onEscape
    }) => {
      if (event[KEYS.CTRL_OR_CMD]) {
        return false;
      }
      if (event.key === KEYS.ESCAPE) {
        onEscape(event);
        return true;
      }
      if (event.key === KEYS.ALT) {
        onEyeDropperToggle(true);
        return true;
      }
      if (event.key === KEYS.I) {
        onEyeDropperToggle();
        return true;
      }
      const colorObj = getColorNameAndShadeFromColor({ color, palette: palette2 });
      if (event.key === KEYS.TAB) {
        const sectionsMap = {
          custom: !!customColors.length,
          baseColors: true,
          shades: colorObj?.shade != null,
          hex: true
        };
        const sections = Object.entries(sectionsMap).reduce((acc, [key, value]) => {
          if (value) {
            acc.push(key);
          }
          return acc;
        }, []);
        const activeSectionIndex = sections.indexOf(activeColorPickerSection);
        const indexOffset = event.shiftKey ? -1 : 1;
        const nextSectionIndex = activeSectionIndex + indexOffset > sections.length - 1 ? 0 : activeSectionIndex + indexOffset < 0 ? sections.length - 1 : activeSectionIndex + indexOffset;
        const nextSection = sections[nextSectionIndex];
        if (nextSection) {
          setActiveColorPickerSection(nextSection);
        }
        if (nextSection === "custom") {
          onChange(customColors[0]);
        } else if (nextSection === "baseColors") {
          const baseColorName = Object.entries(palette2).find(([name, shades]) => {
            if (Array.isArray(shades)) {
              return shades.includes(color);
            } else if (shades === color) {
              return name;
            }
            return null;
          });
          if (!baseColorName) {
            onChange(COLOR_PALETTE.black);
          }
        }
        event.preventDefault();
        event.stopPropagation();
        return true;
      }
      if (hotkeyHandler({
        e: event,
        colorObj,
        onChange,
        palette: palette2,
        customColors,
        setActiveColorPickerSection,
        activeShade
      })) {
        return true;
      }
      if (activeColorPickerSection === "shades") {
        if (colorObj) {
          const { shade } = colorObj;
          const newShade = arrowHandler(event.key, shade, COLORS_PER_ROW);
          if (newShade !== void 0) {
            onChange(palette2[colorObj.colorName][newShade]);
            return true;
          }
        }
      }
      if (activeColorPickerSection === "baseColors") {
        if (colorObj) {
          const { colorName } = colorObj;
          const colorNames = Object.keys(palette2);
          const indexOfColorName = colorNames.indexOf(colorName);
          const newColorIndex = arrowHandler(
            event.key,
            indexOfColorName,
            colorNames.length
          );
          if (newColorIndex !== void 0) {
            const newColorName = colorNames[newColorIndex];
            const newColorNameValue = palette2[newColorName];
            onChange(
              Array.isArray(newColorNameValue) ? newColorNameValue[activeShade] : newColorNameValue
            );
            return true;
          }
        }
      }
      if (activeColorPickerSection === "custom") {
        const indexOfColor = customColors.indexOf(color);
        const newColorIndex = arrowHandler(
          event.key,
          indexOfColor,
          customColors.length
        );
        if (newColorIndex !== void 0) {
          const newColor = customColors[newColorIndex];
          onChange(newColor);
          return true;
        }
      }
      return false;
    };
  }
});

// components/ColorPicker/PickerHeading.tsx
import { jsx as jsx16 } from "react/jsx-runtime";
var PickerHeading, PickerHeading_default;
var init_PickerHeading = __esm({
  "components/ColorPicker/PickerHeading.tsx"() {
    "use strict";
    init_define_import_meta_env();
    PickerHeading = ({ children }) => /* @__PURE__ */ jsx16("div", { className: "color-picker__heading", children });
    PickerHeading_default = PickerHeading;
  }
});

// components/ColorPicker/Picker.tsx
import React6, { useEffect as useEffect11, useState as useState6 } from "react";
import { useAtom as useAtom6 } from "jotai";
import { jsx as jsx17, jsxs as jsxs10 } from "react/jsx-runtime";
var Picker;
var init_Picker = __esm({
  "components/ColorPicker/Picker.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_i18n();
    init_ShadeList();
    init_PickerColorList();
    init_CustomColorList();
    init_keyboardNavHandlers();
    init_PickerHeading();
    init_colorPickerUtils();
    init_colors();
    init_keys();
    init_constants();
    Picker = ({
      color,
      onChange,
      label,
      type,
      elements,
      palette: palette2,
      updateData,
      children,
      onEyeDropperToggle,
      onEscape
    }) => {
      const [customColors] = React6.useState(() => {
        if (type === "canvasBackground") {
          return [];
        }
        return getMostUsedCustomColors(elements, type, palette2);
      });
      const [activeColorPickerSection, setActiveColorPickerSection] = useAtom6(
        activeColorPickerSectionAtom
      );
      const colorObj = getColorNameAndShadeFromColor({
        color,
        palette: palette2
      });
      useEffect11(() => {
        if (!activeColorPickerSection) {
          const isCustom = isCustomColor({ color, palette: palette2 });
          const isCustomButNotInList = isCustom && !customColors.includes(color);
          setActiveColorPickerSection(
            isCustomButNotInList ? "hex" : isCustom ? "custom" : colorObj?.shade != null ? "shades" : "baseColors"
          );
        }
      }, [
        activeColorPickerSection,
        color,
        palette2,
        setActiveColorPickerSection,
        colorObj,
        customColors
      ]);
      const [activeShade, setActiveShade] = useState6(
        colorObj?.shade ?? (type === "elementBackground" ? DEFAULT_ELEMENT_BACKGROUND_COLOR_INDEX : DEFAULT_ELEMENT_STROKE_COLOR_INDEX)
      );
      useEffect11(() => {
        if (colorObj?.shade != null) {
          setActiveShade(colorObj.shade);
        }
        const keyup = (event) => {
          if (event.key === KEYS.ALT) {
            onEyeDropperToggle(false);
          }
        };
        document.addEventListener("keyup" /* KEYUP */, keyup, { capture: true });
        return () => {
          document.removeEventListener("keyup" /* KEYUP */, keyup, { capture: true });
        };
      }, [colorObj, onEyeDropperToggle]);
      const pickerRef = React6.useRef(null);
      return /* @__PURE__ */ jsx17("div", { role: "dialog", "aria-modal": "true", "aria-label": t("labels.colorPicker"), children: /* @__PURE__ */ jsxs10(
        "div",
        {
          ref: pickerRef,
          onKeyDown: (event) => {
            const handled = colorPickerKeyNavHandler({
              event,
              activeColorPickerSection,
              palette: palette2,
              color,
              onChange,
              onEyeDropperToggle,
              customColors,
              setActiveColorPickerSection,
              updateData,
              activeShade,
              onEscape
            });
            if (handled) {
              event.preventDefault();
              event.stopPropagation();
            }
          },
          className: "color-picker-content",
          tabIndex: -1,
          children: [
            !!customColors.length && /* @__PURE__ */ jsxs10("div", { children: [
              /* @__PURE__ */ jsx17(PickerHeading_default, { children: t("colorPicker.mostUsedCustomColors") }),
              /* @__PURE__ */ jsx17(
                CustomColorList,
                {
                  colors: customColors,
                  color,
                  label: t("colorPicker.mostUsedCustomColors"),
                  onChange
                }
              )
            ] }),
            /* @__PURE__ */ jsxs10("div", { children: [
              /* @__PURE__ */ jsx17(PickerHeading_default, { children: t("colorPicker.colors") }),
              /* @__PURE__ */ jsx17(
                PickerColorList_default,
                {
                  color,
                  label,
                  palette: palette2,
                  onChange,
                  activeShade
                }
              )
            ] }),
            /* @__PURE__ */ jsxs10("div", { children: [
              /* @__PURE__ */ jsx17(PickerHeading_default, { children: t("colorPicker.shades") }),
              /* @__PURE__ */ jsx17(ShadeList, { hex: color, onChange, palette: palette2 })
            ] }),
            children
          ]
        }
      ) });
    };
  }
});

// context/ui-appState.ts
import React7 from "react";
var UIAppStateContext, useUIAppState;
var init_ui_appState = __esm({
  "context/ui-appState.ts"() {
    "use strict";
    init_define_import_meta_env();
    UIAppStateContext = React7.createContext(null);
    useUIAppState = () => React7.useContext(UIAppStateContext);
  }
});

// hooks/useCreatePortalContainer.ts
import { useState as useState7, useLayoutEffect as useLayoutEffect3 } from "react";
var useCreatePortalContainer;
var init_useCreatePortalContainer = __esm({
  "hooks/useCreatePortalContainer.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_App();
    init_ui_appState();
    useCreatePortalContainer = (opts) => {
      const [div, setDiv] = useState7(null);
      const device = useDevice();
      const { theme } = useUIAppState();
      const { container: excalidrawContainer } = useExcalidrawContainer();
      useLayoutEffect3(() => {
        if (div) {
          div.className = "";
          div.classList.add("excalidraw", ...opts?.className?.split(/\s+/) || []);
          div.classList.toggle("excalidraw--mobile", device.editor.isMobile);
          div.classList.toggle("theme--dark", theme === "dark");
        }
      }, [div, theme, device.editor.isMobile, opts?.className]);
      useLayoutEffect3(() => {
        const container = opts?.parentSelector ? excalidrawContainer?.querySelector(opts.parentSelector) : document.body;
        if (!container) {
          return;
        }
        const div2 = document.createElement("div");
        container.appendChild(div2);
        setDiv(div2);
        return () => {
          container.removeChild(div2);
        };
      }, [excalidrawContainer, opts?.parentSelector]);
      return div;
    };
  }
});

// hooks/useOutsideClick.ts
import { useEffect as useEffect12 } from "react";
function useOutsideClick(ref, callback, isInside) {
  useEffect12(() => {
    function onOutsideClick(event) {
      const _event = event;
      if (!ref.current) {
        return;
      }
      const isInsideOverride = isInside?.(_event, ref.current);
      if (isInsideOverride === true) {
        return;
      } else if (isInsideOverride === false) {
        return callback(_event);
      }
      if (ref.current.contains(_event.target) || // target is detached from DOM (happens when the element is removed
      // on a pointerup event fired *before* this handler's pointerup is
      // dispatched)
      !document.documentElement.contains(_event.target)) {
        return;
      }
      const isClickOnRadixPortal = _event.target.closest("[data-radix-portal]") || // when radix popup is in "modal" mode, it disables pointer events on
      // the `body` element, so the target element is going to be the `html`
      // (note: this won't work if we selectively re-enable pointer events on
      // specific elements as we do with navbar or excalidraw UI elements)
      _event.target === document.documentElement && document.body.style.pointerEvents === "none";
      if (isClickOnRadixPortal) {
        return;
      }
      if (_event.target.closest("[data-prevent-outside-click]")) {
        return;
      }
      callback(_event);
    }
    document.addEventListener("pointerdown" /* POINTER_DOWN */, onOutsideClick);
    document.addEventListener("touchstart" /* TOUCH_START */, onOutsideClick);
    return () => {
      document.removeEventListener("pointerdown" /* POINTER_DOWN */, onOutsideClick);
      document.removeEventListener("touchstart" /* TOUCH_START */, onOutsideClick);
    };
  }, [ref, callback, isInside]);
}
var init_useOutsideClick = __esm({
  "hooks/useOutsideClick.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_constants();
  }
});

// hooks/useStable.ts
import { useRef as useRef7 } from "react";
var useStable;
var init_useStable = __esm({
  "hooks/useStable.ts"() {
    "use strict";
    init_define_import_meta_env();
    useStable = (value) => {
      const ref = useRef7(value);
      Object.assign(ref.current, value);
      return ref.current;
    };
  }
});

// components/EyeDropper.scss
var init_EyeDropper = __esm({
  "components/EyeDropper.scss"() {
  }
});

// components/EyeDropper.tsx
import { atom as atom5 } from "jotai";
import { useEffect as useEffect13, useRef as useRef8 } from "react";
import { createPortal } from "react-dom";
import { jsx as jsx18 } from "react/jsx-runtime";
var activeEyeDropperAtom, EyeDropper;
var init_EyeDropper2 = __esm({
  "components/EyeDropper.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_colors();
    init_constants();
    init_ui_appState();
    init_useCreatePortalContainer();
    init_useOutsideClick();
    init_keys();
    init_scene();
    init_App();
    init_useStable();
    init_EyeDropper();
    activeEyeDropperAtom = atom5(null);
    EyeDropper = ({ onCancel, onChange, onSelect, colorPickerType }) => {
      const eyeDropperContainer = useCreatePortalContainer({
        className: "excalidraw-eye-dropper-backdrop",
        parentSelector: ".excalidraw-eye-dropper-container"
      });
      const appState = useUIAppState();
      const elements = useExcalidrawElements();
      const app = useApp();
      const selectedElements = getSelectedElements(elements, appState);
      const stableProps = useStable({
        app,
        onCancel,
        onChange,
        onSelect,
        selectedElements
      });
      const { container: excalidrawContainer } = useExcalidrawContainer();
      useEffect13(() => {
        const colorPreviewDiv = ref.current;
        if (!colorPreviewDiv || !app.canvas || !eyeDropperContainer) {
          return;
        }
        let isHoldingPointerDown = false;
        const ctx = app.canvas.getContext("2d");
        const getCurrentColor = ({
          clientX,
          clientY
        }) => {
          const pixel = ctx.getImageData(
            (clientX - appState.offsetLeft) * window.devicePixelRatio,
            (clientY - appState.offsetTop) * window.devicePixelRatio,
            1,
            1
          ).data;
          return rgbToHex(pixel[0], pixel[1], pixel[2]);
        };
        const mouseMoveListener = ({
          clientX,
          clientY,
          altKey
        }) => {
          colorPreviewDiv.style.top = `${clientY + 20}px`;
          colorPreviewDiv.style.left = `${clientX + 20}px`;
          const currentColor = getCurrentColor({ clientX, clientY });
          if (isHoldingPointerDown) {
            stableProps.onChange(
              colorPickerType,
              currentColor,
              stableProps.selectedElements,
              { altKey }
            );
          }
          colorPreviewDiv.style.background = currentColor;
        };
        const onCancel2 = () => {
          stableProps.onCancel();
        };
        const onSelect2 = (color, event) => {
          stableProps.onSelect(color, event);
        };
        const pointerDownListener = (event) => {
          isHoldingPointerDown = true;
          event.stopImmediatePropagation();
        };
        const pointerUpListener = (event) => {
          isHoldingPointerDown = false;
          excalidrawContainer?.focus();
          event.stopImmediatePropagation();
          event.preventDefault();
          onSelect2(getCurrentColor(event), event);
        };
        const keyDownListener = (event) => {
          if (event.key === KEYS.ESCAPE) {
            event.preventDefault();
            event.stopImmediatePropagation();
            onCancel2();
          }
        };
        eyeDropperContainer.tabIndex = -1;
        eyeDropperContainer.focus();
        mouseMoveListener({
          clientX: stableProps.app.lastViewportPosition.x,
          clientY: stableProps.app.lastViewportPosition.y,
          altKey: false
        });
        eyeDropperContainer.addEventListener("keydown" /* KEYDOWN */, keyDownListener);
        eyeDropperContainer.addEventListener(
          "pointerdown" /* POINTER_DOWN */,
          pointerDownListener
        );
        eyeDropperContainer.addEventListener("pointerup" /* POINTER_UP */, pointerUpListener);
        window.addEventListener("pointermove", mouseMoveListener, {
          passive: true
        });
        window.addEventListener("blur" /* BLUR */, onCancel2);
        return () => {
          isHoldingPointerDown = false;
          eyeDropperContainer.removeEventListener("keydown" /* KEYDOWN */, keyDownListener);
          eyeDropperContainer.removeEventListener(
            "pointerdown" /* POINTER_DOWN */,
            pointerDownListener
          );
          eyeDropperContainer.removeEventListener(
            "pointerup" /* POINTER_UP */,
            pointerUpListener
          );
          window.removeEventListener("pointermove", mouseMoveListener);
          window.removeEventListener("blur" /* BLUR */, onCancel2);
        };
      }, [
        stableProps,
        app.canvas,
        eyeDropperContainer,
        colorPickerType,
        excalidrawContainer,
        appState.offsetLeft,
        appState.offsetTop
      ]);
      const ref = useRef8(null);
      useOutsideClick(
        ref,
        () => {
          onCancel();
        },
        (event) => {
          if (event.target.closest(
            ".excalidraw-eye-dropper-trigger, .excalidraw-eye-dropper-backdrop"
          )) {
            return true;
          }
          return false;
        }
      );
      if (!eyeDropperContainer) {
        return null;
      }
      return createPortal(
        /* @__PURE__ */ jsx18("div", { ref, className: "excalidraw-eye-dropper-preview" }),
        eyeDropperContainer
      );
    };
  }
});

// components/ColorPicker/ColorInput.tsx
import { useCallback as useCallback2, useEffect as useEffect14, useRef as useRef9, useState as useState8 } from "react";
import { useAtom as useAtom7 } from "jotai";
import clsx10 from "clsx";
import { Fragment as Fragment2, jsx as jsx19, jsxs as jsxs11 } from "react/jsx-runtime";
var ColorInput;
var init_ColorInput = __esm({
  "components/ColorPicker/ColorInput.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_ColorPicker2();
    init_colorPickerUtils();
    init_icons();
    init_jotai();
    init_keys();
    init_EyeDropper2();
    init_i18n();
    init_App();
    init_utils();
    ColorInput = ({
      color,
      onChange,
      label,
      colorPickerType
    }) => {
      const device = useDevice();
      const [innerValue, setInnerValue] = useState8(color);
      const [activeSection, setActiveColorPickerSection] = useAtom7(
        activeColorPickerSectionAtom
      );
      useEffect14(() => {
        setInnerValue(color);
      }, [color]);
      const changeColor = useCallback2(
        (inputValue) => {
          const value = inputValue.toLowerCase();
          const color2 = getColor(value);
          if (color2) {
            onChange(color2);
          }
          setInnerValue(value);
        },
        [onChange]
      );
      const inputRef = useRef9(null);
      const eyeDropperTriggerRef = useRef9(null);
      useEffect14(() => {
        if (inputRef.current) {
          inputRef.current.focus();
        }
      }, [activeSection]);
      const [eyeDropperState, setEyeDropperState] = useAtom7(
        activeEyeDropperAtom,
        jotaiScope
      );
      useEffect14(() => {
        return () => {
          setEyeDropperState(null);
        };
      }, [setEyeDropperState]);
      return /* @__PURE__ */ jsxs11("div", { className: "color-picker__input-label", children: [
        /* @__PURE__ */ jsx19("div", { className: "color-picker__input-hash", children: "#" }),
        /* @__PURE__ */ jsx19(
          "input",
          {
            ref: activeSection === "hex" ? inputRef : void 0,
            style: { border: 0, padding: 0 },
            spellCheck: false,
            className: "color-picker-input",
            "aria-label": label,
            onChange: (event) => {
              changeColor(event.target.value);
            },
            value: (innerValue || "").replace(/^#/, ""),
            onBlur: () => {
              setInnerValue(color);
            },
            tabIndex: -1,
            onFocus: () => setActiveColorPickerSection("hex"),
            onKeyDown: (event) => {
              if (event.key === KEYS.TAB) {
                return;
              } else if (event.key === KEYS.ESCAPE) {
                eyeDropperTriggerRef.current?.focus();
              }
              event.stopPropagation();
            }
          }
        ),
        !device.editor.isMobile && /* @__PURE__ */ jsxs11(Fragment2, { children: [
          /* @__PURE__ */ jsx19(
            "div",
            {
              style: {
                width: "1px",
                height: "1.25rem",
                backgroundColor: "var(--default-border-color)"
              }
            }
          ),
          /* @__PURE__ */ jsx19(
            "div",
            {
              ref: eyeDropperTriggerRef,
              className: clsx10("excalidraw-eye-dropper-trigger", {
                selected: eyeDropperState
              }),
              onClick: () => setEyeDropperState(
                (s) => s ? null : {
                  keepOpenOnAlt: false,
                  onSelect: (color2) => onChange(color2),
                  colorPickerType
                }
              ),
              title: `${t(
                "labels.eyeDropper"
              )} \u2014 ${KEYS.I.toLocaleUpperCase()} or ${getShortcutKey("Alt")} `,
              children: eyeDropperIcon
            }
          )
        ] })
      ] });
    };
  }
});

// components/ColorPicker/ColorPicker.scss
var init_ColorPicker = __esm({
  "components/ColorPicker/ColorPicker.scss"() {
  }
});

// components/ColorPicker/ColorPicker.tsx
import * as Popover from "@radix-ui/react-popover";
import { useAtom as useAtom8 } from "jotai";
import clsx11 from "clsx";
import { useRef as useRef10 } from "react";
import { jsx as jsx20, jsxs as jsxs12 } from "react/jsx-runtime";
var isValidColor, getColor, ColorPickerPopupContent, ColorPickerTrigger, ColorPicker;
var init_ColorPicker2 = __esm({
  "components/ColorPicker/ColorPicker.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_utils();
    init_TopPicks();
    init_Picker();
    init_colorPickerUtils();
    init_App();
    init_colors();
    init_PickerHeading();
    init_i18n();
    init_jotai();
    init_ColorInput();
    init_EyeDropper2();
    init_ColorPicker();
    isValidColor = (color) => {
      const style = new Option().style;
      style.color = color;
      return !!style.color;
    };
    getColor = (color) => {
      if (isTransparent(color)) {
        return color;
      }
      return isValidColor(`#${color}`) ? `#${color}` : isValidColor(color) ? color : null;
    };
    ColorPickerPopupContent = ({
      type,
      color,
      onChange,
      label,
      elements,
      palette: palette2 = COLOR_PALETTE,
      updateData
    }) => {
      const [, setActiveColorPickerSection] = useAtom8(activeColorPickerSectionAtom);
      const [eyeDropperState, setEyeDropperState] = useAtom8(
        activeEyeDropperAtom,
        jotaiScope
      );
      const { container } = useExcalidrawContainer();
      const device = useDevice();
      const colorInputJSX = /* @__PURE__ */ jsxs12("div", { children: [
        /* @__PURE__ */ jsx20(PickerHeading_default, { children: t("colorPicker.hexCode") }),
        /* @__PURE__ */ jsx20(
          ColorInput,
          {
            color,
            label,
            onChange: (color2) => {
              onChange(color2);
            },
            colorPickerType: type
          }
        )
      ] });
      const popoverRef = useRef10(null);
      const focusPickerContent = () => {
        popoverRef.current?.querySelector(".color-picker-content")?.focus();
      };
      return /* @__PURE__ */ jsx20(Popover.Portal, { container, children: /* @__PURE__ */ jsxs12(
        Popover.Content,
        {
          ref: popoverRef,
          className: "focus-visible-none",
          "data-prevent-outside-click": true,
          onFocusOutside: (event) => {
            focusPickerContent();
            event.preventDefault();
          },
          onPointerDownOutside: (event) => {
            if (eyeDropperState) {
              event.preventDefault();
            }
          },
          onCloseAutoFocus: (e) => {
            e.stopPropagation();
            e.preventDefault();
            if (container && !isInteractive(document.activeElement)) {
              container.focus();
            }
            updateData({ openPopup: null });
            setActiveColorPickerSection(null);
          },
          side: device.editor.isMobile && !device.viewport.isLandscape ? "bottom" : "right",
          align: device.editor.isMobile && !device.viewport.isLandscape ? "center" : "start",
          alignOffset: -16,
          sideOffset: 20,
          style: {
            zIndex: "var(--zIndex-layerUI)",
            backgroundColor: "var(--popup-bg-color)",
            maxWidth: "208px",
            maxHeight: window.innerHeight,
            padding: "12px",
            borderRadius: "8px",
            boxSizing: "border-box",
            overflowY: "auto",
            boxShadow: "0px 7px 14px rgba(0, 0, 0, 0.05), 0px 0px 3.12708px rgba(0, 0, 0, 0.0798), 0px 0px 0.931014px rgba(0, 0, 0, 0.1702)"
          },
          children: [
            palette2 ? /* @__PURE__ */ jsx20(
              Picker,
              {
                palette: palette2,
                color,
                onChange: (changedColor) => {
                  onChange(changedColor);
                },
                onEyeDropperToggle: (force) => {
                  setEyeDropperState((state) => {
                    if (force) {
                      state = state || {
                        keepOpenOnAlt: true,
                        onSelect: onChange,
                        colorPickerType: type
                      };
                      state.keepOpenOnAlt = true;
                      return state;
                    }
                    return force === false || state ? null : {
                      keepOpenOnAlt: false,
                      onSelect: onChange,
                      colorPickerType: type
                    };
                  });
                },
                onEscape: (event) => {
                  if (eyeDropperState) {
                    setEyeDropperState(null);
                  } else if (isWritableElement(event.target)) {
                    focusPickerContent();
                  } else {
                    updateData({ openPopup: null });
                  }
                },
                label,
                type,
                elements,
                updateData,
                children: colorInputJSX
              }
            ) : colorInputJSX,
            /* @__PURE__ */ jsx20(
              Popover.Arrow,
              {
                width: 20,
                height: 10,
                style: {
                  fill: "var(--popup-bg-color)",
                  filter: "drop-shadow(rgba(0, 0, 0, 0.05) 0px 3px 2px)"
                }
              }
            )
          ]
        }
      ) });
    };
    ColorPickerTrigger = ({
      label,
      color,
      type
    }) => {
      return /* @__PURE__ */ jsx20(
        Popover.Trigger,
        {
          type: "button",
          className: clsx11("color-picker__button active-color", {
            "is-transparent": color === "transparent" || !color
          }),
          "aria-label": label,
          style: color ? { "--swatch-color": color } : void 0,
          title: type === "elementStroke" ? t("labels.showStroke") : t("labels.showBackground"),
          children: /* @__PURE__ */ jsx20("div", { className: "color-picker__button-outline" })
        }
      );
    };
    ColorPicker = ({
      type,
      color,
      onChange,
      label,
      elements,
      palette: palette2 = COLOR_PALETTE,
      topPicks,
      updateData,
      appState
    }) => {
      return /* @__PURE__ */ jsx20("div", { children: /* @__PURE__ */ jsxs12("div", { role: "dialog", "aria-modal": "true", className: "color-picker-container", children: [
        /* @__PURE__ */ jsx20(
          TopPicks,
          {
            activeColor: color,
            onChange,
            type,
            topPicks
          }
        ),
        /* @__PURE__ */ jsx20(
          "div",
          {
            style: {
              width: 1,
              height: "100%",
              backgroundColor: "var(--default-border-color)",
              margin: "0 auto"
            }
          }
        ),
        /* @__PURE__ */ jsxs12(
          Popover.Root,
          {
            open: appState.openPopup === type,
            onOpenChange: (open) => {
              updateData({ openPopup: open ? type : null });
            },
            children: [
              /* @__PURE__ */ jsx20(ColorPickerTrigger, { color, label, type }),
              appState.openPopup === type && /* @__PURE__ */ jsx20(
                ColorPickerPopupContent,
                {
                  type,
                  color,
                  onChange,
                  label,
                  elements,
                  palette: palette2,
                  updateData
                }
              )
            ]
          }
        )
      ] }) });
    };
  }
});

// components/Popover.scss
var init_Popover = __esm({
  "components/Popover.scss"() {
  }
});

// components/Popover.tsx
import { useLayoutEffect as useLayoutEffect4, useRef as useRef11, useEffect as useEffect15 } from "react";
import { unstable_batchedUpdates } from "react-dom";
import { jsx as jsx21 } from "react/jsx-runtime";
var Popover2;
var init_Popover2 = __esm({
  "components/Popover.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_Popover();
    init_utils();
    init_keys();
    Popover2 = ({
      children,
      left,
      top,
      onCloseRequest,
      fitInViewport = false,
      offsetLeft = 0,
      offsetTop = 0,
      viewportWidth = window.innerWidth,
      viewportHeight = window.innerHeight
    }) => {
      const popoverRef = useRef11(null);
      useEffect15(() => {
        const container = popoverRef.current;
        if (!container) {
          return;
        }
        if (!container.contains(document.activeElement)) {
          container.focus();
        }
        const handleKeyDown = (event) => {
          if (event.key === KEYS.TAB) {
            const focusableElements = queryFocusableElements(container);
            const { activeElement } = document;
            const currentIndex = focusableElements.findIndex(
              (element) => element === activeElement
            );
            if (activeElement === container) {
              if (event.shiftKey) {
                focusableElements[focusableElements.length - 1]?.focus();
              } else {
                focusableElements[0].focus();
              }
              event.preventDefault();
              event.stopImmediatePropagation();
            } else if (currentIndex === 0 && event.shiftKey) {
              focusableElements[focusableElements.length - 1]?.focus();
              event.preventDefault();
              event.stopImmediatePropagation();
            } else if (currentIndex === focusableElements.length - 1 && !event.shiftKey) {
              focusableElements[0]?.focus();
              event.preventDefault();
              event.stopImmediatePropagation();
            }
          }
        };
        container.addEventListener("keydown", handleKeyDown);
        return () => container.removeEventListener("keydown", handleKeyDown);
      }, []);
      const lastInitializedPosRef = useRef11(
        null
      );
      useLayoutEffect4(() => {
        if (fitInViewport && popoverRef.current && top != null && left != null) {
          const container = popoverRef.current;
          const { width, height } = container.getBoundingClientRect();
          if (lastInitializedPosRef.current?.top === top && lastInitializedPosRef.current?.left === left) {
            return;
          }
          lastInitializedPosRef.current = { top, left };
          if (width >= viewportWidth) {
            container.style.width = `${viewportWidth}px`;
            container.style.left = "0px";
            container.style.overflowX = "scroll";
          } else if (left + width - offsetLeft > viewportWidth) {
            container.style.left = `${viewportWidth - width - 10}px`;
          } else {
            container.style.left = `${left}px`;
          }
          if (height >= viewportHeight) {
            container.style.height = `${viewportHeight - 20}px`;
            container.style.top = "10px";
            container.style.overflowY = "scroll";
          } else if (top + height - offsetTop > viewportHeight) {
            container.style.top = `${viewportHeight - height}px`;
          } else {
            container.style.top = `${top}px`;
          }
        }
      }, [
        top,
        left,
        fitInViewport,
        viewportWidth,
        viewportHeight,
        offsetLeft,
        offsetTop
      ]);
      useEffect15(() => {
        if (onCloseRequest) {
          const handler = (event) => {
            if (!popoverRef.current?.contains(event.target)) {
              unstable_batchedUpdates(() => onCloseRequest(event));
            }
          };
          document.addEventListener("pointerdown", handler, false);
          return () => document.removeEventListener("pointerdown", handler, false);
        }
      }, [onCloseRequest]);
      return /* @__PURE__ */ jsx21("div", { className: "popover", ref: popoverRef, tabIndex: -1, children });
    };
  }
});

// components/IconPicker.scss
var init_IconPicker = __esm({
  "components/IconPicker.scss"() {
  }
});

// components/IconPicker.tsx
import React9 from "react";
import clsx12 from "clsx";
import { Fragment as Fragment3, jsx as jsx22, jsxs as jsxs13 } from "react/jsx-runtime";
function Picker2({
  options,
  value,
  label,
  onChange,
  onClose
}) {
  const rFirstItem = React9.useRef();
  const rActiveItem = React9.useRef();
  const rGallery = React9.useRef(null);
  React9.useEffect(() => {
    if (rActiveItem.current) {
      rActiveItem.current.focus();
    } else if (rGallery.current) {
      rGallery.current.focus();
    }
  }, []);
  const handleKeyDown = (event) => {
    const pressedOption = options.find(
      (option) => option.keyBinding === event.key.toLowerCase()
    );
    if (!(event.metaKey || event.altKey || event.ctrlKey) && pressedOption) {
      const index = options.indexOf(pressedOption);
      rGallery.current.children[index].focus();
      event.preventDefault();
    } else if (event.key === KEYS.TAB) {
      setTimeout(() => {
        const active = rActiveItem.current;
        const docActive = document.activeElement;
        if (active !== docActive) {
          onClose();
        }
      }, 0);
    } else if (isArrowKey(event.key)) {
      const { activeElement } = document;
      const isRTL2 = getLanguage().rtl;
      const index = Array.prototype.indexOf.call(
        rGallery.current.children,
        activeElement
      );
      if (index !== -1) {
        const length = options.length;
        let nextIndex = index;
        switch (event.key) {
          case (isRTL2 ? KEYS.ARROW_LEFT : KEYS.ARROW_RIGHT):
          case KEYS.ARROW_DOWN: {
            nextIndex = (index + 1) % length;
            break;
          }
          case (isRTL2 ? KEYS.ARROW_RIGHT : KEYS.ARROW_LEFT):
          case KEYS.ARROW_UP: {
            nextIndex = (length + index - 1) % length;
            break;
          }
        }
        rGallery.current.children[nextIndex].focus();
      }
      event.preventDefault();
    } else if (event.key === KEYS.ESCAPE || event.key === KEYS.ENTER) {
      event.preventDefault();
      onClose();
    }
    event.nativeEvent.stopImmediatePropagation();
    event.stopPropagation();
  };
  return /* @__PURE__ */ jsx22(
    "div",
    {
      className: `picker`,
      role: "dialog",
      "aria-modal": "true",
      "aria-label": label,
      onKeyDown: handleKeyDown,
      children: /* @__PURE__ */ jsx22("div", { className: "picker-content", ref: rGallery, children: options.map((option, i) => /* @__PURE__ */ jsxs13(
        "button",
        {
          className: clsx12("picker-option", {
            active: value === option.value
          }),
          onClick: (event) => {
            event.currentTarget.focus();
            onChange(option.value);
          },
          title: `${option.text} ${option.keyBinding && `\u2014 ${option.keyBinding.toUpperCase()}`}`,
          "aria-label": option.text || "none",
          "aria-keyshortcuts": option.keyBinding || void 0,
          ref: (el) => {
            if (el && i === 0) {
              rFirstItem.current = el;
            }
            if (el && option.value === value) {
              rActiveItem.current = el;
            }
          },
          onFocus: () => {
            onChange(option.value);
          },
          children: [
            option.icon,
            option.keyBinding && /* @__PURE__ */ jsx22("span", { className: "picker-keybinding", children: option.keyBinding })
          ]
        },
        option.text
      )) })
    }
  );
}
function IconPicker({
  value,
  label,
  options,
  onChange,
  group = ""
}) {
  const [isActive, setActive] = React9.useState(false);
  const rPickerButton = React9.useRef(null);
  const isRTL2 = getLanguage().rtl;
  return /* @__PURE__ */ jsxs13("div", { children: [
    /* @__PURE__ */ jsx22(
      "button",
      {
        name: group,
        className: isActive ? "active" : "",
        "aria-label": label,
        onClick: () => setActive(!isActive),
        ref: rPickerButton,
        children: options.find((option) => option.value === value)?.icon
      }
    ),
    /* @__PURE__ */ jsx22(React9.Suspense, { fallback: "", children: isActive ? /* @__PURE__ */ jsxs13(Fragment3, { children: [
      /* @__PURE__ */ jsx22(
        Popover2,
        {
          onCloseRequest: (event) => event.target !== rPickerButton.current && setActive(false),
          ...isRTL2 ? { right: 5.5 } : { left: -5.5 },
          children: /* @__PURE__ */ jsx22(
            Picker2,
            {
              options: options.filter((opt) => opt.showInPicker !== false),
              value,
              label,
              onChange,
              onClose: () => {
                setActive(false);
                rPickerButton.current?.focus();
              }
            }
          )
        }
      ),
      /* @__PURE__ */ jsx22("div", { className: "picker-triangle" })
    ] }) : null })
  ] });
}
var init_IconPicker2 = __esm({
  "components/IconPicker.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_Popover2();
    init_IconPicker();
    init_keys();
    init_i18n();
  }
});

// actions/actionProperties.tsx
import { Fragment as Fragment4, jsx as jsx23, jsxs as jsxs14 } from "react/jsx-runtime";
var FONT_SIZE_RELATIVE_INCREASE_STEP, changeProperty, getFormValue, offsetElementAfterFontResize, changeFontSize, actionChangeStrokeColor, actionChangeBackgroundColor, actionChangeFillStyle, actionChangeStrokeWidth, actionChangeSloppiness, actionChangeStrokeStyle, actionChangeOpacity, actionChangeFontSize, actionDecreaseFontSize, actionIncreaseFontSize, actionChangeFontFamily, actionChangeTextAlign, actionChangeVerticalAlign, actionChangeRoundness, getArrowheadOptions, actionChangeArrowhead;
var init_actionProperties = __esm({
  "actions/actionProperties.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_colors();
    init_analytics();
    init_ButtonIconSelect();
    init_ColorPicker2();
    init_IconPicker2();
    init_icons();
    init_constants();
    init_element();
    init_mutateElement();
    init_textElement();
    init_typeChecks();
    init_i18n();
    init_keys();
    init_random();
    init_scene();
    init_comparisons();
    init_utils();
    init_register();
    FONT_SIZE_RELATIVE_INCREASE_STEP = 0.1;
    changeProperty = (elements, appState, callback, includeBoundText = false) => {
      const selectedElementIds = arrayToMap(
        getSelectedElements(elements, appState, {
          includeBoundTextElement: includeBoundText
        })
      );
      return elements.map((element) => {
        if (selectedElementIds.get(element.id) || element.id === appState.editingElement?.id) {
          return callback(element);
        }
        return element;
      });
    };
    getFormValue = function(elements, appState, getAttribute, isRelevantElement, defaultValue) {
      const editingElement = appState.editingElement;
      const nonDeletedElements = getNonDeletedElements3(elements);
      let ret = null;
      if (editingElement) {
        ret = getAttribute(editingElement);
      }
      if (!ret) {
        const hasSelection = isSomeElementSelected(nonDeletedElements, appState);
        if (hasSelection) {
          ret = getCommonAttributeOfSelectedElements(
            isRelevantElement === true ? nonDeletedElements : nonDeletedElements.filter((el) => isRelevantElement(el)),
            appState,
            getAttribute
          ) ?? (typeof defaultValue === "function" ? defaultValue(true) : defaultValue);
        } else {
          ret = typeof defaultValue === "function" ? defaultValue(false) : defaultValue;
        }
      }
      return ret;
    };
    offsetElementAfterFontResize = (prevElement, nextElement) => {
      if (isBoundToContainer(nextElement)) {
        return nextElement;
      }
      return mutateElement(
        nextElement,
        {
          x: prevElement.textAlign === "left" ? prevElement.x : prevElement.x + (prevElement.width - nextElement.width) / (prevElement.textAlign === "center" ? 2 : 1),
          // centering vertically is non-standard, but for Excalidraw I think
          // it makes sense
          y: prevElement.y + (prevElement.height - nextElement.height) / 2
        },
        false
      );
    };
    changeFontSize = (elements, appState, app, getNewFontSize, fallbackValue) => {
      const newFontSizes = /* @__PURE__ */ new Set();
      return {
        elements: changeProperty(
          elements,
          appState,
          (oldElement) => {
            if (isTextElement(oldElement)) {
              const newFontSize = getNewFontSize(oldElement);
              newFontSizes.add(newFontSize);
              let newElement2 = newElementWith(oldElement, {
                fontSize: newFontSize
              });
              redrawTextBoundingBox(
                newElement2,
                app.scene.getContainerElement(oldElement),
                app.scene.getNonDeletedElementsMap()
              );
              newElement2 = offsetElementAfterFontResize(oldElement, newElement2);
              return newElement2;
            }
            return oldElement;
          },
          true
        ),
        appState: {
          ...appState,
          // update state only if we've set all select text elements to
          // the same font size
          currentItemFontSize: newFontSizes.size === 1 ? [...newFontSizes][0] : fallbackValue ?? appState.currentItemFontSize
        },
        commitToHistory: true
      };
    };
    actionChangeStrokeColor = register({
      name: "changeStrokeColor",
      trackEvent: false,
      perform: (elements, appState, value) => {
        return {
          ...value.currentItemStrokeColor && {
            elements: changeProperty(
              elements,
              appState,
              (el) => {
                return hasStrokeColor(el.type) ? newElementWith(el, {
                  strokeColor: value.currentItemStrokeColor
                }) : el;
              },
              true
            )
          },
          appState: {
            ...appState,
            ...value
          },
          commitToHistory: !!value.currentItemStrokeColor
        };
      },
      PanelComponent: ({ elements, appState, updateData, appProps }) => /* @__PURE__ */ jsxs14(Fragment4, { children: [
        /* @__PURE__ */ jsx23("h3", { "aria-hidden": "true", children: t("labels.stroke") }),
        /* @__PURE__ */ jsx23(
          ColorPicker,
          {
            topPicks: DEFAULT_ELEMENT_STROKE_PICKS,
            palette: DEFAULT_ELEMENT_STROKE_COLOR_PALETTE,
            type: "elementStroke",
            label: t("labels.stroke"),
            color: getFormValue(
              elements,
              appState,
              (element) => element.strokeColor,
              true,
              appState.currentItemStrokeColor
            ),
            onChange: (color) => updateData({ currentItemStrokeColor: color }),
            elements,
            appState,
            updateData
          }
        )
      ] })
    });
    actionChangeBackgroundColor = register({
      name: "changeBackgroundColor",
      trackEvent: false,
      perform: (elements, appState, value) => {
        return {
          ...value.currentItemBackgroundColor && {
            elements: changeProperty(
              elements,
              appState,
              (el) => newElementWith(el, {
                backgroundColor: value.currentItemBackgroundColor
              })
            )
          },
          appState: {
            ...appState,
            ...value
          },
          commitToHistory: !!value.currentItemBackgroundColor
        };
      },
      PanelComponent: ({ elements, appState, updateData, appProps }) => /* @__PURE__ */ jsxs14(Fragment4, { children: [
        /* @__PURE__ */ jsx23("h3", { "aria-hidden": "true", children: t("labels.background") }),
        /* @__PURE__ */ jsx23(
          ColorPicker,
          {
            topPicks: DEFAULT_ELEMENT_BACKGROUND_PICKS,
            palette: DEFAULT_ELEMENT_BACKGROUND_COLOR_PALETTE,
            type: "elementBackground",
            label: t("labels.background"),
            color: getFormValue(
              elements,
              appState,
              (element) => element.backgroundColor,
              true,
              appState.currentItemBackgroundColor
            ),
            onChange: (color) => updateData({ currentItemBackgroundColor: color }),
            elements,
            appState,
            updateData
          }
        )
      ] })
    });
    actionChangeFillStyle = register({
      name: "changeFillStyle",
      trackEvent: false,
      perform: (elements, appState, value, app) => {
        trackEvent(
          "element",
          "changeFillStyle",
          `${value} (${app.device.editor.isMobile ? "mobile" : "desktop"})`
        );
        return {
          elements: changeProperty(
            elements,
            appState,
            (el) => newElementWith(el, {
              fillStyle: value
            })
          ),
          appState: { ...appState, currentItemFillStyle: value },
          commitToHistory: true
        };
      },
      PanelComponent: ({ elements, appState, updateData }) => {
        const selectedElements = getSelectedElements(elements, appState);
        const allElementsZigZag = selectedElements.length > 0 && selectedElements.every((el) => el.fillStyle === "zigzag");
        return /* @__PURE__ */ jsxs14("fieldset", { children: [
          /* @__PURE__ */ jsx23("legend", { children: t("labels.fill") }),
          /* @__PURE__ */ jsx23(
            ButtonIconSelect,
            {
              type: "button",
              options: [
                {
                  value: "hachure",
                  text: `${allElementsZigZag ? t("labels.zigzag") : t("labels.hachure")} (${getShortcutKey("Alt-Click")})`,
                  icon: allElementsZigZag ? FillZigZagIcon : FillHachureIcon,
                  active: allElementsZigZag ? true : void 0,
                  testId: `fill-hachure`
                },
                {
                  value: "cross-hatch",
                  text: t("labels.crossHatch"),
                  icon: FillCrossHatchIcon,
                  testId: `fill-cross-hatch`
                },
                {
                  value: "solid",
                  text: t("labels.solid"),
                  icon: FillSolidIcon,
                  testId: `fill-solid`
                }
              ],
              value: getFormValue(
                elements,
                appState,
                (element) => element.fillStyle,
                (element) => element.hasOwnProperty("fillStyle"),
                (hasSelection) => hasSelection ? null : appState.currentItemFillStyle
              ),
              onClick: (value, event) => {
                const nextValue = event.altKey && value === "hachure" && selectedElements.every((el) => el.fillStyle === "hachure") ? "zigzag" : value;
                updateData(nextValue);
              }
            }
          )
        ] });
      }
    });
    actionChangeStrokeWidth = register({
      name: "changeStrokeWidth",
      trackEvent: false,
      perform: (elements, appState, value) => {
        return {
          elements: changeProperty(
            elements,
            appState,
            (el) => newElementWith(el, {
              strokeWidth: value
            })
          ),
          appState: { ...appState, currentItemStrokeWidth: value },
          commitToHistory: true
        };
      },
      PanelComponent: ({ elements, appState, updateData }) => /* @__PURE__ */ jsxs14("fieldset", { children: [
        /* @__PURE__ */ jsx23("legend", { children: t("labels.strokeWidth") }),
        /* @__PURE__ */ jsx23(
          ButtonIconSelect,
          {
            group: "stroke-width",
            options: [
              {
                value: STROKE_WIDTH.thin,
                text: t("labels.thin"),
                icon: StrokeWidthBaseIcon,
                testId: "strokeWidth-thin"
              },
              {
                value: STROKE_WIDTH.bold,
                text: t("labels.bold"),
                icon: StrokeWidthBoldIcon,
                testId: "strokeWidth-bold"
              },
              {
                value: STROKE_WIDTH.extraBold,
                text: t("labels.extraBold"),
                icon: StrokeWidthExtraBoldIcon,
                testId: "strokeWidth-extraBold"
              }
            ],
            value: getFormValue(
              elements,
              appState,
              (element) => element.strokeWidth,
              (element) => element.hasOwnProperty("strokeWidth"),
              (hasSelection) => hasSelection ? null : appState.currentItemStrokeWidth
            ),
            onChange: (value) => updateData(value)
          }
        )
      ] })
    });
    actionChangeSloppiness = register({
      name: "changeSloppiness",
      trackEvent: false,
      perform: (elements, appState, value) => {
        return {
          elements: changeProperty(
            elements,
            appState,
            (el) => newElementWith(el, {
              seed: randomInteger(),
              roughness: value
            })
          ),
          appState: { ...appState, currentItemRoughness: value },
          commitToHistory: true
        };
      },
      PanelComponent: ({ elements, appState, updateData }) => /* @__PURE__ */ jsxs14("fieldset", { children: [
        /* @__PURE__ */ jsx23("legend", { children: t("labels.sloppiness") }),
        /* @__PURE__ */ jsx23(
          ButtonIconSelect,
          {
            group: "sloppiness",
            options: [
              {
                value: 0,
                text: t("labels.architect"),
                icon: SloppinessArchitectIcon
              },
              {
                value: 1,
                text: t("labels.artist"),
                icon: SloppinessArtistIcon
              },
              {
                value: 2,
                text: t("labels.cartoonist"),
                icon: SloppinessCartoonistIcon
              }
            ],
            value: getFormValue(
              elements,
              appState,
              (element) => element.roughness,
              (element) => element.hasOwnProperty("roughness"),
              (hasSelection) => hasSelection ? null : appState.currentItemRoughness
            ),
            onChange: (value) => updateData(value)
          }
        )
      ] })
    });
    actionChangeStrokeStyle = register({
      name: "changeStrokeStyle",
      trackEvent: false,
      perform: (elements, appState, value) => {
        return {
          elements: changeProperty(
            elements,
            appState,
            (el) => newElementWith(el, {
              strokeStyle: value
            })
          ),
          appState: { ...appState, currentItemStrokeStyle: value },
          commitToHistory: true
        };
      },
      PanelComponent: ({ elements, appState, updateData }) => /* @__PURE__ */ jsxs14("fieldset", { children: [
        /* @__PURE__ */ jsx23("legend", { children: t("labels.strokeStyle") }),
        /* @__PURE__ */ jsx23(
          ButtonIconSelect,
          {
            group: "strokeStyle",
            options: [
              {
                value: "solid",
                text: t("labels.strokeStyle_solid"),
                icon: StrokeWidthBaseIcon
              },
              {
                value: "dashed",
                text: t("labels.strokeStyle_dashed"),
                icon: StrokeStyleDashedIcon
              },
              {
                value: "dotted",
                text: t("labels.strokeStyle_dotted"),
                icon: StrokeStyleDottedIcon
              }
            ],
            value: getFormValue(
              elements,
              appState,
              (element) => element.strokeStyle,
              (element) => element.hasOwnProperty("strokeStyle"),
              (hasSelection) => hasSelection ? null : appState.currentItemStrokeStyle
            ),
            onChange: (value) => updateData(value)
          }
        )
      ] })
    });
    actionChangeOpacity = register({
      name: "changeOpacity",
      trackEvent: false,
      perform: (elements, appState, value) => {
        return {
          elements: changeProperty(
            elements,
            appState,
            (el) => newElementWith(el, {
              opacity: value
            }),
            true
          ),
          appState: { ...appState, currentItemOpacity: value },
          commitToHistory: true
        };
      },
      PanelComponent: ({ elements, appState, updateData }) => /* @__PURE__ */ jsxs14("label", { className: "control-label", children: [
        t("labels.opacity"),
        /* @__PURE__ */ jsx23(
          "input",
          {
            type: "range",
            min: "0",
            max: "100",
            step: "10",
            onChange: (event) => updateData(+event.target.value),
            value: getFormValue(
              elements,
              appState,
              (element) => element.opacity,
              true,
              appState.currentItemOpacity
            ) ?? void 0
          }
        )
      ] })
    });
    actionChangeFontSize = register({
      name: "changeFontSize",
      trackEvent: false,
      perform: (elements, appState, value, app) => {
        return changeFontSize(elements, appState, app, () => value, value);
      },
      PanelComponent: ({ elements, appState, updateData, app }) => /* @__PURE__ */ jsxs14("fieldset", { children: [
        /* @__PURE__ */ jsx23("legend", { children: t("labels.fontSize") }),
        /* @__PURE__ */ jsx23(
          ButtonIconSelect,
          {
            group: "font-size",
            options: [
              {
                value: 16,
                text: t("labels.small"),
                icon: FontSizeSmallIcon,
                testId: "fontSize-small"
              },
              {
                value: 20,
                text: t("labels.medium"),
                icon: FontSizeMediumIcon,
                testId: "fontSize-medium"
              },
              {
                value: 28,
                text: t("labels.large"),
                icon: FontSizeLargeIcon,
                testId: "fontSize-large"
              },
              {
                value: 36,
                text: t("labels.veryLarge"),
                icon: FontSizeExtraLargeIcon,
                testId: "fontSize-veryLarge"
              }
            ],
            value: getFormValue(
              elements,
              appState,
              (element) => {
                if (isTextElement(element)) {
                  return element.fontSize;
                }
                const boundTextElement = getBoundTextElement(
                  element,
                  app.scene.getNonDeletedElementsMap()
                );
                if (boundTextElement) {
                  return boundTextElement.fontSize;
                }
                return null;
              },
              (element) => isTextElement(element) || getBoundTextElement(
                element,
                app.scene.getNonDeletedElementsMap()
              ) !== null,
              (hasSelection) => hasSelection ? null : appState.currentItemFontSize || DEFAULT_FONT_SIZE
            ),
            onChange: (value) => updateData(value)
          }
        )
      ] })
    });
    actionDecreaseFontSize = register({
      name: "decreaseFontSize",
      trackEvent: false,
      perform: (elements, appState, value, app) => {
        return changeFontSize(
          elements,
          appState,
          app,
          (element) => Math.round(
            // get previous value before relative increase (doesn't work fully
            // due to rounding and float precision issues)
            1 / (1 + FONT_SIZE_RELATIVE_INCREASE_STEP) * element.fontSize
          )
        );
      },
      keyTest: (event) => {
        return event[KEYS.CTRL_OR_CMD] && event.shiftKey && // KEYS.COMMA needed for MacOS
        (event.key === KEYS.CHEVRON_LEFT || event.key === KEYS.COMMA);
      }
    });
    actionIncreaseFontSize = register({
      name: "increaseFontSize",
      trackEvent: false,
      perform: (elements, appState, value, app) => {
        return changeFontSize(
          elements,
          appState,
          app,
          (element) => Math.round(element.fontSize * (1 + FONT_SIZE_RELATIVE_INCREASE_STEP))
        );
      },
      keyTest: (event) => {
        return event[KEYS.CTRL_OR_CMD] && event.shiftKey && // KEYS.PERIOD needed for MacOS
        (event.key === KEYS.CHEVRON_RIGHT || event.key === KEYS.PERIOD);
      }
    });
    actionChangeFontFamily = register({
      name: "changeFontFamily",
      trackEvent: false,
      perform: (elements, appState, value, app) => {
        return {
          elements: changeProperty(
            elements,
            appState,
            (oldElement) => {
              if (isTextElement(oldElement)) {
                const newElement2 = newElementWith(
                  oldElement,
                  {
                    fontFamily: value,
                    lineHeight: getDefaultLineHeight(value)
                  }
                );
                redrawTextBoundingBox(
                  newElement2,
                  app.scene.getContainerElement(oldElement),
                  app.scene.getNonDeletedElementsMap()
                );
                return newElement2;
              }
              return oldElement;
            },
            true
          ),
          appState: {
            ...appState,
            currentItemFontFamily: value
          },
          commitToHistory: true
        };
      },
      PanelComponent: ({ elements, appState, updateData, app }) => {
        const options = [
          {
            value: FONT_FAMILY.Virgil,
            text: t("labels.handDrawn"),
            icon: FreedrawIcon,
            testId: "font-family-virgil"
          },
          {
            value: FONT_FAMILY.Helvetica,
            text: t("labels.normal"),
            icon: FontFamilyNormalIcon,
            testId: "font-family-normal"
          },
          {
            value: FONT_FAMILY.Cascadia,
            text: t("labels.code"),
            icon: FontFamilyCodeIcon,
            testId: "font-family-code"
          }
        ];
        return /* @__PURE__ */ jsxs14("fieldset", { children: [
          /* @__PURE__ */ jsx23("legend", { children: t("labels.fontFamily") }),
          /* @__PURE__ */ jsx23(
            ButtonIconSelect,
            {
              group: "font-family",
              options,
              value: getFormValue(
                elements,
                appState,
                (element) => {
                  if (isTextElement(element)) {
                    return element.fontFamily;
                  }
                  const boundTextElement = getBoundTextElement(
                    element,
                    app.scene.getNonDeletedElementsMap()
                  );
                  if (boundTextElement) {
                    return boundTextElement.fontFamily;
                  }
                  return null;
                },
                (element) => isTextElement(element) || getBoundTextElement(
                  element,
                  app.scene.getNonDeletedElementsMap()
                ) !== null,
                (hasSelection) => hasSelection ? null : appState.currentItemFontFamily || DEFAULT_FONT_FAMILY
              ),
              onChange: (value) => updateData(value)
            }
          )
        ] });
      }
    });
    actionChangeTextAlign = register({
      name: "changeTextAlign",
      trackEvent: false,
      perform: (elements, appState, value, app) => {
        return {
          elements: changeProperty(
            elements,
            appState,
            (oldElement) => {
              if (isTextElement(oldElement)) {
                const newElement2 = newElementWith(
                  oldElement,
                  { textAlign: value }
                );
                redrawTextBoundingBox(
                  newElement2,
                  app.scene.getContainerElement(oldElement),
                  app.scene.getNonDeletedElementsMap()
                );
                return newElement2;
              }
              return oldElement;
            },
            true
          ),
          appState: {
            ...appState,
            currentItemTextAlign: value
          },
          commitToHistory: true
        };
      },
      PanelComponent: ({ elements, appState, updateData, app }) => {
        const elementsMap = app.scene.getNonDeletedElementsMap();
        return /* @__PURE__ */ jsxs14("fieldset", { children: [
          /* @__PURE__ */ jsx23("legend", { children: t("labels.textAlign") }),
          /* @__PURE__ */ jsx23(
            ButtonIconSelect,
            {
              group: "text-align",
              options: [
                {
                  value: "left",
                  text: t("labels.left"),
                  icon: TextAlignLeftIcon,
                  testId: "align-left"
                },
                {
                  value: "center",
                  text: t("labels.center"),
                  icon: TextAlignCenterIcon,
                  testId: "align-horizontal-center"
                },
                {
                  value: "right",
                  text: t("labels.right"),
                  icon: TextAlignRightIcon,
                  testId: "align-right"
                }
              ],
              value: getFormValue(
                elements,
                appState,
                (element) => {
                  if (isTextElement(element)) {
                    return element.textAlign;
                  }
                  const boundTextElement = getBoundTextElement(
                    element,
                    elementsMap
                  );
                  if (boundTextElement) {
                    return boundTextElement.textAlign;
                  }
                  return null;
                },
                (element) => isTextElement(element) || getBoundTextElement(element, elementsMap) !== null,
                (hasSelection) => hasSelection ? null : appState.currentItemTextAlign
              ),
              onChange: (value) => updateData(value)
            }
          )
        ] });
      }
    });
    actionChangeVerticalAlign = register({
      name: "changeVerticalAlign",
      trackEvent: { category: "element" },
      perform: (elements, appState, value, app) => {
        return {
          elements: changeProperty(
            elements,
            appState,
            (oldElement) => {
              if (isTextElement(oldElement)) {
                const newElement2 = newElementWith(
                  oldElement,
                  { verticalAlign: value }
                );
                redrawTextBoundingBox(
                  newElement2,
                  app.scene.getContainerElement(oldElement),
                  app.scene.getNonDeletedElementsMap()
                );
                return newElement2;
              }
              return oldElement;
            },
            true
          ),
          appState: {
            ...appState
          },
          commitToHistory: true
        };
      },
      PanelComponent: ({ elements, appState, updateData, app }) => {
        return /* @__PURE__ */ jsx23("fieldset", { children: /* @__PURE__ */ jsx23(
          ButtonIconSelect,
          {
            group: "text-align",
            options: [
              {
                value: VERTICAL_ALIGN.TOP,
                text: t("labels.alignTop"),
                icon: /* @__PURE__ */ jsx23(TextAlignTopIcon, { theme: appState.theme }),
                testId: "align-top"
              },
              {
                value: VERTICAL_ALIGN.MIDDLE,
                text: t("labels.centerVertically"),
                icon: /* @__PURE__ */ jsx23(TextAlignMiddleIcon, { theme: appState.theme }),
                testId: "align-middle"
              },
              {
                value: VERTICAL_ALIGN.BOTTOM,
                text: t("labels.alignBottom"),
                icon: /* @__PURE__ */ jsx23(TextAlignBottomIcon, { theme: appState.theme }),
                testId: "align-bottom"
              }
            ],
            value: getFormValue(
              elements,
              appState,
              (element) => {
                if (isTextElement(element) && element.containerId) {
                  return element.verticalAlign;
                }
                const boundTextElement = getBoundTextElement(
                  element,
                  app.scene.getNonDeletedElementsMap()
                );
                if (boundTextElement) {
                  return boundTextElement.verticalAlign;
                }
                return null;
              },
              (element) => isTextElement(element) || getBoundTextElement(
                element,
                app.scene.getNonDeletedElementsMap()
              ) !== null,
              (hasSelection) => hasSelection ? null : VERTICAL_ALIGN.MIDDLE
            ),
            onChange: (value) => updateData(value)
          }
        ) });
      }
    });
    actionChangeRoundness = register({
      name: "changeRoundness",
      trackEvent: false,
      perform: (elements, appState, value) => {
        return {
          elements: changeProperty(
            elements,
            appState,
            (el) => newElementWith(el, {
              roundness: value === "round" ? {
                type: isUsingAdaptiveRadius(el.type) ? ROUNDNESS.ADAPTIVE_RADIUS : ROUNDNESS.PROPORTIONAL_RADIUS
              } : null
            })
          ),
          appState: {
            ...appState,
            currentItemRoundness: value
          },
          commitToHistory: true
        };
      },
      PanelComponent: ({ elements, appState, updateData }) => {
        const targetElements = getTargetElements(
          getNonDeletedElements3(elements),
          appState
        );
        const hasLegacyRoundness = targetElements.some(
          (el) => el.roundness?.type === ROUNDNESS.LEGACY
        );
        return /* @__PURE__ */ jsxs14("fieldset", { children: [
          /* @__PURE__ */ jsx23("legend", { children: t("labels.edges") }),
          /* @__PURE__ */ jsx23(
            ButtonIconSelect,
            {
              group: "edges",
              options: [
                {
                  value: "sharp",
                  text: t("labels.sharp"),
                  icon: EdgeSharpIcon
                },
                {
                  value: "round",
                  text: t("labels.round"),
                  icon: EdgeRoundIcon
                }
              ],
              value: getFormValue(
                elements,
                appState,
                (element) => hasLegacyRoundness ? null : element.roundness ? "round" : "sharp",
                (element) => element.hasOwnProperty("roundness"),
                (hasSelection) => hasSelection ? null : appState.currentItemRoundness
              ),
              onChange: (value) => updateData(value)
            }
          )
        ] });
      }
    });
    getArrowheadOptions = (flip) => {
      return [
        {
          value: null,
          text: t("labels.arrowhead_none"),
          keyBinding: "q",
          icon: ArrowheadNoneIcon
        },
        {
          value: "arrow",
          text: t("labels.arrowhead_arrow"),
          keyBinding: "w",
          icon: /* @__PURE__ */ jsx23(ArrowheadArrowIcon, { flip })
        },
        {
          value: "bar",
          text: t("labels.arrowhead_bar"),
          keyBinding: "e",
          icon: /* @__PURE__ */ jsx23(ArrowheadBarIcon, { flip })
        },
        {
          value: "dot",
          text: t("labels.arrowhead_circle"),
          keyBinding: null,
          icon: /* @__PURE__ */ jsx23(ArrowheadCircleIcon, { flip }),
          showInPicker: false
        },
        {
          value: "circle",
          text: t("labels.arrowhead_circle"),
          keyBinding: "r",
          icon: /* @__PURE__ */ jsx23(ArrowheadCircleIcon, { flip }),
          showInPicker: false
        },
        {
          value: "circle_outline",
          text: t("labels.arrowhead_circle_outline"),
          keyBinding: null,
          icon: /* @__PURE__ */ jsx23(ArrowheadCircleOutlineIcon, { flip }),
          showInPicker: false
        },
        {
          value: "triangle",
          text: t("labels.arrowhead_triangle"),
          icon: /* @__PURE__ */ jsx23(ArrowheadTriangleIcon, { flip }),
          keyBinding: "t"
        },
        {
          value: "triangle_outline",
          text: t("labels.arrowhead_triangle_outline"),
          icon: /* @__PURE__ */ jsx23(ArrowheadTriangleOutlineIcon, { flip }),
          keyBinding: null,
          showInPicker: false
        },
        {
          value: "diamond",
          text: t("labels.arrowhead_diamond"),
          icon: /* @__PURE__ */ jsx23(ArrowheadDiamondIcon, { flip }),
          keyBinding: null,
          showInPicker: false
        },
        {
          value: "diamond_outline",
          text: t("labels.arrowhead_diamond_outline"),
          icon: /* @__PURE__ */ jsx23(ArrowheadDiamondOutlineIcon, { flip }),
          keyBinding: null,
          showInPicker: false
        }
      ];
    };
    actionChangeArrowhead = register({
      name: "changeArrowhead",
      trackEvent: false,
      perform: (elements, appState, value) => {
        return {
          elements: changeProperty(elements, appState, (el) => {
            if (isLinearElement(el)) {
              const { position, type } = value;
              if (position === "start") {
                const element = newElementWith(el, {
                  startArrowhead: type
                });
                return element;
              } else if (position === "end") {
                const element = newElementWith(el, {
                  endArrowhead: type
                });
                return element;
              }
            }
            return el;
          }),
          appState: {
            ...appState,
            [value.position === "start" ? "currentItemStartArrowhead" : "currentItemEndArrowhead"]: value.type
          },
          commitToHistory: true
        };
      },
      PanelComponent: ({ elements, appState, updateData }) => {
        const isRTL2 = getLanguage().rtl;
        return /* @__PURE__ */ jsxs14("fieldset", { children: [
          /* @__PURE__ */ jsx23("legend", { children: t("labels.arrowheads") }),
          /* @__PURE__ */ jsxs14("div", { className: "iconSelectList buttonList", children: [
            /* @__PURE__ */ jsx23(
              IconPicker,
              {
                label: "arrowhead_start",
                options: getArrowheadOptions(!isRTL2),
                value: getFormValue(
                  elements,
                  appState,
                  (element) => isLinearElement(element) && canHaveArrowheads(element.type) ? element.startArrowhead : appState.currentItemStartArrowhead,
                  true,
                  appState.currentItemStartArrowhead
                ),
                onChange: (value) => updateData({ position: "start", type: value })
              }
            ),
            /* @__PURE__ */ jsx23(
              IconPicker,
              {
                label: "arrowhead_end",
                group: "arrowheads",
                options: getArrowheadOptions(!!isRTL2),
                value: getFormValue(
                  elements,
                  appState,
                  (element) => isLinearElement(element) && canHaveArrowheads(element.type) ? element.endArrowhead : appState.currentItemEndArrowhead,
                  true,
                  appState.currentItemEndArrowhead
                ),
                onChange: (value) => updateData({ position: "end", type: value })
              }
            )
          ] })
        ] });
      }
    });
  }
});

// actions/actionCanvas.tsx
import { jsx as jsx24, jsxs as jsxs15 } from "react/jsx-runtime";
var actionChangeViewBackgroundColor, actionClearCanvas, actionZoomIn, actionZoomOut, actionResetZoom, zoomValueToFitBoundsOnViewport, zoomToFitBounds, zoomToFit, actionZoomToFitSelectionInViewport, actionZoomToFitSelection, actionZoomToFit, actionToggleTheme, actionToggleEraserTool, actionToggleHandTool;
var init_actionCanvas = __esm({
  "actions/actionCanvas.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_ColorPicker2();
    init_icons();
    init_ToolButton();
    init_constants();
    init_element();
    init_i18n();
    init_keys();
    init_scene();
    init_scroll();
    init_zoom();
    init_utils();
    init_register();
    init_Tooltip2();
    init_mutateElement();
    init_appState();
    init_colors();
    init_cursor();
    actionChangeViewBackgroundColor = register({
      name: "changeViewBackgroundColor",
      trackEvent: false,
      predicate: (elements, appState, props, app) => {
        return !!app.props.UIOptions.canvasActions.changeViewBackgroundColor && !appState.viewModeEnabled;
      },
      perform: (_, appState, value) => {
        return {
          appState: { ...appState, ...value },
          commitToHistory: !!value.viewBackgroundColor
        };
      },
      PanelComponent: ({ elements, appState, updateData, appProps }) => {
        return /* @__PURE__ */ jsx24(
          ColorPicker,
          {
            palette: null,
            topPicks: DEFAULT_CANVAS_BACKGROUND_PICKS,
            label: t("labels.canvasBackground"),
            type: "canvasBackground",
            color: appState.viewBackgroundColor,
            onChange: (color) => updateData({ viewBackgroundColor: color }),
            "data-testid": "canvas-background-picker",
            elements,
            appState,
            updateData
          }
        );
      }
    });
    actionClearCanvas = register({
      name: "clearCanvas",
      trackEvent: { category: "canvas" },
      predicate: (elements, appState, props, app) => {
        return !!app.props.UIOptions.canvasActions.clearCanvas && !appState.viewModeEnabled;
      },
      perform: (elements, appState, _, app) => {
        app.imageCache.clear();
        return {
          elements: elements.map(
            (element) => newElementWith(element, { isDeleted: true })
          ),
          appState: {
            ...getDefaultAppState(),
            files: {},
            theme: appState.theme,
            penMode: appState.penMode,
            penDetected: appState.penDetected,
            exportBackground: appState.exportBackground,
            exportEmbedScene: appState.exportEmbedScene,
            gridSize: appState.gridSize,
            showStats: appState.showStats,
            pasteDialog: appState.pasteDialog,
            activeTool: appState.activeTool.type === "image" ? { ...appState.activeTool, type: "selection" } : appState.activeTool
          },
          commitToHistory: true
        };
      }
    });
    actionZoomIn = register({
      name: "zoomIn",
      viewMode: true,
      trackEvent: { category: "canvas" },
      perform: (_elements, appState, _, app) => {
        return {
          appState: {
            ...appState,
            ...getStateForZoom(
              {
                viewportX: appState.width / 2 + appState.offsetLeft,
                viewportY: appState.height / 2 + appState.offsetTop,
                nextZoom: getNormalizedZoom(appState.zoom.value + ZOOM_STEP)
              },
              appState
            ),
            userToFollow: null
          },
          commitToHistory: false
        };
      },
      PanelComponent: ({ updateData }) => /* @__PURE__ */ jsx24(
        ToolButton,
        {
          type: "button",
          className: "zoom-in-button zoom-button",
          icon: ZoomInIcon,
          title: `${t("buttons.zoomIn")} \u2014 ${getShortcutKey("CtrlOrCmd++")}`,
          "aria-label": t("buttons.zoomIn"),
          onClick: () => {
            updateData(null);
          }
        }
      ),
      keyTest: (event) => (event.code === CODES.EQUAL || event.code === CODES.NUM_ADD) && (event[KEYS.CTRL_OR_CMD] || event.shiftKey)
    });
    actionZoomOut = register({
      name: "zoomOut",
      viewMode: true,
      trackEvent: { category: "canvas" },
      perform: (_elements, appState, _, app) => {
        return {
          appState: {
            ...appState,
            ...getStateForZoom(
              {
                viewportX: appState.width / 2 + appState.offsetLeft,
                viewportY: appState.height / 2 + appState.offsetTop,
                nextZoom: getNormalizedZoom(appState.zoom.value - ZOOM_STEP)
              },
              appState
            ),
            userToFollow: null
          },
          commitToHistory: false
        };
      },
      PanelComponent: ({ updateData }) => /* @__PURE__ */ jsx24(
        ToolButton,
        {
          type: "button",
          className: "zoom-out-button zoom-button",
          icon: ZoomOutIcon,
          title: `${t("buttons.zoomOut")} \u2014 ${getShortcutKey("CtrlOrCmd+-")}`,
          "aria-label": t("buttons.zoomOut"),
          onClick: () => {
            updateData(null);
          }
        }
      ),
      keyTest: (event) => (event.code === CODES.MINUS || event.code === CODES.NUM_SUBTRACT) && (event[KEYS.CTRL_OR_CMD] || event.shiftKey)
    });
    actionResetZoom = register({
      name: "resetZoom",
      viewMode: true,
      trackEvent: { category: "canvas" },
      perform: (_elements, appState, _, app) => {
        return {
          appState: {
            ...appState,
            ...getStateForZoom(
              {
                viewportX: appState.width / 2 + appState.offsetLeft,
                viewportY: appState.height / 2 + appState.offsetTop,
                nextZoom: getNormalizedZoom(1)
              },
              appState
            ),
            userToFollow: null
          },
          commitToHistory: false
        };
      },
      PanelComponent: ({ updateData, appState }) => /* @__PURE__ */ jsx24(Tooltip, { label: t("buttons.resetZoom"), style: { height: "100%" }, children: /* @__PURE__ */ jsxs15(
        ToolButton,
        {
          type: "button",
          className: "reset-zoom-button zoom-button",
          title: t("buttons.resetZoom"),
          "aria-label": t("buttons.resetZoom"),
          onClick: () => {
            updateData(null);
          },
          children: [
            (appState.zoom.value * 100).toFixed(0),
            "%"
          ]
        }
      ) }),
      keyTest: (event) => (event.code === CODES.ZERO || event.code === CODES.NUM_ZERO) && (event[KEYS.CTRL_OR_CMD] || event.shiftKey)
    });
    zoomValueToFitBoundsOnViewport = (bounds, viewportDimensions) => {
      const [x1, y1, x2, y2] = bounds;
      const commonBoundsWidth = x2 - x1;
      const zoomValueForWidth = viewportDimensions.width / commonBoundsWidth;
      const commonBoundsHeight = y2 - y1;
      const zoomValueForHeight = viewportDimensions.height / commonBoundsHeight;
      const smallestZoomValue = Math.min(zoomValueForWidth, zoomValueForHeight);
      const zoomAdjustedToSteps = Math.floor(smallestZoomValue / ZOOM_STEP) * ZOOM_STEP;
      const clampedZoomValueToFitElements = Math.min(
        Math.max(zoomAdjustedToSteps, MIN_ZOOM),
        1
      );
      return clampedZoomValueToFitElements;
    };
    zoomToFitBounds = ({
      bounds,
      appState,
      fitToViewport = false,
      viewportZoomFactor = 0.7
    }) => {
      const [x1, y1, x2, y2] = bounds;
      const centerX = (x1 + x2) / 2;
      const centerY = (y1 + y2) / 2;
      let newZoomValue;
      let scrollX;
      let scrollY;
      if (fitToViewport) {
        const commonBoundsWidth = x2 - x1;
        const commonBoundsHeight = y2 - y1;
        newZoomValue = Math.min(
          appState.width / commonBoundsWidth,
          appState.height / commonBoundsHeight
        ) * Math.min(1, Math.max(viewportZoomFactor, 0.1));
        newZoomValue = Math.min(
          Math.max(newZoomValue, 0.1),
          30
        );
        let appStateWidth = appState.width;
        if (appState.openSidebar) {
          const sidebarDOMElem = document.querySelector(
            ".sidebar"
          );
          const sidebarWidth = sidebarDOMElem?.offsetWidth ?? 0;
          const isRTL2 = document.documentElement.getAttribute("dir") === "rtl";
          appStateWidth = !isRTL2 ? appState.width - sidebarWidth : appState.width + sidebarWidth;
        }
        scrollX = appStateWidth / 2 * (1 / newZoomValue) - centerX;
        scrollY = appState.height / 2 * (1 / newZoomValue) - centerY;
      } else {
        newZoomValue = zoomValueToFitBoundsOnViewport(bounds, {
          width: appState.width,
          height: appState.height
        });
        const centerScroll = centerScrollOn({
          scenePoint: { x: centerX, y: centerY },
          viewportDimensions: {
            width: appState.width,
            height: appState.height
          },
          zoom: { value: newZoomValue }
        });
        scrollX = centerScroll.scrollX;
        scrollY = centerScroll.scrollY;
      }
      return {
        appState: {
          ...appState,
          scrollX,
          scrollY,
          zoom: { value: newZoomValue }
        },
        commitToHistory: false
      };
    };
    zoomToFit = ({
      targetElements,
      appState,
      fitToViewport,
      viewportZoomFactor
    }) => {
      const commonBounds = getCommonBounds(getNonDeletedElements3(targetElements));
      return zoomToFitBounds({
        bounds: commonBounds,
        appState,
        fitToViewport,
        viewportZoomFactor
      });
    };
    actionZoomToFitSelectionInViewport = register({
      name: "zoomToFitSelectionInViewport",
      trackEvent: { category: "canvas" },
      perform: (elements, appState, _, app) => {
        const selectedElements = app.scene.getSelectedElements(appState);
        return zoomToFit({
          targetElements: selectedElements.length ? selectedElements : elements,
          appState: {
            ...appState,
            userToFollow: null
          },
          fitToViewport: false
        });
      },
      // NOTE shift-2 should have been assigned actionZoomToFitSelection.
      // TBD on how proceed
      keyTest: (event) => event.code === CODES.TWO && event.shiftKey && !event.altKey && !event[KEYS.CTRL_OR_CMD]
    });
    actionZoomToFitSelection = register({
      name: "zoomToFitSelection",
      trackEvent: { category: "canvas" },
      perform: (elements, appState, _, app) => {
        const selectedElements = app.scene.getSelectedElements(appState);
        return zoomToFit({
          targetElements: selectedElements.length ? selectedElements : elements,
          appState: {
            ...appState,
            userToFollow: null
          },
          fitToViewport: true
        });
      },
      // NOTE this action should use shift-2 per figma, alas
      keyTest: (event) => event.code === CODES.THREE && event.shiftKey && !event.altKey && !event[KEYS.CTRL_OR_CMD]
    });
    actionZoomToFit = register({
      name: "zoomToFit",
      viewMode: true,
      trackEvent: { category: "canvas" },
      perform: (elements, appState) => zoomToFit({
        targetElements: elements,
        appState: {
          ...appState,
          userToFollow: null
        },
        fitToViewport: false
      }),
      keyTest: (event) => event.code === CODES.ONE && event.shiftKey && !event.altKey && !event[KEYS.CTRL_OR_CMD]
    });
    actionToggleTheme = register({
      name: "toggleTheme",
      viewMode: true,
      trackEvent: { category: "canvas" },
      perform: (_, appState, value) => {
        return {
          appState: {
            ...appState,
            theme: value || (appState.theme === THEME.LIGHT ? THEME.DARK : THEME.LIGHT)
          },
          commitToHistory: false
        };
      },
      keyTest: (event) => event.altKey && event.shiftKey && event.code === CODES.D,
      predicate: (elements, appState, props, app) => {
        return !!app.props.UIOptions.canvasActions.toggleTheme;
      }
    });
    actionToggleEraserTool = register({
      name: "toggleEraserTool",
      trackEvent: { category: "toolbar" },
      perform: (elements, appState) => {
        let activeTool;
        if (isEraserActive(appState)) {
          activeTool = updateActiveTool(appState, {
            ...appState.activeTool.lastActiveTool || {
              type: "selection"
            },
            lastActiveToolBeforeEraser: null
          });
        } else {
          activeTool = updateActiveTool(appState, {
            type: "eraser",
            lastActiveToolBeforeEraser: appState.activeTool
          });
        }
        return {
          appState: {
            ...appState,
            selectedElementIds: {},
            selectedGroupIds: {},
            activeEmbeddable: null,
            activeTool
          },
          commitToHistory: true
        };
      },
      keyTest: (event) => event.key === KEYS.E
    });
    actionToggleHandTool = register({
      name: "toggleHandTool",
      trackEvent: { category: "toolbar" },
      perform: (elements, appState, _, app) => {
        let activeTool;
        if (isHandToolActive(appState)) {
          activeTool = updateActiveTool(appState, {
            ...appState.activeTool.lastActiveTool || {
              type: "selection"
            },
            lastActiveToolBeforeEraser: null
          });
        } else {
          activeTool = updateActiveTool(appState, {
            type: "hand",
            lastActiveToolBeforeEraser: appState.activeTool
          });
          setCursor(app.interactiveCanvas, CURSOR_TYPE.GRAB);
        }
        return {
          appState: {
            ...appState,
            selectedElementIds: {},
            selectedGroupIds: {},
            activeEmbeddable: null,
            activeTool
          },
          commitToHistory: true
        };
      },
      keyTest: (event) => !event.altKey && !event[KEYS.CTRL_OR_CMD] && event.key === KEYS.H
    });
  }
});

// actions/actionFinalize.tsx
import { jsx as jsx25 } from "react/jsx-runtime";
var actionFinalize;
var init_actionFinalize = __esm({
  "actions/actionFinalize.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_keys();
    init_element();
    init_utils();
    init_ToolButton();
    init_icons();
    init_i18n();
    init_register();
    init_mutateElement();
    init_math();
    init_linearElementEditor();
    init_Scene();
    init_binding();
    init_typeChecks();
    init_cursor();
    actionFinalize = register({
      name: "finalize",
      trackEvent: false,
      perform: (elements, appState, _, { interactiveCanvas, focusContainer, scene }) => {
        const elementsMap = scene.getNonDeletedElementsMap();
        if (appState.editingLinearElement) {
          const { elementId, startBindingElement, endBindingElement } = appState.editingLinearElement;
          const element = LinearElementEditor.getElement(elementId, elementsMap);
          if (element) {
            if (isBindingElement(element)) {
              bindOrUnbindLinearElement(
                element,
                startBindingElement,
                endBindingElement,
                elementsMap
              );
            }
            return {
              elements: element.points.length < 2 || isInvisiblySmallElement(element) ? elements.filter((el) => el.id !== element.id) : void 0,
              appState: {
                ...appState,
                cursorButton: "up",
                editingLinearElement: null
              },
              commitToHistory: true
            };
          }
        }
        let newElements = elements;
        const pendingImageElement = appState.pendingImageElementId && scene.getElement(appState.pendingImageElementId);
        if (pendingImageElement) {
          mutateElement(pendingImageElement, { isDeleted: true }, false);
        }
        if (window.document.activeElement instanceof HTMLElement) {
          focusContainer();
        }
        const multiPointElement = appState.multiElement ? appState.multiElement : appState.editingElement?.type === "freedraw" ? appState.editingElement : null;
        if (multiPointElement) {
          if (multiPointElement.type !== "freedraw" && appState.lastPointerDownWith !== "touch") {
            const { points, lastCommittedPoint } = multiPointElement;
            if (!lastCommittedPoint || points[points.length - 1] !== lastCommittedPoint) {
              mutateElement(multiPointElement, {
                points: multiPointElement.points.slice(0, -1)
              });
            }
          }
          if (isInvisiblySmallElement(multiPointElement)) {
            newElements = newElements.filter(
              (el) => el.id !== multiPointElement.id
            );
          }
          const isLoop = isPathALoop(multiPointElement.points, appState.zoom.value);
          if (multiPointElement.type === "line" || multiPointElement.type === "freedraw") {
            if (isLoop) {
              const linePoints = multiPointElement.points;
              const firstPoint = linePoints[0];
              mutateElement(multiPointElement, {
                points: linePoints.map(
                  (point2, index) => index === linePoints.length - 1 ? [firstPoint[0], firstPoint[1]] : point2
                )
              });
            }
          }
          if (isBindingElement(multiPointElement) && !isLoop && multiPointElement.points.length > 1) {
            const [x, y] = LinearElementEditor.getPointAtIndexGlobalCoordinates(
              multiPointElement,
              -1,
              arrayToMap(elements)
            );
            maybeBindLinearElement(
              multiPointElement,
              appState,
              Scene_default.getScene(multiPointElement),
              { x, y },
              elementsMap
            );
          }
        }
        if (!appState.activeTool.locked && appState.activeTool.type !== "freedraw" || !multiPointElement) {
          resetCursor(interactiveCanvas);
        }
        let activeTool;
        if (appState.activeTool.type === "eraser") {
          activeTool = updateActiveTool(appState, {
            ...appState.activeTool.lastActiveTool || {
              type: "selection"
            },
            lastActiveToolBeforeEraser: null
          });
        } else {
          activeTool = updateActiveTool(appState, {
            type: "selection"
          });
        }
        return {
          elements: newElements,
          appState: {
            ...appState,
            cursorButton: "up",
            activeTool: (appState.activeTool.locked || appState.activeTool.type === "freedraw") && multiPointElement ? appState.activeTool : activeTool,
            activeEmbeddable: null,
            draggingElement: null,
            multiElement: null,
            editingElement: null,
            startBoundElement: null,
            suggestedBindings: [],
            selectedElementIds: multiPointElement && !appState.activeTool.locked && appState.activeTool.type !== "freedraw" ? {
              ...appState.selectedElementIds,
              [multiPointElement.id]: true
            } : appState.selectedElementIds,
            // To select the linear element when user has finished mutipoint editing
            selectedLinearElement: multiPointElement && isLinearElement(multiPointElement) ? new LinearElementEditor(multiPointElement) : appState.selectedLinearElement,
            pendingImageElementId: null
          },
          commitToHistory: appState.activeTool.type === "freedraw"
        };
      },
      keyTest: (event, appState) => event.key === KEYS.ESCAPE && (appState.editingLinearElement !== null || !appState.draggingElement && appState.multiElement === null) || (event.key === KEYS.ESCAPE || event.key === KEYS.ENTER) && appState.multiElement !== null,
      PanelComponent: ({ appState, updateData, data }) => /* @__PURE__ */ jsx25(
        ToolButton,
        {
          type: "button",
          icon: done,
          title: t("buttons.done"),
          "aria-label": t("buttons.done"),
          onClick: updateData,
          visible: appState.multiElement != null,
          size: data?.size || "medium"
        }
      )
    });
  }
});

// components/TextInput.scss
var init_TextInput = __esm({
  "components/TextInput.scss"() {
  }
});

// components/ProjectName.scss
var init_ProjectName = __esm({
  "components/ProjectName.scss"() {
  }
});

// components/ProjectName.tsx
import { useState as useState9 } from "react";
import { jsx as jsx26, jsxs as jsxs16 } from "react/jsx-runtime";
var ProjectName;
var init_ProjectName2 = __esm({
  "components/ProjectName.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_TextInput();
    init_utils();
    init_ProjectName();
    init_App();
    init_keys();
    ProjectName = (props) => {
      const { id } = useExcalidrawContainer();
      const [fileName, setFileName] = useState9(props.value);
      const handleBlur = (event) => {
        if (!props.ignoreFocus) {
          focusNearestParent(event.target);
        }
        const value = event.target.value;
        if (value !== props.value) {
          props.onChange(value);
        }
      };
      const handleKeyDown = (event) => {
        if (event.key === KEYS.ENTER) {
          event.preventDefault();
          if (event.nativeEvent.isComposing || event.keyCode === 229) {
            return;
          }
          event.currentTarget.blur();
        }
      };
      return /* @__PURE__ */ jsxs16("div", { className: "ProjectName", children: [
        /* @__PURE__ */ jsx26("label", { className: "ProjectName-label", htmlFor: "filename", children: `${props.label}:` }),
        /* @__PURE__ */ jsx26(
          "input",
          {
            type: "text",
            className: "TextInput",
            onBlur: handleBlur,
            onKeyDown: handleKeyDown,
            id: `${id}-filename`,
            value: fileName,
            onChange: (event) => setFileName(event.target.value)
          }
        )
      ] });
    };
  }
});

// components/DarkModeToggle.tsx
import { jsx as jsx27 } from "react/jsx-runtime";
var DarkModeToggle, ICONS;
var init_DarkModeToggle = __esm({
  "components/DarkModeToggle.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_ToolIcon();
    init_i18n();
    init_ToolButton();
    init_constants();
    DarkModeToggle = (props) => {
      const title = props.title || (props.value === "dark" ? t("buttons.lightMode") : t("buttons.darkMode"));
      return /* @__PURE__ */ jsx27(
        ToolButton,
        {
          type: "icon",
          icon: props.value === THEME.LIGHT ? ICONS.MOON : ICONS.SUN,
          title,
          "aria-label": title,
          onClick: () => props.onChange(props.value === THEME.DARK ? THEME.LIGHT : THEME.DARK),
          "data-testid": "toggle-dark-mode"
        }
      );
    };
    ICONS = {
      SUN: /* @__PURE__ */ jsx27("svg", { width: "512", height: "512", className: "rtl-mirror", viewBox: "0 0 512 512", children: /* @__PURE__ */ jsx27(
        "path",
        {
          fill: "currentColor",
          d: "M256 160c-52.9 0-96 43.1-96 96s43.1 96 96 96 96-43.1 96-96-43.1-96-96-96zm246.4 80.5l-94.7-47.3 33.5-100.4c4.5-13.6-8.4-26.5-21.9-21.9l-100.4 33.5-47.4-94.8c-6.4-12.8-24.6-12.8-31 0l-47.3 94.7L92.7 70.8c-13.6-4.5-26.5 8.4-21.9 21.9l33.5 100.4-94.7 47.4c-12.8 6.4-12.8 24.6 0 31l94.7 47.3-33.5 100.5c-4.5 13.6 8.4 26.5 21.9 21.9l100.4-33.5 47.3 94.7c6.4 12.8 24.6 12.8 31 0l47.3-94.7 100.4 33.5c13.6 4.5 26.5-8.4 21.9-21.9l-33.5-100.4 94.7-47.3c13-6.5 13-24.7.2-31.1zm-155.9 106c-49.9 49.9-131.1 49.9-181 0-49.9-49.9-49.9-131.1 0-181 49.9-49.9 131.1-49.9 181 0 49.9 49.9 49.9 131.1 0 181z"
        }
      ) }),
      MOON: /* @__PURE__ */ jsx27("svg", { width: "512", height: "512", className: "rtl-mirror", viewBox: "0 0 512 512", children: /* @__PURE__ */ jsx27(
        "path",
        {
          fill: "currentColor",
          d: "M283.211 512c78.962 0 151.079-35.925 198.857-94.792 7.068-8.708-.639-21.43-11.562-19.35-124.203 23.654-238.262-71.576-238.262-196.954 0-72.222 38.662-138.635 101.498-174.394 9.686-5.512 7.25-20.197-3.756-22.23A258.156 258.156 0 0 0 283.211 0c-141.309 0-256 114.511-256 256 0 141.309 114.511 256 256 256z"
        }
      ) })
    };
  }
});

// data/index.ts
var prepareElementsForExport, exportCanvas;
var init_data = __esm({
  "data/index.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_clipboard();
    init_constants();
    init_element();
    init_typeChecks();
    init_i18n();
    init_scene();
    init_export();
    init_utils();
    init_blob();
    init_filesystem();
    init_json();
    init_frame();
    init_blob();
    init_json();
    prepareElementsForExport = (elements, { selectedElementIds }, exportSelectionOnly) => {
      elements = getNonDeletedElements3(elements);
      const isExportingSelection = exportSelectionOnly && isSomeElementSelected(elements, { selectedElementIds });
      let exportingFrame = null;
      let exportedElements = isExportingSelection ? getSelectedElements(
        elements,
        { selectedElementIds },
        {
          includeBoundTextElement: true
        }
      ) : elements;
      if (isExportingSelection) {
        if (exportedElements.length === 1 && isFrameLikeElement(exportedElements[0])) {
          exportingFrame = exportedElements[0];
          exportedElements = getElementsOverlappingFrame(elements, exportingFrame);
        } else if (exportedElements.length > 1) {
          exportedElements = getSelectedElements(
            elements,
            { selectedElementIds },
            {
              includeBoundTextElement: true,
              includeElementsInFrames: true
            }
          );
        }
      }
      return {
        exportingFrame,
        exportedElements: cloneJSON(exportedElements)
      };
    };
    exportCanvas = async (type, elements, appState, files, {
      exportBackground,
      exportPadding = DEFAULT_EXPORT_PADDING,
      viewBackgroundColor,
      name = appState.name || DEFAULT_FILENAME,
      fileHandle = null,
      exportingFrame = null
    }) => {
      if (elements.length === 0) {
        throw new Error(t("alerts.cannotExportEmptyCanvas"));
      }
      if (type === "svg" || type === "clipboard-svg") {
        const svgPromise = exportToSvg(
          elements,
          {
            exportBackground,
            exportWithDarkMode: appState.exportWithDarkMode,
            viewBackgroundColor,
            exportPadding,
            exportScale: appState.exportScale,
            exportEmbedScene: appState.exportEmbedScene && type === "svg"
          },
          files,
          { exportingFrame }
        );
        if (type === "svg") {
          return fileSave(
            svgPromise.then((svg) => {
              return new Blob([svg.outerHTML], { type: MIME_TYPES.svg });
            }),
            {
              description: "Export to SVG",
              name,
              extension: appState.exportEmbedScene ? "excalidraw.svg" : "svg",
              fileHandle
            }
          );
        } else if (type === "clipboard-svg") {
          await copyTextToSystemClipboard(
            await svgPromise.then((svg) => svg.outerHTML)
          );
          return;
        }
      }
      const tempCanvas = exportToCanvas(elements, appState, files, {
        exportBackground,
        viewBackgroundColor,
        exportPadding,
        exportingFrame
      });
      if (type === "png") {
        let blob = canvasToBlob(tempCanvas);
        if (appState.exportEmbedScene) {
          blob = blob.then(
            (blob2) => Promise.resolve().then(() => (init_image(), image_exports)).then(
              ({ encodePngMetadata: encodePngMetadata2 }) => encodePngMetadata2({
                blob: blob2,
                metadata: serializeAsJSON(elements, appState, files, "local")
              })
            )
          );
        }
        return fileSave(blob, {
          description: "Export to PNG",
          name,
          // FIXME reintroduce `excalidraw.png` when most people upgrade away
          // from 111.0.5563.64 (arm64), see #6349
          extension: (
            /* appState.exportEmbedScene ? "excalidraw.png" : */
            "png"
          ),
          fileHandle
        });
      } else if (type === "clipboard") {
        try {
          const blob = canvasToBlob(tempCanvas);
          await copyBlobToClipboardAsPng(blob);
        } catch (error) {
          console.warn(error);
          if (error.name === "CANVAS_POSSIBLY_TOO_BIG") {
            throw error;
          }
          if (isFirefox && error.name === "TypeError") {
            throw new Error(
              `${t("alerts.couldNotCopyToClipboard")}

${t(
                "hints.firefox_clipboard_write"
              )}`
            );
          } else {
            throw new Error(t("alerts.couldNotCopyToClipboard"));
          }
        }
      } else {
        throw new Error("Unsupported export type");
      }
    };
  }
});

// data/resave.ts
var resaveAsImageWithScene;
var init_resave = __esm({
  "data/resave.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_data();
    init_blob();
    resaveAsImageWithScene = async (elements, appState, files, name) => {
      const { exportBackground, viewBackgroundColor, fileHandle } = appState;
      const fileHandleType = getFileHandleType(fileHandle);
      if (!fileHandle || !isImageFileHandleType(fileHandleType)) {
        throw new Error(
          "fileHandle should exist and should be of type svg or png when resaving"
        );
      }
      appState = {
        ...appState,
        exportEmbedScene: true
      };
      const { exportedElements, exportingFrame } = prepareElementsForExport(
        elements,
        appState,
        false
      );
      await exportCanvas(fileHandleType, exportedElements, appState, files, {
        exportBackground,
        viewBackgroundColor,
        name,
        fileHandle,
        exportingFrame
      });
      return { fileHandle };
    };
  }
});

// components/CheckboxItem.scss
var init_CheckboxItem = __esm({
  "components/CheckboxItem.scss"() {
  }
});

// components/CheckboxItem.tsx
import clsx13 from "clsx";
import { jsx as jsx28, jsxs as jsxs17 } from "react/jsx-runtime";
var CheckboxItem;
var init_CheckboxItem2 = __esm({
  "components/CheckboxItem.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_icons();
    init_CheckboxItem();
    CheckboxItem = ({ children, checked, onChange, className }) => {
      return /* @__PURE__ */ jsxs17(
        "div",
        {
          className: clsx13("Checkbox", className, { "is-checked": checked }),
          onClick: (event) => {
            onChange(!checked, event);
            event.currentTarget.querySelector(
              ".Checkbox-box"
            ).focus();
          },
          children: [
            /* @__PURE__ */ jsx28("button", { className: "Checkbox-box", role: "checkbox", "aria-checked": checked, children: checkIcon }),
            /* @__PURE__ */ jsx28("div", { className: "Checkbox-label", children })
          ]
        }
      );
    };
  }
});

// actions/actionExport.tsx
import { Fragment as Fragment5, jsx as jsx29, jsxs as jsxs18 } from "react/jsx-runtime";
var actionChangeProjectName, actionChangeExportScale, actionChangeExportBackground, actionChangeExportEmbedScene, actionSaveToActiveFile, actionSaveFileToDisk, actionLoadScene, actionExportWithDarkMode;
var init_actionExport = __esm({
  "actions/actionExport.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_icons();
    init_ProjectName2();
    init_ToolButton();
    init_Tooltip2();
    init_DarkModeToggle();
    init_data();
    init_resave();
    init_i18n();
    init_App();
    init_keys();
    init_register();
    init_CheckboxItem2();
    init_export();
    init_constants();
    init_scene();
    init_element();
    init_blob();
    init_filesystem();
    init_ToolIcon();
    actionChangeProjectName = register({
      name: "changeProjectName",
      trackEvent: false,
      perform: (_elements, appState, value) => {
        return { appState: { ...appState, name: value }, commitToHistory: false };
      },
      PanelComponent: ({ appState, updateData, appProps, data, app }) => /* @__PURE__ */ jsx29(
        ProjectName,
        {
          label: t("labels.fileTitle"),
          value: app.getName(),
          onChange: (name) => updateData(name),
          ignoreFocus: data?.ignoreFocus ?? false
        }
      )
    });
    actionChangeExportScale = register({
      name: "changeExportScale",
      trackEvent: { category: "export", action: "scale" },
      perform: (_elements, appState, value) => {
        return {
          appState: { ...appState, exportScale: value },
          commitToHistory: false
        };
      },
      PanelComponent: ({ elements: allElements, appState, updateData }) => {
        const elements = getNonDeletedElements3(allElements);
        const exportSelected = isSomeElementSelected(elements, appState);
        const exportedElements = exportSelected ? getSelectedElements(elements, appState) : elements;
        return /* @__PURE__ */ jsx29(Fragment5, { children: EXPORT_SCALES.map((s) => {
          const [width, height] = getExportSize(
            exportedElements,
            DEFAULT_EXPORT_PADDING,
            s
          );
          const scaleButtonTitle = `${t(
            "imageExportDialog.label.scale"
          )} ${s}x (${width}x${height})`;
          return /* @__PURE__ */ jsx29(
            ToolButton,
            {
              size: "small",
              type: "radio",
              icon: `${s}x`,
              name: "export-canvas-scale",
              title: scaleButtonTitle,
              "aria-label": scaleButtonTitle,
              id: "export-canvas-scale",
              checked: s === appState.exportScale,
              onChange: () => updateData(s)
            },
            s
          );
        }) });
      }
    });
    actionChangeExportBackground = register({
      name: "changeExportBackground",
      trackEvent: { category: "export", action: "toggleBackground" },
      perform: (_elements, appState, value) => {
        return {
          appState: { ...appState, exportBackground: value },
          commitToHistory: false
        };
      },
      PanelComponent: ({ appState, updateData }) => /* @__PURE__ */ jsx29(
        CheckboxItem,
        {
          checked: appState.exportBackground,
          onChange: (checked) => updateData(checked),
          children: t("imageExportDialog.label.withBackground")
        }
      )
    });
    actionChangeExportEmbedScene = register({
      name: "changeExportEmbedScene",
      trackEvent: { category: "export", action: "embedScene" },
      perform: (_elements, appState, value) => {
        return {
          appState: { ...appState, exportEmbedScene: value },
          commitToHistory: false
        };
      },
      PanelComponent: ({ appState, updateData }) => /* @__PURE__ */ jsxs18(
        CheckboxItem,
        {
          checked: appState.exportEmbedScene,
          onChange: (checked) => updateData(checked),
          children: [
            t("imageExportDialog.label.embedScene"),
            /* @__PURE__ */ jsx29(Tooltip, { label: t("imageExportDialog.tooltip.embedScene"), long: true, children: /* @__PURE__ */ jsx29("div", { className: "excalidraw-tooltip-icon", children: questionCircle }) })
          ]
        }
      )
    });
    actionSaveToActiveFile = register({
      name: "saveToActiveFile",
      trackEvent: { category: "export" },
      predicate: (elements, appState, props, app) => {
        return !!app.props.UIOptions.canvasActions.saveToActiveFile && !!appState.fileHandle && !appState.viewModeEnabled;
      },
      perform: async (elements, appState, value, app) => {
        const fileHandleExists = !!appState.fileHandle;
        try {
          const { fileHandle } = isImageFileHandle(appState.fileHandle) ? await resaveAsImageWithScene(
            elements,
            appState,
            app.files,
            app.getName()
          ) : await saveAsJSON(elements, appState, app.files, app.getName());
          return {
            commitToHistory: false,
            appState: {
              ...appState,
              fileHandle,
              toast: fileHandleExists ? {
                message: fileHandle?.name ? t("toast.fileSavedToFilename").replace(
                  "{filename}",
                  `"${fileHandle.name}"`
                ) : t("toast.fileSaved")
              } : null
            }
          };
        } catch (error) {
          if (error?.name !== "AbortError") {
            console.error(error);
          } else {
            console.warn(error);
          }
          return { commitToHistory: false };
        }
      },
      keyTest: (event) => event.key === KEYS.S && event[KEYS.CTRL_OR_CMD] && !event.shiftKey
    });
    actionSaveFileToDisk = register({
      name: "saveFileToDisk",
      viewMode: true,
      trackEvent: { category: "export" },
      perform: async (elements, appState, value, app) => {
        try {
          const { fileHandle } = await saveAsJSON(
            elements,
            {
              ...appState,
              fileHandle: null
            },
            app.files,
            app.getName()
          );
          return {
            commitToHistory: false,
            appState: {
              ...appState,
              openDialog: null,
              fileHandle,
              toast: { message: t("toast.fileSaved") }
            }
          };
        } catch (error) {
          if (error?.name !== "AbortError") {
            console.error(error);
          } else {
            console.warn(error);
          }
          return { commitToHistory: false };
        }
      },
      keyTest: (event) => event.key === KEYS.S && event.shiftKey && event[KEYS.CTRL_OR_CMD],
      PanelComponent: ({ updateData }) => /* @__PURE__ */ jsx29(
        ToolButton,
        {
          type: "button",
          icon: saveAs,
          title: t("buttons.saveAs"),
          "aria-label": t("buttons.saveAs"),
          showAriaLabel: useDevice().editor.isMobile,
          hidden: !nativeFileSystemSupported,
          onClick: () => updateData(null),
          "data-testid": "save-as-button"
        }
      )
    });
    actionLoadScene = register({
      name: "loadScene",
      trackEvent: { category: "export" },
      predicate: (elements, appState, props, app) => {
        return !!app.props.UIOptions.canvasActions.loadScene && !appState.viewModeEnabled;
      },
      perform: async (elements, appState, _, app) => {
        try {
          const {
            elements: loadedElements,
            appState: loadedAppState,
            files
          } = await loadFromJSON(appState, elements);
          return {
            elements: loadedElements,
            appState: loadedAppState,
            files,
            commitToHistory: true
          };
        } catch (error) {
          if (error?.name === "AbortError") {
            console.warn(error);
            return false;
          }
          return {
            elements,
            appState: { ...appState, errorMessage: error.message },
            files: app.files,
            commitToHistory: false
          };
        }
      },
      keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.key === KEYS.O
    });
    actionExportWithDarkMode = register({
      name: "exportWithDarkMode",
      trackEvent: { category: "export", action: "toggleTheme" },
      perform: (_elements, appState, value) => {
        return {
          appState: { ...appState, exportWithDarkMode: value },
          commitToHistory: false
        };
      },
      PanelComponent: ({ appState, updateData }) => /* @__PURE__ */ jsx29(
        "div",
        {
          style: {
            display: "flex",
            justifyContent: "flex-end",
            marginTop: "-45px",
            marginBottom: "10px"
          },
          children: /* @__PURE__ */ jsx29(
            DarkModeToggle,
            {
              value: appState.exportWithDarkMode ? THEME.DARK : THEME.LIGHT,
              onChange: (theme) => {
                updateData(theme === THEME.DARK);
              },
              title: t("imageExportDialog.label.darkMode")
            }
          )
        }
      )
    });
  }
});

// actions/actionStyles.ts
var copiedStyles, actionCopyStyles, actionPasteStyles;
var init_actionStyles = __esm({
  "actions/actionStyles.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_element();
    init_keys();
    init_i18n();
    init_register();
    init_mutateElement();
    init_constants();
    init_textElement();
    init_typeChecks();
    init_scene();
    copiedStyles = "{}";
    actionCopyStyles = register({
      name: "copyStyles",
      trackEvent: { category: "element" },
      perform: (elements, appState, formData, app) => {
        const elementsCopied = [];
        const element = elements.find((el) => appState.selectedElementIds[el.id]);
        elementsCopied.push(element);
        if (element && hasBoundTextElement(element)) {
          const boundTextElement = getBoundTextElement(
            element,
            app.scene.getNonDeletedElementsMap()
          );
          elementsCopied.push(boundTextElement);
        }
        if (element) {
          copiedStyles = JSON.stringify(elementsCopied);
        }
        return {
          appState: {
            ...appState,
            toast: { message: t("toast.copyStyles") }
          },
          commitToHistory: false
        };
      },
      contextItemLabel: "labels.copyStyles",
      keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.C
    });
    actionPasteStyles = register({
      name: "pasteStyles",
      trackEvent: { category: "element" },
      perform: (elements, appState, formData, app) => {
        const elementsCopied = JSON.parse(copiedStyles);
        const pastedElement = elementsCopied[0];
        const boundTextElement = elementsCopied[1];
        if (!isExcalidrawElement(pastedElement)) {
          return { elements, commitToHistory: false };
        }
        const selectedElements = getSelectedElements(elements, appState, {
          includeBoundTextElement: true
        });
        const selectedElementIds = selectedElements.map((element) => element.id);
        return {
          elements: elements.map((element) => {
            if (selectedElementIds.includes(element.id)) {
              let elementStylesToCopyFrom = pastedElement;
              if (isTextElement(element) && element.containerId) {
                elementStylesToCopyFrom = boundTextElement;
              }
              if (!elementStylesToCopyFrom) {
                return element;
              }
              let newElement2 = newElementWith(element, {
                backgroundColor: elementStylesToCopyFrom?.backgroundColor,
                strokeWidth: elementStylesToCopyFrom?.strokeWidth,
                strokeColor: elementStylesToCopyFrom?.strokeColor,
                strokeStyle: elementStylesToCopyFrom?.strokeStyle,
                fillStyle: elementStylesToCopyFrom?.fillStyle,
                opacity: elementStylesToCopyFrom?.opacity,
                roughness: elementStylesToCopyFrom?.roughness,
                roundness: elementStylesToCopyFrom.roundness ? canApplyRoundnessTypeToElement(
                  elementStylesToCopyFrom.roundness.type,
                  element
                ) ? elementStylesToCopyFrom.roundness : getDefaultRoundnessTypeForElement(element) : null
              });
              if (isTextElement(newElement2)) {
                const fontSize = elementStylesToCopyFrom.fontSize || DEFAULT_FONT_SIZE;
                const fontFamily = elementStylesToCopyFrom.fontFamily || DEFAULT_FONT_FAMILY;
                newElement2 = newElementWith(newElement2, {
                  fontSize,
                  fontFamily,
                  textAlign: elementStylesToCopyFrom.textAlign || DEFAULT_TEXT_ALIGN,
                  lineHeight: elementStylesToCopyFrom.lineHeight || getDefaultLineHeight(fontFamily)
                });
                let container = null;
                if (newElement2.containerId) {
                  container = selectedElements.find(
                    (element2) => isTextElement(newElement2) && element2.id === newElement2.containerId
                  ) || null;
                }
                redrawTextBoundingBox(
                  newElement2,
                  container,
                  app.scene.getNonDeletedElementsMap()
                );
              }
              if (newElement2.type === "arrow" && isArrowElement(elementStylesToCopyFrom)) {
                newElement2 = newElementWith(newElement2, {
                  startArrowhead: elementStylesToCopyFrom.startArrowhead,
                  endArrowhead: elementStylesToCopyFrom.endArrowhead
                });
              }
              if (isFrameLikeElement(element)) {
                newElement2 = newElementWith(newElement2, {
                  roundness: null,
                  backgroundColor: "transparent"
                });
              }
              return newElement2;
            }
            return element;
          }),
          commitToHistory: true
        };
      },
      contextItemLabel: "labels.pasteStyles",
      keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.V
    });
  }
});

// actions/actionMenu.tsx
import { jsx as jsx30 } from "react/jsx-runtime";
var actionToggleCanvasMenu, actionToggleEditMenu, actionShortcuts;
var init_actionMenu = __esm({
  "actions/actionMenu.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_icons();
    init_ToolButton();
    init_i18n();
    init_element();
    init_register();
    init_keys();
    actionToggleCanvasMenu = register({
      name: "toggleCanvasMenu",
      trackEvent: { category: "menu" },
      perform: (_, appState) => ({
        appState: {
          ...appState,
          openMenu: appState.openMenu === "canvas" ? null : "canvas"
        },
        commitToHistory: false
      }),
      PanelComponent: ({ appState, updateData }) => /* @__PURE__ */ jsx30(
        ToolButton,
        {
          type: "button",
          icon: HamburgerMenuIcon,
          "aria-label": t("buttons.menu"),
          onClick: updateData,
          selected: appState.openMenu === "canvas"
        }
      )
    });
    actionToggleEditMenu = register({
      name: "toggleEditMenu",
      trackEvent: { category: "menu" },
      perform: (_elements, appState) => ({
        appState: {
          ...appState,
          openMenu: appState.openMenu === "shape" ? null : "shape"
        },
        commitToHistory: false
      }),
      PanelComponent: ({ elements, appState, updateData }) => /* @__PURE__ */ jsx30(
        ToolButton,
        {
          visible: showSelectedShapeActions(
            appState,
            getNonDeletedElements3(elements)
          ),
          type: "button",
          icon: palette,
          "aria-label": t("buttons.edit"),
          onClick: updateData,
          selected: appState.openMenu === "shape"
        }
      )
    });
    actionShortcuts = register({
      name: "toggleShortcuts",
      viewMode: true,
      trackEvent: { category: "menu", action: "toggleHelpDialog" },
      perform: (_elements, appState, _, { focusContainer }) => {
        if (appState.openDialog?.name === "help") {
          focusContainer();
        }
        return {
          appState: {
            ...appState,
            openDialog: appState.openDialog?.name === "help" ? null : {
              name: "help"
            }
          },
          commitToHistory: false
        };
      },
      keyTest: (event) => event.key === KEYS.QUESTION_MARK
    });
  }
});

// actions/actionGroup.tsx
import { jsx as jsx31 } from "react/jsx-runtime";
var allElementsInSameGroup, enableActionGroup, actionGroup, actionUngroup;
var init_actionGroup = __esm({
  "actions/actionGroup.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_keys();
    init_i18n();
    init_utils();
    init_register();
    init_icons();
    init_mutateElement();
    init_scene();
    init_groups();
    init_element();
    init_random();
    init_ToolButton();
    init_typeChecks();
    init_frame();
    allElementsInSameGroup = (elements) => {
      if (elements.length >= 2) {
        const groupIds = elements[0].groupIds;
        for (const groupId of groupIds) {
          if (elements.reduce(
            (acc, element) => acc && isElementInGroup(element, groupId),
            true
          )) {
            return true;
          }
        }
      }
      return false;
    };
    enableActionGroup = (elements, appState, app) => {
      const selectedElements = app.scene.getSelectedElements({
        selectedElementIds: appState.selectedElementIds,
        includeBoundTextElement: true
      });
      return selectedElements.length >= 2 && !allElementsInSameGroup(selectedElements);
    };
    actionGroup = register({
      name: "group",
      trackEvent: { category: "element" },
      perform: (elements, appState, _, app) => {
        const selectedElements = app.scene.getSelectedElements({
          selectedElementIds: appState.selectedElementIds,
          includeBoundTextElement: true
        });
        if (selectedElements.length < 2) {
          return { appState, elements, commitToHistory: false };
        }
        const selectedGroupIds = getSelectedGroupIds(appState);
        if (selectedGroupIds.length === 1) {
          const selectedGroupId = selectedGroupIds[0];
          const elementIdsInGroup = new Set(
            getElementsInGroup(elements, selectedGroupId).map(
              (element) => element.id
            )
          );
          const selectedElementIds = new Set(
            selectedElements.map((element) => element.id)
          );
          const combinedSet = /* @__PURE__ */ new Set([
            ...Array.from(elementIdsInGroup),
            ...Array.from(selectedElementIds)
          ]);
          if (combinedSet.size === elementIdsInGroup.size) {
            return { appState, elements, commitToHistory: false };
          }
        }
        let nextElements = [...elements];
        const groupingElementsFromDifferentFrames = new Set(selectedElements.map((element) => element.frameId)).size > 1;
        if (groupingElementsFromDifferentFrames) {
          const frameElementsMap = groupByFrameLikes(selectedElements);
          frameElementsMap.forEach((elementsInFrame, frameId) => {
            removeElementsFromFrame(
              elementsInFrame,
              app.scene.getNonDeletedElementsMap()
            );
          });
        }
        const newGroupId = randomId();
        const selectElementIds = arrayToMap(selectedElements);
        nextElements = nextElements.map((element) => {
          if (!selectElementIds.get(element.id)) {
            return element;
          }
          return newElementWith(element, {
            groupIds: addToGroup(
              element.groupIds,
              newGroupId,
              appState.editingGroupId
            )
          });
        });
        const elementsInGroup = getElementsInGroup(nextElements, newGroupId);
        const lastElementInGroup = elementsInGroup[elementsInGroup.length - 1];
        const lastGroupElementIndex = nextElements.lastIndexOf(lastElementInGroup);
        const elementsAfterGroup = nextElements.slice(lastGroupElementIndex + 1);
        const elementsBeforeGroup = nextElements.slice(0, lastGroupElementIndex).filter(
          (updatedElement) => !isElementInGroup(updatedElement, newGroupId)
        );
        nextElements = [
          ...elementsBeforeGroup,
          ...elementsInGroup,
          ...elementsAfterGroup
        ];
        return {
          appState: {
            ...appState,
            ...selectGroup(
              newGroupId,
              { ...appState, selectedGroupIds: {} },
              getNonDeletedElements3(nextElements)
            )
          },
          elements: nextElements,
          commitToHistory: true
        };
      },
      contextItemLabel: "labels.group",
      predicate: (elements, appState, _, app) => enableActionGroup(elements, appState, app),
      keyTest: (event) => !event.shiftKey && event[KEYS.CTRL_OR_CMD] && event.key === KEYS.G,
      PanelComponent: ({ elements, appState, updateData, app }) => /* @__PURE__ */ jsx31(
        ToolButton,
        {
          hidden: !enableActionGroup(elements, appState, app),
          type: "button",
          icon: /* @__PURE__ */ jsx31(GroupIcon, { theme: appState.theme }),
          onClick: () => updateData(null),
          title: `${t("labels.group")} \u2014 ${getShortcutKey("CtrlOrCmd+G")}`,
          "aria-label": t("labels.group"),
          visible: isSomeElementSelected(getNonDeletedElements3(elements), appState)
        }
      )
    });
    actionUngroup = register({
      name: "ungroup",
      trackEvent: { category: "element" },
      perform: (elements, appState, _, app) => {
        const groupIds = getSelectedGroupIds(appState);
        const elementsMap = arrayToMap(elements);
        if (groupIds.length === 0) {
          return { appState, elements, commitToHistory: false };
        }
        let nextElements = [...elements];
        const boundTextElementIds = [];
        nextElements = nextElements.map((element) => {
          if (isBoundToContainer(element)) {
            boundTextElementIds.push(element.id);
          }
          const nextGroupIds = removeFromSelectedGroups(
            element.groupIds,
            appState.selectedGroupIds
          );
          if (nextGroupIds.length === element.groupIds.length) {
            return element;
          }
          return newElementWith(element, {
            groupIds: nextGroupIds
          });
        });
        const updateAppState = selectGroupsForSelectedElements(
          appState,
          getNonDeletedElements3(nextElements),
          appState,
          null
        );
        const selectedElements = app.scene.getSelectedElements(appState);
        const selectedElementFrameIds = new Set(
          selectedElements.filter((element) => element.frameId).map((element) => element.frameId)
        );
        const targetFrames = getFrameLikeElements(elements).filter(
          (frame) => selectedElementFrameIds.has(frame.id)
        );
        targetFrames.forEach((frame) => {
          if (frame) {
            nextElements = replaceAllElementsInFrame(
              nextElements,
              getElementsInResizingFrame(
                nextElements,
                frame,
                appState,
                elementsMap
              ),
              frame,
              app
            );
          }
        });
        updateAppState.selectedElementIds = Object.entries(
          updateAppState.selectedElementIds
        ).reduce(
          (acc, [id, selected]) => {
            if (selected && !boundTextElementIds.includes(id)) {
              acc[id] = true;
            }
            return acc;
          },
          {}
        );
        return {
          appState: { ...appState, ...updateAppState },
          elements: nextElements,
          commitToHistory: true
        };
      },
      keyTest: (event) => event.shiftKey && event[KEYS.CTRL_OR_CMD] && event.key === KEYS.G.toUpperCase(),
      contextItemLabel: "labels.ungroup",
      predicate: (elements, appState) => getSelectedGroupIds(appState).length > 0,
      PanelComponent: ({ elements, appState, updateData }) => /* @__PURE__ */ jsx31(
        ToolButton,
        {
          type: "button",
          hidden: getSelectedGroupIds(appState).length === 0,
          icon: /* @__PURE__ */ jsx31(UngroupIcon, { theme: appState.theme }),
          onClick: () => updateData(null),
          title: `${t("labels.ungroup")} \u2014 ${getShortcutKey("CtrlOrCmd+Shift+G")}`,
          "aria-label": t("labels.ungroup"),
          visible: isSomeElementSelected(getNonDeletedElements3(elements), appState)
        }
      )
    });
  }
});

// components/Avatar.scss
var init_Avatar = __esm({
  "components/Avatar.scss"() {
  }
});

// components/Avatar.tsx
import { useState as useState10 } from "react";
import clsx14 from "clsx";
import { jsx as jsx32 } from "react/jsx-runtime";
var Avatar;
var init_Avatar2 = __esm({
  "components/Avatar.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_Avatar();
    init_clients();
    Avatar = ({
      color,
      onClick,
      name,
      src,
      isBeingFollowed,
      isCurrentUser
    }) => {
      const shortName = getNameInitial(name);
      const [error, setError] = useState10(false);
      const loadImg = !error && src;
      const style = loadImg ? void 0 : { background: color };
      return /* @__PURE__ */ jsx32(
        "div",
        {
          className: clsx14("Avatar", {
            "Avatar--is-followed": isBeingFollowed,
            "Avatar--is-current-user": isCurrentUser
          }),
          style,
          onClick,
          children: loadImg ? /* @__PURE__ */ jsx32(
            "img",
            {
              className: "Avatar-img",
              src,
              alt: shortName,
              referrerPolicy: "no-referrer",
              onError: () => setError(true)
            }
          ) : shortName
        }
      );
    };
  }
});

// actions/actionNavigate.tsx
import { jsx as jsx33, jsxs as jsxs19 } from "react/jsx-runtime";
var actionGoToCollaborator;
var init_actionNavigate = __esm({
  "actions/actionNavigate.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_clients();
    init_Avatar2();
    init_icons();
    init_i18n();
    init_register();
    actionGoToCollaborator = register({
      name: "goToCollaborator",
      viewMode: true,
      trackEvent: { category: "collab" },
      perform: (_elements, appState, collaborator) => {
        if (!collaborator.socketId || appState.userToFollow?.socketId === collaborator.socketId || collaborator.isCurrentUser) {
          return {
            appState: {
              ...appState,
              userToFollow: null
            },
            commitToHistory: false
          };
        }
        return {
          appState: {
            ...appState,
            userToFollow: {
              socketId: collaborator.socketId,
              username: collaborator.username || ""
            },
            // Close mobile menu
            openMenu: appState.openMenu === "canvas" ? null : appState.openMenu
          },
          commitToHistory: false
        };
      },
      PanelComponent: ({ updateData, data, appState }) => {
        const { clientId, collaborator, withName, isBeingFollowed } = data;
        const background = getClientColor(clientId);
        return withName ? /* @__PURE__ */ jsxs19(
          "div",
          {
            className: "dropdown-menu-item dropdown-menu-item-base UserList__collaborator",
            onClick: () => updateData(collaborator),
            children: [
              /* @__PURE__ */ jsx33(
                Avatar,
                {
                  color: background,
                  onClick: () => {
                  },
                  name: collaborator.username || "",
                  src: collaborator.avatarUrl,
                  isBeingFollowed,
                  isCurrentUser: collaborator.isCurrentUser === true
                }
              ),
              /* @__PURE__ */ jsx33("div", { className: "UserList__collaborator-name", children: collaborator.username }),
              /* @__PURE__ */ jsx33(
                "div",
                {
                  className: "UserList__collaborator-follow-status-icon",
                  style: { visibility: isBeingFollowed ? "visible" : "hidden" },
                  title: isBeingFollowed ? t("userList.hint.followStatus") : void 0,
                  "aria-hidden": true,
                  children: eyeIcon
                }
              )
            ]
          }
        ) : /* @__PURE__ */ jsx33(
          Avatar,
          {
            color: background,
            onClick: () => {
              updateData(collaborator);
            },
            name: collaborator.username || "",
            src: collaborator.avatarUrl,
            isBeingFollowed,
            isCurrentUser: collaborator.isCurrentUser === true
          }
        );
      }
    });
  }
});

// actions/actionAddToLibrary.ts
var actionAddToLibrary;
var init_actionAddToLibrary = __esm({
  "actions/actionAddToLibrary.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_register();
    init_newElement();
    init_random();
    init_i18n();
    init_constants();
    actionAddToLibrary = register({
      name: "addToLibrary",
      trackEvent: { category: "element" },
      perform: (elements, appState, _, app) => {
        const selectedElements = app.scene.getSelectedElements({
          selectedElementIds: appState.selectedElementIds,
          includeBoundTextElement: true,
          includeElementsInFrames: true
        });
        for (const type of LIBRARY_DISABLED_TYPES) {
          if (selectedElements.some((element) => element.type === type)) {
            return {
              commitToHistory: false,
              appState: {
                ...appState,
                errorMessage: t(`errors.libraryElementTypeError.${type}`)
              }
            };
          }
        }
        return app.library.getLatestLibrary().then((items) => {
          return app.library.setLibrary([
            {
              id: randomId(),
              status: "unpublished",
              elements: selectedElements.map(deepCopyElement),
              created: Date.now()
            },
            ...items
          ]);
        }).then(() => {
          return {
            commitToHistory: false,
            appState: {
              ...appState,
              toast: { message: t("toast.addedToLibrary") }
            }
          };
        }).catch((error) => {
          return {
            commitToHistory: false,
            appState: {
              ...appState,
              errorMessage: error.message
            }
          };
        });
      },
      contextItemLabel: "labels.addToLibrary"
    });
  }
});

// align.ts
var alignElements, calculateTranslation;
var init_align = __esm({
  "align.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_mutateElement();
    init_bounds();
    init_groups();
    alignElements = (selectedElements, elementsMap, alignment) => {
      const groups = getMaximumGroups(
        selectedElements,
        elementsMap
      );
      const selectionBoundingBox = getCommonBoundingBox(selectedElements);
      return groups.flatMap((group) => {
        const translation2 = calculateTranslation(
          group,
          selectionBoundingBox,
          alignment
        );
        return group.map(
          (element) => newElementWith(element, {
            x: element.x + translation2.x,
            y: element.y + translation2.y
          })
        );
      });
    };
    calculateTranslation = (group, selectionBoundingBox, { axis, position }) => {
      const groupBoundingBox = getCommonBoundingBox(group);
      const [min, max] = axis === "x" ? ["minX", "maxX"] : ["minY", "maxY"];
      const noTranslation = { x: 0, y: 0 };
      if (position === "start") {
        return {
          ...noTranslation,
          [axis]: selectionBoundingBox[min] - groupBoundingBox[min]
        };
      } else if (position === "end") {
        return {
          ...noTranslation,
          [axis]: selectionBoundingBox[max] - groupBoundingBox[max]
        };
      }
      return {
        ...noTranslation,
        [axis]: (selectionBoundingBox[min] + selectionBoundingBox[max]) / 2 - (groupBoundingBox[min] + groupBoundingBox[max]) / 2
      };
    };
  }
});

// actions/actionAlign.tsx
import { jsx as jsx34 } from "react/jsx-runtime";
var alignActionsPredicate, alignSelectedElements, actionAlignTop, actionAlignBottom, actionAlignLeft, actionAlignRight, actionAlignVerticallyCentered, actionAlignHorizontallyCentered;
var init_actionAlign = __esm({
  "actions/actionAlign.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_align();
    init_icons();
    init_ToolButton();
    init_element();
    init_typeChecks();
    init_frame();
    init_i18n();
    init_keys();
    init_scene();
    init_utils();
    init_register();
    alignActionsPredicate = (elements, appState, _, app) => {
      const selectedElements = app.scene.getSelectedElements(appState);
      return selectedElements.length > 1 && // TODO enable aligning frames when implemented properly
      !selectedElements.some((el) => isFrameLikeElement(el));
    };
    alignSelectedElements = (elements, appState, app, alignment) => {
      const selectedElements = app.scene.getSelectedElements(appState);
      const elementsMap = arrayToMap(elements);
      const updatedElements = alignElements(
        selectedElements,
        elementsMap,
        alignment
      );
      const updatedElementsMap = arrayToMap(updatedElements);
      return updateFrameMembershipOfSelectedElements(
        elements.map((element) => updatedElementsMap.get(element.id) || element),
        appState,
        app
      );
    };
    actionAlignTop = register({
      name: "alignTop",
      trackEvent: { category: "element" },
      predicate: alignActionsPredicate,
      perform: (elements, appState, _, app) => {
        return {
          appState,
          elements: alignSelectedElements(elements, appState, app, {
            position: "start",
            axis: "y"
          }),
          commitToHistory: true
        };
      },
      keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.shiftKey && event.key === KEYS.ARROW_UP,
      PanelComponent: ({ elements, appState, updateData, app }) => /* @__PURE__ */ jsx34(
        ToolButton,
        {
          hidden: !alignActionsPredicate(elements, appState, null, app),
          type: "button",
          icon: AlignTopIcon,
          onClick: () => updateData(null),
          title: `${t("labels.alignTop")} \u2014 ${getShortcutKey(
            "CtrlOrCmd+Shift+Up"
          )}`,
          "aria-label": t("labels.alignTop"),
          visible: isSomeElementSelected(getNonDeletedElements3(elements), appState)
        }
      )
    });
    actionAlignBottom = register({
      name: "alignBottom",
      trackEvent: { category: "element" },
      predicate: alignActionsPredicate,
      perform: (elements, appState, _, app) => {
        return {
          appState,
          elements: alignSelectedElements(elements, appState, app, {
            position: "end",
            axis: "y"
          }),
          commitToHistory: true
        };
      },
      keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.shiftKey && event.key === KEYS.ARROW_DOWN,
      PanelComponent: ({ elements, appState, updateData, app }) => /* @__PURE__ */ jsx34(
        ToolButton,
        {
          hidden: !alignActionsPredicate(elements, appState, null, app),
          type: "button",
          icon: AlignBottomIcon,
          onClick: () => updateData(null),
          title: `${t("labels.alignBottom")} \u2014 ${getShortcutKey(
            "CtrlOrCmd+Shift+Down"
          )}`,
          "aria-label": t("labels.alignBottom"),
          visible: isSomeElementSelected(getNonDeletedElements3(elements), appState)
        }
      )
    });
    actionAlignLeft = register({
      name: "alignLeft",
      trackEvent: { category: "element" },
      predicate: alignActionsPredicate,
      perform: (elements, appState, _, app) => {
        return {
          appState,
          elements: alignSelectedElements(elements, appState, app, {
            position: "start",
            axis: "x"
          }),
          commitToHistory: true
        };
      },
      keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.shiftKey && event.key === KEYS.ARROW_LEFT,
      PanelComponent: ({ elements, appState, updateData, app }) => /* @__PURE__ */ jsx34(
        ToolButton,
        {
          hidden: !alignActionsPredicate(elements, appState, null, app),
          type: "button",
          icon: AlignLeftIcon,
          onClick: () => updateData(null),
          title: `${t("labels.alignLeft")} \u2014 ${getShortcutKey(
            "CtrlOrCmd+Shift+Left"
          )}`,
          "aria-label": t("labels.alignLeft"),
          visible: isSomeElementSelected(getNonDeletedElements3(elements), appState)
        }
      )
    });
    actionAlignRight = register({
      name: "alignRight",
      trackEvent: { category: "element" },
      predicate: alignActionsPredicate,
      perform: (elements, appState, _, app) => {
        return {
          appState,
          elements: alignSelectedElements(elements, appState, app, {
            position: "end",
            axis: "x"
          }),
          commitToHistory: true
        };
      },
      keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.shiftKey && event.key === KEYS.ARROW_RIGHT,
      PanelComponent: ({ elements, appState, updateData, app }) => /* @__PURE__ */ jsx34(
        ToolButton,
        {
          hidden: !alignActionsPredicate(elements, appState, null, app),
          type: "button",
          icon: AlignRightIcon,
          onClick: () => updateData(null),
          title: `${t("labels.alignRight")} \u2014 ${getShortcutKey(
            "CtrlOrCmd+Shift+Right"
          )}`,
          "aria-label": t("labels.alignRight"),
          visible: isSomeElementSelected(getNonDeletedElements3(elements), appState)
        }
      )
    });
    actionAlignVerticallyCentered = register({
      name: "alignVerticallyCentered",
      trackEvent: { category: "element" },
      predicate: alignActionsPredicate,
      perform: (elements, appState, _, app) => {
        return {
          appState,
          elements: alignSelectedElements(elements, appState, app, {
            position: "center",
            axis: "y"
          }),
          commitToHistory: true
        };
      },
      PanelComponent: ({ elements, appState, updateData, app }) => /* @__PURE__ */ jsx34(
        ToolButton,
        {
          hidden: !alignActionsPredicate(elements, appState, null, app),
          type: "button",
          icon: CenterVerticallyIcon,
          onClick: () => updateData(null),
          title: t("labels.centerVertically"),
          "aria-label": t("labels.centerVertically"),
          visible: isSomeElementSelected(getNonDeletedElements3(elements), appState)
        }
      )
    });
    actionAlignHorizontallyCentered = register({
      name: "alignHorizontallyCentered",
      trackEvent: { category: "element" },
      predicate: alignActionsPredicate,
      perform: (elements, appState, _, app) => {
        return {
          appState,
          elements: alignSelectedElements(elements, appState, app, {
            position: "center",
            axis: "x"
          }),
          commitToHistory: true
        };
      },
      PanelComponent: ({ elements, appState, updateData, app }) => /* @__PURE__ */ jsx34(
        ToolButton,
        {
          hidden: !alignActionsPredicate(elements, appState, null, app),
          type: "button",
          icon: CenterHorizontallyIcon,
          onClick: () => updateData(null),
          title: t("labels.centerHorizontally"),
          "aria-label": t("labels.centerHorizontally"),
          visible: isSomeElementSelected(getNonDeletedElements3(elements), appState)
        }
      )
    });
  }
});

// distribute.ts
var distributeElements;
var init_distribute = __esm({
  "distribute.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_mutateElement();
    init_groups();
    init_bounds();
    distributeElements = (selectedElements, elementsMap, distribution) => {
      const [start2, mid, end, extent] = distribution.axis === "x" ? ["minX", "midX", "maxX", "width"] : ["minY", "midY", "maxY", "height"];
      const bounds = getCommonBoundingBox(selectedElements);
      const groups = getMaximumGroups(selectedElements, elementsMap).map((group) => [group, getCommonBoundingBox(group)]).sort((a, b) => a[1][mid] - b[1][mid]);
      let span = 0;
      for (const group of groups) {
        span += group[1][extent];
      }
      const step = (bounds[extent] - span) / (groups.length - 1);
      if (step < 0) {
        const index0 = groups.findIndex((g) => g[1][start2] === bounds[start2]);
        const index1 = groups.findIndex((g) => g[1][end] === bounds[end]);
        const step2 = (groups[index1][1][mid] - groups[index0][1][mid]) / (groups.length - 1);
        let pos2 = groups[index0][1][mid];
        return groups.flatMap(([group, box], index) => {
          const translation2 = {
            x: 0,
            y: 0
          };
          if (index !== index0 && index !== index1) {
            pos2 += step2;
            translation2[distribution.axis] = pos2 - box[mid];
          }
          return group.map(
            (element) => newElementWith(element, {
              x: element.x + translation2.x,
              y: element.y + translation2.y
            })
          );
        });
      }
      let pos = bounds[start2];
      return groups.flatMap(([group, box]) => {
        const translation2 = {
          x: 0,
          y: 0
        };
        translation2[distribution.axis] = pos - box[start2];
        pos += step;
        pos += box[extent];
        return group.map(
          (element) => newElementWith(element, {
            x: element.x + translation2.x,
            y: element.y + translation2.y
          })
        );
      });
    };
  }
});

// actions/actionDistribute.tsx
import { jsx as jsx35 } from "react/jsx-runtime";
var enableActionGroup2, distributeSelectedElements, distributeHorizontally, distributeVertically;
var init_actionDistribute = __esm({
  "actions/actionDistribute.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_icons();
    init_ToolButton();
    init_distribute();
    init_element();
    init_typeChecks();
    init_frame();
    init_i18n();
    init_keys();
    init_scene();
    init_utils();
    init_register();
    enableActionGroup2 = (appState, app) => {
      const selectedElements = app.scene.getSelectedElements(appState);
      return selectedElements.length > 1 && // TODO enable distributing frames when implemented properly
      !selectedElements.some((el) => isFrameLikeElement(el));
    };
    distributeSelectedElements = (elements, appState, app, distribution) => {
      const selectedElements = app.scene.getSelectedElements(appState);
      const updatedElements = distributeElements(
        selectedElements,
        app.scene.getNonDeletedElementsMap(),
        distribution
      );
      const updatedElementsMap = arrayToMap(updatedElements);
      return updateFrameMembershipOfSelectedElements(
        elements.map((element) => updatedElementsMap.get(element.id) || element),
        appState,
        app
      );
    };
    distributeHorizontally = register({
      name: "distributeHorizontally",
      trackEvent: { category: "element" },
      perform: (elements, appState, _, app) => {
        return {
          appState,
          elements: distributeSelectedElements(elements, appState, app, {
            space: "between",
            axis: "x"
          }),
          commitToHistory: true
        };
      },
      keyTest: (event) => !event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.H,
      PanelComponent: ({ elements, appState, updateData, app }) => /* @__PURE__ */ jsx35(
        ToolButton,
        {
          hidden: !enableActionGroup2(appState, app),
          type: "button",
          icon: DistributeHorizontallyIcon,
          onClick: () => updateData(null),
          title: `${t("labels.distributeHorizontally")} \u2014 ${getShortcutKey(
            "Alt+H"
          )}`,
          "aria-label": t("labels.distributeHorizontally"),
          visible: isSomeElementSelected(getNonDeletedElements3(elements), appState)
        }
      )
    });
    distributeVertically = register({
      name: "distributeVertically",
      trackEvent: { category: "element" },
      perform: (elements, appState, _, app) => {
        return {
          appState,
          elements: distributeSelectedElements(elements, appState, app, {
            space: "between",
            axis: "y"
          }),
          commitToHistory: true
        };
      },
      keyTest: (event) => !event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.V,
      PanelComponent: ({ elements, appState, updateData, app }) => /* @__PURE__ */ jsx35(
        ToolButton,
        {
          hidden: !enableActionGroup2(appState, app),
          type: "button",
          icon: DistributeVerticallyIcon,
          onClick: () => updateData(null),
          title: `${t("labels.distributeVertically")} \u2014 ${getShortcutKey("Alt+V")}`,
          "aria-label": t("labels.distributeVertically"),
          visible: isSomeElementSelected(getNonDeletedElements3(elements), appState)
        }
      )
    });
  }
});

// actions/actionFlip.ts
var actionFlipHorizontal, actionFlipVertical, flipSelectedElements, flipElements;
var init_actionFlip = __esm({
  "actions/actionFlip.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_register();
    init_scene();
    init_element();
    init_resizeElements();
    init_utils();
    init_keys();
    init_bounds();
    init_binding();
    init_frame();
    actionFlipHorizontal = register({
      name: "flipHorizontal",
      trackEvent: { category: "element" },
      perform: (elements, appState, _, app) => {
        return {
          elements: updateFrameMembershipOfSelectedElements(
            flipSelectedElements(
              elements,
              app.scene.getNonDeletedElementsMap(),
              appState,
              "horizontal"
            ),
            appState,
            app
          ),
          appState,
          commitToHistory: true
        };
      },
      keyTest: (event) => event.shiftKey && event.code === CODES.H,
      contextItemLabel: "labels.flipHorizontal"
    });
    actionFlipVertical = register({
      name: "flipVertical",
      trackEvent: { category: "element" },
      perform: (elements, appState, _, app) => {
        return {
          elements: updateFrameMembershipOfSelectedElements(
            flipSelectedElements(
              elements,
              app.scene.getNonDeletedElementsMap(),
              appState,
              "vertical"
            ),
            appState,
            app
          ),
          appState,
          commitToHistory: true
        };
      },
      keyTest: (event) => event.shiftKey && event.code === CODES.V && !event[KEYS.CTRL_OR_CMD],
      contextItemLabel: "labels.flipVertical"
    });
    flipSelectedElements = (elements, elementsMap, appState, flipDirection) => {
      const selectedElements = getSelectedElements(
        getNonDeletedElements3(elements),
        appState,
        {
          includeBoundTextElement: true,
          includeElementsInFrames: true
        }
      );
      const updatedElements = flipElements(
        selectedElements,
        elements,
        elementsMap,
        appState,
        flipDirection
      );
      const updatedElementsMap = arrayToMap(updatedElements);
      return elements.map(
        (element) => updatedElementsMap.get(element.id) || element
      );
    };
    flipElements = (selectedElements, elements, elementsMap, appState, flipDirection) => {
      const { minX, minY, maxX, maxY } = getCommonBoundingBox(selectedElements);
      resizeMultipleElements(
        elementsMap,
        selectedElements,
        elementsMap,
        "nw",
        true,
        flipDirection === "horizontal" ? maxX : minX,
        flipDirection === "horizontal" ? minY : maxY
      );
      isBindingEnabled(appState) ? bindOrUnbindSelectedElements(selectedElements, elements, elementsMap) : unbindLinearElements(selectedElements, elementsMap);
      return selectedElements;
    };
  }
});

// actions/actionClipboard.tsx
var actionCopy, actionPaste, actionCut, actionCopyAsSvg, actionCopyAsPng, copyText;
var init_actionClipboard = __esm({
  "actions/actionClipboard.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_keys();
    init_register();
    init_clipboard();
    init_actionDeleteSelected();
    init_data();
    init_element();
    init_i18n();
    init_constants();
    actionCopy = register({
      name: "copy",
      trackEvent: { category: "element" },
      perform: async (elements, appState, event, app) => {
        const elementsToCopy = app.scene.getSelectedElements({
          selectedElementIds: appState.selectedElementIds,
          includeBoundTextElement: true,
          includeElementsInFrames: true
        });
        try {
          await copyToClipboard(elementsToCopy, app.files, event);
        } catch (error) {
          return {
            commitToHistory: false,
            appState: {
              ...appState,
              errorMessage: error.message
            }
          };
        }
        return {
          commitToHistory: false
        };
      },
      contextItemLabel: "labels.copy",
      // don't supply a shortcut since we handle this conditionally via onCopy event
      keyTest: void 0
    });
    actionPaste = register({
      name: "paste",
      trackEvent: { category: "element" },
      perform: async (elements, appState, data, app) => {
        let types;
        try {
          types = await readSystemClipboard();
        } catch (error) {
          if (error.name === "AbortError" || error.name === "NotAllowedError") {
            return false;
          }
          console.error(`actionPaste ${error.name}: ${error.message}`);
          if (isFirefox) {
            return {
              commitToHistory: false,
              appState: {
                ...appState,
                errorMessage: t("hints.firefox_clipboard_write")
              }
            };
          }
          return {
            commitToHistory: false,
            appState: {
              ...appState,
              errorMessage: t("errors.asyncPasteFailedOnRead")
            }
          };
        }
        try {
          app.pasteFromClipboard(createPasteEvent({ types }));
        } catch (error) {
          console.error(error);
          return {
            commitToHistory: false,
            appState: {
              ...appState,
              errorMessage: t("errors.asyncPasteFailedOnParse")
            }
          };
        }
        return {
          commitToHistory: false
        };
      },
      contextItemLabel: "labels.paste",
      // don't supply a shortcut since we handle this conditionally via onCopy event
      keyTest: void 0
    });
    actionCut = register({
      name: "cut",
      trackEvent: { category: "element" },
      perform: (elements, appState, event, app) => {
        actionCopy.perform(elements, appState, event, app);
        return actionDeleteSelected.perform(elements, appState, null, app);
      },
      contextItemLabel: "labels.cut",
      keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.key === KEYS.X
    });
    actionCopyAsSvg = register({
      name: "copyAsSvg",
      trackEvent: { category: "element" },
      perform: async (elements, appState, _data, app) => {
        if (!app.canvas) {
          return {
            commitToHistory: false
          };
        }
        const { exportedElements, exportingFrame } = prepareElementsForExport(
          elements,
          appState,
          true
        );
        try {
          await exportCanvas(
            "clipboard-svg",
            exportedElements,
            appState,
            app.files,
            {
              ...appState,
              exportingFrame,
              name: app.getName()
            }
          );
          return {
            commitToHistory: false
          };
        } catch (error) {
          console.error(error);
          return {
            appState: {
              ...appState,
              errorMessage: error.message
            },
            commitToHistory: false
          };
        }
      },
      predicate: (elements) => {
        return probablySupportsClipboardWriteText && elements.length > 0;
      },
      contextItemLabel: "labels.copyAsSvg"
    });
    actionCopyAsPng = register({
      name: "copyAsPng",
      trackEvent: { category: "element" },
      perform: async (elements, appState, _data, app) => {
        if (!app.canvas) {
          return {
            commitToHistory: false
          };
        }
        const selectedElements = app.scene.getSelectedElements({
          selectedElementIds: appState.selectedElementIds,
          includeBoundTextElement: true,
          includeElementsInFrames: true
        });
        const { exportedElements, exportingFrame } = prepareElementsForExport(
          elements,
          appState,
          true
        );
        try {
          await exportCanvas("clipboard", exportedElements, appState, app.files, {
            ...appState,
            exportingFrame,
            name: app.getName()
          });
          return {
            appState: {
              ...appState,
              toast: {
                message: t("toast.copyToClipboardAsPng", {
                  exportSelection: selectedElements.length ? t("toast.selection") : t("toast.canvas"),
                  exportColorScheme: appState.exportWithDarkMode ? t("buttons.darkMode") : t("buttons.lightMode")
                })
              }
            },
            commitToHistory: false
          };
        } catch (error) {
          console.error(error);
          return {
            appState: {
              ...appState,
              errorMessage: error.message
            },
            commitToHistory: false
          };
        }
      },
      predicate: (elements) => {
        return probablySupportsClipboardBlob && elements.length > 0;
      },
      contextItemLabel: "labels.copyAsPng",
      keyTest: (event) => event.code === CODES.C && event.altKey && event.shiftKey
    });
    copyText = register({
      name: "copyText",
      trackEvent: { category: "element" },
      perform: (elements, appState, _, app) => {
        const selectedElements = app.scene.getSelectedElements({
          selectedElementIds: appState.selectedElementIds,
          includeBoundTextElement: true
        });
        const text = selectedElements.reduce((acc, element) => {
          if (isTextElement(element)) {
            acc.push(element.text);
          }
          return acc;
        }, []).join("\n\n");
        copyTextToSystemClipboard(text);
        return {
          commitToHistory: false
        };
      },
      predicate: (elements, appState, _, app) => {
        return probablySupportsClipboardWriteText && app.scene.getSelectedElements({
          selectedElementIds: appState.selectedElementIds,
          includeBoundTextElement: true
        }).some(isTextElement);
      },
      contextItemLabel: "labels.copyText"
    });
  }
});

// actions/actionToggleGridMode.tsx
var actionToggleGridMode;
var init_actionToggleGridMode = __esm({
  "actions/actionToggleGridMode.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_keys();
    init_register();
    init_constants();
    actionToggleGridMode = register({
      name: "gridMode",
      viewMode: true,
      trackEvent: {
        category: "canvas",
        predicate: (appState) => !appState.gridSize
      },
      perform(elements, appState) {
        return {
          appState: {
            ...appState,
            gridSize: this.checked(appState) ? null : GRID_SIZE,
            objectsSnapModeEnabled: false
          },
          commitToHistory: false
        };
      },
      checked: (appState) => appState.gridSize !== null,
      predicate: (element, appState, props) => {
        return typeof props.gridModeEnabled === "undefined";
      },
      contextItemLabel: "labels.showGrid",
      keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.code === CODES.QUOTE
    });
  }
});

// actions/actionToggleZenMode.tsx
var actionToggleZenMode;
var init_actionToggleZenMode = __esm({
  "actions/actionToggleZenMode.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_keys();
    init_register();
    actionToggleZenMode = register({
      name: "zenMode",
      viewMode: true,
      trackEvent: {
        category: "canvas",
        predicate: (appState) => !appState.zenModeEnabled
      },
      perform(elements, appState) {
        return {
          appState: {
            ...appState,
            zenModeEnabled: !this.checked(appState)
          },
          commitToHistory: false
        };
      },
      checked: (appState) => appState.zenModeEnabled,
      predicate: (elements, appState, appProps) => {
        return typeof appProps.zenModeEnabled === "undefined";
      },
      contextItemLabel: "buttons.zenMode",
      keyTest: (event) => !event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.Z
    });
  }
});

// actions/actionToggleObjectsSnapMode.tsx
var actionToggleObjectsSnapMode;
var init_actionToggleObjectsSnapMode = __esm({
  "actions/actionToggleObjectsSnapMode.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_keys();
    init_register();
    actionToggleObjectsSnapMode = register({
      name: "objectsSnapMode",
      viewMode: true,
      trackEvent: {
        category: "canvas",
        predicate: (appState) => !appState.objectsSnapModeEnabled
      },
      perform(elements, appState) {
        return {
          appState: {
            ...appState,
            objectsSnapModeEnabled: !this.checked(appState),
            gridSize: null
          },
          commitToHistory: false
        };
      },
      checked: (appState) => appState.objectsSnapModeEnabled,
      predicate: (elements, appState, appProps) => {
        return typeof appProps.objectsSnapModeEnabled === "undefined";
      },
      contextItemLabel: "buttons.objectsSnapMode",
      keyTest: (event) => !event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.S
    });
  }
});

// actions/actionToggleStats.tsx
var actionToggleStats;
var init_actionToggleStats = __esm({
  "actions/actionToggleStats.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_register();
    init_keys();
    actionToggleStats = register({
      name: "stats",
      viewMode: true,
      trackEvent: { category: "menu" },
      perform(elements, appState) {
        return {
          appState: {
            ...appState,
            showStats: !this.checked(appState)
          },
          commitToHistory: false
        };
      },
      checked: (appState) => appState.showStats,
      contextItemLabel: "stats.title",
      keyTest: (event) => !event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.SLASH
    });
  }
});

// actions/actionBoundText.tsx
var actionUnbindText, actionBindText, pushTextAboveContainer, pushContainerBelowText, actionWrapTextInContainer;
var init_actionBoundText = __esm({
  "actions/actionBoundText.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_constants();
    init_element();
    init_mutateElement();
    init_textElement();
    init_containerCache();
    init_typeChecks();
    init_utils();
    init_register();
    actionUnbindText = register({
      name: "unbindText",
      contextItemLabel: "labels.unbindText",
      trackEvent: { category: "element" },
      predicate: (elements, appState, _, app) => {
        const selectedElements = app.scene.getSelectedElements(appState);
        return selectedElements.some((element) => hasBoundTextElement(element));
      },
      perform: (elements, appState, _, app) => {
        const selectedElements = app.scene.getSelectedElements(appState);
        const elementsMap = app.scene.getNonDeletedElementsMap();
        selectedElements.forEach((element) => {
          const boundTextElement = getBoundTextElement(element, elementsMap);
          if (boundTextElement) {
            const { width, height, baseline } = measureText(
              boundTextElement.originalText,
              getFontString(boundTextElement),
              boundTextElement.lineHeight
            );
            const originalContainerHeight = getOriginalContainerHeightFromCache(
              element.id
            );
            resetOriginalContainerCache(element.id);
            const { x, y } = computeBoundTextPosition(
              element,
              boundTextElement,
              elementsMap
            );
            mutateElement(boundTextElement, {
              containerId: null,
              width,
              height,
              baseline,
              text: boundTextElement.originalText,
              x,
              y
            });
            mutateElement(element, {
              boundElements: element.boundElements?.filter(
                (ele) => ele.id !== boundTextElement.id
              ),
              height: originalContainerHeight ? originalContainerHeight : element.height
            });
          }
        });
        return {
          elements,
          appState,
          commitToHistory: true
        };
      }
    });
    actionBindText = register({
      name: "bindText",
      contextItemLabel: "labels.bindText",
      trackEvent: { category: "element" },
      predicate: (elements, appState, _, app) => {
        const selectedElements = app.scene.getSelectedElements(appState);
        if (selectedElements.length === 2) {
          const textElement = isTextElement(selectedElements[0]) || isTextElement(selectedElements[1]);
          let bindingContainer;
          if (isTextBindableContainer(selectedElements[0])) {
            bindingContainer = selectedElements[0];
          } else if (isTextBindableContainer(selectedElements[1])) {
            bindingContainer = selectedElements[1];
          }
          if (textElement && bindingContainer && getBoundTextElement(
            bindingContainer,
            app.scene.getNonDeletedElementsMap()
          ) === null) {
            return true;
          }
        }
        return false;
      },
      perform: (elements, appState, _, app) => {
        const selectedElements = app.scene.getSelectedElements(appState);
        let textElement;
        let container;
        if (isTextElement(selectedElements[0]) && isTextBindableContainer(selectedElements[1])) {
          textElement = selectedElements[0];
          container = selectedElements[1];
        } else {
          textElement = selectedElements[1];
          container = selectedElements[0];
        }
        mutateElement(textElement, {
          containerId: container.id,
          verticalAlign: VERTICAL_ALIGN.MIDDLE,
          textAlign: TEXT_ALIGN.CENTER
        });
        mutateElement(container, {
          boundElements: (container.boundElements || []).concat({
            type: "text",
            id: textElement.id
          })
        });
        const originalContainerHeight = container.height;
        redrawTextBoundingBox(
          textElement,
          container,
          app.scene.getNonDeletedElementsMap()
        );
        updateOriginalContainerCache(container.id, originalContainerHeight);
        return {
          elements: pushTextAboveContainer(elements, container, textElement),
          appState: { ...appState, selectedElementIds: { [container.id]: true } },
          commitToHistory: true
        };
      }
    });
    pushTextAboveContainer = (elements, container, textElement) => {
      const updatedElements = elements.slice();
      const textElementIndex = updatedElements.findIndex(
        (ele) => ele.id === textElement.id
      );
      updatedElements.splice(textElementIndex, 1);
      const containerIndex = updatedElements.findIndex(
        (ele) => ele.id === container.id
      );
      updatedElements.splice(containerIndex + 1, 0, textElement);
      return updatedElements;
    };
    pushContainerBelowText = (elements, container, textElement) => {
      const updatedElements = elements.slice();
      const containerIndex = updatedElements.findIndex(
        (ele) => ele.id === container.id
      );
      updatedElements.splice(containerIndex, 1);
      const textElementIndex = updatedElements.findIndex(
        (ele) => ele.id === textElement.id
      );
      updatedElements.splice(textElementIndex, 0, container);
      return updatedElements;
    };
    actionWrapTextInContainer = register({
      name: "wrapTextInContainer",
      contextItemLabel: "labels.createContainerFromText",
      trackEvent: { category: "element" },
      predicate: (elements, appState, _, app) => {
        const selectedElements = app.scene.getSelectedElements(appState);
        const areTextElements = selectedElements.every((el) => isTextElement(el));
        return selectedElements.length > 0 && areTextElements;
      },
      perform: (elements, appState, _, app) => {
        const selectedElements = app.scene.getSelectedElements(appState);
        let updatedElements = elements.slice();
        const containerIds = {};
        for (const textElement of selectedElements) {
          if (isTextElement(textElement)) {
            const container = newElement({
              type: "rectangle",
              backgroundColor: appState.currentItemBackgroundColor,
              boundElements: [
                ...textElement.boundElements || [],
                { id: textElement.id, type: "text" }
              ],
              angle: textElement.angle,
              fillStyle: appState.currentItemFillStyle,
              strokeColor: appState.currentItemStrokeColor,
              roughness: appState.currentItemRoughness,
              strokeWidth: appState.currentItemStrokeWidth,
              strokeStyle: appState.currentItemStrokeStyle,
              roundness: appState.currentItemRoundness === "round" ? {
                type: isUsingAdaptiveRadius("rectangle") ? ROUNDNESS.ADAPTIVE_RADIUS : ROUNDNESS.PROPORTIONAL_RADIUS
              } : null,
              opacity: 100,
              locked: false,
              x: textElement.x - BOUND_TEXT_PADDING,
              y: textElement.y - BOUND_TEXT_PADDING,
              width: computeContainerDimensionForBoundText(
                textElement.width,
                "rectangle"
              ),
              height: computeContainerDimensionForBoundText(
                textElement.height,
                "rectangle"
              ),
              groupIds: textElement.groupIds,
              frameId: textElement.frameId
            });
            if (textElement.boundElements?.length) {
              const linearElementIds = textElement.boundElements.filter((ele) => ele.type === "arrow").map((el) => el.id);
              const linearElements = updatedElements.filter(
                (ele) => linearElementIds.includes(ele.id)
              );
              linearElements.forEach((ele) => {
                let startBinding = ele.startBinding;
                let endBinding = ele.endBinding;
                if (startBinding?.elementId === textElement.id) {
                  startBinding = {
                    ...startBinding,
                    elementId: container.id
                  };
                }
                if (endBinding?.elementId === textElement.id) {
                  endBinding = { ...endBinding, elementId: container.id };
                }
                if (startBinding || endBinding) {
                  mutateElement(ele, { startBinding, endBinding }, false);
                }
              });
            }
            mutateElement(
              textElement,
              {
                containerId: container.id,
                verticalAlign: VERTICAL_ALIGN.MIDDLE,
                boundElements: null,
                textAlign: TEXT_ALIGN.CENTER
              },
              false
            );
            redrawTextBoundingBox(
              textElement,
              container,
              app.scene.getNonDeletedElementsMap()
            );
            updatedElements = pushContainerBelowText(
              [...updatedElements, container],
              container,
              textElement
            );
            containerIds[container.id] = true;
          }
        }
        return {
          elements: updatedElements,
          appState: {
            ...appState,
            selectedElementIds: containerIds
          },
          commitToHistory: true
        };
      }
    });
  }
});

// actions/actionElementLock.ts
var shouldLock, actionToggleElementLock, actionUnlockAllElements;
var init_actionElementLock = __esm({
  "actions/actionElementLock.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_mutateElement();
    init_typeChecks();
    init_keys();
    init_utils();
    init_register();
    shouldLock = (elements) => elements.every((el) => !el.locked);
    actionToggleElementLock = register({
      name: "toggleElementLock",
      trackEvent: { category: "element" },
      predicate: (elements, appState, _, app) => {
        const selectedElements = app.scene.getSelectedElements(appState);
        return !selectedElements.some(
          (element) => element.locked && element.frameId
        );
      },
      perform: (elements, appState, _, app) => {
        const selectedElements = app.scene.getSelectedElements({
          selectedElementIds: appState.selectedElementIds,
          includeBoundTextElement: true,
          includeElementsInFrames: true
        });
        if (!selectedElements.length) {
          return false;
        }
        const nextLockState = shouldLock(selectedElements);
        const selectedElementsMap = arrayToMap(selectedElements);
        return {
          elements: elements.map((element) => {
            if (!selectedElementsMap.has(element.id)) {
              return element;
            }
            return newElementWith(element, { locked: nextLockState });
          }),
          appState: {
            ...appState,
            selectedLinearElement: nextLockState ? null : appState.selectedLinearElement
          },
          commitToHistory: true
        };
      },
      contextItemLabel: (elements, appState, app) => {
        const selected = app.scene.getSelectedElements({
          selectedElementIds: appState.selectedElementIds,
          includeBoundTextElement: false
        });
        if (selected.length === 1 && !isFrameLikeElement(selected[0])) {
          return selected[0].locked ? "labels.elementLock.unlock" : "labels.elementLock.lock";
        }
        return shouldLock(selected) ? "labels.elementLock.lockAll" : "labels.elementLock.unlockAll";
      },
      keyTest: (event, appState, elements, app) => {
        return event.key.toLocaleLowerCase() === KEYS.L && event[KEYS.CTRL_OR_CMD] && event.shiftKey && app.scene.getSelectedElements({
          selectedElementIds: appState.selectedElementIds,
          includeBoundTextElement: false
        }).length > 0;
      }
    });
    actionUnlockAllElements = register({
      name: "unlockAllElements",
      trackEvent: { category: "canvas" },
      viewMode: false,
      predicate: (elements) => {
        return elements.some((element) => element.locked);
      },
      perform: (elements, appState) => {
        const lockedElements = elements.filter((el) => el.locked);
        return {
          elements: elements.map((element) => {
            if (element.locked) {
              return newElementWith(element, { locked: false });
            }
            return element;
          }),
          appState: {
            ...appState,
            selectedElementIds: Object.fromEntries(
              lockedElements.map((el) => [el.id, true])
            )
          },
          commitToHistory: true
        };
      },
      contextItemLabel: "labels.elementLock.unlockAll"
    });
  }
});

// actions/actionLinearEditor.ts
var actionToggleLinearEditor;
var init_actionLinearEditor = __esm({
  "actions/actionLinearEditor.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_linearElementEditor();
    init_typeChecks();
    init_register();
    actionToggleLinearEditor = register({
      name: "toggleLinearEditor",
      trackEvent: {
        category: "element"
      },
      predicate: (elements, appState, _, app) => {
        const selectedElements = app.scene.getSelectedElements(appState);
        if (selectedElements.length === 1 && isLinearElement(selectedElements[0])) {
          return true;
        }
        return false;
      },
      perform(elements, appState, _, app) {
        const selectedElement = app.scene.getSelectedElements({
          selectedElementIds: appState.selectedElementIds,
          includeBoundTextElement: true
        })[0];
        const editingLinearElement = appState.editingLinearElement?.elementId === selectedElement.id ? null : new LinearElementEditor(selectedElement);
        return {
          appState: {
            ...appState,
            editingLinearElement
          },
          commitToHistory: false
        };
      },
      contextItemLabel: (elements, appState, app) => {
        const selectedElement = app.scene.getSelectedElements({
          selectedElementIds: appState.selectedElementIds,
          includeBoundTextElement: true
        })[0];
        return appState.editingLinearElement?.elementId === selectedElement.id ? "labels.lineEditor.exit" : "labels.lineEditor.edit";
      }
    });
  }
});

// actions/index.ts
var init_actions = __esm({
  "actions/index.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_actionDeleteSelected();
    init_actionZindex();
    init_actionSelectAll();
    init_actionDuplicateSelection();
    init_actionProperties();
    init_actionCanvas();
    init_actionFinalize();
    init_actionExport();
    init_actionStyles();
    init_actionMenu();
    init_actionGroup();
    init_actionNavigate();
    init_actionAddToLibrary();
    init_actionAlign();
    init_actionDistribute();
    init_actionFlip();
    init_actionClipboard();
    init_actionToggleGridMode();
    init_actionToggleZenMode();
    init_actionToggleObjectsSnapMode();
    init_actionToggleStats();
    init_actionBoundText();
    init_Hyperlink2();
    init_actionElementLock();
    init_actionLinearEditor();
  }
});

// actions/actionHistory.tsx
import { jsx as jsx36 } from "react/jsx-runtime";
var writeData, createUndoAction, createRedoAction;
var init_actionHistory = __esm({
  "actions/actionHistory.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_icons();
    init_ToolButton();
    init_i18n();
    init_keys();
    init_mutateElement();
    init_binding();
    init_utils();
    init_constants();
    writeData = (prevElements, appState, updater) => {
      const commitToHistory = false;
      if (!appState.multiElement && !appState.resizingElement && !appState.editingElement && !appState.draggingElement) {
        const data = updater();
        if (data === null) {
          return { commitToHistory };
        }
        const prevElementMap = arrayToMap(prevElements);
        const nextElements = data.elements;
        const nextElementMap = arrayToMap(nextElements);
        const deletedElements = prevElements.filter(
          (prevElement) => !nextElementMap.has(prevElement.id)
        );
        const elements = nextElements.map(
          (nextElement) => newElementWith(
            prevElementMap.get(nextElement.id) || nextElement,
            nextElement
          )
        ).concat(
          deletedElements.map(
            (prevElement) => newElementWith(prevElement, { isDeleted: true })
          )
        );
        fixBindingsAfterDeletion(elements, deletedElements);
        return {
          elements,
          appState: { ...appState, ...data.appState },
          commitToHistory,
          syncHistory: true
        };
      }
      return { commitToHistory };
    };
    createUndoAction = (history) => ({
      name: "undo",
      trackEvent: { category: "history" },
      perform: (elements, appState) => writeData(elements, appState, () => history.undoOnce()),
      keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.key.toLowerCase() === KEYS.Z && !event.shiftKey,
      PanelComponent: ({ updateData, data }) => /* @__PURE__ */ jsx36(
        ToolButton,
        {
          type: "button",
          icon: UndoIcon,
          "aria-label": t("buttons.undo"),
          onClick: updateData,
          size: data?.size || "medium"
        }
      ),
      commitToHistory: () => false
    });
    createRedoAction = (history) => ({
      name: "redo",
      trackEvent: { category: "history" },
      perform: (elements, appState) => writeData(elements, appState, () => history.redoOnce()),
      keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.shiftKey && event.key.toLowerCase() === KEYS.Z || isWindows && event.ctrlKey && !event.shiftKey && event.key === KEYS.Y,
      PanelComponent: ({ updateData, data }) => /* @__PURE__ */ jsx36(
        ToolButton,
        {
          type: "button",
          icon: RedoIcon,
          "aria-label": t("buttons.redo"),
          onClick: updateData,
          size: data?.size || "medium"
        }
      ),
      commitToHistory: () => false
    });
  }
});

// actions/manager.tsx
import { jsx as jsx37 } from "react/jsx-runtime";
var trackAction, ActionManager;
var init_manager = __esm({
  "actions/manager.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_analytics();
    init_utils();
    trackAction = (action, source, appState, elements, app, value) => {
      if (action.trackEvent) {
        try {
          if (typeof action.trackEvent === "object") {
            const shouldTrack = action.trackEvent.predicate ? action.trackEvent.predicate(appState, elements, value) : true;
            if (shouldTrack) {
              trackEvent(
                action.trackEvent.category,
                action.trackEvent.action || action.name,
                `${source} (${app.device.editor.isMobile ? "mobile" : "desktop"})`
              );
            }
          }
        } catch (error) {
          console.error("error while logging action:", error);
        }
      }
    };
    ActionManager = class {
      actions = {};
      updater;
      getAppState;
      getElementsIncludingDeleted;
      app;
      constructor(updater, getAppState, getElementsIncludingDeleted, app) {
        this.updater = (actionResult) => {
          if (isPromiseLike(actionResult)) {
            actionResult.then((actionResult2) => {
              return updater(actionResult2);
            });
          } else {
            return updater(actionResult);
          }
        };
        this.getAppState = getAppState;
        this.getElementsIncludingDeleted = getElementsIncludingDeleted;
        this.app = app;
      }
      registerAction(action) {
        this.actions[action.name] = action;
      }
      registerAll(actions2) {
        actions2.forEach((action) => this.registerAction(action));
      }
      handleKeyDown(event) {
        const canvasActions = this.app.props.UIOptions.canvasActions;
        const data = Object.values(this.actions).sort((a, b) => (b.keyPriority || 0) - (a.keyPriority || 0)).filter(
          (action2) => (action2.name in canvasActions ? canvasActions[action2.name] : true) && action2.keyTest && action2.keyTest(
            event,
            this.getAppState(),
            this.getElementsIncludingDeleted(),
            this.app
          )
        );
        if (data.length !== 1) {
          if (data.length > 1) {
            console.warn("Canceling as multiple actions match this shortcut", data);
          }
          return false;
        }
        const action = data[0];
        if (this.getAppState().viewModeEnabled && action.viewMode !== true) {
          return false;
        }
        const elements = this.getElementsIncludingDeleted();
        const appState = this.getAppState();
        const value = null;
        trackAction(action, "keyboard", appState, elements, this.app, null);
        event.preventDefault();
        event.stopPropagation();
        this.updater(data[0].perform(elements, appState, value, this.app));
        return true;
      }
      executeAction(action, source = "api", value = null) {
        const elements = this.getElementsIncludingDeleted();
        const appState = this.getAppState();
        trackAction(action, source, appState, elements, this.app, value);
        this.updater(action.perform(elements, appState, value, this.app));
      }
      /**
       * @param data additional data sent to the PanelComponent
       */
      renderAction = (name, data) => {
        const canvasActions = this.app.props.UIOptions.canvasActions;
        if (this.actions[name] && "PanelComponent" in this.actions[name] && (name in canvasActions ? canvasActions[name] : true)) {
          const action = this.actions[name];
          const PanelComponent = action.PanelComponent;
          PanelComponent.displayName = "PanelComponent";
          const elements = this.getElementsIncludingDeleted();
          const appState = this.getAppState();
          const updateData = (formState) => {
            trackAction(action, "ui", appState, elements, this.app, formState);
            this.updater(
              action.perform(
                this.getElementsIncludingDeleted(),
                this.getAppState(),
                formState,
                this.app
              )
            );
          };
          return /* @__PURE__ */ jsx37(
            PanelComponent,
            {
              elements: this.getElementsIncludingDeleted(),
              appState: this.getAppState(),
              updateData,
              appProps: this.app.props,
              app: this.app,
              data
            }
          );
        }
        return null;
      };
      isActionEnabled = (action) => {
        const elements = this.getElementsIncludingDeleted();
        const appState = this.getAppState();
        return !action.predicate || action.predicate(elements, appState, this.app.props, this.app);
      };
    };
  }
});

// gesture.ts
var getCenter, getDistance, sum;
var init_gesture = __esm({
  "gesture.ts"() {
    "use strict";
    init_define_import_meta_env();
    getCenter = (pointers) => {
      const allCoords = Array.from(pointers.values());
      return {
        x: sum(allCoords, (coords) => coords.x) / allCoords.length,
        y: sum(allCoords, (coords) => coords.y) / allCoords.length
      };
    };
    getDistance = ([a, b]) => Math.hypot(a.x - b.x, a.y - b.y);
    sum = (array, mapper) => array.reduce((acc, item) => acc + mapper(item), 0);
  }
});

// history.ts
var clearAppStatePropertiesForHistory, History, history_default;
var init_history = __esm({
  "history.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_typeChecks();
    init_newElement();
    clearAppStatePropertiesForHistory = (appState) => {
      return {
        selectedElementIds: appState.selectedElementIds,
        selectedGroupIds: appState.selectedGroupIds,
        viewBackgroundColor: appState.viewBackgroundColor,
        editingLinearElement: appState.editingLinearElement,
        editingGroupId: appState.editingGroupId,
        name: appState.name
      };
    };
    History = class {
      elementCache = /* @__PURE__ */ new Map();
      recording = true;
      stateHistory = [];
      redoStack = [];
      lastEntry = null;
      hydrateHistoryEntry({
        appState,
        elements
      }) {
        return {
          appState: JSON.parse(appState),
          elements: elements.map((dehydratedExcalidrawElement) => {
            const element = this.elementCache.get(dehydratedExcalidrawElement.id)?.get(dehydratedExcalidrawElement.versionNonce);
            if (!element) {
              throw new Error(
                `Element not found: ${dehydratedExcalidrawElement.id}:${dehydratedExcalidrawElement.versionNonce}`
              );
            }
            return element;
          })
        };
      }
      dehydrateHistoryEntry({
        appState,
        elements
      }) {
        return {
          appState: JSON.stringify(appState),
          elements: elements.map((element) => {
            if (!this.elementCache.has(element.id)) {
              this.elementCache.set(element.id, /* @__PURE__ */ new Map());
            }
            const versions = this.elementCache.get(element.id);
            if (!versions.has(element.versionNonce)) {
              versions.set(element.versionNonce, deepCopyElement(element));
            }
            return {
              id: element.id,
              versionNonce: element.versionNonce
            };
          })
        };
      }
      getSnapshotForTest() {
        return {
          recording: this.recording,
          stateHistory: this.stateHistory.map(
            (dehydratedHistoryEntry) => this.hydrateHistoryEntry(dehydratedHistoryEntry)
          ),
          redoStack: this.redoStack.map(
            (dehydratedHistoryEntry) => this.hydrateHistoryEntry(dehydratedHistoryEntry)
          )
        };
      }
      clear() {
        this.stateHistory.length = 0;
        this.redoStack.length = 0;
        this.lastEntry = null;
        this.elementCache.clear();
      }
      generateEntry = (appState, elements) => this.dehydrateHistoryEntry({
        appState: clearAppStatePropertiesForHistory(appState),
        elements: elements.reduce((elements2, element) => {
          if (isLinearElement(element) && appState.multiElement && appState.multiElement.id === element.id) {
            if (appState.multiElement && appState.multiElement.id === element.id && element.points.length < 2) {
              return elements2;
            }
            elements2.push({
              ...element,
              // don't store last point if not committed
              points: element.lastCommittedPoint !== element.points[element.points.length - 1] ? element.points.slice(0, -1) : element.points
            });
          } else {
            elements2.push(element);
          }
          return elements2;
        }, [])
      });
      shouldCreateEntry(nextEntry) {
        const { lastEntry } = this;
        if (!lastEntry) {
          return true;
        }
        if (nextEntry.elements.length !== lastEntry.elements.length) {
          return true;
        }
        for (let i = nextEntry.elements.length - 1; i > -1; i--) {
          const prev = nextEntry.elements[i];
          const next = lastEntry.elements[i];
          if (!prev || !next || prev.id !== next.id || prev.versionNonce !== next.versionNonce) {
            return true;
          }
        }
        let key;
        for (key in nextEntry.appState) {
          if (key === "editingLinearElement") {
            if (nextEntry.appState[key]?.elementId === lastEntry.appState[key]?.elementId) {
              continue;
            }
          }
          if (key === "selectedElementIds" || key === "selectedGroupIds") {
            continue;
          }
          if (nextEntry.appState[key] !== lastEntry.appState[key]) {
            return true;
          }
        }
        return false;
      }
      pushEntry(appState, elements) {
        const newEntryDehydrated = this.generateEntry(appState, elements);
        const newEntry = this.hydrateHistoryEntry(newEntryDehydrated);
        if (newEntry) {
          if (!this.shouldCreateEntry(newEntry)) {
            return;
          }
          this.stateHistory.push(newEntryDehydrated);
          this.lastEntry = newEntry;
          this.clearRedoStack();
        }
      }
      clearRedoStack() {
        this.redoStack.splice(0, this.redoStack.length);
      }
      redoOnce() {
        if (this.redoStack.length === 0) {
          return null;
        }
        const entryToRestore = this.redoStack.pop();
        if (entryToRestore !== void 0) {
          this.stateHistory.push(entryToRestore);
          return this.hydrateHistoryEntry(entryToRestore);
        }
        return null;
      }
      undoOnce() {
        if (this.stateHistory.length === 1) {
          return null;
        }
        const currentEntry = this.stateHistory.pop();
        const entryToRestore = this.stateHistory[this.stateHistory.length - 1];
        if (currentEntry !== void 0) {
          this.redoStack.push(currentEntry);
          return this.hydrateHistoryEntry(entryToRestore);
        }
        return null;
      }
      /**
       * Updates history's `lastEntry` to latest app state. This is necessary
       *  when doing undo/redo which itself doesn't commit to history, but updates
       *  app state in a way that would break `shouldCreateEntry` which relies on
       *  `lastEntry` to reflect last comittable history state.
       * We can't update `lastEntry` from within history when calling undo/redo
       *  because the action potentially mutates appState/elements before storing
       *  it.
       */
      setCurrentState(appState, elements) {
        this.lastEntry = this.hydrateHistoryEntry(
          this.generateEntry(appState, elements)
        );
      }
      // Suspicious that this is called so many places. Seems error-prone.
      resumeRecording() {
        this.recording = true;
      }
      record(state, elements) {
        if (this.recording) {
          this.pushEntry(state, elements);
          this.recording = false;
        }
      }
    };
    history_default = History;
  }
});

// shapes.tsx
var SHAPES, findShapeByKey;
var init_shapes = __esm({
  "shapes.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_icons();
    init_keys();
    SHAPES = [
      {
        icon: SelectionIcon,
        value: "selection",
        key: KEYS.V,
        numericKey: KEYS["1"],
        fillable: true
      },
      {
        icon: RectangleIcon,
        value: "rectangle",
        key: KEYS.R,
        numericKey: KEYS["2"],
        fillable: true
      },
      {
        icon: DiamondIcon,
        value: "diamond",
        key: KEYS.D,
        numericKey: KEYS["3"],
        fillable: true
      },
      {
        icon: EllipseIcon,
        value: "ellipse",
        key: KEYS.O,
        numericKey: KEYS["4"],
        fillable: true
      },
      {
        icon: ArrowIcon,
        value: "arrow",
        key: KEYS.A,
        numericKey: KEYS["5"],
        fillable: true
      },
      {
        icon: LineIcon,
        value: "line",
        key: KEYS.L,
        numericKey: KEYS["6"],
        fillable: true
      },
      {
        icon: FreedrawIcon,
        value: "freedraw",
        key: [KEYS.P, KEYS.X],
        numericKey: KEYS["7"],
        fillable: false
      },
      {
        icon: TextIcon,
        value: "text",
        key: KEYS.T,
        numericKey: KEYS["8"],
        fillable: false
      },
      {
        icon: ImageIcon,
        value: "image",
        key: null,
        numericKey: KEYS["9"],
        fillable: false
      },
      {
        icon: EraserIcon,
        value: "eraser",
        key: KEYS.E,
        numericKey: KEYS["0"],
        fillable: false
      }
    ];
    findShapeByKey = (key) => {
      const shape = SHAPES.find((shape2, index) => {
        return shape2.numericKey != null && key === shape2.numericKey.toString() || shape2.key && (typeof shape2.key === "string" ? shape2.key === key : shape2.key.includes(key));
      });
      return shape?.value || null;
    };
  }
});

// components/ContextMenu.scss
var init_ContextMenu = __esm({
  "components/ContextMenu.scss"() {
  }
});

// actions/shortcuts.ts
var shortcutMap, getShortcutFromShortcutName;
var init_shortcuts = __esm({
  "actions/shortcuts.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_constants();
    init_i18n();
    init_utils();
    shortcutMap = {
      toggleTheme: [getShortcutKey("Shift+Alt+D")],
      saveScene: [getShortcutKey("CtrlOrCmd+S")],
      loadScene: [getShortcutKey("CtrlOrCmd+O")],
      clearCanvas: [getShortcutKey("CtrlOrCmd+Delete")],
      imageExport: [getShortcutKey("CtrlOrCmd+Shift+E")],
      cut: [getShortcutKey("CtrlOrCmd+X")],
      copy: [getShortcutKey("CtrlOrCmd+C")],
      paste: [getShortcutKey("CtrlOrCmd+V")],
      copyStyles: [getShortcutKey("CtrlOrCmd+Alt+C")],
      pasteStyles: [getShortcutKey("CtrlOrCmd+Alt+V")],
      selectAll: [getShortcutKey("CtrlOrCmd+A")],
      deleteSelectedElements: [getShortcutKey("Delete")],
      duplicateSelection: [
        getShortcutKey("CtrlOrCmd+D"),
        getShortcutKey(`Alt+${t("helpDialog.drag")}`)
      ],
      sendBackward: [getShortcutKey("CtrlOrCmd+[")],
      bringForward: [getShortcutKey("CtrlOrCmd+]")],
      sendToBack: [
        isDarwin ? getShortcutKey("CtrlOrCmd+Alt+[") : getShortcutKey("CtrlOrCmd+Shift+[")
      ],
      bringToFront: [
        isDarwin ? getShortcutKey("CtrlOrCmd+Alt+]") : getShortcutKey("CtrlOrCmd+Shift+]")
      ],
      copyAsPng: [getShortcutKey("Shift+Alt+C")],
      copyAsSvg: [],
      group: [getShortcutKey("CtrlOrCmd+G")],
      ungroup: [getShortcutKey("CtrlOrCmd+Shift+G")],
      gridMode: [getShortcutKey("CtrlOrCmd+'")],
      zenMode: [getShortcutKey("Alt+Z")],
      objectsSnapMode: [getShortcutKey("Alt+S")],
      stats: [getShortcutKey("Alt+/")],
      addToLibrary: [],
      flipHorizontal: [getShortcutKey("Shift+H")],
      flipVertical: [getShortcutKey("Shift+V")],
      viewMode: [getShortcutKey("Alt+R")],
      hyperlink: [getShortcutKey("CtrlOrCmd+K")],
      toggleElementLock: [getShortcutKey("CtrlOrCmd+Shift+L")]
    };
    getShortcutFromShortcutName = (name) => {
      const shortcuts = shortcutMap[name];
      return shortcuts && shortcuts.length > 0 ? shortcuts[0] : "";
    };
  }
});

// components/ContextMenu.tsx
import clsx15 from "clsx";
import React12 from "react";
import { jsx as jsx38, jsxs as jsxs20 } from "react/jsx-runtime";
var CONTEXT_MENU_SEPARATOR, ContextMenu;
var init_ContextMenu2 = __esm({
  "components/ContextMenu.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_Popover2();
    init_i18n();
    init_ContextMenu();
    init_shortcuts();
    init_App();
    CONTEXT_MENU_SEPARATOR = "separator";
    ContextMenu = React12.memo(
      ({ actionManager, items, top, left, onClose }) => {
        const appState = useExcalidrawAppState();
        const elements = useExcalidrawElements();
        const filteredItems = items.reduce((acc, item) => {
          if (item && (item === CONTEXT_MENU_SEPARATOR || !item.predicate || item.predicate(
            elements,
            appState,
            actionManager.app.props,
            actionManager.app
          ))) {
            acc.push(item);
          }
          return acc;
        }, []);
        return /* @__PURE__ */ jsx38(
          Popover2,
          {
            onCloseRequest: () => {
              onClose();
            },
            top,
            left,
            fitInViewport: true,
            offsetLeft: appState.offsetLeft,
            offsetTop: appState.offsetTop,
            viewportWidth: appState.width,
            viewportHeight: appState.height,
            children: /* @__PURE__ */ jsx38(
              "ul",
              {
                className: "context-menu",
                onContextMenu: (event) => event.preventDefault(),
                children: filteredItems.map((item, idx) => {
                  if (item === CONTEXT_MENU_SEPARATOR) {
                    if (!filteredItems[idx - 1] || filteredItems[idx - 1] === CONTEXT_MENU_SEPARATOR) {
                      return null;
                    }
                    return /* @__PURE__ */ jsx38("hr", { className: "context-menu-item-separator" }, idx);
                  }
                  const actionName = item.name;
                  let label = "";
                  if (item.contextItemLabel) {
                    if (typeof item.contextItemLabel === "function") {
                      label = t(
                        item.contextItemLabel(
                          elements,
                          appState,
                          actionManager.app
                        )
                      );
                    } else {
                      label = t(item.contextItemLabel);
                    }
                  }
                  return /* @__PURE__ */ jsx38(
                    "li",
                    {
                      "data-testid": actionName,
                      onClick: () => {
                        onClose(() => {
                          actionManager.executeAction(item, "contextMenu");
                        });
                      },
                      children: /* @__PURE__ */ jsxs20(
                        "button",
                        {
                          className: clsx15("context-menu-item", {
                            dangerous: actionName === "deleteSelectedElements",
                            checkmark: item.checked?.(appState)
                          }),
                          children: [
                            /* @__PURE__ */ jsx38("div", { className: "context-menu-item__label", children: label }),
                            /* @__PURE__ */ jsx38("kbd", { className: "context-menu-item__shortcut", children: actionName ? getShortcutFromShortcutName(actionName) : "" })
                          ]
                        }
                      )
                    },
                    idx
                  );
                })
              }
            )
          }
        );
      }
    );
  }
});

// components/Stack.scss
var init_Stack = __esm({
  "components/Stack.scss"() {
  }
});

// components/Stack.tsx
import { forwardRef } from "react";
import clsx16 from "clsx";
import { jsx as jsx39 } from "react/jsx-runtime";
var RowStack, ColStack, Stack_default;
var init_Stack2 = __esm({
  "components/Stack.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_Stack();
    RowStack = forwardRef(
      ({ children, gap, align, justifyContent, className, style }, ref) => {
        return /* @__PURE__ */ jsx39(
          "div",
          {
            className: clsx16("Stack Stack_horizontal", className),
            style: {
              "--gap": gap,
              alignItems: align,
              justifyContent,
              ...style
            },
            ref,
            children
          }
        );
      }
    );
    ColStack = forwardRef(
      ({ children, gap, align, justifyContent, className, style }, ref) => {
        return /* @__PURE__ */ jsx39(
          "div",
          {
            className: clsx16("Stack Stack_vertical", className),
            style: {
              "--gap": gap,
              justifyItems: align,
              justifyContent,
              ...style
            },
            ref,
            children
          }
        );
      }
    );
    Stack_default = {
      Row: RowStack,
      Col: ColStack
    };
  }
});

// components/Actions.scss
var init_Actions = __esm({
  "components/Actions.scss"() {
  }
});

// components/dropdownMenu/DropdownMenuTrigger.tsx
import clsx17 from "clsx";
import { jsx as jsx40 } from "react/jsx-runtime";
var MenuTrigger, DropdownMenuTrigger_default;
var init_DropdownMenuTrigger = __esm({
  "components/dropdownMenu/DropdownMenuTrigger.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_App();
    MenuTrigger = ({
      className = "",
      children,
      onToggle,
      title,
      ...rest
    }) => {
      const device = useDevice();
      const classNames = clsx17(
        `dropdown-menu-button ${className}`,
        "zen-mode-transition",
        {
          "dropdown-menu-button--mobile": device.editor.isMobile
        }
      ).trim();
      return /* @__PURE__ */ jsx40(
        "button",
        {
          "data-prevent-outside-click": true,
          className: classNames,
          onClick: onToggle,
          type: "button",
          "data-testid": "dropdown-menu-button",
          title,
          ...rest,
          children
        }
      );
    };
    DropdownMenuTrigger_default = MenuTrigger;
    MenuTrigger.displayName = "DropdownMenuTrigger";
  }
});

// components/dropdownMenu/common.ts
import React14, { useContext } from "react";
var DropdownMenuContentPropsContext, getDropdownMenuItemClassName, useHandleDropdownMenuItemClick;
var init_common = __esm({
  "components/dropdownMenu/common.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_constants();
    init_utils();
    DropdownMenuContentPropsContext = React14.createContext({});
    getDropdownMenuItemClassName = (className = "", selected = false) => {
      return `dropdown-menu-item dropdown-menu-item-base ${className} ${selected ? "dropdown-menu-item--selected" : ""}`.trim();
    };
    useHandleDropdownMenuItemClick = (origOnClick, onSelect) => {
      const DropdownMenuContentProps = useContext(DropdownMenuContentPropsContext);
      return composeEventHandlers(origOnClick, (event) => {
        const itemSelectEvent = new CustomEvent("menu.itemSelect" /* MENU_ITEM_SELECT */, {
          bubbles: true,
          cancelable: true
        });
        onSelect?.(itemSelectEvent);
        if (!itemSelectEvent.defaultPrevented) {
          DropdownMenuContentProps.onSelect?.(itemSelectEvent);
        }
      });
    };
  }
});

// components/dropdownMenu/DropdownMenuItemContent.tsx
import { Fragment as Fragment6, jsx as jsx41, jsxs as jsxs21 } from "react/jsx-runtime";
var MenuItemContent, DropdownMenuItemContent_default;
var init_DropdownMenuItemContent = __esm({
  "components/dropdownMenu/DropdownMenuItemContent.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_App();
    MenuItemContent = ({
      icon,
      shortcut,
      children
    }) => {
      const device = useDevice();
      return /* @__PURE__ */ jsxs21(Fragment6, { children: [
        /* @__PURE__ */ jsx41("div", { className: "dropdown-menu-item__icon", children: icon }),
        /* @__PURE__ */ jsx41("div", { className: "dropdown-menu-item__text", children }),
        shortcut && !device.editor.isMobile && /* @__PURE__ */ jsx41("div", { className: "dropdown-menu-item__shortcut", children: shortcut })
      ] });
    };
    DropdownMenuItemContent_default = MenuItemContent;
  }
});

// components/dropdownMenu/DropdownMenuItem.tsx
import { jsx as jsx42 } from "react/jsx-runtime";
var DropdownMenuItem, DropDownMenuItemBadge, DropdownMenuItem_default;
var init_DropdownMenuItem = __esm({
  "components/dropdownMenu/DropdownMenuItem.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_common();
    init_DropdownMenuItemContent();
    DropdownMenuItem = ({
      icon,
      onSelect,
      children,
      shortcut,
      className,
      selected,
      ...rest
    }) => {
      const handleClick = useHandleDropdownMenuItemClick(rest.onClick, onSelect);
      return /* @__PURE__ */ jsx42(
        "button",
        {
          ...rest,
          onClick: handleClick,
          type: "button",
          className: getDropdownMenuItemClassName(className, selected),
          title: rest.title ?? rest["aria-label"],
          children: /* @__PURE__ */ jsx42(DropdownMenuItemContent_default, { icon, shortcut, children })
        }
      );
    };
    DropdownMenuItem.displayName = "DropdownMenuItem";
    DropDownMenuItemBadge = ({
      children
    }) => {
      return /* @__PURE__ */ jsx42(
        "div",
        {
          style: {
            display: "inline-flex",
            marginLeft: "auto",
            padding: "2px 4px",
            background: "pink",
            borderRadius: 6,
            fontSize: 9,
            color: "black",
            fontFamily: "Cascadia, monospace"
          },
          children
        }
      );
    };
    DropDownMenuItemBadge.displayName = "DropdownMenuItemBadge";
    DropdownMenuItem.Badge = DropDownMenuItemBadge;
    DropdownMenuItem_default = DropdownMenuItem;
  }
});

// components/dropdownMenu/DropdownMenuSeparator.tsx
import { jsx as jsx43 } from "react/jsx-runtime";
var MenuSeparator, DropdownMenuSeparator_default;
var init_DropdownMenuSeparator = __esm({
  "components/dropdownMenu/DropdownMenuSeparator.tsx"() {
    "use strict";
    init_define_import_meta_env();
    MenuSeparator = () => /* @__PURE__ */ jsx43(
      "div",
      {
        style: {
          height: "1px",
          backgroundColor: "var(--default-border-color)",
          margin: ".5rem 0"
        }
      }
    );
    DropdownMenuSeparator_default = MenuSeparator;
    MenuSeparator.displayName = "DropdownMenuSeparator";
  }
});

// components/dropdownMenu/DropdownMenuGroup.tsx
import { jsx as jsx44, jsxs as jsxs22 } from "react/jsx-runtime";
var MenuGroup, DropdownMenuGroup_default;
var init_DropdownMenuGroup = __esm({
  "components/dropdownMenu/DropdownMenuGroup.tsx"() {
    "use strict";
    init_define_import_meta_env();
    MenuGroup = ({
      children,
      className = "",
      style,
      title
    }) => {
      return /* @__PURE__ */ jsxs22("div", { className: `dropdown-menu-group ${className}`, style, children: [
        title && /* @__PURE__ */ jsx44("p", { className: "dropdown-menu-group-title", children: title }),
        children
      ] });
    };
    DropdownMenuGroup_default = MenuGroup;
    MenuGroup.displayName = "DropdownMenuGroup";
  }
});

// components/Island.scss
var init_Island = __esm({
  "components/Island.scss"() {
  }
});

// components/Island.tsx
import React15 from "react";
import clsx18 from "clsx";
import { jsx as jsx45 } from "react/jsx-runtime";
var Island;
var init_Island2 = __esm({
  "components/Island.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_Island();
    Island = React15.forwardRef(
      ({ children, padding, className, style }, ref) => /* @__PURE__ */ jsx45(
        "div",
        {
          className: clsx18("Island", className),
          style: { "--padding": padding, ...style },
          ref,
          children
        }
      )
    );
  }
});

// components/dropdownMenu/DropdownMenuContent.tsx
import clsx19 from "clsx";
import { useRef as useRef12 } from "react";
import { jsx as jsx46 } from "react/jsx-runtime";
var MenuContent, DropdownMenuContent_default;
var init_DropdownMenuContent = __esm({
  "components/dropdownMenu/DropdownMenuContent.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_Island2();
    init_App();
    init_Stack2();
    init_common();
    init_useOutsideClick();
    MenuContent = ({
      children,
      onClickOutside,
      className = "",
      onSelect,
      style
    }) => {
      const device = useDevice();
      const menuRef = useRef12(null);
      useOutsideClick(menuRef, () => {
        onClickOutside?.();
      });
      const classNames = clsx19(`dropdown-menu ${className}`, {
        "dropdown-menu--mobile": device.editor.isMobile
      }).trim();
      return /* @__PURE__ */ jsx46(DropdownMenuContentPropsContext.Provider, { value: { onSelect }, children: /* @__PURE__ */ jsx46(
        "div",
        {
          ref: menuRef,
          className: classNames,
          style,
          "data-testid": "dropdown-menu",
          children: device.editor.isMobile ? /* @__PURE__ */ jsx46(Stack_default.Col, { className: "dropdown-menu-container", children }) : /* @__PURE__ */ jsx46(
            Island,
            {
              className: "dropdown-menu-container",
              padding: 2,
              style: { zIndex: 2 },
              children
            }
          )
        }
      ) });
    };
    MenuContent.displayName = "DropdownMenuContent";
    DropdownMenuContent_default = MenuContent;
  }
});

// components/dropdownMenu/DropdownMenuItemLink.tsx
import { jsx as jsx47 } from "react/jsx-runtime";
var DropdownMenuItemLink, DropdownMenuItemLink_default;
var init_DropdownMenuItemLink = __esm({
  "components/dropdownMenu/DropdownMenuItemLink.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_DropdownMenuItemContent();
    init_common();
    DropdownMenuItemLink = ({
      icon,
      shortcut,
      href,
      children,
      onSelect,
      className = "",
      selected,
      ...rest
    }) => {
      const handleClick = useHandleDropdownMenuItemClick(rest.onClick, onSelect);
      return /* @__PURE__ */ jsx47(
        "a",
        {
          ...rest,
          href,
          target: "_blank",
          rel: "noreferrer",
          className: getDropdownMenuItemClassName(className, selected),
          title: rest.title ?? rest["aria-label"],
          onClick: handleClick,
          children: /* @__PURE__ */ jsx47(DropdownMenuItemContent_default, { icon, shortcut, children })
        }
      );
    };
    DropdownMenuItemLink_default = DropdownMenuItemLink;
    DropdownMenuItemLink.displayName = "DropdownMenuItemLink";
  }
});

// components/dropdownMenu/DropdownMenuItemCustom.tsx
import { jsx as jsx48 } from "react/jsx-runtime";
var DropdownMenuItemCustom, DropdownMenuItemCustom_default;
var init_DropdownMenuItemCustom = __esm({
  "components/dropdownMenu/DropdownMenuItemCustom.tsx"() {
    "use strict";
    init_define_import_meta_env();
    DropdownMenuItemCustom = ({
      children,
      className = "",
      selected,
      ...rest
    }) => {
      return /* @__PURE__ */ jsx48(
        "div",
        {
          ...rest,
          className: `dropdown-menu-item-base dropdown-menu-item-custom ${className} ${selected ? `dropdown-menu-item--selected` : ``}`.trim(),
          children
        }
      );
    };
    DropdownMenuItemCustom_default = DropdownMenuItemCustom;
  }
});

// components/dropdownMenu/dropdownMenuUtils.ts
import React17 from "react";
var getMenuTriggerComponent, getMenuContentComponent;
var init_dropdownMenuUtils = __esm({
  "components/dropdownMenu/dropdownMenuUtils.ts"() {
    "use strict";
    init_define_import_meta_env();
    getMenuTriggerComponent = (children) => {
      const comp = React17.Children.toArray(children).find(
        (child) => React17.isValidElement(child) && typeof child.type !== "string" && //@ts-ignore
        child?.type.displayName && //@ts-ignore
        child.type.displayName === "DropdownMenuTrigger"
      );
      if (!comp) {
        return null;
      }
      return comp;
    };
    getMenuContentComponent = (children) => {
      const comp = React17.Children.toArray(children).find(
        (child) => React17.isValidElement(child) && typeof child.type !== "string" && //@ts-ignore
        child?.type.displayName && //@ts-ignore
        child.type.displayName === "DropdownMenuContent"
      );
      if (!comp) {
        return null;
      }
      return comp;
    };
  }
});

// components/dropdownMenu/DropdownMenu.scss
var init_DropdownMenu = __esm({
  "components/dropdownMenu/DropdownMenu.scss"() {
  }
});

// components/dropdownMenu/DropdownMenu.tsx
import { Fragment as Fragment7, jsxs as jsxs23 } from "react/jsx-runtime";
var DropdownMenu, DropdownMenu_default;
var init_DropdownMenu2 = __esm({
  "components/dropdownMenu/DropdownMenu.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_DropdownMenuTrigger();
    init_DropdownMenuItem();
    init_DropdownMenuSeparator();
    init_DropdownMenuGroup();
    init_DropdownMenuContent();
    init_DropdownMenuItemLink();
    init_DropdownMenuItemCustom();
    init_dropdownMenuUtils();
    init_DropdownMenu();
    DropdownMenu = ({
      children,
      open
    }) => {
      const MenuTriggerComp = getMenuTriggerComponent(children);
      const MenuContentComp = getMenuContentComponent(children);
      return /* @__PURE__ */ jsxs23(Fragment7, { children: [
        MenuTriggerComp,
        open && MenuContentComp
      ] });
    };
    DropdownMenu.Trigger = DropdownMenuTrigger_default;
    DropdownMenu.Content = DropdownMenuContent_default;
    DropdownMenu.Item = DropdownMenuItem_default;
    DropdownMenu.ItemLink = DropdownMenuItemLink_default;
    DropdownMenu.ItemCustom = DropdownMenuItemCustom_default;
    DropdownMenu.Group = DropdownMenuGroup_default;
    DropdownMenu.Separator = DropdownMenuSeparator_default;
    DropdownMenu_default = DropdownMenu;
    DropdownMenu.displayName = "DropdownMenu";
  }
});

// context/tunnels.ts
import React18 from "react";
import tunnel from "tunnel-rat";
var TunnelsContext, useTunnels, useInitializeTunnels;
var init_tunnels = __esm({
  "context/tunnels.ts"() {
    "use strict";
    init_define_import_meta_env();
    TunnelsContext = React18.createContext(null);
    useTunnels = () => React18.useContext(TunnelsContext);
    useInitializeTunnels = () => {
      return React18.useMemo(() => {
        return {
          MainMenuTunnel: tunnel(),
          WelcomeScreenMenuHintTunnel: tunnel(),
          WelcomeScreenToolbarHintTunnel: tunnel(),
          WelcomeScreenHelpHintTunnel: tunnel(),
          WelcomeScreenCenterTunnel: tunnel(),
          FooterCenterTunnel: tunnel(),
          DefaultSidebarTriggerTunnel: tunnel(),
          DefaultSidebarTabTriggersTunnel: tunnel(),
          OverwriteConfirmDialogTunnel: tunnel(),
          TTDDialogTriggerTunnel: tunnel(),
          jotaiScope: Symbol()
        };
      }, []);
    };
  }
});

// components/Actions.tsx
import { useState as useState11 } from "react";
import clsx20 from "clsx";
import { Fragment as Fragment8, jsx as jsx49, jsxs as jsxs24 } from "react/jsx-runtime";
var SelectedShapeActions, ShapesSwitcher, ZoomActions, UndoRedoActions, ExitZenModeAction, FinalizeAction;
var init_Actions2 = __esm({
  "components/Actions.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_i18n();
    init_App();
    init_scene();
    init_shapes();
    init_utils();
    init_Stack2();
    init_ToolButton();
    init_comparisons();
    init_analytics();
    init_typeChecks();
    init_actions();
    init_Tooltip2();
    init_textElement();
    init_Actions();
    init_DropdownMenu2();
    init_icons();
    init_keys();
    init_tunnels();
    SelectedShapeActions = ({
      appState,
      elementsMap,
      renderAction
    }) => {
      const targetElements = getTargetElements(elementsMap, appState);
      let isSingleElementBoundContainer = false;
      if (targetElements.length === 2 && (hasBoundTextElement(targetElements[0]) || hasBoundTextElement(targetElements[1]))) {
        isSingleElementBoundContainer = true;
      }
      const isEditing = Boolean(appState.editingElement);
      const device = useDevice();
      const isRTL2 = document.documentElement.getAttribute("dir") === "rtl";
      const showFillIcons = hasBackground(appState.activeTool.type) && !isTransparent(appState.currentItemBackgroundColor) || targetElements.some(
        (element) => hasBackground(element.type) && !isTransparent(element.backgroundColor)
      );
      const showChangeBackgroundIcons = hasBackground(appState.activeTool.type) || targetElements.some((element) => hasBackground(element.type));
      const showLinkIcon = targetElements.length === 1 || isSingleElementBoundContainer;
      let commonSelectedType = targetElements[0]?.type || null;
      for (const element of targetElements) {
        if (element.type !== commonSelectedType) {
          commonSelectedType = null;
          break;
        }
      }
      return /* @__PURE__ */ jsxs24("div", { className: "panelColumn", children: [
        /* @__PURE__ */ jsx49("div", { children: (hasStrokeColor(appState.activeTool.type) && appState.activeTool.type !== "image" && commonSelectedType !== "image" && commonSelectedType !== "frame" && commonSelectedType !== "magicframe" || targetElements.some((element) => hasStrokeColor(element.type))) && renderAction("changeStrokeColor") }),
        showChangeBackgroundIcons && /* @__PURE__ */ jsx49("div", { children: renderAction("changeBackgroundColor") }),
        showFillIcons && renderAction("changeFillStyle"),
        (hasStrokeWidth(appState.activeTool.type) || targetElements.some((element) => hasStrokeWidth(element.type))) && renderAction("changeStrokeWidth"),
        (appState.activeTool.type === "freedraw" || targetElements.some((element) => element.type === "freedraw")) && renderAction("changeStrokeShape"),
        (hasStrokeStyle(appState.activeTool.type) || targetElements.some((element) => hasStrokeStyle(element.type))) && /* @__PURE__ */ jsxs24(Fragment8, { children: [
          renderAction("changeStrokeStyle"),
          renderAction("changeSloppiness")
        ] }),
        (canChangeRoundness(appState.activeTool.type) || targetElements.some((element) => canChangeRoundness(element.type))) && /* @__PURE__ */ jsx49(Fragment8, { children: renderAction("changeRoundness") }),
        (appState.activeTool.type === "text" || targetElements.some(isTextElement)) && /* @__PURE__ */ jsxs24(Fragment8, { children: [
          renderAction("changeFontSize"),
          renderAction("changeFontFamily"),
          (appState.activeTool.type === "text" || suppportsHorizontalAlign(targetElements, elementsMap)) && renderAction("changeTextAlign")
        ] }),
        shouldAllowVerticalAlign(targetElements, elementsMap) && renderAction("changeVerticalAlign"),
        (canHaveArrowheads(appState.activeTool.type) || targetElements.some((element) => canHaveArrowheads(element.type))) && /* @__PURE__ */ jsx49(Fragment8, { children: renderAction("changeArrowhead") }),
        renderAction("changeOpacity"),
        /* @__PURE__ */ jsxs24("fieldset", { children: [
          /* @__PURE__ */ jsx49("legend", { children: t("labels.layers") }),
          /* @__PURE__ */ jsxs24("div", { className: "buttonList", children: [
            renderAction("sendToBack"),
            renderAction("sendBackward"),
            renderAction("bringToFront"),
            renderAction("bringForward")
          ] })
        ] }),
        targetElements.length > 1 && !isSingleElementBoundContainer && /* @__PURE__ */ jsxs24("fieldset", { children: [
          /* @__PURE__ */ jsx49("legend", { children: t("labels.align") }),
          /* @__PURE__ */ jsxs24("div", { className: "buttonList", children: [
            isRTL2 ? /* @__PURE__ */ jsxs24(Fragment8, { children: [
              renderAction("alignRight"),
              renderAction("alignHorizontallyCentered"),
              renderAction("alignLeft")
            ] }) : /* @__PURE__ */ jsxs24(Fragment8, { children: [
              renderAction("alignLeft"),
              renderAction("alignHorizontallyCentered"),
              renderAction("alignRight")
            ] }),
            targetElements.length > 2 && renderAction("distributeHorizontally"),
            /* @__PURE__ */ jsx49("div", { style: { flexBasis: "100%", height: 0 } }),
            /* @__PURE__ */ jsxs24(
              "div",
              {
                style: {
                  display: "flex",
                  flexWrap: "wrap",
                  gap: ".5rem",
                  marginTop: "-0.5rem"
                },
                children: [
                  renderAction("alignTop"),
                  renderAction("alignVerticallyCentered"),
                  renderAction("alignBottom"),
                  targetElements.length > 2 && renderAction("distributeVertically")
                ]
              }
            )
          ] })
        ] }),
        !isEditing && targetElements.length > 0 && /* @__PURE__ */ jsxs24("fieldset", { children: [
          /* @__PURE__ */ jsx49("legend", { children: t("labels.actions") }),
          /* @__PURE__ */ jsxs24("div", { className: "buttonList", children: [
            !device.editor.isMobile && renderAction("duplicateSelection"),
            !device.editor.isMobile && renderAction("deleteSelectedElements"),
            renderAction("group"),
            renderAction("ungroup"),
            showLinkIcon && renderAction("hyperlink")
          ] })
        ] })
      ] });
    };
    ShapesSwitcher = ({
      activeTool,
      appState,
      app,
      UIOptions
    }) => {
      const [isExtraToolsMenuOpen, setIsExtraToolsMenuOpen] = useState11(false);
      const frameToolSelected = activeTool.type === "frame";
      const laserToolSelected = activeTool.type === "laser";
      const embeddableToolSelected = activeTool.type === "embeddable";
      const { TTDDialogTriggerTunnel } = useTunnels();
      return /* @__PURE__ */ jsxs24(Fragment8, { children: [
        SHAPES.map(({ value, icon, key, numericKey, fillable }, index) => {
          if (UIOptions.tools?.[value] === false) {
            return null;
          }
          const label = t(`toolBar.${value}`);
          const letter = key && capitalizeString(typeof key === "string" ? key : key[0]);
          const shortcut = letter ? `${letter} ${t("helpDialog.or")} ${numericKey}` : `${numericKey}`;
          return /* @__PURE__ */ jsx49(
            ToolButton,
            {
              className: clsx20("Shape", { fillable }),
              type: "radio",
              icon,
              checked: activeTool.type === value,
              name: "editor-current-shape",
              title: `${capitalizeString(label)} \u2014 ${shortcut}`,
              keyBindingLabel: numericKey || letter,
              "aria-label": capitalizeString(label),
              "aria-keyshortcuts": shortcut,
              "data-testid": `toolbar-${value}`,
              onPointerDown: ({ pointerType }) => {
                if (!appState.penDetected && pointerType === "pen") {
                  app.togglePenMode(true);
                }
              },
              onChange: ({ pointerType }) => {
                if (appState.activeTool.type !== value) {
                  trackEvent("toolbar", value, "ui");
                }
                if (value === "image") {
                  app.setActiveTool({
                    type: value,
                    insertOnCanvasDirectly: pointerType !== "mouse"
                  });
                } else {
                  app.setActiveTool({ type: value });
                }
              }
            },
            value
          );
        }),
        /* @__PURE__ */ jsx49("div", { className: "App-toolbar__divider" }),
        /* @__PURE__ */ jsxs24(DropdownMenu_default, { open: isExtraToolsMenuOpen, children: [
          /* @__PURE__ */ jsx49(
            DropdownMenu_default.Trigger,
            {
              className: clsx20("App-toolbar__extra-tools-trigger", {
                "App-toolbar__extra-tools-trigger--selected": frameToolSelected || embeddableToolSelected || // in collab we're already highlighting the laser button
                // outside toolbar, so let's not highlight extra-tools button
                // on top of it
                laserToolSelected && !app.props.isCollaborating
              }),
              onToggle: () => setIsExtraToolsMenuOpen(!isExtraToolsMenuOpen),
              title: t("toolBar.extraTools"),
              children: extraToolsIcon
            }
          ),
          /* @__PURE__ */ jsxs24(
            DropdownMenu_default.Content,
            {
              onClickOutside: () => setIsExtraToolsMenuOpen(false),
              onSelect: () => setIsExtraToolsMenuOpen(false),
              className: "App-toolbar__extra-tools-dropdown",
              children: [
                /* @__PURE__ */ jsx49(
                  DropdownMenu_default.Item,
                  {
                    onSelect: () => app.setActiveTool({ type: "frame" }),
                    icon: frameToolIcon,
                    shortcut: KEYS.F.toLocaleUpperCase(),
                    "data-testid": "toolbar-frame",
                    selected: frameToolSelected,
                    children: t("toolBar.frame")
                  }
                ),
                /* @__PURE__ */ jsx49(
                  DropdownMenu_default.Item,
                  {
                    onSelect: () => app.setActiveTool({ type: "embeddable" }),
                    icon: EmbedIcon,
                    "data-testid": "toolbar-embeddable",
                    selected: embeddableToolSelected,
                    children: t("toolBar.embeddable")
                  }
                ),
                /* @__PURE__ */ jsx49(
                  DropdownMenu_default.Item,
                  {
                    onSelect: () => app.setActiveTool({ type: "laser" }),
                    icon: laserPointerToolIcon,
                    "data-testid": "toolbar-laser",
                    selected: laserToolSelected,
                    shortcut: KEYS.K.toLocaleUpperCase(),
                    children: t("toolBar.laser")
                  }
                ),
                /* @__PURE__ */ jsx49("div", { style: { margin: "6px 0", fontSize: 14, fontWeight: 600 }, children: "Generate" }),
                app.props.aiEnabled !== false && /* @__PURE__ */ jsx49(TTDDialogTriggerTunnel.Out, {}),
                /* @__PURE__ */ jsx49(
                  DropdownMenu_default.Item,
                  {
                    onSelect: () => app.setOpenDialog({ name: "ttd", tab: "mermaid" }),
                    icon: mermaidLogoIcon,
                    "data-testid": "toolbar-embeddable",
                    children: t("toolBar.mermaidToExcalidraw")
                  }
                ),
                app.props.aiEnabled !== false && /* @__PURE__ */ jsxs24(Fragment8, { children: [
                  /* @__PURE__ */ jsxs24(
                    DropdownMenu_default.Item,
                    {
                      onSelect: () => app.onMagicframeToolSelect(),
                      icon: MagicIcon,
                      "data-testid": "toolbar-magicframe",
                      children: [
                        t("toolBar.magicframe"),
                        /* @__PURE__ */ jsx49(DropdownMenu_default.Item.Badge, { children: "AI" })
                      ]
                    }
                  ),
                  /* @__PURE__ */ jsx49(
                    DropdownMenu_default.Item,
                    {
                      onSelect: () => {
                        trackEvent("ai", "open-settings", "d2c");
                        app.setOpenDialog({
                          name: "settings",
                          source: "settings",
                          tab: "diagram-to-code"
                        });
                      },
                      icon: OpenAIIcon,
                      "data-testid": "toolbar-magicSettings",
                      children: t("toolBar.magicSettings")
                    }
                  )
                ] })
              ]
            }
          )
        ] })
      ] });
    };
    ZoomActions = ({
      renderAction,
      zoom
    }) => /* @__PURE__ */ jsx49(Stack_default.Col, { gap: 1, className: "zoom-actions", children: /* @__PURE__ */ jsxs24(Stack_default.Row, { align: "center", children: [
      renderAction("zoomOut"),
      renderAction("resetZoom"),
      renderAction("zoomIn")
    ] }) });
    UndoRedoActions = ({
      renderAction,
      className
    }) => /* @__PURE__ */ jsxs24("div", { className: `undo-redo-buttons ${className}`, children: [
      /* @__PURE__ */ jsx49("div", { className: "undo-button-container", children: /* @__PURE__ */ jsx49(Tooltip, { label: t("buttons.undo"), children: renderAction("undo") }) }),
      /* @__PURE__ */ jsx49("div", { className: "redo-button-container", children: /* @__PURE__ */ jsxs24(Tooltip, { label: t("buttons.redo"), children: [
        " ",
        renderAction("redo")
      ] }) })
    ] });
    ExitZenModeAction = ({
      actionManager,
      showExitZenModeBtn
    }) => /* @__PURE__ */ jsx49(
      "button",
      {
        className: clsx20("disable-zen-mode", {
          "disable-zen-mode--visible": showExitZenModeBtn
        }),
        onClick: () => actionManager.executeAction(actionToggleZenMode),
        children: t("buttons.exitZenMode")
      }
    );
    FinalizeAction = ({
      renderAction,
      className
    }) => /* @__PURE__ */ jsx49("div", { className: `finalize-button ${className}`, children: renderAction("finalize", { size: "small" }) });
  }
});

// hooks/useCallbackRefState.ts
import { useCallback as useCallback3, useState as useState12 } from "react";
var useCallbackRefState;
var init_useCallbackRefState = __esm({
  "hooks/useCallbackRefState.ts"() {
    "use strict";
    init_define_import_meta_env();
    useCallbackRefState = () => {
      const [refValue, setRefValue] = useState12(null);
      const refCallback = useCallback3((value) => setRefValue(value), []);
      return [refValue, refCallback];
    };
  }
});

// components/Dialog.scss
var init_Dialog = __esm({
  "components/Dialog.scss"() {
  }
});

// components/Modal.scss
var init_Modal = __esm({
  "components/Modal.scss"() {
  }
});

// components/Modal.tsx
import { createPortal as createPortal2 } from "react-dom";
import clsx21 from "clsx";
import { jsx as jsx50, jsxs as jsxs25 } from "react/jsx-runtime";
var Modal;
var init_Modal2 = __esm({
  "components/Modal.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_Modal();
    init_keys();
    init_useCreatePortalContainer();
    Modal = (props) => {
      const { closeOnClickOutside = true } = props;
      const modalRoot = useCreatePortalContainer({
        className: "excalidraw-modal-container"
      });
      if (!modalRoot) {
        return null;
      }
      const handleKeydown = (event) => {
        if (event.key === KEYS.ESCAPE) {
          event.nativeEvent.stopImmediatePropagation();
          event.stopPropagation();
          props.onCloseRequest();
        }
      };
      return createPortal2(
        /* @__PURE__ */ jsxs25(
          "div",
          {
            className: clsx21("Modal", props.className),
            role: "dialog",
            "aria-modal": "true",
            onKeyDown: handleKeydown,
            "aria-labelledby": props.labelledBy,
            "data-prevent-outside-click": true,
            children: [
              /* @__PURE__ */ jsx50(
                "div",
                {
                  className: "Modal__background",
                  onClick: closeOnClickOutside ? props.onCloseRequest : void 0
                }
              ),
              /* @__PURE__ */ jsx50(
                "div",
                {
                  className: "Modal__content",
                  style: { "--max-width": `${props.maxWidth}px` },
                  tabIndex: 0,
                  children: props.children
                }
              )
            ]
          }
        ),
        modalRoot
      );
    };
  }
});

// components/LibraryMenuBrowseButton.tsx
import { jsx as jsx51 } from "react/jsx-runtime";
var LibraryMenuBrowseButton, LibraryMenuBrowseButton_default;
var init_LibraryMenuBrowseButton = __esm({
  "components/LibraryMenuBrowseButton.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_constants();
    init_i18n();
    LibraryMenuBrowseButton = ({
      theme,
      id,
      libraryReturnUrl
    }) => {
      const referrer = libraryReturnUrl || window.location.origin + window.location.pathname;
      return /* @__PURE__ */ jsx51(
        "a",
        {
          className: "library-menu-browse-button",
          href: `${define_import_meta_env_default.VITE_APP_LIBRARY_URL}?target=${window.name || "_blank"}&referrer=${referrer}&useHash=true&token=${id}&theme=${theme}&version=${VERSIONS.excalidrawLibrary}`,
          target: "_excalidraw_libraries",
          children: t("labels.libraries")
        }
      );
    };
    LibraryMenuBrowseButton_default = LibraryMenuBrowseButton;
  }
});

// components/LibraryMenuControlButtons.tsx
import clsx22 from "clsx";
import { jsx as jsx52, jsxs as jsxs26 } from "react/jsx-runtime";
var LibraryMenuControlButtons;
var init_LibraryMenuControlButtons = __esm({
  "components/LibraryMenuControlButtons.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_LibraryMenuBrowseButton();
    LibraryMenuControlButtons = ({
      libraryReturnUrl,
      theme,
      id,
      style,
      children,
      className
    }) => {
      return /* @__PURE__ */ jsxs26(
        "div",
        {
          className: clsx22("library-menu-control-buttons", className),
          style,
          children: [
            /* @__PURE__ */ jsx52(
              LibraryMenuBrowseButton_default,
              {
                id,
                libraryReturnUrl,
                theme
              }
            ),
            children
          ]
        }
      );
    };
  }
});

// components/Trans.tsx
import React19 from "react";
var SPLIT_REGEX, KEY_REGEXP, TAG_START_REGEXP, TAG_END_REGEXP, getTransChildren, Trans, Trans_default;
var init_Trans = __esm({
  "components/Trans.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_i18n();
    SPLIT_REGEX = /({{[\w-]+}})|(<[\w-]+>)|(<\/[\w-]+>)/g;
    KEY_REGEXP = /{{([\w-]+)}}/;
    TAG_START_REGEXP = /<([\w-]+)>/;
    TAG_END_REGEXP = /<\/([\w-]+)>/;
    getTransChildren = (format, props) => {
      const stack = [
        {
          name: "",
          children: []
        }
      ];
      format.split(SPLIT_REGEX).filter(Boolean).forEach((match) => {
        const tagStartMatch = match.match(TAG_START_REGEXP);
        const tagEndMatch = match.match(TAG_END_REGEXP);
        const keyMatch = match.match(KEY_REGEXP);
        if (tagStartMatch !== null) {
          const name = tagStartMatch[1];
          if (props.hasOwnProperty(name)) {
            stack.push({
              name,
              children: []
            });
          } else {
            console.warn(
              `Trans: missed to pass in prop ${name} for interpolating ${format}`
            );
          }
        } else if (tagEndMatch !== null) {
          const name = tagEndMatch[1];
          if (name === stack[stack.length - 1].name) {
            const item = stack.pop();
            const itemChildren = React19.createElement(
              React19.Fragment,
              {},
              ...item.children
            );
            const fn = props[item.name];
            if (typeof fn === "function") {
              stack[stack.length - 1].children.push(fn(itemChildren));
            }
          } else {
            console.warn(
              `Trans: unexpected end tag ${match} for interpolating ${format}`
            );
          }
        } else if (keyMatch !== null) {
          const name = keyMatch[1];
          if (props.hasOwnProperty(name)) {
            stack[stack.length - 1].children.push(props[name]);
          } else {
            console.warn(
              `Trans: key ${name} not in props for interpolating ${format}`
            );
          }
        } else {
          stack[stack.length - 1].children.push(match);
        }
      });
      if (stack.length !== 1) {
        console.warn(`Trans: stack not empty for interpolating ${format}`);
      }
      return stack[0].children;
    };
    Trans = ({
      i18nKey,
      children,
      ...props
    }) => {
      const { t: t2 } = useI18n();
      return React19.createElement(
        React19.Fragment,
        {},
        ...getTransChildren(t2(i18nKey), props)
      );
    };
    Trans_default = Trans;
  }
});

// components/ConfirmDialog.scss
var init_ConfirmDialog = __esm({
  "components/ConfirmDialog.scss"() {
  }
});

// components/DialogActionButton.scss
var init_DialogActionButton = __esm({
  "components/DialogActionButton.scss"() {
  }
});

// components/DialogActionButton.tsx
import clsx23 from "clsx";
import { jsx as jsx53, jsxs as jsxs27 } from "react/jsx-runtime";
var DialogActionButton, DialogActionButton_default;
var init_DialogActionButton2 = __esm({
  "components/DialogActionButton.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_DialogActionButton();
    init_Spinner2();
    DialogActionButton = ({
      label,
      onClick,
      className,
      children,
      actionType,
      type = "button",
      isLoading,
      ...rest
    }) => {
      const cs = actionType ? `Dialog__action-button--${actionType}` : "";
      return /* @__PURE__ */ jsxs27(
        "button",
        {
          className: clsx23("Dialog__action-button", cs, className),
          type,
          "aria-label": label,
          onClick,
          ...rest,
          children: [
            children && /* @__PURE__ */ jsx53("div", { style: isLoading ? { visibility: "hidden" } : {}, children }),
            /* @__PURE__ */ jsx53("div", { style: isLoading ? { visibility: "hidden" } : {}, children: label }),
            isLoading && /* @__PURE__ */ jsx53("div", { style: { position: "absolute", inset: 0 }, children: /* @__PURE__ */ jsx53(Spinner_default, {}) })
          ]
        }
      );
    };
    DialogActionButton_default = DialogActionButton;
  }
});

// components/ConfirmDialog.tsx
import { useSetAtom } from "jotai";
import { jsx as jsx54, jsxs as jsxs28 } from "react/jsx-runtime";
var ConfirmDialog, ConfirmDialog_default;
var init_ConfirmDialog2 = __esm({
  "components/ConfirmDialog.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_i18n();
    init_Dialog2();
    init_ConfirmDialog();
    init_DialogActionButton2();
    init_LibraryMenu2();
    init_App();
    init_jotai();
    ConfirmDialog = (props) => {
      const {
        onConfirm,
        onCancel,
        children,
        confirmText = t("buttons.confirm"),
        cancelText = t("buttons.cancel"),
        className = "",
        ...rest
      } = props;
      const setAppState = useExcalidrawSetAppState();
      const setIsLibraryMenuOpen = useSetAtom(isLibraryMenuOpenAtom, jotaiScope);
      const { container } = useExcalidrawContainer();
      return /* @__PURE__ */ jsxs28(
        Dialog,
        {
          onCloseRequest: onCancel,
          size: "small",
          ...rest,
          className: `confirm-dialog ${className}`,
          children: [
            children,
            /* @__PURE__ */ jsxs28("div", { className: "confirm-dialog-buttons", children: [
              /* @__PURE__ */ jsx54(
                DialogActionButton_default,
                {
                  label: cancelText,
                  onClick: () => {
                    setAppState({ openMenu: null });
                    setIsLibraryMenuOpen(false);
                    onCancel();
                    container?.focus();
                  }
                }
              ),
              /* @__PURE__ */ jsx54(
                DialogActionButton_default,
                {
                  label: confirmText,
                  onClick: () => {
                    setAppState({ openMenu: null });
                    setIsLibraryMenuOpen(false);
                    onConfirm();
                    container?.focus();
                  },
                  actionType: "danger"
                }
              )
            ] })
          ]
        }
      );
    };
    ConfirmDialog_default = ConfirmDialog;
  }
});

// data/EditorLocalStorage.ts
var EditorLocalStorage;
var init_EditorLocalStorage = __esm({
  "data/EditorLocalStorage.ts"() {
    "use strict";
    init_define_import_meta_env();
    EditorLocalStorage = class {
      static has(key) {
        try {
          return !!window.localStorage.getItem(key);
        } catch (error) {
          console.warn(`localStorage.getItem error: ${error.message}`);
          return false;
        }
      }
      static get(key) {
        try {
          const value = window.localStorage.getItem(key);
          if (value) {
            return JSON.parse(value);
          }
          return null;
        } catch (error) {
          console.warn(`localStorage.getItem error: ${error.message}`);
          return null;
        }
      }
      static set = (key, value) => {
        try {
          window.localStorage.setItem(key, JSON.stringify(value));
          return true;
        } catch (error) {
          console.warn(`localStorage.setItem error: ${error.message}`);
          return false;
        }
      };
      static delete = (name) => {
        try {
          window.localStorage.removeItem(name);
        } catch (error) {
          console.warn(`localStorage.removeItem error: ${error.message}`);
        }
      };
    };
  }
});

// components/PublishLibrary.scss
var init_PublishLibrary = __esm({
  "components/PublishLibrary.scss"() {
  }
});

// components/PublishLibrary.tsx
import { useCallback as useCallback4, useEffect as useEffect16, useRef as useRef13, useState as useState13 } from "react";
import OpenColor2 from "open-color";
import { jsx as jsx55, jsxs as jsxs29 } from "react/jsx-runtime";
var generatePreviewImage, SingleLibraryItem, PublishLibrary, PublishLibrary_default;
var init_PublishLibrary2 = __esm({
  "components/PublishLibrary.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_Dialog2();
    init_i18n();
    init_Trans();
    init_export2();
    init_constants();
    init_blob();
    init_utils();
    init_DialogActionButton2();
    init_icons();
    init_ToolButton();
    init_EditorLocalStorage();
    init_PublishLibrary();
    generatePreviewImage = async (libraryItems) => {
      const MAX_ITEMS_PER_ROW = 6;
      const BOX_SIZE = 128;
      const BOX_PADDING = Math.round(BOX_SIZE / 16);
      const BORDER_WIDTH = Math.max(Math.round(BOX_SIZE / 64), 2);
      const rows = chunk(libraryItems, MAX_ITEMS_PER_ROW);
      const canvas2 = document.createElement("canvas");
      canvas2.width = rows[0].length * BOX_SIZE + (rows[0].length + 1) * (BOX_PADDING * 2) - BOX_PADDING * 2;
      canvas2.height = rows.length * BOX_SIZE + (rows.length + 1) * (BOX_PADDING * 2) - BOX_PADDING * 2;
      const ctx = canvas2.getContext("2d");
      ctx.fillStyle = OpenColor2.white;
      ctx.fillRect(0, 0, canvas2.width, canvas2.height);
      for (const [index, item] of libraryItems.entries()) {
        const itemCanvas = await exportToCanvas2({
          elements: item.elements,
          files: null,
          maxWidthOrHeight: BOX_SIZE
        });
        const { width, height } = itemCanvas;
        const rowOffset = Math.floor(index / MAX_ITEMS_PER_ROW) * (BOX_SIZE + BOX_PADDING * 2);
        const colOffset = index % MAX_ITEMS_PER_ROW * (BOX_SIZE + BOX_PADDING * 2);
        ctx.drawImage(
          itemCanvas,
          colOffset + (BOX_SIZE - width) / 2 + BOX_PADDING,
          rowOffset + (BOX_SIZE - height) / 2 + BOX_PADDING
        );
        ctx.lineWidth = BORDER_WIDTH;
        ctx.strokeStyle = OpenColor2.gray[4];
        ctx.strokeRect(
          colOffset + BOX_PADDING / 2,
          rowOffset + BOX_PADDING / 2,
          BOX_SIZE + BOX_PADDING,
          BOX_SIZE + BOX_PADDING
        );
      }
      return await resizeImageFile(
        new File([await canvasToBlob(canvas2)], "preview", { type: MIME_TYPES.png }),
        {
          outputType: MIME_TYPES.jpg,
          maxWidthOrHeight: 5e3
        }
      );
    };
    SingleLibraryItem = ({
      libItem,
      appState,
      index,
      onChange,
      onRemove
    }) => {
      const svgRef = useRef13(null);
      const inputRef = useRef13(null);
      useEffect16(() => {
        const node = svgRef.current;
        if (!node) {
          return;
        }
        (async () => {
          const svg = await exportToSvg2({
            elements: libItem.elements,
            appState: {
              ...appState,
              viewBackgroundColor: OpenColor2.white,
              exportBackground: true
            },
            files: null
          });
          node.innerHTML = svg.outerHTML;
        })();
      }, [libItem.elements, appState]);
      return /* @__PURE__ */ jsxs29("div", { className: "single-library-item", children: [
        libItem.status === "published" && /* @__PURE__ */ jsx55("span", { className: "single-library-item-status", children: t("labels.statusPublished") }),
        /* @__PURE__ */ jsx55("div", { ref: svgRef, className: "single-library-item__svg" }),
        /* @__PURE__ */ jsx55(
          ToolButton,
          {
            "aria-label": t("buttons.remove"),
            type: "button",
            icon: CloseIcon,
            className: "single-library-item--remove",
            onClick: onRemove.bind(null, libItem.id),
            title: t("buttons.remove")
          }
        ),
        /* @__PURE__ */ jsxs29(
          "div",
          {
            style: {
              display: "flex",
              margin: "0.8rem 0",
              width: "100%",
              fontSize: "14px",
              fontWeight: 500,
              flexDirection: "column"
            },
            children: [
              /* @__PURE__ */ jsxs29(
                "label",
                {
                  style: {
                    display: "flex",
                    justifyContent: "space-between",
                    flexDirection: "column"
                  },
                  children: [
                    /* @__PURE__ */ jsxs29("div", { style: { padding: "0.5em 0" }, children: [
                      /* @__PURE__ */ jsx55("span", { style: { fontWeight: 500, color: OpenColor2.gray[6] }, children: t("publishDialog.itemName") }),
                      /* @__PURE__ */ jsx55("span", { "aria-hidden": "true", className: "required", children: "*" })
                    ] }),
                    /* @__PURE__ */ jsx55(
                      "input",
                      {
                        type: "text",
                        ref: inputRef,
                        style: { width: "80%", padding: "0.2rem" },
                        defaultValue: libItem.name,
                        placeholder: "Item name",
                        onChange: (event) => {
                          onChange(event.target.value, index);
                        }
                      }
                    )
                  ]
                }
              ),
              /* @__PURE__ */ jsx55("span", { className: "error", children: libItem.error })
            ]
          }
        )
      ] });
    };
    PublishLibrary = ({
      onClose,
      libraryItems,
      appState,
      onSuccess,
      onError,
      updateItemsInStorage,
      onRemove
    }) => {
      const [libraryData, setLibraryData] = useState13({
        authorName: "",
        githubHandle: "",
        name: "",
        description: "",
        twitterHandle: "",
        website: ""
      });
      const [isSubmitting, setIsSubmitting] = useState13(false);
      useEffect16(() => {
        const data = EditorLocalStorage.get(
          EDITOR_LS_KEYS.PUBLISH_LIBRARY
        );
        if (data) {
          setLibraryData(data);
        }
      }, []);
      const [clonedLibItems, setClonedLibItems] = useState13(
        libraryItems.slice()
      );
      useEffect16(() => {
        setClonedLibItems(libraryItems.slice());
      }, [libraryItems]);
      const onInputChange = (event) => {
        setLibraryData({
          ...libraryData,
          [event.target.name]: event.target.value
        });
      };
      const onSubmit = async (event) => {
        event.preventDefault();
        setIsSubmitting(true);
        const erroredLibItems = [];
        let isError = false;
        clonedLibItems.forEach((libItem) => {
          let error = "";
          if (!libItem.name) {
            error = t("publishDialog.errors.required");
            isError = true;
          }
          erroredLibItems.push({ ...libItem, error });
        });
        if (isError) {
          setClonedLibItems(erroredLibItems);
          setIsSubmitting(false);
          return;
        }
        const previewImage = await generatePreviewImage(clonedLibItems);
        const libContent = {
          type: EXPORT_DATA_TYPES.excalidrawLibrary,
          version: VERSIONS.excalidrawLibrary,
          source: EXPORT_SOURCE,
          libraryItems: clonedLibItems
        };
        const content = JSON.stringify(libContent, null, 2);
        const lib = new Blob([content], { type: "application/json" });
        const formData = new FormData();
        formData.append("excalidrawLib", lib);
        formData.append("previewImage", previewImage);
        formData.append("previewImageType", previewImage.type);
        formData.append("title", libraryData.name);
        formData.append("authorName", libraryData.authorName);
        formData.append("githubHandle", libraryData.githubHandle);
        formData.append("name", libraryData.name);
        formData.append("description", libraryData.description);
        formData.append("twitterHandle", libraryData.twitterHandle);
        formData.append("website", libraryData.website);
        fetch(`${define_import_meta_env_default.VITE_APP_LIBRARY_BACKEND}/submit`, {
          method: "post",
          body: formData
        }).then(
          (response) => {
            if (response.ok) {
              return response.json().then(({ url }) => {
                EditorLocalStorage.delete(EDITOR_LS_KEYS.PUBLISH_LIBRARY);
                onSuccess({
                  url,
                  authorName: libraryData.authorName,
                  items: clonedLibItems
                });
              });
            }
            return response.json().catch(() => {
              throw new Error(response.statusText || "something went wrong");
            }).then((error) => {
              throw new Error(
                error.message || response.statusText || "something went wrong"
              );
            });
          },
          (err) => {
            console.error(err);
            onError(err);
            setIsSubmitting(false);
          }
        ).catch((err) => {
          console.error(err);
          onError(err);
          setIsSubmitting(false);
        });
      };
      const renderLibraryItems = () => {
        const items = [];
        clonedLibItems.forEach((libItem, index) => {
          items.push(
            /* @__PURE__ */ jsx55("div", { className: "single-library-item-wrapper", children: /* @__PURE__ */ jsx55(
              SingleLibraryItem,
              {
                libItem,
                appState,
                index,
                onChange: (val, index2) => {
                  const items2 = clonedLibItems.slice();
                  items2[index2].name = val;
                  setClonedLibItems(items2);
                },
                onRemove
              }
            ) }, index)
          );
        });
        return /* @__PURE__ */ jsx55("div", { className: "selected-library-items", children: items });
      };
      const onDialogClose = useCallback4(() => {
        updateItemsInStorage(clonedLibItems);
        EditorLocalStorage.set(EDITOR_LS_KEYS.PUBLISH_LIBRARY, libraryData);
        onClose();
      }, [clonedLibItems, onClose, updateItemsInStorage, libraryData]);
      const shouldRenderForm = !!libraryItems.length;
      const containsPublishedItems = libraryItems.some(
        (item) => item.status === "published"
      );
      return /* @__PURE__ */ jsx55(
        Dialog,
        {
          onCloseRequest: onDialogClose,
          title: t("publishDialog.title"),
          className: "publish-library",
          children: shouldRenderForm ? /* @__PURE__ */ jsxs29("form", { onSubmit, children: [
            /* @__PURE__ */ jsx55("div", { className: "publish-library-note", children: /* @__PURE__ */ jsx55(
              Trans_default,
              {
                i18nKey: "publishDialog.noteDescription",
                link: (el) => /* @__PURE__ */ jsx55(
                  "a",
                  {
                    href: "https://libraries.excalidraw.com",
                    target: "_blank",
                    rel: "noopener noreferrer",
                    children: el
                  }
                )
              }
            ) }),
            /* @__PURE__ */ jsx55("span", { className: "publish-library-note", children: /* @__PURE__ */ jsx55(
              Trans_default,
              {
                i18nKey: "publishDialog.noteGuidelines",
                link: (el) => /* @__PURE__ */ jsx55(
                  "a",
                  {
                    href: "https://github.com/excalidraw/excalidraw-libraries#guidelines",
                    target: "_blank",
                    rel: "noopener noreferrer",
                    children: el
                  }
                )
              }
            ) }),
            /* @__PURE__ */ jsx55("div", { className: "publish-library-note", children: t("publishDialog.noteItems") }),
            containsPublishedItems && /* @__PURE__ */ jsx55("span", { className: "publish-library-note publish-library-warning", children: t("publishDialog.republishWarning") }),
            renderLibraryItems(),
            /* @__PURE__ */ jsxs29("div", { className: "publish-library__fields", children: [
              /* @__PURE__ */ jsxs29("label", { children: [
                /* @__PURE__ */ jsxs29("div", { children: [
                  /* @__PURE__ */ jsx55("span", { children: t("publishDialog.libraryName") }),
                  /* @__PURE__ */ jsx55("span", { "aria-hidden": "true", className: "required", children: "*" })
                ] }),
                /* @__PURE__ */ jsx55(
                  "input",
                  {
                    type: "text",
                    name: "name",
                    required: true,
                    value: libraryData.name,
                    onChange: onInputChange,
                    placeholder: t("publishDialog.placeholder.libraryName")
                  }
                )
              ] }),
              /* @__PURE__ */ jsxs29("label", { style: { alignItems: "flex-start" }, children: [
                /* @__PURE__ */ jsxs29("div", { children: [
                  /* @__PURE__ */ jsx55("span", { children: t("publishDialog.libraryDesc") }),
                  /* @__PURE__ */ jsx55("span", { "aria-hidden": "true", className: "required", children: "*" })
                ] }),
                /* @__PURE__ */ jsx55(
                  "textarea",
                  {
                    name: "description",
                    rows: 4,
                    required: true,
                    value: libraryData.description,
                    onChange: onInputChange,
                    placeholder: t("publishDialog.placeholder.libraryDesc")
                  }
                )
              ] }),
              /* @__PURE__ */ jsxs29("label", { children: [
                /* @__PURE__ */ jsxs29("div", { children: [
                  /* @__PURE__ */ jsx55("span", { children: t("publishDialog.authorName") }),
                  /* @__PURE__ */ jsx55("span", { "aria-hidden": "true", className: "required", children: "*" })
                ] }),
                /* @__PURE__ */ jsx55(
                  "input",
                  {
                    type: "text",
                    name: "authorName",
                    required: true,
                    value: libraryData.authorName,
                    onChange: onInputChange,
                    placeholder: t("publishDialog.placeholder.authorName")
                  }
                )
              ] }),
              /* @__PURE__ */ jsxs29("label", { children: [
                /* @__PURE__ */ jsx55("span", { children: t("publishDialog.githubUsername") }),
                /* @__PURE__ */ jsx55(
                  "input",
                  {
                    type: "text",
                    name: "githubHandle",
                    value: libraryData.githubHandle,
                    onChange: onInputChange,
                    placeholder: t("publishDialog.placeholder.githubHandle")
                  }
                )
              ] }),
              /* @__PURE__ */ jsxs29("label", { children: [
                /* @__PURE__ */ jsx55("span", { children: t("publishDialog.twitterUsername") }),
                /* @__PURE__ */ jsx55(
                  "input",
                  {
                    type: "text",
                    name: "twitterHandle",
                    value: libraryData.twitterHandle,
                    onChange: onInputChange,
                    placeholder: t("publishDialog.placeholder.twitterHandle")
                  }
                )
              ] }),
              /* @__PURE__ */ jsxs29("label", { children: [
                /* @__PURE__ */ jsx55("span", { children: t("publishDialog.website") }),
                /* @__PURE__ */ jsx55(
                  "input",
                  {
                    type: "text",
                    name: "website",
                    pattern: "https?://.+",
                    title: t("publishDialog.errors.website"),
                    value: libraryData.website,
                    onChange: onInputChange,
                    placeholder: t("publishDialog.placeholder.website")
                  }
                )
              ] }),
              /* @__PURE__ */ jsx55("span", { className: "publish-library-note", children: /* @__PURE__ */ jsx55(
                Trans_default,
                {
                  i18nKey: "publishDialog.noteLicense",
                  link: (el) => /* @__PURE__ */ jsx55(
                    "a",
                    {
                      href: "https://github.com/excalidraw/excalidraw-libraries/blob/main/LICENSE",
                      target: "_blank",
                      rel: "noopener noreferrer",
                      children: el
                    }
                  )
                }
              ) })
            ] }),
            /* @__PURE__ */ jsxs29("div", { className: "publish-library__buttons", children: [
              /* @__PURE__ */ jsx55(
                DialogActionButton_default,
                {
                  label: t("buttons.cancel"),
                  onClick: onDialogClose,
                  "data-testid": "cancel-clear-canvas-button"
                }
              ),
              /* @__PURE__ */ jsx55(
                DialogActionButton_default,
                {
                  type: "submit",
                  label: t("buttons.submit"),
                  actionType: "primary",
                  isLoading: isSubmitting
                }
              )
            ] })
          ] }) : /* @__PURE__ */ jsx55("p", { style: { padding: "1em", textAlign: "center", fontWeight: 500 }, children: t("publishDialog.atleastOneLibItem") })
        }
      );
    };
    PublishLibrary_default = PublishLibrary;
  }
});

// components/LibraryMenuHeaderContent.tsx
import { useCallback as useCallback5, useState as useState14 } from "react";
import { useAtom as useAtom9 } from "jotai";
import clsx24 from "clsx";
import { jsx as jsx56, jsxs as jsxs30 } from "react/jsx-runtime";
var getSelectedItems, LibraryDropdownMenuButton, LibraryDropdownMenu;
var init_LibraryMenuHeaderContent = __esm({
  "components/LibraryMenuHeaderContent.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_i18n();
    init_Trans();
    init_jotai();
    init_App();
    init_json();
    init_library();
    init_icons();
    init_ToolButton();
    init_filesystem();
    init_utils();
    init_ConfirmDialog2();
    init_PublishLibrary2();
    init_Dialog2();
    init_DropdownMenu2();
    init_LibraryMenu2();
    init_ui_appState();
    init_useLibraryItemSvg();
    getSelectedItems = (libraryItems, selectedItems) => libraryItems.filter((item) => selectedItems.includes(item.id));
    LibraryDropdownMenuButton = ({
      setAppState,
      selectedItems,
      library,
      onRemoveFromLibrary,
      resetLibrary,
      onSelectItems,
      appState,
      className
    }) => {
      const [libraryItemsData] = useAtom9(libraryItemsAtom, jotaiScope);
      const [isLibraryMenuOpen, setIsLibraryMenuOpen] = useAtom9(
        isLibraryMenuOpenAtom,
        jotaiScope
      );
      const renderRemoveLibAlert = () => {
        const content = selectedItems.length ? t("alerts.removeItemsFromsLibrary", { count: selectedItems.length }) : t("alerts.resetLibrary");
        const title = selectedItems.length ? t("confirmDialog.removeItemsFromLib") : t("confirmDialog.resetLibrary");
        return /* @__PURE__ */ jsx56(
          ConfirmDialog_default,
          {
            onConfirm: () => {
              if (selectedItems.length) {
                onRemoveFromLibrary();
              } else {
                resetLibrary();
              }
              setShowRemoveLibAlert(false);
            },
            onCancel: () => {
              setShowRemoveLibAlert(false);
            },
            title,
            children: /* @__PURE__ */ jsx56("p", { children: content })
          }
        );
      };
      const [showRemoveLibAlert, setShowRemoveLibAlert] = useState14(false);
      const itemsSelected = !!selectedItems.length;
      const items = itemsSelected ? libraryItemsData.libraryItems.filter(
        (item) => selectedItems.includes(item.id)
      ) : libraryItemsData.libraryItems;
      const resetLabel = itemsSelected ? t("buttons.remove") : t("buttons.resetLibrary");
      const [showPublishLibraryDialog, setShowPublishLibraryDialog] = useState14(false);
      const [publishLibSuccess, setPublishLibSuccess] = useState14(null);
      const renderPublishSuccess = useCallback5(() => {
        return /* @__PURE__ */ jsxs30(
          Dialog,
          {
            onCloseRequest: () => setPublishLibSuccess(null),
            title: t("publishSuccessDialog.title"),
            className: "publish-library-success",
            size: "small",
            children: [
              /* @__PURE__ */ jsx56("p", { children: /* @__PURE__ */ jsx56(
                Trans_default,
                {
                  i18nKey: "publishSuccessDialog.content",
                  authorName: publishLibSuccess.authorName,
                  link: (el) => /* @__PURE__ */ jsx56(
                    "a",
                    {
                      href: publishLibSuccess?.url,
                      target: "_blank",
                      rel: "noopener noreferrer",
                      children: el
                    }
                  )
                }
              ) }),
              /* @__PURE__ */ jsx56(
                ToolButton,
                {
                  type: "button",
                  title: t("buttons.close"),
                  "aria-label": t("buttons.close"),
                  label: t("buttons.close"),
                  onClick: () => setPublishLibSuccess(null),
                  "data-testid": "publish-library-success-close",
                  className: "publish-library-success-close"
                }
              )
            ]
          }
        );
      }, [setPublishLibSuccess, publishLibSuccess]);
      const onPublishLibSuccess = (data, libraryItems) => {
        setShowPublishLibraryDialog(false);
        setPublishLibSuccess({ url: data.url, authorName: data.authorName });
        const nextLibItems = libraryItems.slice();
        nextLibItems.forEach((libItem) => {
          if (selectedItems.includes(libItem.id)) {
            libItem.status = "published";
          }
        });
        library.setLibrary(nextLibItems);
      };
      const onLibraryImport = async () => {
        try {
          await library.updateLibrary({
            libraryItems: fileOpen({
              description: "Excalidraw library files"
              // ToDo: Be over-permissive until https://bugs.webkit.org/show_bug.cgi?id=34442
              // gets resolved. Else, iOS users cannot open `.excalidraw` files.
              /*
                extensions: [".json", ".excalidrawlib"],
                */
            }),
            merge: true,
            openLibraryMenu: true
          });
        } catch (error) {
          if (error?.name === "AbortError") {
            console.warn(error);
            return;
          }
          setAppState({ errorMessage: t("errors.importLibraryError") });
        }
      };
      const onLibraryExport = async () => {
        const libraryItems = itemsSelected ? items : await library.getLatestLibrary();
        saveLibraryAsJSON(libraryItems).catch(muteFSAbortError).catch((error) => {
          setAppState({ errorMessage: error.message });
        });
      };
      const renderLibraryMenu = () => {
        return /* @__PURE__ */ jsxs30(DropdownMenu_default, { open: isLibraryMenuOpen, children: [
          /* @__PURE__ */ jsx56(
            DropdownMenu_default.Trigger,
            {
              onToggle: () => setIsLibraryMenuOpen(!isLibraryMenuOpen),
              children: DotsIcon
            }
          ),
          /* @__PURE__ */ jsxs30(
            DropdownMenu_default.Content,
            {
              onClickOutside: () => setIsLibraryMenuOpen(false),
              onSelect: () => setIsLibraryMenuOpen(false),
              className: "library-menu",
              children: [
                !itemsSelected && /* @__PURE__ */ jsx56(
                  DropdownMenu_default.Item,
                  {
                    onSelect: onLibraryImport,
                    icon: LoadIcon,
                    "data-testid": "lib-dropdown--load",
                    children: t("buttons.load")
                  }
                ),
                !!items.length && /* @__PURE__ */ jsx56(
                  DropdownMenu_default.Item,
                  {
                    onSelect: onLibraryExport,
                    icon: ExportIcon,
                    "data-testid": "lib-dropdown--export",
                    children: t("buttons.export")
                  }
                ),
                !!items.length && /* @__PURE__ */ jsx56(
                  DropdownMenu_default.Item,
                  {
                    onSelect: () => setShowRemoveLibAlert(true),
                    icon: TrashIcon,
                    children: resetLabel
                  }
                ),
                itemsSelected && /* @__PURE__ */ jsx56(
                  DropdownMenu_default.Item,
                  {
                    icon: publishIcon,
                    onSelect: () => setShowPublishLibraryDialog(true),
                    "data-testid": "lib-dropdown--remove",
                    children: t("buttons.publishLibrary")
                  }
                )
              ]
            }
          )
        ] });
      };
      return /* @__PURE__ */ jsxs30("div", { className: clsx24("library-menu-dropdown-container", className), children: [
        renderLibraryMenu(),
        selectedItems.length > 0 && /* @__PURE__ */ jsx56("div", { className: "library-actions-counter", children: selectedItems.length }),
        showRemoveLibAlert && renderRemoveLibAlert(),
        showPublishLibraryDialog && /* @__PURE__ */ jsx56(
          PublishLibrary_default,
          {
            onClose: () => setShowPublishLibraryDialog(false),
            libraryItems: getSelectedItems(
              libraryItemsData.libraryItems,
              selectedItems
            ),
            appState,
            onSuccess: (data) => onPublishLibSuccess(data, libraryItemsData.libraryItems),
            onError: (error) => window.alert(error),
            updateItemsInStorage: () => library.setLibrary(libraryItemsData.libraryItems),
            onRemove: (id) => onSelectItems(selectedItems.filter((_id) => _id !== id))
          }
        ),
        publishLibSuccess && renderPublishSuccess()
      ] });
    };
    LibraryDropdownMenu = ({
      selectedItems,
      onSelectItems,
      className
    }) => {
      const { library } = useApp();
      const { clearLibraryCache, deleteItemsFromLibraryCache } = useLibraryCache();
      const appState = useUIAppState();
      const setAppState = useExcalidrawSetAppState();
      const [libraryItemsData] = useAtom9(libraryItemsAtom, jotaiScope);
      const removeFromLibrary = async (libraryItems) => {
        const nextItems = libraryItems.filter(
          (item) => !selectedItems.includes(item.id)
        );
        library.setLibrary(nextItems).catch(() => {
          setAppState({ errorMessage: t("alerts.errorRemovingFromLibrary") });
        });
        deleteItemsFromLibraryCache(selectedItems);
        onSelectItems([]);
      };
      const resetLibrary = () => {
        library.resetLibrary();
        clearLibraryCache();
      };
      return /* @__PURE__ */ jsx56(
        LibraryDropdownMenuButton,
        {
          appState,
          setAppState,
          selectedItems,
          onSelectItems,
          library,
          onRemoveFromLibrary: () => removeFromLibrary(libraryItemsData.libraryItems),
          resetLibrary,
          className
        }
      );
    };
  }
});

// components/LibraryUnit.scss
var init_LibraryUnit = __esm({
  "components/LibraryUnit.scss"() {
  }
});

// components/LibraryUnit.tsx
import clsx25 from "clsx";
import { memo, useEffect as useEffect17, useRef as useRef14, useState as useState15 } from "react";
import { jsx as jsx57, jsxs as jsxs31 } from "react/jsx-runtime";
var LibraryUnit, EmptyLibraryUnit;
var init_LibraryUnit2 = __esm({
  "components/LibraryUnit.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_App();
    init_LibraryUnit();
    init_CheckboxItem2();
    init_icons();
    init_useLibraryItemSvg();
    LibraryUnit = memo(
      ({
        id,
        elements,
        isPending,
        onClick,
        selected,
        onToggle,
        onDrag,
        svgCache
      }) => {
        const ref = useRef14(null);
        const svg = useLibraryItemSvg(id, elements, svgCache);
        useEffect17(() => {
          const node = ref.current;
          if (!node) {
            return;
          }
          if (svg) {
            node.innerHTML = svg.outerHTML;
          }
          return () => {
            node.innerHTML = "";
          };
        }, [svg]);
        const [isHovered, setIsHovered] = useState15(false);
        const isMobile = useDevice().editor.isMobile;
        const adder = isPending && /* @__PURE__ */ jsx57("div", { className: "library-unit__adder", children: PlusIcon });
        return /* @__PURE__ */ jsxs31(
          "div",
          {
            className: clsx25("library-unit", {
              "library-unit__active": elements,
              "library-unit--hover": elements && isHovered,
              "library-unit--selected": selected,
              "library-unit--skeleton": !svg
            }),
            onMouseEnter: () => setIsHovered(true),
            onMouseLeave: () => setIsHovered(false),
            children: [
              /* @__PURE__ */ jsx57(
                "div",
                {
                  className: clsx25("library-unit__dragger", {
                    "library-unit__pulse": !!isPending
                  }),
                  ref,
                  draggable: !!elements,
                  onClick: !!elements || !!isPending ? (event) => {
                    if (id && event.shiftKey) {
                      onToggle(id, event);
                    } else {
                      onClick(id);
                    }
                  } : void 0,
                  onDragStart: (event) => {
                    if (!id) {
                      event.preventDefault();
                      return;
                    }
                    setIsHovered(false);
                    onDrag(id, event);
                  }
                }
              ),
              adder,
              id && elements && (isHovered || isMobile || selected) && /* @__PURE__ */ jsx57(
                CheckboxItem,
                {
                  checked: selected,
                  onChange: (checked, event) => onToggle(id, event),
                  className: "library-unit__checkbox"
                }
              )
            ]
          }
        );
      }
    );
    EmptyLibraryUnit = () => /* @__PURE__ */ jsx57("div", { className: "library-unit library-unit--skeleton" });
  }
});

// hooks/useTransition.ts
import React20, { useCallback as useCallback6 } from "react";
function useTransitionPolyfill() {
  const startTransition = useCallback6((callback) => callback(), []);
  return [false, startTransition];
}
var useTransition;
var init_useTransition = __esm({
  "hooks/useTransition.ts"() {
    "use strict";
    init_define_import_meta_env();
    useTransition = React20.useTransition || useTransitionPolyfill;
  }
});

// components/LibraryMenuSection.tsx
import { memo as memo2, useEffect as useEffect18, useState as useState16 } from "react";
import { Fragment as Fragment9, jsx as jsx58 } from "react/jsx-runtime";
var LibraryMenuSectionGrid, LibraryMenuSection;
var init_LibraryMenuSection = __esm({
  "components/LibraryMenuSection.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_LibraryUnit2();
    init_useTransition();
    LibraryMenuSectionGrid = ({
      children
    }) => {
      return /* @__PURE__ */ jsx58("div", { className: "library-menu-items-container__grid", children });
    };
    LibraryMenuSection = memo2(
      ({
        items,
        onItemSelectToggle,
        onItemDrag,
        isItemSelected,
        onClick,
        svgCache,
        itemsRenderedPerBatch
      }) => {
        const [, startTransition] = useTransition();
        const [index, setIndex] = useState16(0);
        useEffect18(() => {
          if (index < items.length) {
            startTransition(() => {
              setIndex(index + itemsRenderedPerBatch);
            });
          }
        }, [index, items.length, startTransition, itemsRenderedPerBatch]);
        return /* @__PURE__ */ jsx58(Fragment9, { children: items.map((item, i) => {
          return i < index ? /* @__PURE__ */ jsx58(
            LibraryUnit,
            {
              elements: item?.elements,
              isPending: !item?.id && !!item?.elements,
              onClick,
              svgCache,
              id: item?.id,
              selected: isItemSelected(item.id),
              onToggle: onItemSelectToggle,
              onDrag: onItemDrag
            },
            item?.id ?? i
          ) : /* @__PURE__ */ jsx58(EmptyLibraryUnit, {}, i);
        }) });
      }
    );
  }
});

// hooks/useScrollPosition.ts
import { useEffect as useEffect19 } from "react";
import { atom as atom6, useAtom as useAtom10 } from "jotai";
import throttle from "lodash.throttle";
var scrollPositionAtom, useScrollPosition;
var init_useScrollPosition = __esm({
  "hooks/useScrollPosition.ts"() {
    "use strict";
    init_define_import_meta_env();
    scrollPositionAtom = atom6(0);
    useScrollPosition = (elementRef) => {
      const [scrollPosition, setScrollPosition] = useAtom10(scrollPositionAtom);
      useEffect19(() => {
        const { current: element } = elementRef;
        if (!element) {
          return;
        }
        const handleScroll = throttle(() => {
          const { scrollTop } = element;
          setScrollPosition(scrollTop);
        }, 200);
        element.addEventListener("scroll", handleScroll);
        return () => {
          handleScroll.cancel();
          element.removeEventListener("scroll", handleScroll);
        };
      }, [elementRef, setScrollPosition]);
      return scrollPosition;
    };
  }
});

// components/LibraryMenuItems.scss
var init_LibraryMenuItems = __esm({
  "components/LibraryMenuItems.scss"() {
  }
});

// components/LibraryMenuItems.tsx
import {
  useCallback as useCallback7,
  useEffect as useEffect20,
  useMemo,
  useRef as useRef15,
  useState as useState17
} from "react";
import { Fragment as Fragment10, jsx as jsx59, jsxs as jsxs32 } from "react/jsx-runtime";
function LibraryMenuItems({
  isLoading,
  libraryItems,
  onAddToLibrary,
  onInsertLibraryItems,
  pendingElements,
  theme,
  id,
  libraryReturnUrl,
  onSelectItems,
  selectedItems
}) {
  const libraryContainerRef = useRef15(null);
  const scrollPosition = useScrollPosition(libraryContainerRef);
  useEffect20(() => {
    if (scrollPosition > 0) {
      libraryContainerRef.current?.scrollTo(0, scrollPosition);
    }
  }, []);
  const { svgCache } = useLibraryCache();
  const unpublishedItems = useMemo(
    () => libraryItems.filter((item) => item.status !== "published"),
    [libraryItems]
  );
  const publishedItems = useMemo(
    () => libraryItems.filter((item) => item.status === "published"),
    [libraryItems]
  );
  const showBtn = !libraryItems.length && !pendingElements.length;
  const isLibraryEmpty = !pendingElements.length && !unpublishedItems.length && !publishedItems.length;
  const [lastSelectedItem, setLastSelectedItem] = useState17(null);
  const onItemSelectToggle = useCallback7(
    (id2, event) => {
      const shouldSelect = !selectedItems.includes(id2);
      const orderedItems = [...unpublishedItems, ...publishedItems];
      if (shouldSelect) {
        if (event.shiftKey && lastSelectedItem) {
          const rangeStart = orderedItems.findIndex(
            (item) => item.id === lastSelectedItem
          );
          const rangeEnd = orderedItems.findIndex((item) => item.id === id2);
          if (rangeStart === -1 || rangeEnd === -1) {
            onSelectItems([...selectedItems, id2]);
            return;
          }
          const selectedItemsMap = arrayToMap(selectedItems);
          const nextSelectedIds = orderedItems.reduce(
            (acc, item, idx) => {
              if (idx >= rangeStart && idx <= rangeEnd || selectedItemsMap.has(item.id)) {
                acc.push(item.id);
              }
              return acc;
            },
            []
          );
          onSelectItems(nextSelectedIds);
        } else {
          onSelectItems([...selectedItems, id2]);
        }
        setLastSelectedItem(id2);
      } else {
        setLastSelectedItem(null);
        onSelectItems(selectedItems.filter((_id) => _id !== id2));
      }
    },
    [
      lastSelectedItem,
      onSelectItems,
      publishedItems,
      selectedItems,
      unpublishedItems
    ]
  );
  const getInsertedElements = useCallback7(
    (id2) => {
      let targetElements;
      if (selectedItems.includes(id2)) {
        targetElements = libraryItems.filter(
          (item) => selectedItems.includes(item.id)
        );
      } else {
        targetElements = libraryItems.filter((item) => item.id === id2);
      }
      return targetElements.map((item) => {
        return {
          ...item,
          // duplicate each library item before inserting on canvas to confine
          // ids and bindings to each library item. See #6465
          elements: duplicateElements(item.elements, { randomizeSeed: true })
        };
      });
    },
    [libraryItems, selectedItems]
  );
  const onItemDrag = useCallback7(
    (id2, event) => {
      event.dataTransfer.setData(
        MIME_TYPES.excalidrawlib,
        serializeLibraryAsJSON(getInsertedElements(id2))
      );
    },
    [getInsertedElements]
  );
  const isItemSelected = useCallback7(
    (id2) => {
      if (!id2) {
        return false;
      }
      return selectedItems.includes(id2);
    },
    [selectedItems]
  );
  const onAddToLibraryClick = useCallback7(() => {
    onAddToLibrary(pendingElements);
  }, [pendingElements, onAddToLibrary]);
  const onItemClick = useCallback7(
    (id2) => {
      if (id2) {
        onInsertLibraryItems(getInsertedElements(id2));
      }
    },
    [getInsertedElements, onInsertLibraryItems]
  );
  const itemsRenderedPerBatch = svgCache.size >= libraryItems.length ? CACHED_ITEMS_RENDERED_PER_BATCH : ITEMS_RENDERED_PER_BATCH;
  return /* @__PURE__ */ jsxs32(
    "div",
    {
      className: "library-menu-items-container",
      style: pendingElements.length || unpublishedItems.length || publishedItems.length ? { justifyContent: "flex-start" } : { borderBottom: 0 },
      children: [
        !isLibraryEmpty && /* @__PURE__ */ jsx59(
          LibraryDropdownMenu,
          {
            selectedItems,
            onSelectItems,
            className: "library-menu-dropdown-container--in-heading"
          }
        ),
        /* @__PURE__ */ jsxs32(
          Stack_default.Col,
          {
            className: "library-menu-items-container__items",
            align: "start",
            gap: 1,
            style: {
              flex: publishedItems.length > 0 ? 1 : "0 1 auto",
              marginBottom: 0
            },
            ref: libraryContainerRef,
            children: [
              /* @__PURE__ */ jsxs32(Fragment10, { children: [
                !isLibraryEmpty && /* @__PURE__ */ jsx59("div", { className: "library-menu-items-container__header", children: t("labels.personalLib") }),
                isLoading && /* @__PURE__ */ jsx59(
                  "div",
                  {
                    style: {
                      position: "absolute",
                      top: "var(--container-padding-y)",
                      right: "var(--container-padding-x)",
                      transform: "translateY(50%)"
                    },
                    children: /* @__PURE__ */ jsx59(Spinner_default, {})
                  }
                ),
                !pendingElements.length && !unpublishedItems.length ? /* @__PURE__ */ jsxs32("div", { className: "library-menu-items__no-items", children: [
                  /* @__PURE__ */ jsx59("div", { className: "library-menu-items__no-items__label", children: t("library.noItems") }),
                  /* @__PURE__ */ jsx59("div", { className: "library-menu-items__no-items__hint", children: publishedItems.length > 0 ? t("library.hint_emptyPrivateLibrary") : t("library.hint_emptyLibrary") })
                ] }) : /* @__PURE__ */ jsxs32(LibraryMenuSectionGrid, { children: [
                  pendingElements.length > 0 && /* @__PURE__ */ jsx59(
                    LibraryMenuSection,
                    {
                      itemsRenderedPerBatch,
                      items: [{ id: null, elements: pendingElements }],
                      onItemSelectToggle,
                      onItemDrag,
                      onClick: onAddToLibraryClick,
                      isItemSelected,
                      svgCache
                    }
                  ),
                  /* @__PURE__ */ jsx59(
                    LibraryMenuSection,
                    {
                      itemsRenderedPerBatch,
                      items: unpublishedItems,
                      onItemSelectToggle,
                      onItemDrag,
                      onClick: onItemClick,
                      isItemSelected,
                      svgCache
                    }
                  )
                ] })
              ] }),
              /* @__PURE__ */ jsxs32(Fragment10, { children: [
                (publishedItems.length > 0 || pendingElements.length > 0 || unpublishedItems.length > 0) && /* @__PURE__ */ jsx59("div", { className: "library-menu-items-container__header library-menu-items-container__header--excal", children: t("labels.excalidrawLib") }),
                publishedItems.length > 0 ? /* @__PURE__ */ jsx59(LibraryMenuSectionGrid, { children: /* @__PURE__ */ jsx59(
                  LibraryMenuSection,
                  {
                    itemsRenderedPerBatch,
                    items: publishedItems,
                    onItemSelectToggle,
                    onItemDrag,
                    onClick: onItemClick,
                    isItemSelected,
                    svgCache
                  }
                ) }) : unpublishedItems.length > 0 ? /* @__PURE__ */ jsx59(
                  "div",
                  {
                    style: {
                      margin: "1rem 0",
                      display: "flex",
                      flexDirection: "column",
                      alignItems: "center",
                      justifyContent: "center",
                      width: "100%",
                      fontSize: ".9rem"
                    },
                    children: t("library.noItems")
                  }
                ) : null
              ] }),
              showBtn && /* @__PURE__ */ jsx59(
                LibraryMenuControlButtons,
                {
                  style: { padding: "16px 0", width: "100%" },
                  id,
                  libraryReturnUrl,
                  theme,
                  children: /* @__PURE__ */ jsx59(
                    LibraryDropdownMenu,
                    {
                      selectedItems,
                      onSelectItems
                    }
                  )
                }
              )
            ]
          }
        )
      ]
    }
  );
}
var ITEMS_RENDERED_PER_BATCH, CACHED_ITEMS_RENDERED_PER_BATCH;
var init_LibraryMenuItems2 = __esm({
  "components/LibraryMenuItems.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_json();
    init_i18n();
    init_utils();
    init_Stack2();
    init_constants();
    init_Spinner2();
    init_newElement();
    init_LibraryMenuControlButtons();
    init_LibraryMenuHeaderContent();
    init_LibraryMenuSection();
    init_useScrollPosition();
    init_useLibraryItemSvg();
    init_LibraryMenuItems();
    ITEMS_RENDERED_PER_BATCH = 17;
    CACHED_ITEMS_RENDERED_PER_BATCH = 64;
  }
});

// components/LibraryMenu.scss
var init_LibraryMenu = __esm({
  "components/LibraryMenu.scss"() {
  }
});

// components/LibraryMenu.tsx
import { useState as useState18, useCallback as useCallback8, useMemo as useMemo2, useRef as useRef16 } from "react";
import { atom as atom7, useAtom as useAtom11 } from "jotai";
import { jsx as jsx60, jsxs as jsxs33 } from "react/jsx-runtime";
var isLibraryMenuOpenAtom, LibraryMenuWrapper, LibraryMenuContent, usePendingElementsMemo, LibraryMenu;
var init_LibraryMenu2 = __esm({
  "components/LibraryMenu.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_library();
    init_i18n();
    init_random();
    init_LibraryMenuItems2();
    init_analytics();
    init_jotai();
    init_Spinner2();
    init_App();
    init_scene();
    init_ui_appState();
    init_LibraryMenu();
    init_LibraryMenuControlButtons();
    init_utils();
    init_constants();
    isLibraryMenuOpenAtom = atom7(false);
    LibraryMenuWrapper = ({ children }) => {
      return /* @__PURE__ */ jsx60("div", { className: "layer-ui__library", children });
    };
    LibraryMenuContent = ({
      onInsertLibraryItems,
      pendingElements,
      onAddToLibrary,
      setAppState,
      libraryReturnUrl,
      library,
      id,
      theme,
      selectedItems,
      onSelectItems
    }) => {
      const [libraryItemsData] = useAtom11(libraryItemsAtom, jotaiScope);
      const _onAddToLibrary = useCallback8(
        (elements) => {
          const addToLibrary = async (processedElements, libraryItems2) => {
            trackEvent("element", "addToLibrary", "ui");
            for (const type of LIBRARY_DISABLED_TYPES) {
              if (processedElements.some((element) => element.type === type)) {
                return setAppState({
                  errorMessage: t(`errors.libraryElementTypeError.${type}`)
                });
              }
            }
            const nextItems = [
              {
                status: "unpublished",
                elements: processedElements,
                id: randomId(),
                created: Date.now()
              },
              ...libraryItems2
            ];
            onAddToLibrary();
            library.setLibrary(nextItems).catch(() => {
              setAppState({ errorMessage: t("alerts.errorAddingToLibrary") });
            });
          };
          addToLibrary(elements, libraryItemsData.libraryItems);
        },
        [onAddToLibrary, library, setAppState, libraryItemsData.libraryItems]
      );
      const libraryItems = useMemo2(
        () => libraryItemsData.libraryItems,
        [libraryItemsData]
      );
      if (libraryItemsData.status === "loading" && !libraryItemsData.isInitialized) {
        return /* @__PURE__ */ jsx60(LibraryMenuWrapper, { children: /* @__PURE__ */ jsx60("div", { className: "layer-ui__library-message", children: /* @__PURE__ */ jsxs33("div", { children: [
          /* @__PURE__ */ jsx60(Spinner_default, { size: "2em" }),
          /* @__PURE__ */ jsx60("span", { children: t("labels.libraryLoadingMessage") })
        ] }) }) });
      }
      const showBtn = libraryItemsData.libraryItems.length > 0 || pendingElements.length > 0;
      return /* @__PURE__ */ jsxs33(LibraryMenuWrapper, { children: [
        /* @__PURE__ */ jsx60(
          LibraryMenuItems,
          {
            isLoading: libraryItemsData.status === "loading",
            libraryItems,
            onAddToLibrary: _onAddToLibrary,
            onInsertLibraryItems,
            pendingElements,
            id,
            libraryReturnUrl,
            theme,
            onSelectItems,
            selectedItems
          }
        ),
        showBtn && /* @__PURE__ */ jsx60(
          LibraryMenuControlButtons,
          {
            className: "library-menu-control-buttons--at-bottom",
            style: { padding: "16px 12px 0 12px" },
            id,
            libraryReturnUrl,
            theme
          }
        )
      ] });
    };
    usePendingElementsMemo = (appState, elements) => {
      const create = () => getSelectedElements(elements, appState, {
        includeBoundTextElement: true,
        includeElementsInFrames: true
      });
      const val = useRef16(create());
      const prevAppState = useRef16(appState);
      const prevElements = useRef16(elements);
      if (!isShallowEqual(
        appState.selectedElementIds,
        prevAppState.current.selectedElementIds
      ) || !isShallowEqual(elements, prevElements.current)) {
        val.current = create();
        prevAppState.current = appState;
        prevElements.current = elements;
      }
      return val.current;
    };
    LibraryMenu = () => {
      const { library, id, onInsertElements } = useApp();
      const appProps = useAppProps();
      const appState = useUIAppState();
      const setAppState = useExcalidrawSetAppState();
      const elements = useExcalidrawElements();
      const [selectedItems, setSelectedItems] = useState18([]);
      const memoizedLibrary = useMemo2(() => library, [library]);
      const pendingElements = usePendingElementsMemo(appState, elements);
      const onInsertLibraryItems = useCallback8(
        (libraryItems) => {
          onInsertElements(distributeLibraryItemsOnSquareGrid(libraryItems));
        },
        [onInsertElements]
      );
      const deselectItems = useCallback8(() => {
        setAppState({
          selectedElementIds: {},
          selectedGroupIds: {},
          activeEmbeddable: null
        });
      }, [setAppState]);
      return /* @__PURE__ */ jsx60(
        LibraryMenuContent,
        {
          pendingElements,
          onInsertLibraryItems,
          onAddToLibrary: deselectItems,
          setAppState,
          libraryReturnUrl: appProps.libraryReturnUrl,
          library: memoizedLibrary,
          id,
          theme: appState.theme,
          selectedItems,
          onSelectItems: setSelectedItems
        }
      );
    };
  }
});

// components/Dialog.tsx
import clsx26 from "clsx";
import { useEffect as useEffect21, useState as useState19 } from "react";
import { useSetAtom as useSetAtom2 } from "jotai";
import { jsx as jsx61, jsxs as jsxs34 } from "react/jsx-runtime";
function getDialogSize(size) {
  if (size && typeof size === "number") {
    return size;
  }
  switch (size) {
    case "small":
      return 550;
    case "wide":
      return 1024;
    case "regular":
    default:
      return 800;
  }
}
var Dialog;
var init_Dialog2 = __esm({
  "components/Dialog.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_useCallbackRefState();
    init_i18n();
    init_App();
    init_keys();
    init_Dialog();
    init_icons();
    init_Island2();
    init_Modal2();
    init_utils();
    init_LibraryMenu2();
    init_jotai();
    Dialog = (props) => {
      const [islandNode, setIslandNode] = useCallbackRefState();
      const [lastActiveElement] = useState19(document.activeElement);
      const { id } = useExcalidrawContainer();
      const isFullscreen = useDevice().viewport.isMobile;
      useEffect21(() => {
        if (!islandNode) {
          return;
        }
        const focusableElements = queryFocusableElements(islandNode);
        if (focusableElements.length > 0 && props.autofocus !== false) {
          (focusableElements[1] || focusableElements[0]).focus();
        }
        const handleKeyDown = (event) => {
          if (event.key === KEYS.TAB) {
            const focusableElements2 = queryFocusableElements(islandNode);
            const { activeElement } = document;
            const currentIndex = focusableElements2.findIndex(
              (element) => element === activeElement
            );
            if (currentIndex === 0 && event.shiftKey) {
              focusableElements2[focusableElements2.length - 1].focus();
              event.preventDefault();
            } else if (currentIndex === focusableElements2.length - 1 && !event.shiftKey) {
              focusableElements2[0].focus();
              event.preventDefault();
            }
          }
        };
        islandNode.addEventListener("keydown", handleKeyDown);
        return () => islandNode.removeEventListener("keydown", handleKeyDown);
      }, [islandNode, props.autofocus]);
      const setAppState = useExcalidrawSetAppState();
      const setIsLibraryMenuOpen = useSetAtom2(isLibraryMenuOpenAtom, jotaiScope);
      const onClose = () => {
        setAppState({ openMenu: null });
        setIsLibraryMenuOpen(false);
        lastActiveElement.focus();
        props.onCloseRequest();
      };
      return /* @__PURE__ */ jsx61(
        Modal,
        {
          className: clsx26("Dialog", props.className, {
            "Dialog--fullscreen": isFullscreen
          }),
          labelledBy: "dialog-title",
          maxWidth: getDialogSize(props.size),
          onCloseRequest: onClose,
          closeOnClickOutside: props.closeOnClickOutside,
          children: /* @__PURE__ */ jsxs34(Island, { ref: setIslandNode, children: [
            props.title && /* @__PURE__ */ jsx61("h2", { id: `${id}-dialog-title`, className: "Dialog__title", children: /* @__PURE__ */ jsx61("span", { className: "Dialog__titleContent", children: props.title }) }),
            /* @__PURE__ */ jsx61(
              "button",
              {
                className: "Dialog__close",
                onClick: onClose,
                title: t("buttons.close"),
                "aria-label": t("buttons.close"),
                children: isFullscreen ? back : CloseIcon
              }
            ),
            /* @__PURE__ */ jsx61("div", { className: "Dialog__content", children: props.children })
          ] })
        }
      );
    };
  }
});

// components/ErrorDialog.tsx
import React25, { useState as useState20 } from "react";
import { Fragment as Fragment11, jsx as jsx62 } from "react/jsx-runtime";
var ErrorDialog;
var init_ErrorDialog = __esm({
  "components/ErrorDialog.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_i18n();
    init_Dialog2();
    init_App();
    ErrorDialog = ({
      children,
      onClose
    }) => {
      const [modalIsShown, setModalIsShown] = useState20(!!children);
      const { container: excalidrawContainer } = useExcalidrawContainer();
      const handleClose = React25.useCallback(() => {
        setModalIsShown(false);
        if (onClose) {
          onClose();
        }
        excalidrawContainer?.focus();
      }, [onClose, excalidrawContainer]);
      return /* @__PURE__ */ jsx62(Fragment11, { children: modalIsShown && /* @__PURE__ */ jsx62(
        Dialog,
        {
          size: "small",
          onCloseRequest: handleClose,
          title: t("errorDialog.title"),
          children: /* @__PURE__ */ jsx62("div", { style: { whiteSpace: "pre-wrap" }, children })
        }
      ) });
    };
  }
});

// components/RadioGroup.scss
var init_RadioGroup = __esm({
  "components/RadioGroup.scss"() {
  }
});

// components/RadioGroup.tsx
import clsx27 from "clsx";
import { jsx as jsx63, jsxs as jsxs35 } from "react/jsx-runtime";
var RadioGroup;
var init_RadioGroup2 = __esm({
  "components/RadioGroup.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_RadioGroup();
    RadioGroup = function({
      onChange,
      value,
      choices,
      name
    }) {
      return /* @__PURE__ */ jsx63("div", { className: "RadioGroup", children: choices.map((choice) => /* @__PURE__ */ jsxs35(
        "div",
        {
          className: clsx27("RadioGroup__choice", {
            active: choice.value === value
          }),
          children: [
            /* @__PURE__ */ jsx63(
              "input",
              {
                name,
                type: "radio",
                checked: choice.value === value,
                onChange: () => onChange(choice.value)
              }
            ),
            choice.label
          ]
        },
        choice.label
      )) });
    };
  }
});

// components/Switch.scss
var init_Switch = __esm({
  "components/Switch.scss"() {
  }
});

// components/Switch.tsx
import clsx28 from "clsx";
import { jsx as jsx64 } from "react/jsx-runtime";
var Switch;
var init_Switch2 = __esm({
  "components/Switch.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_Switch();
    Switch = ({
      title,
      name,
      checked,
      onChange,
      disabled = false
    }) => {
      return /* @__PURE__ */ jsx64("div", { className: clsx28("Switch", { toggled: checked, disabled }), children: /* @__PURE__ */ jsx64(
        "input",
        {
          name,
          id: name,
          title,
          type: "checkbox",
          checked,
          disabled,
          onChange: () => onChange(!checked),
          onKeyDown: (event) => {
            if (event.key === " ") {
              onChange(!checked);
            }
          }
        }
      ) });
    };
  }
});

// components/ImageExportDialog.scss
var init_ImageExportDialog = __esm({
  "components/ImageExportDialog.scss"() {
  }
});

// components/FilledButton.scss
var init_FilledButton = __esm({
  "components/FilledButton.scss"() {
  }
});

// components/FilledButton.tsx
import { forwardRef as forwardRef2, useState as useState21 } from "react";
import clsx29 from "clsx";
import { jsx as jsx65, jsxs as jsxs36 } from "react/jsx-runtime";
var FilledButton;
var init_FilledButton2 = __esm({
  "components/FilledButton.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_FilledButton();
    init_errors();
    init_Spinner2();
    init_utils();
    FilledButton = forwardRef2(
      ({
        children,
        icon,
        onClick,
        label,
        variant = "filled",
        color = "primary",
        size = "medium",
        fullWidth,
        className
      }, ref) => {
        const [isLoading, setIsLoading] = useState21(false);
        const _onClick = async (event) => {
          const ret = onClick?.(event);
          if (isPromiseLike(ret)) {
            try {
              setIsLoading(true);
              await ret;
            } catch (error) {
              if (!(error instanceof AbortError)) {
                throw error;
              } else {
                console.warn(error);
              }
            } finally {
              setIsLoading(false);
            }
          }
        };
        return /* @__PURE__ */ jsx65(
          "button",
          {
            className: clsx29(
              "ExcButton",
              `ExcButton--color-${color}`,
              `ExcButton--variant-${variant}`,
              `ExcButton--size-${size}`,
              { "ExcButton--fullWidth": fullWidth },
              className
            ),
            onClick: _onClick,
            type: "button",
            "aria-label": label,
            ref,
            disabled: isLoading,
            children: /* @__PURE__ */ jsxs36("div", { className: "ExcButton__contents", children: [
              isLoading && /* @__PURE__ */ jsx65(Spinner_default, {}),
              icon && /* @__PURE__ */ jsx65("div", { className: "ExcButton__icon", "aria-hidden": true, children: icon }),
              variant !== "icon" && (children ?? label)
            ] })
          }
        );
      }
    );
  }
});

// components/ImageExportDialog.tsx
import { useEffect as useEffect22, useRef as useRef17, useState as useState22 } from "react";
import { jsx as jsx66, jsxs as jsxs37 } from "react/jsx-runtime";
var supportsContextFilters, ErrorCanvasPreview, ImageExportModal, ExportSetting, ImageExportDialog;
var init_ImageExportDialog2 = __esm({
  "components/ImageExportDialog.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_actionExport();
    init_clipboard();
    init_constants();
    init_blob();
    init_filesystem();
    init_i18n();
    init_scene();
    init_export2();
    init_icons();
    init_Dialog2();
    init_RadioGroup2();
    init_Switch2();
    init_Tooltip2();
    init_ImageExportDialog();
    init_FilledButton2();
    init_utils();
    init_data();
    supportsContextFilters = "filter" in document.createElement("canvas").getContext("2d");
    ErrorCanvasPreview = () => {
      return /* @__PURE__ */ jsxs37("div", { children: [
        /* @__PURE__ */ jsx66("h3", { children: t("canvasError.cannotShowPreview") }),
        /* @__PURE__ */ jsx66("p", { children: /* @__PURE__ */ jsx66("span", { children: t("canvasError.canvasTooBig") }) }),
        /* @__PURE__ */ jsxs37("em", { children: [
          "(",
          t("canvasError.canvasTooBigTip"),
          ")"
        ] })
      ] });
    };
    ImageExportModal = ({
      appStateSnapshot,
      elementsSnapshot,
      files,
      actionManager,
      onExportImage,
      name
    }) => {
      const hasSelection = isSomeElementSelected(
        elementsSnapshot,
        appStateSnapshot
      );
      const [projectName, setProjectName] = useState22(name);
      const [exportSelectionOnly, setExportSelectionOnly] = useState22(hasSelection);
      const [exportWithBackground, setExportWithBackground] = useState22(
        appStateSnapshot.exportBackground
      );
      const [exportDarkMode, setExportDarkMode] = useState22(
        appStateSnapshot.exportWithDarkMode
      );
      const [embedScene, setEmbedScene] = useState22(
        appStateSnapshot.exportEmbedScene
      );
      const [exportScale, setExportScale] = useState22(appStateSnapshot.exportScale);
      const previewRef = useRef17(null);
      const [renderError, setRenderError] = useState22(null);
      const { exportedElements, exportingFrame } = prepareElementsForExport(
        elementsSnapshot,
        appStateSnapshot,
        exportSelectionOnly
      );
      useEffect22(() => {
        const previewNode = previewRef.current;
        if (!previewNode) {
          return;
        }
        const maxWidth = previewNode.offsetWidth;
        const maxHeight = previewNode.offsetHeight;
        if (!maxWidth) {
          return;
        }
        exportToCanvas2({
          elements: exportedElements,
          appState: {
            ...appStateSnapshot,
            name: projectName,
            exportBackground: exportWithBackground,
            exportWithDarkMode: exportDarkMode,
            exportScale,
            exportEmbedScene: embedScene
          },
          files,
          exportPadding: DEFAULT_EXPORT_PADDING,
          maxWidthOrHeight: Math.max(maxWidth, maxHeight),
          exportingFrame
        }).then((canvas2) => {
          setRenderError(null);
          return canvasToBlob(canvas2).then(() => {
            previewNode.replaceChildren(canvas2);
          });
        }).catch((error) => {
          console.error(error);
          setRenderError(error);
        });
      }, [
        appStateSnapshot,
        files,
        exportedElements,
        exportingFrame,
        projectName,
        exportWithBackground,
        exportDarkMode,
        exportScale,
        embedScene
      ]);
      return /* @__PURE__ */ jsxs37("div", { className: "ImageExportModal", children: [
        /* @__PURE__ */ jsx66("h3", { children: t("imageExportDialog.header") }),
        /* @__PURE__ */ jsxs37("div", { className: "ImageExportModal__preview", children: [
          /* @__PURE__ */ jsx66("div", { className: "ImageExportModal__preview__canvas", ref: previewRef, children: renderError && /* @__PURE__ */ jsx66(ErrorCanvasPreview, {}) }),
          /* @__PURE__ */ jsx66("div", { className: "ImageExportModal__preview__filename", children: !nativeFileSystemSupported && /* @__PURE__ */ jsx66(
            "input",
            {
              type: "text",
              className: "TextInput",
              value: projectName,
              style: { width: "30ch" },
              onChange: (event) => {
                setProjectName(event.target.value);
                actionManager.executeAction(
                  actionChangeProjectName,
                  "ui",
                  event.target.value
                );
              }
            }
          ) })
        ] }),
        /* @__PURE__ */ jsxs37("div", { className: "ImageExportModal__settings", children: [
          /* @__PURE__ */ jsx66("h3", { children: t("imageExportDialog.header") }),
          hasSelection && /* @__PURE__ */ jsx66(
            ExportSetting,
            {
              label: t("imageExportDialog.label.onlySelected"),
              name: "exportOnlySelected",
              children: /* @__PURE__ */ jsx66(
                Switch,
                {
                  name: "exportOnlySelected",
                  checked: exportSelectionOnly,
                  onChange: (checked) => {
                    setExportSelectionOnly(checked);
                  }
                }
              )
            }
          ),
          /* @__PURE__ */ jsx66(
            ExportSetting,
            {
              label: t("imageExportDialog.label.withBackground"),
              name: "exportBackgroundSwitch",
              children: /* @__PURE__ */ jsx66(
                Switch,
                {
                  name: "exportBackgroundSwitch",
                  checked: exportWithBackground,
                  onChange: (checked) => {
                    setExportWithBackground(checked);
                    actionManager.executeAction(
                      actionChangeExportBackground,
                      "ui",
                      checked
                    );
                  }
                }
              )
            }
          ),
          supportsContextFilters && /* @__PURE__ */ jsx66(
            ExportSetting,
            {
              label: t("imageExportDialog.label.darkMode"),
              name: "exportDarkModeSwitch",
              children: /* @__PURE__ */ jsx66(
                Switch,
                {
                  name: "exportDarkModeSwitch",
                  checked: exportDarkMode,
                  onChange: (checked) => {
                    setExportDarkMode(checked);
                    actionManager.executeAction(
                      actionExportWithDarkMode,
                      "ui",
                      checked
                    );
                  }
                }
              )
            }
          ),
          /* @__PURE__ */ jsx66(
            ExportSetting,
            {
              label: t("imageExportDialog.label.embedScene"),
              tooltip: t("imageExportDialog.tooltip.embedScene"),
              name: "exportEmbedSwitch",
              children: /* @__PURE__ */ jsx66(
                Switch,
                {
                  name: "exportEmbedSwitch",
                  checked: embedScene,
                  onChange: (checked) => {
                    setEmbedScene(checked);
                    actionManager.executeAction(
                      actionChangeExportEmbedScene,
                      "ui",
                      checked
                    );
                  }
                }
              )
            }
          ),
          /* @__PURE__ */ jsx66(
            ExportSetting,
            {
              label: t("imageExportDialog.label.scale"),
              name: "exportScale",
              children: /* @__PURE__ */ jsx66(
                RadioGroup,
                {
                  name: "exportScale",
                  value: exportScale,
                  onChange: (scale) => {
                    setExportScale(scale);
                    actionManager.executeAction(actionChangeExportScale, "ui", scale);
                  },
                  choices: EXPORT_SCALES.map((scale) => ({
                    value: scale,
                    label: `${scale}\xD7`
                  }))
                }
              )
            }
          ),
          /* @__PURE__ */ jsxs37("div", { className: "ImageExportModal__settings__buttons", children: [
            /* @__PURE__ */ jsx66(
              FilledButton,
              {
                className: "ImageExportModal__settings__buttons__button",
                label: t("imageExportDialog.title.exportToPng"),
                onClick: () => onExportImage(EXPORT_IMAGE_TYPES.png, exportedElements, {
                  exportingFrame
                }),
                icon: downloadIcon,
                children: t("imageExportDialog.button.exportToPng")
              }
            ),
            /* @__PURE__ */ jsx66(
              FilledButton,
              {
                className: "ImageExportModal__settings__buttons__button",
                label: t("imageExportDialog.title.exportToSvg"),
                onClick: () => onExportImage(EXPORT_IMAGE_TYPES.svg, exportedElements, {
                  exportingFrame
                }),
                icon: downloadIcon,
                children: t("imageExportDialog.button.exportToSvg")
              }
            ),
            (probablySupportsClipboardBlob || isFirefox) && /* @__PURE__ */ jsx66(
              FilledButton,
              {
                className: "ImageExportModal__settings__buttons__button",
                label: t("imageExportDialog.title.copyPngToClipboard"),
                onClick: () => onExportImage(EXPORT_IMAGE_TYPES.clipboard, exportedElements, {
                  exportingFrame
                }),
                icon: copyIcon,
                children: t("imageExportDialog.button.copyPngToClipboard")
              }
            )
          ] })
        ] })
      ] });
    };
    ExportSetting = ({
      label,
      children,
      tooltip,
      name
    }) => {
      return /* @__PURE__ */ jsxs37("div", { className: "ImageExportModal__settings__setting", title: label, children: [
        /* @__PURE__ */ jsxs37(
          "label",
          {
            htmlFor: name,
            className: "ImageExportModal__settings__setting__label",
            children: [
              label,
              tooltip && /* @__PURE__ */ jsx66(Tooltip, { label: tooltip, long: true, children: helpIcon })
            ]
          }
        ),
        /* @__PURE__ */ jsx66("div", { className: "ImageExportModal__settings__setting__content", children })
      ] });
    };
    ImageExportDialog = ({
      elements,
      appState,
      files,
      actionManager,
      onExportImage,
      onCloseRequest,
      name
    }) => {
      const [{ appStateSnapshot, elementsSnapshot }] = useState22(() => {
        return {
          appStateSnapshot: cloneJSON(appState),
          elementsSnapshot: cloneJSON(elements)
        };
      });
      return /* @__PURE__ */ jsx66(Dialog, { onCloseRequest, size: "wide", title: false, children: /* @__PURE__ */ jsx66(
        ImageExportModal,
        {
          elementsSnapshot,
          appStateSnapshot,
          files,
          actionManager,
          onExportImage,
          name
        }
      ) });
    };
  }
});

// components/FixedSideContainer.scss
var init_FixedSideContainer = __esm({
  "components/FixedSideContainer.scss"() {
  }
});

// components/FixedSideContainer.tsx
import clsx30 from "clsx";
import { jsx as jsx67 } from "react/jsx-runtime";
var FixedSideContainer;
var init_FixedSideContainer2 = __esm({
  "components/FixedSideContainer.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_FixedSideContainer();
    FixedSideContainer = ({
      children,
      side,
      className
    }) => /* @__PURE__ */ jsx67(
      "div",
      {
        className: clsx30(
          "FixedSideContainer",
          `FixedSideContainer_side_${side}`,
          className
        ),
        children
      }
    );
  }
});

// components/HintViewer.scss
var init_HintViewer = __esm({
  "components/HintViewer.scss"() {
  }
});

// components/HintViewer.tsx
import { jsx as jsx68 } from "react/jsx-runtime";
var getHints, HintViewer;
var init_HintViewer2 = __esm({
  "components/HintViewer.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_i18n();
    init_typeChecks();
    init_utils();
    init_appState();
    init_HintViewer();
    getHints = ({ appState, isMobile, device, app }) => {
      const { activeTool, isResizing, isRotating, lastPointerDownWith } = appState;
      const multiMode = appState.multiElement !== null;
      if (appState.openSidebar && !device.editor.canFitSidebar) {
        return null;
      }
      if (isEraserActive(appState)) {
        return t("hints.eraserRevert");
      }
      if (activeTool.type === "arrow" || activeTool.type === "line") {
        if (!multiMode) {
          return t("hints.linearElement");
        }
        return t("hints.linearElementMulti");
      }
      if (activeTool.type === "freedraw") {
        return t("hints.freeDraw");
      }
      if (activeTool.type === "text") {
        return t("hints.text");
      }
      if (activeTool.type === "embeddable") {
        return t("hints.embeddable");
      }
      if (appState.activeTool.type === "image" && appState.pendingImageElementId) {
        return t("hints.placeImage");
      }
      const selectedElements = app.scene.getSelectedElements(appState);
      if (isResizing && lastPointerDownWith === "mouse" && selectedElements.length === 1) {
        const targetElement = selectedElements[0];
        if (isLinearElement(targetElement) && targetElement.points.length === 2) {
          return t("hints.lockAngle");
        }
        return isImageElement(targetElement) ? t("hints.resizeImage") : t("hints.resize");
      }
      if (isRotating && lastPointerDownWith === "mouse") {
        return t("hints.rotate");
      }
      if (selectedElements.length === 1 && isTextElement(selectedElements[0])) {
        return t("hints.text_selected");
      }
      if (appState.editingElement && isTextElement(appState.editingElement)) {
        return t("hints.text_editing");
      }
      if (activeTool.type === "selection") {
        if (appState.draggingElement?.type === "selection" && !selectedElements.length && !appState.editingElement && !appState.editingLinearElement) {
          return t("hints.deepBoxSelect");
        }
        if (appState.gridSize && appState.draggingElement) {
          return t("hints.disableSnapping");
        }
        if (!selectedElements.length && !isMobile) {
          return t("hints.canvasPanning");
        }
        if (selectedElements.length === 1) {
          if (isLinearElement(selectedElements[0])) {
            if (appState.editingLinearElement) {
              return appState.editingLinearElement.selectedPointsIndices ? t("hints.lineEditor_pointSelected") : t("hints.lineEditor_nothingSelected");
            }
            return t("hints.lineEditor_info");
          }
          if (!appState.draggingElement && isTextBindableContainer(selectedElements[0])) {
            return t("hints.bindTextToElement");
          }
        }
      }
      return null;
    };
    HintViewer = ({
      appState,
      isMobile,
      device,
      app
    }) => {
      let hint = getHints({
        appState,
        isMobile,
        device,
        app
      });
      if (!hint) {
        return null;
      }
      hint = getShortcutKey(hint);
      return /* @__PURE__ */ jsx68("div", { className: "HintViewer", children: /* @__PURE__ */ jsx68("span", { children: hint }) });
    };
  }
});

// components/LockButton.tsx
import clsx31 from "clsx";
import { jsx as jsx69, jsxs as jsxs38 } from "react/jsx-runtime";
var DEFAULT_SIZE, ICONS2, LockButton;
var init_LockButton = __esm({
  "components/LockButton.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_ToolIcon();
    init_icons();
    DEFAULT_SIZE = "medium";
    ICONS2 = {
      CHECKED: LockedIcon,
      UNCHECKED: UnlockedIcon
    };
    LockButton = (props) => {
      return /* @__PURE__ */ jsxs38(
        "label",
        {
          className: clsx31(
            "ToolIcon ToolIcon__lock",
            `ToolIcon_size_${DEFAULT_SIZE}`,
            {
              "is-mobile": props.isMobile
            }
          ),
          title: `${props.title} \u2014 Q`,
          children: [
            /* @__PURE__ */ jsx69(
              "input",
              {
                className: "ToolIcon_type_checkbox",
                type: "checkbox",
                name: props.name,
                onChange: props.onChange,
                checked: props.checked,
                "aria-label": props.title,
                "data-testid": "toolbar-lock"
              }
            ),
            /* @__PURE__ */ jsx69("div", { className: "ToolIcon__icon", children: props.checked ? ICONS2.CHECKED : ICONS2.UNCHECKED })
          ]
        }
      );
    };
  }
});

// components/Section.tsx
import { Fragment as Fragment12, jsx as jsx70, jsxs as jsxs39 } from "react/jsx-runtime";
var Section;
var init_Section = __esm({
  "components/Section.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_i18n();
    init_App();
    Section = ({ heading, children, ...props }) => {
      const { id } = useExcalidrawContainer();
      const header = /* @__PURE__ */ jsx70("h2", { className: "visually-hidden", id: `${id}-${heading}-title`, children: t(`headings.${heading}`) });
      return /* @__PURE__ */ jsx70("section", { ...props, "aria-labelledby": `${id}-${heading}-title`, children: typeof children === "function" ? children(header) : /* @__PURE__ */ jsxs39(Fragment12, { children: [
        header,
        children
      ] }) });
    };
  }
});

// components/PenModeButton.tsx
import clsx32 from "clsx";
import { jsx as jsx71, jsxs as jsxs40 } from "react/jsx-runtime";
var DEFAULT_SIZE2, PenModeButton;
var init_PenModeButton = __esm({
  "components/PenModeButton.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_ToolIcon();
    init_icons();
    DEFAULT_SIZE2 = "medium";
    PenModeButton = (props) => {
      if (!props.penDetected) {
        return null;
      }
      return /* @__PURE__ */ jsxs40(
        "label",
        {
          className: clsx32(
            "ToolIcon ToolIcon__penMode",
            `ToolIcon_size_${DEFAULT_SIZE2}`,
            {
              "is-mobile": props.isMobile
            }
          ),
          title: `${props.title}`,
          children: [
            /* @__PURE__ */ jsx71(
              "input",
              {
                className: "ToolIcon_type_checkbox",
                type: "checkbox",
                name: props.name,
                onChange: props.onChange,
                checked: props.checked,
                "aria-label": props.title
              }
            ),
            /* @__PURE__ */ jsx71("div", { className: "ToolIcon__icon", children: PenModeIcon })
          ]
        }
      );
    };
  }
});

// components/Stats.scss
var init_Stats = __esm({
  "components/Stats.scss"() {
  }
});

// components/Stats.tsx
import { Fragment as Fragment13, jsx as jsx72, jsxs as jsxs41 } from "react/jsx-runtime";
var Stats;
var init_Stats2 = __esm({
  "components/Stats.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_bounds();
    init_i18n();
    init_scene();
    init_icons();
    init_Island2();
    init_Stats();
    Stats = (props) => {
      const boundingBox = getCommonBounds(props.elements);
      const selectedElements = getTargetElements(props.elements, props.appState);
      const selectedBoundingBox = getCommonBounds(selectedElements);
      return /* @__PURE__ */ jsx72("div", { className: "Stats", children: /* @__PURE__ */ jsxs41(Island, { padding: 2, children: [
        /* @__PURE__ */ jsx72("div", { className: "close", onClick: props.onClose, children: CloseIcon }),
        /* @__PURE__ */ jsx72("h3", { children: t("stats.title") }),
        /* @__PURE__ */ jsx72("table", { children: /* @__PURE__ */ jsxs41("tbody", { children: [
          /* @__PURE__ */ jsx72("tr", { children: /* @__PURE__ */ jsx72("th", { colSpan: 2, children: t("stats.scene") }) }),
          /* @__PURE__ */ jsxs41("tr", { children: [
            /* @__PURE__ */ jsx72("td", { children: t("stats.elements") }),
            /* @__PURE__ */ jsx72("td", { children: props.elements.length })
          ] }),
          /* @__PURE__ */ jsxs41("tr", { children: [
            /* @__PURE__ */ jsx72("td", { children: t("stats.width") }),
            /* @__PURE__ */ jsx72("td", { children: Math.round(boundingBox[2]) - Math.round(boundingBox[0]) })
          ] }),
          /* @__PURE__ */ jsxs41("tr", { children: [
            /* @__PURE__ */ jsx72("td", { children: t("stats.height") }),
            /* @__PURE__ */ jsx72("td", { children: Math.round(boundingBox[3]) - Math.round(boundingBox[1]) })
          ] }),
          selectedElements.length === 1 && /* @__PURE__ */ jsx72("tr", { children: /* @__PURE__ */ jsx72("th", { colSpan: 2, children: t("stats.element") }) }),
          selectedElements.length > 1 && /* @__PURE__ */ jsxs41(Fragment13, { children: [
            /* @__PURE__ */ jsx72("tr", { children: /* @__PURE__ */ jsx72("th", { colSpan: 2, children: t("stats.selected") }) }),
            /* @__PURE__ */ jsxs41("tr", { children: [
              /* @__PURE__ */ jsx72("td", { children: t("stats.elements") }),
              /* @__PURE__ */ jsx72("td", { children: selectedElements.length })
            ] })
          ] }),
          selectedElements.length > 0 && /* @__PURE__ */ jsxs41(Fragment13, { children: [
            /* @__PURE__ */ jsxs41("tr", { children: [
              /* @__PURE__ */ jsx72("td", { children: "x" }),
              /* @__PURE__ */ jsx72("td", { children: Math.round(selectedBoundingBox[0]) })
            ] }),
            /* @__PURE__ */ jsxs41("tr", { children: [
              /* @__PURE__ */ jsx72("td", { children: "y" }),
              /* @__PURE__ */ jsx72("td", { children: Math.round(selectedBoundingBox[1]) })
            ] }),
            /* @__PURE__ */ jsxs41("tr", { children: [
              /* @__PURE__ */ jsx72("td", { children: t("stats.width") }),
              /* @__PURE__ */ jsx72("td", { children: Math.round(
                selectedBoundingBox[2] - selectedBoundingBox[0]
              ) })
            ] }),
            /* @__PURE__ */ jsxs41("tr", { children: [
              /* @__PURE__ */ jsx72("td", { children: t("stats.height") }),
              /* @__PURE__ */ jsx72("td", { children: Math.round(
                selectedBoundingBox[3] - selectedBoundingBox[1]
              ) })
            ] })
          ] }),
          selectedElements.length === 1 && /* @__PURE__ */ jsxs41("tr", { children: [
            /* @__PURE__ */ jsx72("td", { children: t("stats.angle") }),
            /* @__PURE__ */ jsx72("td", { children: `${Math.round(
              selectedElements[0].angle * 180 / Math.PI
            )}\xB0` })
          ] }),
          props.renderCustomStats?.(props.elements, props.appState)
        ] }) })
      ] }) });
    };
  }
});

// components/HandButton.tsx
import clsx33 from "clsx";
import { jsx as jsx73 } from "react/jsx-runtime";
var HandButton;
var init_HandButton = __esm({
  "components/HandButton.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_ToolIcon();
    init_ToolButton();
    init_icons();
    init_keys();
    HandButton = (props) => {
      return /* @__PURE__ */ jsx73(
        ToolButton,
        {
          className: clsx33("Shape", { fillable: false }),
          type: "radio",
          icon: handIcon,
          name: "editor-current-shape",
          checked: props.checked,
          title: `${props.title} \u2014 H`,
          keyBindingLabel: !props.isMobile ? KEYS.H.toLocaleUpperCase() : void 0,
          "aria-label": `${props.title} \u2014 H`,
          "aria-keyshortcuts": KEYS.H,
          "data-testid": `toolbar-hand`,
          onChange: () => props.onChange?.()
        }
      );
    };
  }
});

// components/MobileMenu.tsx
import { Fragment as Fragment14, jsx as jsx74, jsxs as jsxs42 } from "react/jsx-runtime";
var MobileMenu;
var init_MobileMenu = __esm({
  "components/MobileMenu.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_i18n();
    init_Stack2();
    init_element();
    init_FixedSideContainer2();
    init_Island2();
    init_HintViewer2();
    init_scene();
    init_Actions2();
    init_Section();
    init_scrollbars();
    init_LockButton();
    init_PenModeButton();
    init_Stats2();
    init_actions();
    init_HandButton();
    init_appState();
    init_tunnels();
    MobileMenu = ({
      appState,
      elements,
      actionManager,
      setAppState,
      onLockToggle,
      onHandToolToggle,
      onPenModeToggle,
      renderTopRightUI,
      renderCustomStats,
      renderSidebars,
      device,
      renderWelcomeScreen,
      UIOptions,
      app
    }) => {
      const {
        WelcomeScreenCenterTunnel,
        MainMenuTunnel,
        DefaultSidebarTriggerTunnel
      } = useTunnels();
      const renderToolbar = () => {
        return /* @__PURE__ */ jsxs42(FixedSideContainer, { side: "top", className: "App-top-bar", children: [
          renderWelcomeScreen && /* @__PURE__ */ jsx74(WelcomeScreenCenterTunnel.Out, {}),
          /* @__PURE__ */ jsx74(Section, { heading: "shapes", children: (heading) => /* @__PURE__ */ jsx74(Stack_default.Col, { gap: 4, align: "center", children: /* @__PURE__ */ jsxs42(Stack_default.Row, { gap: 1, className: "App-toolbar-container", children: [
            /* @__PURE__ */ jsxs42(Island, { padding: 1, className: "App-toolbar App-toolbar--mobile", children: [
              heading,
              /* @__PURE__ */ jsx74(Stack_default.Row, { gap: 1, children: /* @__PURE__ */ jsx74(
                ShapesSwitcher,
                {
                  appState,
                  activeTool: appState.activeTool,
                  UIOptions,
                  app
                }
              ) })
            ] }),
            renderTopRightUI && renderTopRightUI(true, appState),
            /* @__PURE__ */ jsxs42("div", { className: "mobile-misc-tools-container", children: [
              !appState.viewModeEnabled && /* @__PURE__ */ jsx74(DefaultSidebarTriggerTunnel.Out, {}),
              /* @__PURE__ */ jsx74(
                PenModeButton,
                {
                  checked: appState.penMode,
                  onChange: () => onPenModeToggle(null),
                  title: t("toolBar.penMode"),
                  isMobile: true,
                  penDetected: appState.penDetected
                }
              ),
              /* @__PURE__ */ jsx74(
                LockButton,
                {
                  checked: appState.activeTool.locked,
                  onChange: onLockToggle,
                  title: t("toolBar.lock"),
                  isMobile: true
                }
              ),
              /* @__PURE__ */ jsx74(
                HandButton,
                {
                  checked: isHandToolActive(appState),
                  onChange: () => onHandToolToggle(),
                  title: t("toolBar.hand"),
                  isMobile: true
                }
              )
            ] })
          ] }) }) }),
          /* @__PURE__ */ jsx74(
            HintViewer,
            {
              appState,
              isMobile: true,
              device,
              app
            }
          )
        ] });
      };
      const renderAppToolbar = () => {
        if (appState.viewModeEnabled) {
          return /* @__PURE__ */ jsx74("div", { className: "App-toolbar-content", children: /* @__PURE__ */ jsx74(MainMenuTunnel.Out, {}) });
        }
        return /* @__PURE__ */ jsxs42("div", { className: "App-toolbar-content", children: [
          /* @__PURE__ */ jsx74(MainMenuTunnel.Out, {}),
          actionManager.renderAction("toggleEditMenu"),
          actionManager.renderAction("undo"),
          actionManager.renderAction("redo"),
          actionManager.renderAction(
            appState.multiElement ? "finalize" : "duplicateSelection"
          ),
          actionManager.renderAction("deleteSelectedElements")
        ] });
      };
      return /* @__PURE__ */ jsxs42(Fragment14, { children: [
        renderSidebars(),
        !appState.viewModeEnabled && renderToolbar(),
        !appState.openMenu && appState.showStats && /* @__PURE__ */ jsx74(
          Stats,
          {
            appState,
            setAppState,
            elements,
            onClose: () => {
              actionManager.executeAction(actionToggleStats);
            },
            renderCustomStats
          }
        ),
        /* @__PURE__ */ jsx74(
          "div",
          {
            className: "App-bottom-bar",
            style: {
              marginBottom: SCROLLBAR_WIDTH + SCROLLBAR_MARGIN * 2,
              marginLeft: SCROLLBAR_WIDTH + SCROLLBAR_MARGIN * 2,
              marginRight: SCROLLBAR_WIDTH + SCROLLBAR_MARGIN * 2
            },
            children: /* @__PURE__ */ jsxs42(Island, { padding: 0, children: [
              appState.openMenu === "shape" && !appState.viewModeEnabled && showSelectedShapeActions(appState, elements) ? /* @__PURE__ */ jsx74(Section, { className: "App-mobile-menu", heading: "selectedShapeActions", children: /* @__PURE__ */ jsx74(
                SelectedShapeActions,
                {
                  appState,
                  elementsMap: app.scene.getNonDeletedElementsMap(),
                  renderAction: actionManager.renderAction
                }
              ) }) : null,
              /* @__PURE__ */ jsxs42("footer", { className: "App-toolbar", children: [
                renderAppToolbar(),
                appState.scrolledOutside && !appState.openMenu && !appState.openSidebar && /* @__PURE__ */ jsx74(
                  "button",
                  {
                    className: "scroll-back-to-content",
                    onClick: () => {
                      setAppState((appState2) => ({
                        ...calculateScrollCenter(elements, appState2)
                      }));
                    },
                    children: t("buttons.scrollBackToContent")
                  }
                )
              ] })
            ] })
          }
        )
      ] });
    };
  }
});

// components/PasteChartDialog.scss
var init_PasteChartDialog = __esm({
  "components/PasteChartDialog.scss"() {
  }
});

// components/PasteChartDialog.tsx
import oc4 from "open-color";
import React28, { useLayoutEffect as useLayoutEffect5, useRef as useRef18, useState as useState23 } from "react";
import { jsx as jsx75, jsxs as jsxs43 } from "react/jsx-runtime";
var ChartPreviewBtn, PasteChartDialog;
var init_PasteChartDialog2 = __esm({
  "components/PasteChartDialog.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_analytics();
    init_charts();
    init_i18n();
    init_export();
    init_App();
    init_Dialog2();
    init_PasteChartDialog();
    ChartPreviewBtn = (props) => {
      const previewRef = useRef18(null);
      const [chartElements, setChartElements] = useState23(
        null
      );
      useLayoutEffect5(() => {
        if (!props.spreadsheet) {
          return;
        }
        const elements = renderSpreadsheet(
          props.chartType,
          props.spreadsheet,
          0,
          0
        );
        setChartElements(elements);
        let svg;
        const previewNode = previewRef.current;
        (async () => {
          svg = await exportToSvg(
            elements,
            {
              exportBackground: false,
              viewBackgroundColor: oc4.white
            },
            null
            // files
          );
          svg.querySelector(".style-fonts")?.remove();
          previewNode.replaceChildren();
          previewNode.appendChild(svg);
          if (props.selected) {
            previewNode.parentNode.focus();
          }
        })();
        return () => {
          previewNode.replaceChildren();
        };
      }, [props.spreadsheet, props.chartType, props.selected]);
      return /* @__PURE__ */ jsx75(
        "button",
        {
          className: "ChartPreview",
          onClick: () => {
            if (chartElements) {
              props.onClick(props.chartType, chartElements);
            }
          },
          children: /* @__PURE__ */ jsx75("div", { ref: previewRef })
        }
      );
    };
    PasteChartDialog = ({
      setAppState,
      appState,
      onClose
    }) => {
      const { onInsertElements } = useApp();
      const handleClose = React28.useCallback(() => {
        if (onClose) {
          onClose();
        }
      }, [onClose]);
      const handleChartClick = (chartType, elements) => {
        onInsertElements(elements);
        trackEvent("paste", "chart", chartType);
        setAppState({
          currentChartType: chartType,
          pasteDialog: {
            shown: false,
            data: null
          }
        });
      };
      return /* @__PURE__ */ jsx75(
        Dialog,
        {
          size: "small",
          onCloseRequest: handleClose,
          title: t("labels.pasteCharts"),
          className: "PasteChartDialog",
          autofocus: false,
          children: /* @__PURE__ */ jsxs43("div", { className: "container", children: [
            /* @__PURE__ */ jsx75(
              ChartPreviewBtn,
              {
                chartType: "bar",
                spreadsheet: appState.pasteDialog.data,
                selected: appState.currentChartType === "bar",
                onClick: handleChartClick
              }
            ),
            /* @__PURE__ */ jsx75(
              ChartPreviewBtn,
              {
                chartType: "line",
                spreadsheet: appState.pasteDialog.data,
                selected: appState.currentChartType === "line",
                onClick: handleChartClick
              }
            )
          ] })
        }
      );
    };
  }
});

// components/HelpDialog.scss
var init_HelpDialog = __esm({
  "components/HelpDialog.scss"() {
  }
});

// components/HelpDialog.tsx
import React29 from "react";
import { Fragment as Fragment15, jsx as jsx76, jsxs as jsxs44 } from "react/jsx-runtime";
function* intersperse(as, delim) {
  let first = true;
  for (const x of as) {
    if (!first) {
      yield delim;
    }
    first = false;
    yield x;
  }
}
var Header, Section2, ShortcutIsland, upperCaseSingleChars, Shortcut, ShortcutKey, HelpDialog;
var init_HelpDialog2 = __esm({
  "components/HelpDialog.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_i18n();
    init_keys();
    init_Dialog2();
    init_utils();
    init_HelpDialog();
    init_icons();
    init_clipboard();
    init_constants();
    Header = () => /* @__PURE__ */ jsxs44("div", { className: "HelpDialog__header", children: [
      /* @__PURE__ */ jsxs44(
        "a",
        {
          className: "HelpDialog__btn",
          href: "https://docs.excalidraw.com",
          target: "_blank",
          rel: "noopener noreferrer",
          children: [
            t("helpDialog.documentation"),
            /* @__PURE__ */ jsx76("div", { className: "HelpDialog__link-icon", children: ExternalLinkIcon })
          ]
        }
      ),
      /* @__PURE__ */ jsxs44(
        "a",
        {
          className: "HelpDialog__btn",
          href: "https://blog.excalidraw.com",
          target: "_blank",
          rel: "noopener noreferrer",
          children: [
            t("helpDialog.blog"),
            /* @__PURE__ */ jsx76("div", { className: "HelpDialog__link-icon", children: ExternalLinkIcon })
          ]
        }
      ),
      /* @__PURE__ */ jsxs44(
        "a",
        {
          className: "HelpDialog__btn",
          href: "https://github.com/excalidraw/excalidraw/issues",
          target: "_blank",
          rel: "noopener noreferrer",
          children: [
            t("helpDialog.github"),
            /* @__PURE__ */ jsx76("div", { className: "HelpDialog__link-icon", children: ExternalLinkIcon })
          ]
        }
      )
    ] });
    Section2 = (props) => /* @__PURE__ */ jsxs44(Fragment15, { children: [
      /* @__PURE__ */ jsx76("h3", { children: props.title }),
      /* @__PURE__ */ jsx76("div", { className: "HelpDialog__islands-container", children: props.children })
    ] });
    ShortcutIsland = (props) => /* @__PURE__ */ jsxs44("div", { className: `HelpDialog__island ${props.className}`, children: [
      /* @__PURE__ */ jsx76("h4", { className: "HelpDialog__island-title", children: props.caption }),
      /* @__PURE__ */ jsx76("div", { className: "HelpDialog__island-content", children: props.children })
    ] });
    upperCaseSingleChars = (str) => {
      return str.replace(/\b[a-z]\b/, (c) => c.toUpperCase());
    };
    Shortcut = ({
      label,
      shortcuts,
      isOr = true
    }) => {
      const splitShortcutKeys = shortcuts.map((shortcut) => {
        const keys = shortcut.endsWith("++") ? [...shortcut.slice(0, -2).split("+"), "+"] : shortcut.split("+");
        return keys.map((key) => /* @__PURE__ */ jsx76(ShortcutKey, { children: upperCaseSingleChars(key) }, key));
      });
      return /* @__PURE__ */ jsxs44("div", { className: "HelpDialog__shortcut", children: [
        /* @__PURE__ */ jsx76("div", { children: label }),
        /* @__PURE__ */ jsx76("div", { className: "HelpDialog__key-container", children: [...intersperse(splitShortcutKeys, isOr ? t("helpDialog.or") : null)] })
      ] });
    };
    ShortcutKey = (props) => /* @__PURE__ */ jsx76("kbd", { className: "HelpDialog__key", ...props });
    HelpDialog = ({ onClose }) => {
      const handleClose = React29.useCallback(() => {
        if (onClose) {
          onClose();
        }
      }, [onClose]);
      return /* @__PURE__ */ jsx76(Fragment15, { children: /* @__PURE__ */ jsxs44(
        Dialog,
        {
          onCloseRequest: handleClose,
          title: t("helpDialog.title"),
          className: "HelpDialog",
          children: [
            /* @__PURE__ */ jsx76(Header, {}),
            /* @__PURE__ */ jsxs44(Section2, { title: t("helpDialog.shortcuts"), children: [
              /* @__PURE__ */ jsxs44(
                ShortcutIsland,
                {
                  className: "HelpDialog__island--tools",
                  caption: t("helpDialog.tools"),
                  children: [
                    /* @__PURE__ */ jsx76(Shortcut, { label: t("toolBar.hand"), shortcuts: [KEYS.H] }),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("toolBar.selection"),
                        shortcuts: [KEYS.V, KEYS["1"]]
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("toolBar.rectangle"),
                        shortcuts: [KEYS.R, KEYS["2"]]
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("toolBar.diamond"),
                        shortcuts: [KEYS.D, KEYS["3"]]
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("toolBar.ellipse"),
                        shortcuts: [KEYS.O, KEYS["4"]]
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("toolBar.arrow"),
                        shortcuts: [KEYS.A, KEYS["5"]]
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("toolBar.line"),
                        shortcuts: [KEYS.L, KEYS["6"]]
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("toolBar.freedraw"),
                        shortcuts: [KEYS.P, KEYS["7"]]
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("toolBar.text"),
                        shortcuts: [KEYS.T, KEYS["8"]]
                      }
                    ),
                    /* @__PURE__ */ jsx76(Shortcut, { label: t("toolBar.image"), shortcuts: [KEYS["9"]] }),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("toolBar.eraser"),
                        shortcuts: [KEYS.E, KEYS["0"]]
                      }
                    ),
                    /* @__PURE__ */ jsx76(Shortcut, { label: t("toolBar.frame"), shortcuts: [KEYS.F] }),
                    /* @__PURE__ */ jsx76(Shortcut, { label: t("toolBar.laser"), shortcuts: [KEYS.K] }),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("labels.eyeDropper"),
                        shortcuts: [KEYS.I, "Shift+S", "Shift+G"]
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("helpDialog.editLineArrowPoints"),
                        shortcuts: [getShortcutKey("CtrlOrCmd+Enter")]
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("helpDialog.editText"),
                        shortcuts: [getShortcutKey("Enter")]
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("helpDialog.textNewLine"),
                        shortcuts: [
                          getShortcutKey("Enter"),
                          getShortcutKey("Shift+Enter")
                        ]
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("helpDialog.textFinish"),
                        shortcuts: [
                          getShortcutKey("Esc"),
                          getShortcutKey("CtrlOrCmd+Enter")
                        ]
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("helpDialog.curvedArrow"),
                        shortcuts: [
                          "A",
                          t("helpDialog.click"),
                          t("helpDialog.click"),
                          t("helpDialog.click")
                        ],
                        isOr: false
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("helpDialog.curvedLine"),
                        shortcuts: [
                          "L",
                          t("helpDialog.click"),
                          t("helpDialog.click"),
                          t("helpDialog.click")
                        ],
                        isOr: false
                      }
                    ),
                    /* @__PURE__ */ jsx76(Shortcut, { label: t("toolBar.lock"), shortcuts: [KEYS.Q] }),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("helpDialog.preventBinding"),
                        shortcuts: [getShortcutKey("CtrlOrCmd")]
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("toolBar.link"),
                        shortcuts: [getShortcutKey("CtrlOrCmd+K")]
                      }
                    )
                  ]
                }
              ),
              /* @__PURE__ */ jsxs44(
                ShortcutIsland,
                {
                  className: "HelpDialog__island--view",
                  caption: t("helpDialog.view"),
                  children: [
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("buttons.zoomIn"),
                        shortcuts: [getShortcutKey("CtrlOrCmd++")]
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("buttons.zoomOut"),
                        shortcuts: [getShortcutKey("CtrlOrCmd+-")]
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("buttons.resetZoom"),
                        shortcuts: [getShortcutKey("CtrlOrCmd+0")]
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("helpDialog.zoomToFit"),
                        shortcuts: ["Shift+1"]
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("helpDialog.zoomToSelection"),
                        shortcuts: ["Shift+2"]
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("helpDialog.movePageUpDown"),
                        shortcuts: ["PgUp/PgDn"]
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("helpDialog.movePageLeftRight"),
                        shortcuts: ["Shift+PgUp/PgDn"]
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("buttons.zenMode"),
                        shortcuts: [getShortcutKey("Alt+Z")]
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("buttons.objectsSnapMode"),
                        shortcuts: [getShortcutKey("Alt+S")]
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("labels.showGrid"),
                        shortcuts: [getShortcutKey("CtrlOrCmd+'")]
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("labels.viewMode"),
                        shortcuts: [getShortcutKey("Alt+R")]
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("labels.toggleTheme"),
                        shortcuts: [getShortcutKey("Alt+Shift+D")]
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("stats.title"),
                        shortcuts: [getShortcutKey("Alt+/")]
                      }
                    )
                  ]
                }
              ),
              /* @__PURE__ */ jsxs44(
                ShortcutIsland,
                {
                  className: "HelpDialog__island--editor",
                  caption: t("helpDialog.editor"),
                  children: [
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("labels.moveCanvas"),
                        shortcuts: [
                          getShortcutKey(`Space+${t("helpDialog.drag")}`),
                          getShortcutKey(`Wheel+${t("helpDialog.drag")}`)
                        ],
                        isOr: true
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("buttons.clearReset"),
                        shortcuts: [getShortcutKey("CtrlOrCmd+Delete")]
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("labels.delete"),
                        shortcuts: [getShortcutKey("Delete")]
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("labels.cut"),
                        shortcuts: [getShortcutKey("CtrlOrCmd+X")]
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("labels.copy"),
                        shortcuts: [getShortcutKey("CtrlOrCmd+C")]
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("labels.paste"),
                        shortcuts: [getShortcutKey("CtrlOrCmd+V")]
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("labels.pasteAsPlaintext"),
                        shortcuts: [getShortcutKey("CtrlOrCmd+Shift+V")]
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("labels.selectAll"),
                        shortcuts: [getShortcutKey("CtrlOrCmd+A")]
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("labels.multiSelect"),
                        shortcuts: [getShortcutKey(`Shift+${t("helpDialog.click")}`)]
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("helpDialog.deepSelect"),
                        shortcuts: [getShortcutKey(`CtrlOrCmd+${t("helpDialog.click")}`)]
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("helpDialog.deepBoxSelect"),
                        shortcuts: [getShortcutKey(`CtrlOrCmd+${t("helpDialog.drag")}`)]
                      }
                    ),
                    (probablySupportsClipboardBlob || isFirefox) && /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("labels.copyAsPng"),
                        shortcuts: [getShortcutKey("Shift+Alt+C")]
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("labels.copyStyles"),
                        shortcuts: [getShortcutKey("CtrlOrCmd+Alt+C")]
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("labels.pasteStyles"),
                        shortcuts: [getShortcutKey("CtrlOrCmd+Alt+V")]
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("labels.sendToBack"),
                        shortcuts: [
                          isDarwin ? getShortcutKey("CtrlOrCmd+Alt+[") : getShortcutKey("CtrlOrCmd+Shift+[")
                        ]
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("labels.bringToFront"),
                        shortcuts: [
                          isDarwin ? getShortcutKey("CtrlOrCmd+Alt+]") : getShortcutKey("CtrlOrCmd+Shift+]")
                        ]
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("labels.sendBackward"),
                        shortcuts: [getShortcutKey("CtrlOrCmd+[")]
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("labels.bringForward"),
                        shortcuts: [getShortcutKey("CtrlOrCmd+]")]
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("labels.alignTop"),
                        shortcuts: [getShortcutKey("CtrlOrCmd+Shift+Up")]
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("labels.alignBottom"),
                        shortcuts: [getShortcutKey("CtrlOrCmd+Shift+Down")]
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("labels.alignLeft"),
                        shortcuts: [getShortcutKey("CtrlOrCmd+Shift+Left")]
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("labels.alignRight"),
                        shortcuts: [getShortcutKey("CtrlOrCmd+Shift+Right")]
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("labels.duplicateSelection"),
                        shortcuts: [
                          getShortcutKey("CtrlOrCmd+D"),
                          getShortcutKey(`Alt+${t("helpDialog.drag")}`)
                        ]
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("helpDialog.toggleElementLock"),
                        shortcuts: [getShortcutKey("CtrlOrCmd+Shift+L")]
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("buttons.undo"),
                        shortcuts: [getShortcutKey("CtrlOrCmd+Z")]
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("buttons.redo"),
                        shortcuts: isWindows ? [
                          getShortcutKey("CtrlOrCmd+Y"),
                          getShortcutKey("CtrlOrCmd+Shift+Z")
                        ] : [getShortcutKey("CtrlOrCmd+Shift+Z")]
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("labels.group"),
                        shortcuts: [getShortcutKey("CtrlOrCmd+G")]
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("labels.ungroup"),
                        shortcuts: [getShortcutKey("CtrlOrCmd+Shift+G")]
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("labels.flipHorizontal"),
                        shortcuts: [getShortcutKey("Shift+H")]
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("labels.flipVertical"),
                        shortcuts: [getShortcutKey("Shift+V")]
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("labels.showStroke"),
                        shortcuts: [getShortcutKey("S")]
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("labels.showBackground"),
                        shortcuts: [getShortcutKey("G")]
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("labels.decreaseFontSize"),
                        shortcuts: [getShortcutKey("CtrlOrCmd+Shift+<")]
                      }
                    ),
                    /* @__PURE__ */ jsx76(
                      Shortcut,
                      {
                        label: t("labels.increaseFontSize"),
                        shortcuts: [getShortcutKey("CtrlOrCmd+Shift+>")]
                      }
                    )
                  ]
                }
              )
            ] })
          ]
        }
      ) });
    };
  }
});

// components/UserList.scss
var init_UserList = __esm({
  "components/UserList.scss"() {
  }
});

// components/UserList.tsx
import React30 from "react";
import clsx34 from "clsx";
import * as Popover3 from "@radix-ui/react-popover";
import { jsx as jsx77, jsxs as jsxs45 } from "react/jsx-runtime";
var FIRST_N_AVATARS, SHOW_COLLABORATORS_FILTER_AT, ConditionalTooltipWrapper, renderCollaborator, collaboratorComparatorKeys, UserList;
var init_UserList2 = __esm({
  "components/UserList.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_UserList();
    init_Tooltip2();
    init_App();
    init_Island2();
    init_icons();
    init_i18n();
    init_utils();
    FIRST_N_AVATARS = 3;
    SHOW_COLLABORATORS_FILTER_AT = 8;
    ConditionalTooltipWrapper = ({
      shouldWrap,
      children,
      clientId,
      username
    }) => shouldWrap ? /* @__PURE__ */ jsx77(Tooltip, { label: username || "Unknown user", children }, clientId) : /* @__PURE__ */ jsx77(React30.Fragment, { children }, clientId);
    renderCollaborator = ({
      actionManager,
      collaborator,
      clientId,
      withName = false,
      shouldWrapWithTooltip = false,
      isBeingFollowed
    }) => {
      const data = {
        clientId,
        collaborator,
        withName,
        isBeingFollowed
      };
      const avatarJSX = actionManager.renderAction("goToCollaborator", data);
      return /* @__PURE__ */ jsx77(
        ConditionalTooltipWrapper,
        {
          clientId,
          username: collaborator.username,
          shouldWrap: shouldWrapWithTooltip,
          children: avatarJSX
        },
        clientId
      );
    };
    collaboratorComparatorKeys = [
      "avatarUrl",
      "id",
      "socketId",
      "username"
    ];
    UserList = React30.memo(
      ({ className, mobile, collaborators, userToFollow }) => {
        const actionManager = useExcalidrawActionManager();
        const uniqueCollaboratorsMap = /* @__PURE__ */ new Map();
        collaborators.forEach((collaborator, socketId) => {
          const userId = collaborator.id || socketId;
          uniqueCollaboratorsMap.set(
            // filter on user id, else fall back on unique socketId
            userId,
            { ...collaborator, socketId }
          );
        });
        const uniqueCollaboratorsArray = Array.from(uniqueCollaboratorsMap).filter(
          ([_, collaborator]) => collaborator.username?.trim()
        );
        const [searchTerm, setSearchTerm] = React30.useState("");
        if (uniqueCollaboratorsArray.length === 0) {
          return null;
        }
        const searchTermNormalized = searchTerm.trim().toLowerCase();
        const filteredCollaborators = searchTermNormalized ? uniqueCollaboratorsArray.filter(
          ([, collaborator]) => collaborator.username?.toLowerCase().includes(searchTerm)
        ) : uniqueCollaboratorsArray;
        const firstNCollaborators = uniqueCollaboratorsArray.slice(
          0,
          FIRST_N_AVATARS
        );
        const firstNAvatarsJSX = firstNCollaborators.map(
          ([clientId, collaborator]) => renderCollaborator({
            actionManager,
            collaborator,
            clientId,
            shouldWrapWithTooltip: true,
            isBeingFollowed: collaborator.socketId === userToFollow
          })
        );
        return mobile ? /* @__PURE__ */ jsx77("div", { className: clsx34("UserList UserList_mobile", className), children: uniqueCollaboratorsArray.map(
          ([clientId, collaborator]) => renderCollaborator({
            actionManager,
            collaborator,
            clientId,
            shouldWrapWithTooltip: true,
            isBeingFollowed: collaborator.socketId === userToFollow
          })
        ) }) : /* @__PURE__ */ jsxs45("div", { className: clsx34("UserList", className), children: [
          firstNAvatarsJSX,
          uniqueCollaboratorsArray.length > FIRST_N_AVATARS && /* @__PURE__ */ jsxs45(
            Popover3.Root,
            {
              onOpenChange: (isOpen) => {
                if (!isOpen) {
                  setSearchTerm("");
                }
              },
              children: [
                /* @__PURE__ */ jsxs45(Popover3.Trigger, { className: "UserList__more", children: [
                  "+",
                  uniqueCollaboratorsArray.length - FIRST_N_AVATARS
                ] }),
                /* @__PURE__ */ jsx77(
                  Popover3.Content,
                  {
                    style: {
                      zIndex: 2,
                      width: "13rem",
                      textAlign: "left"
                    },
                    align: "end",
                    sideOffset: 10,
                    children: /* @__PURE__ */ jsxs45(Island, { style: { overflow: "hidden" }, children: [
                      uniqueCollaboratorsArray.length >= SHOW_COLLABORATORS_FILTER_AT && /* @__PURE__ */ jsxs45("div", { className: "UserList__search-wrapper", children: [
                        searchIcon,
                        /* @__PURE__ */ jsx77(
                          "input",
                          {
                            className: "UserList__search",
                            type: "text",
                            placeholder: t("userList.search.placeholder"),
                            value: searchTerm,
                            onChange: (e) => {
                              setSearchTerm(e.target.value);
                            }
                          }
                        )
                      ] }),
                      /* @__PURE__ */ jsxs45("div", { className: "dropdown-menu UserList__collaborators", children: [
                        filteredCollaborators.length === 0 && /* @__PURE__ */ jsx77("div", { className: "UserList__collaborators__empty", children: t("userList.search.empty") }),
                        /* @__PURE__ */ jsx77("div", { className: "UserList__hint", children: t("userList.hint.text") }),
                        filteredCollaborators.map(
                          ([clientId, collaborator]) => renderCollaborator({
                            actionManager,
                            collaborator,
                            clientId,
                            withName: true,
                            isBeingFollowed: collaborator.socketId === userToFollow
                          })
                        )
                      ] })
                    ] })
                  }
                )
              ]
            }
          )
        ] });
      },
      (prev, next) => {
        if (prev.collaborators.size !== next.collaborators.size || prev.mobile !== next.mobile || prev.className !== next.className || prev.userToFollow !== next.userToFollow) {
          return false;
        }
        for (const [socketId, collaborator] of prev.collaborators) {
          const nextCollaborator = next.collaborators.get(socketId);
          if (!nextCollaborator || !isShallowEqual(
            collaborator,
            nextCollaborator,
            collaboratorComparatorKeys
          )) {
            return false;
          }
        }
        return true;
      }
    );
  }
});

// components/Card.scss
var init_Card = __esm({
  "components/Card.scss"() {
  }
});

// components/Card.tsx
import OpenColor3 from "open-color";
import { jsx as jsx78 } from "react/jsx-runtime";
var Card;
var init_Card2 = __esm({
  "components/Card.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_Card();
    Card = ({ children, color }) => {
      return /* @__PURE__ */ jsx78(
        "div",
        {
          className: "Card",
          style: {
            ["--card-color"]: color === "primary" ? "var(--color-primary)" : OpenColor3[color][7],
            ["--card-color-darker"]: color === "primary" ? "var(--color-primary-darker)" : OpenColor3[color][8],
            ["--card-color-darkest"]: color === "primary" ? "var(--color-primary-darkest)" : OpenColor3[color][9]
          },
          children
        }
      );
    };
  }
});

// components/ExportDialog.scss
var init_ExportDialog = __esm({
  "components/ExportDialog.scss"() {
  }
});

// components/JSONExportDialog.tsx
import React31 from "react";
import { Fragment as Fragment16, jsx as jsx79, jsxs as jsxs46 } from "react/jsx-runtime";
var JSONExportModal, JSONExportDialog;
var init_JSONExportDialog = __esm({
  "components/JSONExportDialog.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_i18n();
    init_Dialog2();
    init_icons();
    init_ToolButton();
    init_actionExport();
    init_Card2();
    init_ExportDialog();
    init_filesystem();
    init_analytics();
    init_utils();
    JSONExportModal = ({
      elements,
      appState,
      setAppState,
      files,
      actionManager,
      exportOpts,
      canvas: canvas2,
      onCloseRequest
    }) => {
      const { onExportToBackend } = exportOpts;
      return /* @__PURE__ */ jsx79("div", { className: "ExportDialog ExportDialog--json", children: /* @__PURE__ */ jsxs46("div", { className: "ExportDialog-cards", children: [
        exportOpts.saveFileToDisk && /* @__PURE__ */ jsxs46(Card, { color: "lime", children: [
          /* @__PURE__ */ jsx79("div", { className: "Card-icon", children: exportToFileIcon }),
          /* @__PURE__ */ jsx79("h2", { children: t("exportDialog.disk_title") }),
          /* @__PURE__ */ jsxs46("div", { className: "Card-details", children: [
            t("exportDialog.disk_details"),
            !nativeFileSystemSupported && actionManager.renderAction("changeProjectName")
          ] }),
          /* @__PURE__ */ jsx79(
            ToolButton,
            {
              className: "Card-button",
              type: "button",
              title: t("exportDialog.disk_button"),
              "aria-label": t("exportDialog.disk_button"),
              showAriaLabel: true,
              onClick: () => {
                actionManager.executeAction(actionSaveFileToDisk, "ui");
              }
            }
          )
        ] }),
        onExportToBackend && /* @__PURE__ */ jsxs46(Card, { color: "pink", children: [
          /* @__PURE__ */ jsx79("div", { className: "Card-icon", children: LinkIcon }),
          /* @__PURE__ */ jsx79("h2", { children: t("exportDialog.link_title") }),
          /* @__PURE__ */ jsx79("div", { className: "Card-details", children: t("exportDialog.link_details") }),
          /* @__PURE__ */ jsx79(
            ToolButton,
            {
              className: "Card-button",
              type: "button",
              title: t("exportDialog.link_button"),
              "aria-label": t("exportDialog.link_button"),
              showAriaLabel: true,
              onClick: async () => {
                try {
                  trackEvent("export", "link", `ui (${getFrame()})`);
                  await onExportToBackend(elements, appState, files);
                  onCloseRequest();
                } catch (error) {
                  setAppState({ errorMessage: error.message });
                }
              }
            }
          )
        ] }),
        exportOpts.renderCustomUI && exportOpts.renderCustomUI(elements, appState, files, canvas2)
      ] }) });
    };
    JSONExportDialog = ({
      elements,
      appState,
      files,
      actionManager,
      exportOpts,
      canvas: canvas2,
      setAppState
    }) => {
      const handleClose = React31.useCallback(() => {
        setAppState({ openDialog: null });
      }, [setAppState]);
      return /* @__PURE__ */ jsx79(Fragment16, { children: appState.openDialog?.name === "jsonExport" && /* @__PURE__ */ jsx79(Dialog, { onCloseRequest: handleClose, title: t("buttons.export"), children: /* @__PURE__ */ jsx79(
        JSONExportModal,
        {
          elements,
          appState,
          setAppState,
          files,
          actionManager,
          onCloseRequest: handleClose,
          exportOpts,
          canvas: canvas2
        }
      ) }) });
    };
  }
});

// components/HelpButton.tsx
import { jsx as jsx80 } from "react/jsx-runtime";
var HelpButton;
var init_HelpButton = __esm({
  "components/HelpButton.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_i18n();
    init_icons();
    HelpButton = (props) => /* @__PURE__ */ jsx80(
      "button",
      {
        className: "help-icon",
        onClick: props.onClick,
        type: "button",
        title: `${t("helpDialog.title")} \u2014 ?`,
        "aria-label": t("helpDialog.title"),
        children: HelpIcon
      }
    );
  }
});

// components/footer/Footer.tsx
import clsx35 from "clsx";
import { jsx as jsx81, jsxs as jsxs47 } from "react/jsx-runtime";
var Footer, Footer_default;
var init_Footer = __esm({
  "components/footer/Footer.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_actions();
    init_Actions2();
    init_App();
    init_tunnels();
    init_HelpButton();
    init_Section();
    init_Stack2();
    Footer = ({
      appState,
      actionManager,
      showExitZenModeBtn,
      renderWelcomeScreen
    }) => {
      const { FooterCenterTunnel, WelcomeScreenHelpHintTunnel } = useTunnels();
      const device = useDevice();
      const showFinalize = !appState.viewModeEnabled && appState.multiElement && device.isTouchScreen;
      return /* @__PURE__ */ jsxs47(
        "footer",
        {
          role: "contentinfo",
          className: "layer-ui__wrapper__footer App-menu App-menu_bottom",
          children: [
            /* @__PURE__ */ jsx81(
              "div",
              {
                className: clsx35("layer-ui__wrapper__footer-left zen-mode-transition", {
                  "layer-ui__wrapper__footer-left--transition-left": appState.zenModeEnabled
                }),
                children: /* @__PURE__ */ jsx81(Stack_default.Col, { gap: 2, children: /* @__PURE__ */ jsxs47(Section, { heading: "canvasActions", children: [
                  /* @__PURE__ */ jsx81(
                    ZoomActions,
                    {
                      renderAction: actionManager.renderAction,
                      zoom: appState.zoom
                    }
                  ),
                  !appState.viewModeEnabled && /* @__PURE__ */ jsx81(
                    UndoRedoActions,
                    {
                      renderAction: actionManager.renderAction,
                      className: clsx35("zen-mode-transition", {
                        "layer-ui__wrapper__footer-left--transition-bottom": appState.zenModeEnabled
                      })
                    }
                  ),
                  showFinalize && /* @__PURE__ */ jsx81(
                    FinalizeAction,
                    {
                      renderAction: actionManager.renderAction,
                      className: clsx35("zen-mode-transition", {
                        "layer-ui__wrapper__footer-left--transition-left": appState.zenModeEnabled
                      })
                    }
                  )
                ] }) })
              }
            ),
            /* @__PURE__ */ jsx81(FooterCenterTunnel.Out, {}),
            /* @__PURE__ */ jsx81(
              "div",
              {
                className: clsx35("layer-ui__wrapper__footer-right zen-mode-transition", {
                  "transition-right": appState.zenModeEnabled
                }),
                children: /* @__PURE__ */ jsxs47("div", { style: { position: "relative" }, children: [
                  renderWelcomeScreen && /* @__PURE__ */ jsx81(WelcomeScreenHelpHintTunnel.Out, {}),
                  /* @__PURE__ */ jsx81(
                    HelpButton,
                    {
                      onClick: () => actionManager.executeAction(actionShortcuts)
                    }
                  )
                ] })
              }
            ),
            /* @__PURE__ */ jsx81(
              ExitZenModeAction,
              {
                actionManager,
                showExitZenModeBtn
              }
            )
          ]
        }
      );
    };
    Footer_default = Footer;
    Footer.displayName = "Footer";
  }
});

// components/Sidebar/common.ts
import React32 from "react";
var SidebarPropsContext;
var init_common2 = __esm({
  "components/Sidebar/common.ts"() {
    "use strict";
    init_define_import_meta_env();
    SidebarPropsContext = React32.createContext({});
  }
});

// components/Button.scss
var init_Button = __esm({
  "components/Button.scss"() {
  }
});

// components/Button.tsx
import clsx36 from "clsx";
import { jsx as jsx82 } from "react/jsx-runtime";
var Button;
var init_Button2 = __esm({
  "components/Button.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_utils();
    init_Button();
    Button = ({
      type = "button",
      onSelect,
      selected,
      children,
      className = "",
      ...rest
    }) => {
      return /* @__PURE__ */ jsx82(
        "button",
        {
          onClick: composeEventHandlers(rest.onClick, (event) => {
            onSelect();
          }),
          type,
          className: clsx36("excalidraw-button", className, { selected }),
          ...rest,
          children
        }
      );
    };
  }
});

// components/Sidebar/SidebarHeader.tsx
import clsx37 from "clsx";
import { useContext as useContext2 } from "react";
import { jsx as jsx83, jsxs as jsxs48 } from "react/jsx-runtime";
var SidebarHeader;
var init_SidebarHeader = __esm({
  "components/Sidebar/SidebarHeader.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_i18n();
    init_App();
    init_common2();
    init_icons();
    init_Tooltip2();
    init_Button2();
    SidebarHeader = ({
      children,
      className
    }) => {
      const device = useDevice();
      const props = useContext2(SidebarPropsContext);
      const renderDockButton = !!(device.editor.canFitSidebar && props.shouldRenderDockButton);
      return /* @__PURE__ */ jsxs48(
        "div",
        {
          className: clsx37("sidebar__header", className),
          "data-testid": "sidebar-header",
          children: [
            children,
            /* @__PURE__ */ jsxs48("div", { className: "sidebar__header__buttons", children: [
              renderDockButton && /* @__PURE__ */ jsx83(Tooltip, { label: t("labels.sidebarLock"), children: /* @__PURE__ */ jsx83(
                Button,
                {
                  onSelect: () => props.onDock?.(!props.docked),
                  selected: !!props.docked,
                  className: "sidebar__dock",
                  "data-testid": "sidebar-dock",
                  "aria-label": t("labels.sidebarLock"),
                  children: PinIcon
                }
              ) }),
              /* @__PURE__ */ jsx83(
                Button,
                {
                  "data-testid": "sidebar-close",
                  className: "sidebar__close",
                  onSelect: props.onCloseRequest,
                  "aria-label": t("buttons.close"),
                  children: CloseIcon
                }
              )
            ] })
          ]
        }
      );
    };
    SidebarHeader.displayName = "SidebarHeader";
  }
});

// components/Sidebar/SidebarTrigger.scss
var init_SidebarTrigger = __esm({
  "components/Sidebar/SidebarTrigger.scss"() {
  }
});

// components/Sidebar/SidebarTrigger.tsx
import clsx38 from "clsx";
import { jsx as jsx84, jsxs as jsxs49 } from "react/jsx-runtime";
var SidebarTrigger;
var init_SidebarTrigger2 = __esm({
  "components/Sidebar/SidebarTrigger.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_App();
    init_ui_appState();
    init_SidebarTrigger();
    SidebarTrigger = ({
      name,
      tab,
      icon,
      title,
      children,
      onToggle,
      className,
      style
    }) => {
      const setAppState = useExcalidrawSetAppState();
      const appState = useUIAppState();
      return /* @__PURE__ */ jsxs49("label", { title, className: "sidebar-trigger__label-element", children: [
        /* @__PURE__ */ jsx84(
          "input",
          {
            className: "ToolIcon_type_checkbox",
            type: "checkbox",
            onChange: (event) => {
              document.querySelector(".layer-ui__wrapper")?.classList.remove("animate");
              const isOpen = event.target.checked;
              setAppState({ openSidebar: isOpen ? { name, tab } : null });
              onToggle?.(isOpen);
            },
            checked: appState.openSidebar?.name === name,
            "aria-label": title,
            "aria-keyshortcuts": "0"
          }
        ),
        /* @__PURE__ */ jsxs49("div", { className: clsx38("sidebar-trigger", className), style, children: [
          icon && /* @__PURE__ */ jsx84("div", { children: icon }),
          children && /* @__PURE__ */ jsx84("div", { className: "sidebar-trigger__label", children })
        ] })
      ] });
    };
    SidebarTrigger.displayName = "SidebarTrigger";
  }
});

// components/Sidebar/SidebarTabTriggers.tsx
import * as RadixTabs from "@radix-ui/react-tabs";
import { jsx as jsx85 } from "react/jsx-runtime";
var SidebarTabTriggers;
var init_SidebarTabTriggers = __esm({
  "components/Sidebar/SidebarTabTriggers.tsx"() {
    "use strict";
    init_define_import_meta_env();
    SidebarTabTriggers = ({
      children,
      ...rest
    }) => {
      return /* @__PURE__ */ jsx85(RadixTabs.List, { className: "sidebar-triggers", ...rest, children });
    };
    SidebarTabTriggers.displayName = "SidebarTabTriggers";
  }
});

// components/Sidebar/SidebarTabTrigger.tsx
import * as RadixTabs2 from "@radix-ui/react-tabs";
import { jsx as jsx86 } from "react/jsx-runtime";
var SidebarTabTrigger;
var init_SidebarTabTrigger = __esm({
  "components/Sidebar/SidebarTabTrigger.tsx"() {
    "use strict";
    init_define_import_meta_env();
    SidebarTabTrigger = ({
      children,
      tab,
      onSelect,
      ...rest
    }) => {
      return /* @__PURE__ */ jsx86(RadixTabs2.Trigger, { value: tab, asChild: true, onSelect, children: /* @__PURE__ */ jsx86(
        "button",
        {
          type: "button",
          className: `excalidraw-button sidebar-tab-trigger`,
          ...rest,
          children
        }
      ) });
    };
    SidebarTabTrigger.displayName = "SidebarTabTrigger";
  }
});

// components/Sidebar/SidebarTabs.tsx
import * as RadixTabs3 from "@radix-ui/react-tabs";
import { jsx as jsx87 } from "react/jsx-runtime";
var SidebarTabs;
var init_SidebarTabs = __esm({
  "components/Sidebar/SidebarTabs.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_ui_appState();
    init_App();
    SidebarTabs = ({
      children,
      ...rest
    }) => {
      const appState = useUIAppState();
      const setAppState = useExcalidrawSetAppState();
      if (!appState.openSidebar) {
        return null;
      }
      const { name } = appState.openSidebar;
      return /* @__PURE__ */ jsx87(
        RadixTabs3.Root,
        {
          className: "sidebar-tabs-root",
          value: appState.openSidebar.tab,
          onValueChange: (tab) => setAppState((state) => ({
            ...state,
            openSidebar: { ...state.openSidebar, name, tab }
          })),
          ...rest,
          children
        }
      );
    };
    SidebarTabs.displayName = "SidebarTabs";
  }
});

// components/Sidebar/SidebarTab.tsx
import * as RadixTabs4 from "@radix-ui/react-tabs";
import { jsx as jsx88 } from "react/jsx-runtime";
var SidebarTab;
var init_SidebarTab = __esm({
  "components/Sidebar/SidebarTab.tsx"() {
    "use strict";
    init_define_import_meta_env();
    SidebarTab = ({
      tab,
      children,
      ...rest
    }) => {
      return /* @__PURE__ */ jsx88(RadixTabs4.Content, { ...rest, value: tab, children });
    };
    SidebarTab.displayName = "SidebarTab";
  }
});

// components/Sidebar/Sidebar.scss
var init_Sidebar = __esm({
  "components/Sidebar/Sidebar.scss"() {
  }
});

// components/Sidebar/Sidebar.tsx
import {
  useEffect as useEffect23,
  useLayoutEffect as useLayoutEffect6,
  useRef as useRef19,
  useState as useState24,
  forwardRef as forwardRef3,
  useImperativeHandle,
  useCallback as useCallback9
} from "react";
import { atom as atom8, useSetAtom as useSetAtom3 } from "jotai";
import clsx39 from "clsx";
import { jsx as jsx89 } from "react/jsx-runtime";
import { createElement } from "react";
var isSidebarDockedAtom, SidebarInner, Sidebar;
var init_Sidebar2 = __esm({
  "components/Sidebar/Sidebar.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_Island2();
    init_jotai();
    init_common2();
    init_SidebarHeader();
    init_App();
    init_utils();
    init_keys();
    init_constants();
    init_SidebarTrigger2();
    init_SidebarTabTriggers();
    init_SidebarTabTrigger();
    init_SidebarTabs();
    init_SidebarTab();
    init_ui_appState();
    init_useOutsideClick();
    init_Sidebar();
    isSidebarDockedAtom = atom8(false);
    SidebarInner = forwardRef3(
      ({
        name,
        children,
        onDock,
        docked,
        className,
        ...rest
      }, ref) => {
        if (define_import_meta_env_default.DEV && onDock && docked == null) {
          console.warn(
            "Sidebar: `docked` must be set when `onDock` is supplied for the sidebar to be user-dockable. To hide this message, either pass `docked` or remove `onDock`"
          );
        }
        const setAppState = useExcalidrawSetAppState();
        const setIsSidebarDockedAtom = useSetAtom3(isSidebarDockedAtom, jotaiScope);
        useLayoutEffect6(() => {
          setIsSidebarDockedAtom(!!docked);
          return () => {
            setIsSidebarDockedAtom(false);
          };
        }, [setIsSidebarDockedAtom, docked]);
        const headerPropsRef = useRef19(
          {}
        );
        headerPropsRef.current.onCloseRequest = () => {
          setAppState({ openSidebar: null });
        };
        headerPropsRef.current.onDock = (isDocked) => onDock?.(isDocked);
        headerPropsRef.current = updateObject(headerPropsRef.current, {
          docked,
          // explicit prop to rerender on update
          shouldRenderDockButton: !!onDock && docked != null
        });
        const islandRef = useRef19(null);
        useImperativeHandle(ref, () => {
          return islandRef.current;
        });
        const device = useDevice();
        const closeLibrary = useCallback9(() => {
          const isDialogOpen = !!document.querySelector(".Dialog");
          if (isDialogOpen) {
            return;
          }
          setAppState({ openSidebar: null });
        }, [setAppState]);
        useOutsideClick(
          islandRef,
          useCallback9(
            (event) => {
              if (event.target.closest(".sidebar-trigger")) {
                return;
              }
              if (!docked || !device.editor.canFitSidebar) {
                closeLibrary();
              }
            },
            [closeLibrary, docked, device.editor.canFitSidebar]
          )
        );
        useEffect23(() => {
          const handleKeyDown = (event) => {
            if (event.key === KEYS.ESCAPE && (!docked || !device.editor.canFitSidebar)) {
              closeLibrary();
            }
          };
          document.addEventListener("keydown" /* KEYDOWN */, handleKeyDown);
          return () => {
            document.removeEventListener("keydown" /* KEYDOWN */, handleKeyDown);
          };
        }, [closeLibrary, docked, device.editor.canFitSidebar]);
        return /* @__PURE__ */ jsx89(
          Island,
          {
            ...rest,
            className: clsx39("sidebar", { "sidebar--docked": docked }, className),
            ref: islandRef,
            children: /* @__PURE__ */ jsx89(SidebarPropsContext.Provider, { value: headerPropsRef.current, children })
          }
        );
      }
    );
    SidebarInner.displayName = "SidebarInner";
    Sidebar = Object.assign(
      forwardRef3((props, ref) => {
        const appState = useUIAppState();
        const { onStateChange } = props;
        const refPrevOpenSidebar = useRef19(appState.openSidebar);
        useEffect23(() => {
          if (
            // closing sidebar
            (!appState.openSidebar && refPrevOpenSidebar?.current?.name === props.name || // opening current sidebar
            appState.openSidebar?.name === props.name && refPrevOpenSidebar?.current?.name !== props.name || // switching tabs or switching to a different sidebar
            refPrevOpenSidebar.current?.name === props.name) && appState.openSidebar !== refPrevOpenSidebar.current
          ) {
            onStateChange?.(
              appState.openSidebar?.name !== props.name ? null : appState.openSidebar
            );
          }
          refPrevOpenSidebar.current = appState.openSidebar;
        }, [appState.openSidebar, onStateChange, props.name]);
        const [mounted, setMounted] = useState24(false);
        useLayoutEffect6(() => {
          setMounted(true);
          return () => setMounted(false);
        }, []);
        const shouldRender = mounted && appState.openSidebar?.name === props.name;
        if (!shouldRender) {
          return null;
        }
        return /* @__PURE__ */ createElement(SidebarInner, { ...props, ref, key: props.name });
      }),
      {
        Header: SidebarHeader,
        TabTriggers: SidebarTabTriggers,
        TabTrigger: SidebarTabTrigger,
        Tabs: SidebarTabs,
        Tab: SidebarTab,
        Trigger: SidebarTrigger
      }
    );
    Sidebar.displayName = "Sidebar";
  }
});

// components/main-menu/DefaultItems.scss
var init_DefaultItems = __esm({
  "components/main-menu/DefaultItems.scss"() {
  }
});

// components/ActiveConfirmDialog.tsx
import { atom as atom9, useAtom as useAtom12 } from "jotai";
import { jsx as jsx90, jsxs as jsxs50 } from "react/jsx-runtime";
var activeConfirmDialogAtom, ActiveConfirmDialog;
var init_ActiveConfirmDialog = __esm({
  "components/ActiveConfirmDialog.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_actions();
    init_i18n();
    init_jotai();
    init_App();
    init_ConfirmDialog2();
    activeConfirmDialogAtom = atom9(null);
    ActiveConfirmDialog = () => {
      const [activeConfirmDialog, setActiveConfirmDialog] = useAtom12(
        activeConfirmDialogAtom,
        jotaiScope
      );
      const actionManager = useExcalidrawActionManager();
      if (!activeConfirmDialog) {
        return null;
      }
      if (activeConfirmDialog === "clearCanvas") {
        return /* @__PURE__ */ jsx90(
          ConfirmDialog_default,
          {
            onConfirm: () => {
              actionManager.executeAction(actionClearCanvas);
              setActiveConfirmDialog(null);
            },
            onCancel: () => setActiveConfirmDialog(null),
            title: t("clearCanvasDialog.title"),
            children: /* @__PURE__ */ jsxs50("p", { className: "clear-canvas__content", children: [
              " ",
              t("alerts.clearReset")
            ] })
          }
        );
      }
      return null;
    };
  }
});

// components/OverwriteConfirm/OverwriteConfirmState.ts
import { atom as atom10 } from "jotai";
async function openConfirmModal({
  title,
  description,
  actionLabel,
  color
}) {
  return new Promise((resolve) => {
    jotaiStore.set(overwriteConfirmStateAtom, {
      active: true,
      onConfirm: () => resolve(true),
      onClose: () => resolve(false),
      onReject: () => resolve(false),
      title,
      description,
      actionLabel,
      color
    });
  });
}
var overwriteConfirmStateAtom;
var init_OverwriteConfirmState = __esm({
  "components/OverwriteConfirm/OverwriteConfirmState.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_jotai();
    overwriteConfirmStateAtom = atom10({
      active: false
    });
  }
});

// components/main-menu/DefaultItems.tsx
var DefaultItems_exports = {};
__export(DefaultItems_exports, {
  ChangeCanvasBackground: () => ChangeCanvasBackground,
  ClearCanvas: () => ClearCanvas,
  Export: () => Export,
  Help: () => Help,
  LiveCollaborationTrigger: () => LiveCollaborationTrigger,
  LoadScene: () => LoadScene,
  SaveAsImage: () => SaveAsImage,
  SaveToActiveFile: () => SaveToActiveFile,
  Socials: () => Socials,
  ToggleTheme: () => ToggleTheme
});
import clsx40 from "clsx";
import { useSetAtom as useSetAtom4 } from "jotai";
import { Fragment as Fragment17, jsx as jsx91, jsxs as jsxs51 } from "react/jsx-runtime";
var LoadScene, SaveToActiveFile, SaveAsImage, Help, ClearCanvas, ToggleTheme, ChangeCanvasBackground, Export, Socials, LiveCollaborationTrigger;
var init_DefaultItems2 = __esm({
  "components/main-menu/DefaultItems.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_shortcuts();
    init_i18n();
    init_App();
    init_icons();
    init_icons();
    init_DropdownMenuItem();
    init_DropdownMenuItemLink();
    init_actions();
    init_DefaultItems();
    init_ActiveConfirmDialog();
    init_jotai();
    init_ui_appState();
    init_OverwriteConfirmState();
    init_Trans();
    LoadScene = () => {
      const { t: t2 } = useI18n();
      const actionManager = useExcalidrawActionManager();
      const elements = useExcalidrawElements();
      if (!actionManager.isActionEnabled(actionLoadScene)) {
        return null;
      }
      const handleSelect = async () => {
        if (!elements.length || await openConfirmModal({
          title: t2("overwriteConfirm.modal.loadFromFile.title"),
          actionLabel: t2("overwriteConfirm.modal.loadFromFile.button"),
          color: "warning",
          description: /* @__PURE__ */ jsx91(
            Trans_default,
            {
              i18nKey: "overwriteConfirm.modal.loadFromFile.description",
              bold: (text) => /* @__PURE__ */ jsx91("strong", { children: text }),
              br: () => /* @__PURE__ */ jsx91("br", {})
            }
          )
        })) {
          actionManager.executeAction(actionLoadScene);
        }
      };
      return /* @__PURE__ */ jsx91(
        DropdownMenuItem_default,
        {
          icon: LoadIcon,
          onSelect: handleSelect,
          "data-testid": "load-button",
          shortcut: getShortcutFromShortcutName("loadScene"),
          "aria-label": t2("buttons.load"),
          children: t2("buttons.load")
        }
      );
    };
    LoadScene.displayName = "LoadScene";
    SaveToActiveFile = () => {
      const { t: t2 } = useI18n();
      const actionManager = useExcalidrawActionManager();
      if (!actionManager.isActionEnabled(actionSaveToActiveFile)) {
        return null;
      }
      return /* @__PURE__ */ jsx91(
        DropdownMenuItem_default,
        {
          shortcut: getShortcutFromShortcutName("saveScene"),
          "data-testid": "save-button",
          onSelect: () => actionManager.executeAction(actionSaveToActiveFile),
          icon: save,
          "aria-label": `${t2("buttons.save")}`,
          children: `${t2("buttons.save")}`
        }
      );
    };
    SaveToActiveFile.displayName = "SaveToActiveFile";
    SaveAsImage = () => {
      const setAppState = useExcalidrawSetAppState();
      const { t: t2 } = useI18n();
      return /* @__PURE__ */ jsx91(
        DropdownMenuItem_default,
        {
          icon: ExportImageIcon,
          "data-testid": "image-export-button",
          onSelect: () => setAppState({ openDialog: { name: "imageExport" } }),
          shortcut: getShortcutFromShortcutName("imageExport"),
          "aria-label": t2("buttons.exportImage"),
          children: t2("buttons.exportImage")
        }
      );
    };
    SaveAsImage.displayName = "SaveAsImage";
    Help = () => {
      const { t: t2 } = useI18n();
      const actionManager = useExcalidrawActionManager();
      return /* @__PURE__ */ jsx91(
        DropdownMenuItem_default,
        {
          "data-testid": "help-menu-item",
          icon: HelpIcon,
          onSelect: () => actionManager.executeAction(actionShortcuts),
          shortcut: "?",
          "aria-label": t2("helpDialog.title"),
          children: t2("helpDialog.title")
        }
      );
    };
    Help.displayName = "Help";
    ClearCanvas = () => {
      const { t: t2 } = useI18n();
      const setActiveConfirmDialog = useSetAtom4(
        activeConfirmDialogAtom,
        jotaiScope
      );
      const actionManager = useExcalidrawActionManager();
      if (!actionManager.isActionEnabled(actionClearCanvas)) {
        return null;
      }
      return /* @__PURE__ */ jsx91(
        DropdownMenuItem_default,
        {
          icon: TrashIcon,
          onSelect: () => setActiveConfirmDialog("clearCanvas"),
          "data-testid": "clear-canvas-button",
          "aria-label": t2("buttons.clearReset"),
          children: t2("buttons.clearReset")
        }
      );
    };
    ClearCanvas.displayName = "ClearCanvas";
    ToggleTheme = () => {
      const { t: t2 } = useI18n();
      const appState = useUIAppState();
      const actionManager = useExcalidrawActionManager();
      if (!actionManager.isActionEnabled(actionToggleTheme)) {
        return null;
      }
      return /* @__PURE__ */ jsx91(
        DropdownMenuItem_default,
        {
          onSelect: (event) => {
            event.preventDefault();
            return actionManager.executeAction(actionToggleTheme);
          },
          icon: appState.theme === "dark" ? SunIcon : MoonIcon,
          "data-testid": "toggle-dark-mode",
          shortcut: getShortcutFromShortcutName("toggleTheme"),
          "aria-label": appState.theme === "dark" ? t2("buttons.lightMode") : t2("buttons.darkMode"),
          children: appState.theme === "dark" ? t2("buttons.lightMode") : t2("buttons.darkMode")
        }
      );
    };
    ToggleTheme.displayName = "ToggleTheme";
    ChangeCanvasBackground = () => {
      const { t: t2 } = useI18n();
      const appState = useUIAppState();
      const actionManager = useExcalidrawActionManager();
      const appProps = useAppProps();
      if (appState.viewModeEnabled || !appProps.UIOptions.canvasActions.changeViewBackgroundColor) {
        return null;
      }
      return /* @__PURE__ */ jsxs51("div", { style: { marginTop: "0.5rem" }, children: [
        /* @__PURE__ */ jsx91(
          "div",
          {
            "data-testid": "canvas-background-label",
            style: { fontSize: ".75rem", marginBottom: ".5rem" },
            children: t2("labels.canvasBackground")
          }
        ),
        /* @__PURE__ */ jsx91("div", { style: { padding: "0 0.625rem" }, children: actionManager.renderAction("changeViewBackgroundColor") })
      ] });
    };
    ChangeCanvasBackground.displayName = "ChangeCanvasBackground";
    Export = () => {
      const { t: t2 } = useI18n();
      const setAppState = useExcalidrawSetAppState();
      return /* @__PURE__ */ jsx91(
        DropdownMenuItem_default,
        {
          icon: ExportIcon,
          onSelect: () => {
            setAppState({ openDialog: { name: "jsonExport" } });
          },
          "data-testid": "json-export-button",
          "aria-label": t2("buttons.export"),
          children: t2("buttons.export")
        }
      );
    };
    Export.displayName = "Export";
    Socials = () => {
      const { t: t2 } = useI18n();
      return /* @__PURE__ */ jsxs51(Fragment17, { children: [
        /* @__PURE__ */ jsx91(
          DropdownMenuItemLink_default,
          {
            icon: GithubIcon,
            href: "https://github.com/excalidraw/excalidraw",
            "aria-label": "GitHub",
            children: "GitHub"
          }
        ),
        /* @__PURE__ */ jsx91(
          DropdownMenuItemLink_default,
          {
            icon: XBrandIcon,
            href: "https://x.com/excalidraw",
            "aria-label": "X",
            children: t2("labels.followUs")
          }
        ),
        /* @__PURE__ */ jsx91(
          DropdownMenuItemLink_default,
          {
            icon: DiscordIcon,
            href: "https://discord.gg/UexuTaE",
            "aria-label": "Discord",
            children: t2("labels.discordChat")
          }
        )
      ] });
    };
    Socials.displayName = "Socials";
    LiveCollaborationTrigger = ({
      onSelect,
      isCollaborating
    }) => {
      const { t: t2 } = useI18n();
      return /* @__PURE__ */ jsx91(
        DropdownMenuItem_default,
        {
          "data-testid": "collab-button",
          icon: usersIcon,
          className: clsx40({
            "active-collab": isCollaborating
          }),
          onSelect,
          children: t2("labels.liveCollaboration")
        }
      );
    };
    LiveCollaborationTrigger.displayName = "LiveCollaborationTrigger";
  }
});

// components/hoc/withInternalFallback.tsx
import { atom as atom11, useAtom as useAtom13 } from "jotai";
import { useLayoutEffect as useLayoutEffect7, useRef as useRef20 } from "react";
import { jsx as jsx92 } from "react/jsx-runtime";
var withInternalFallback;
var init_withInternalFallback = __esm({
  "components/hoc/withInternalFallback.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_tunnels();
    withInternalFallback = (componentName, Component) => {
      const renderAtom = atom11(0);
      const WrapperComponent = (props) => {
        const { jotaiScope: jotaiScope2 } = useTunnels();
        const [, setCounter] = useAtom13(renderAtom, jotaiScope2);
        const metaRef = useRef20({
          // flag set on initial render to tell the fallback component to skip the
          // render until mount counter are initialized. This is because the counter
          // is initialized in an effect, and thus we could end rendering both
          // components at the same time until counter is initialized.
          preferHost: false,
          counter: 0
        });
        useLayoutEffect7(() => {
          const meta = metaRef.current;
          setCounter((c) => {
            const next = c + 1;
            meta.counter = next;
            return next;
          });
          return () => {
            setCounter((c) => {
              const next = c - 1;
              meta.counter = next;
              if (!next) {
                meta.preferHost = false;
              }
              return next;
            });
          };
        }, [setCounter]);
        if (!props.__fallback) {
          metaRef.current.preferHost = true;
        }
        if (
          // either before the counters are initialized
          !metaRef.current.counter && props.__fallback && metaRef.current.preferHost || // or after the counters are initialized, and both are rendered
          // (this is the default when host renders as well)
          metaRef.current.counter > 1 && props.__fallback
        ) {
          return null;
        }
        return /* @__PURE__ */ jsx92(Component, { ...props });
      };
      WrapperComponent.displayName = componentName;
      return WrapperComponent;
    };
  }
});

// components/main-menu/MainMenu.tsx
import { jsx as jsx93, jsxs as jsxs52 } from "react/jsx-runtime";
var MainMenu, MainMenu_default;
var init_MainMenu = __esm({
  "components/main-menu/MainMenu.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_App();
    init_DropdownMenu2();
    init_DefaultItems2();
    init_UserList2();
    init_i18n();
    init_icons();
    init_withInternalFallback();
    init_utils();
    init_tunnels();
    init_ui_appState();
    MainMenu = Object.assign(
      withInternalFallback(
        "MainMenu",
        ({
          children,
          onSelect
        }) => {
          const { MainMenuTunnel } = useTunnels();
          const device = useDevice();
          const appState = useUIAppState();
          const setAppState = useExcalidrawSetAppState();
          const onClickOutside = device.editor.isMobile ? void 0 : () => setAppState({ openMenu: null });
          return /* @__PURE__ */ jsx93(MainMenuTunnel.In, { children: /* @__PURE__ */ jsxs52(DropdownMenu_default, { open: appState.openMenu === "canvas", children: [
            /* @__PURE__ */ jsx93(
              DropdownMenu_default.Trigger,
              {
                onToggle: () => {
                  setAppState({
                    openMenu: appState.openMenu === "canvas" ? null : "canvas"
                  });
                },
                "data-testid": "main-menu-trigger",
                className: "main-menu-trigger",
                children: HamburgerMenuIcon
              }
            ),
            /* @__PURE__ */ jsxs52(
              DropdownMenu_default.Content,
              {
                onClickOutside,
                onSelect: composeEventHandlers(onSelect, () => {
                  setAppState({ openMenu: null });
                }),
                children: [
                  children,
                  device.editor.isMobile && appState.collaborators.size > 0 && /* @__PURE__ */ jsxs52("fieldset", { className: "UserList-Wrapper", children: [
                    /* @__PURE__ */ jsx93("legend", { children: t("labels.collaborators") }),
                    /* @__PURE__ */ jsx93(
                      UserList,
                      {
                        mobile: true,
                        collaborators: appState.collaborators,
                        userToFollow: appState.userToFollow?.socketId || null
                      }
                    )
                  ] })
                ]
              }
            )
          ] }) });
        }
      ),
      {
        Trigger: DropdownMenu_default.Trigger,
        Item: DropdownMenu_default.Item,
        ItemLink: DropdownMenu_default.ItemLink,
        ItemCustom: DropdownMenu_default.ItemCustom,
        Group: DropdownMenu_default.Group,
        Separator: DropdownMenu_default.Separator,
        DefaultItems: DefaultItems_exports
      }
    );
    MainMenu_default = MainMenu;
  }
});

// components/OverwriteConfirm/OverwriteConfirmActions.tsx
import { jsx as jsx94, jsxs as jsxs53 } from "react/jsx-runtime";
var Action, ExportToImage, SaveToDisk, Actions;
var init_OverwriteConfirmActions = __esm({
  "components/OverwriteConfirm/OverwriteConfirmActions.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_FilledButton2();
    init_App();
    init_actions();
    init_i18n();
    init_actionExport();
    Action = ({
      title,
      children,
      actionLabel,
      onClick
    }) => {
      return /* @__PURE__ */ jsxs53("div", { className: "OverwriteConfirm__Actions__Action", children: [
        /* @__PURE__ */ jsx94("h4", { children: title }),
        /* @__PURE__ */ jsx94("div", { className: "OverwriteConfirm__Actions__Action__content", children }),
        /* @__PURE__ */ jsx94(
          FilledButton,
          {
            variant: "outlined",
            color: "muted",
            label: actionLabel,
            size: "large",
            fullWidth: true,
            onClick
          }
        )
      ] });
    };
    ExportToImage = () => {
      const { t: t2 } = useI18n();
      const actionManager = useExcalidrawActionManager();
      const setAppState = useExcalidrawSetAppState();
      return /* @__PURE__ */ jsx94(
        Action,
        {
          title: t2("overwriteConfirm.action.exportToImage.title"),
          actionLabel: t2("overwriteConfirm.action.exportToImage.button"),
          onClick: () => {
            actionManager.executeAction(actionChangeExportEmbedScene, "ui", true);
            setAppState({ openDialog: { name: "imageExport" } });
          },
          children: t2("overwriteConfirm.action.exportToImage.description")
        }
      );
    };
    SaveToDisk = () => {
      const { t: t2 } = useI18n();
      const actionManager = useExcalidrawActionManager();
      return /* @__PURE__ */ jsx94(
        Action,
        {
          title: t2("overwriteConfirm.action.saveToDisk.title"),
          actionLabel: t2("overwriteConfirm.action.saveToDisk.button"),
          onClick: () => {
            actionManager.executeAction(actionSaveFileToDisk, "ui");
          },
          children: t2("overwriteConfirm.action.saveToDisk.description")
        }
      );
    };
    Actions = Object.assign(
      ({ children }) => {
        return /* @__PURE__ */ jsx94("div", { className: "OverwriteConfirm__Actions", children });
      },
      {
        ExportToImage,
        SaveToDisk
      }
    );
  }
});

// components/OverwriteConfirm/OverwriteConfirm.scss
var init_OverwriteConfirm = __esm({
  "components/OverwriteConfirm/OverwriteConfirm.scss"() {
  }
});

// components/OverwriteConfirm/OverwriteConfirm.tsx
import { useAtom as useAtom14 } from "jotai";
import { jsx as jsx95, jsxs as jsxs54 } from "react/jsx-runtime";
var OverwriteConfirmDialog;
var init_OverwriteConfirm2 = __esm({
  "components/OverwriteConfirm/OverwriteConfirm.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_tunnels();
    init_jotai();
    init_Dialog2();
    init_withInternalFallback();
    init_OverwriteConfirmState();
    init_FilledButton2();
    init_icons();
    init_OverwriteConfirmActions();
    init_OverwriteConfirm();
    OverwriteConfirmDialog = Object.assign(
      withInternalFallback(
        "OverwriteConfirmDialog",
        ({ children }) => {
          const { OverwriteConfirmDialogTunnel } = useTunnels();
          const [overwriteConfirmState, setState] = useAtom14(
            overwriteConfirmStateAtom,
            jotaiScope
          );
          if (!overwriteConfirmState.active) {
            return null;
          }
          const handleClose = () => {
            overwriteConfirmState.onClose();
            setState((state) => ({ ...state, active: false }));
          };
          const handleConfirm = () => {
            overwriteConfirmState.onConfirm();
            setState((state) => ({ ...state, active: false }));
          };
          return /* @__PURE__ */ jsx95(OverwriteConfirmDialogTunnel.In, { children: /* @__PURE__ */ jsx95(Dialog, { onCloseRequest: handleClose, title: false, size: 916, children: /* @__PURE__ */ jsxs54("div", { className: "OverwriteConfirm", children: [
            /* @__PURE__ */ jsx95("h3", { children: overwriteConfirmState.title }),
            /* @__PURE__ */ jsxs54(
              "div",
              {
                className: `OverwriteConfirm__Description OverwriteConfirm__Description--color-${overwriteConfirmState.color}`,
                children: [
                  /* @__PURE__ */ jsx95("div", { className: "OverwriteConfirm__Description__icon", children: alertTriangleIcon }),
                  /* @__PURE__ */ jsx95("div", { children: overwriteConfirmState.description }),
                  /* @__PURE__ */ jsx95("div", { className: "OverwriteConfirm__Description__spacer" }),
                  /* @__PURE__ */ jsx95(
                    FilledButton,
                    {
                      color: overwriteConfirmState.color,
                      size: "large",
                      label: overwriteConfirmState.actionLabel,
                      onClick: handleConfirm
                    }
                  )
                ]
              }
            ),
            /* @__PURE__ */ jsx95(Actions, { children })
          ] }) }) });
        }
      ),
      {
        Actions,
        Action
      }
    );
  }
});

// components/DefaultSidebar.tsx
import clsx41 from "clsx";
import { jsx as jsx96, jsxs as jsxs55 } from "react/jsx-runtime";
import { createElement as createElement2 } from "react";
var DefaultSidebarTrigger, DefaultTabTriggers, DefaultSidebar;
var init_DefaultSidebar = __esm({
  "components/DefaultSidebar.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_constants();
    init_tunnels();
    init_ui_appState();
    init_i18n();
    init_utils();
    init_App();
    init_withInternalFallback();
    init_LibraryMenu2();
    init_Sidebar2();
    DefaultSidebarTrigger = withInternalFallback(
      "DefaultSidebarTrigger",
      (props) => {
        const { DefaultSidebarTriggerTunnel } = useTunnels();
        return /* @__PURE__ */ jsx96(DefaultSidebarTriggerTunnel.In, { children: /* @__PURE__ */ jsx96(
          Sidebar.Trigger,
          {
            ...props,
            className: "default-sidebar-trigger",
            name: DEFAULT_SIDEBAR.name
          }
        ) });
      }
    );
    DefaultSidebarTrigger.displayName = "DefaultSidebarTrigger";
    DefaultTabTriggers = ({
      children,
      ...rest
    }) => {
      const { DefaultSidebarTabTriggersTunnel } = useTunnels();
      return /* @__PURE__ */ jsx96(DefaultSidebarTabTriggersTunnel.In, { children: /* @__PURE__ */ jsx96(Sidebar.TabTriggers, { ...rest, children }) });
    };
    DefaultTabTriggers.displayName = "DefaultTabTriggers";
    DefaultSidebar = Object.assign(
      withInternalFallback(
        "DefaultSidebar",
        ({
          children,
          className,
          onDock,
          docked,
          ...rest
        }) => {
          const appState = useUIAppState();
          const setAppState = useExcalidrawSetAppState();
          const { DefaultSidebarTabTriggersTunnel } = useTunnels();
          return /* @__PURE__ */ createElement2(
            Sidebar,
            {
              ...rest,
              name: "default",
              key: "default",
              className: clsx41("default-sidebar", className),
              docked: docked ?? appState.defaultSidebarDockedPreference,
              onDock: (
                // `onDock=false` disables docking.
                // if `docked` passed, but no onDock passed, disable manual docking.
                onDock === false || !onDock && docked != null ? void 0 : (
                  // compose to allow the host app to listen on default behavior
                  composeEventHandlers(onDock, (docked2) => {
                    setAppState({ defaultSidebarDockedPreference: docked2 });
                  })
                )
              )
            },
            /* @__PURE__ */ jsxs55(Sidebar.Tabs, { children: [
              /* @__PURE__ */ jsxs55(Sidebar.Header, { children: [
                rest.__fallback && /* @__PURE__ */ jsx96(
                  "div",
                  {
                    style: {
                      color: "var(--color-primary)",
                      fontSize: "1.2em",
                      fontWeight: "bold",
                      textOverflow: "ellipsis",
                      overflow: "hidden",
                      whiteSpace: "nowrap",
                      paddingRight: "1em"
                    },
                    children: t("toolBar.library")
                  }
                ),
                /* @__PURE__ */ jsx96(DefaultSidebarTabTriggersTunnel.Out, {})
              ] }),
              /* @__PURE__ */ jsx96(Sidebar.Tab, { tab: LIBRARY_SIDEBAR_TAB, children: /* @__PURE__ */ jsx96(LibraryMenu, {}) }),
              children
            ] })
          );
        }
      ),
      {
        Trigger: DefaultSidebarTrigger,
        TabTriggers: DefaultTabTriggers
      }
    );
  }
});

// components/LayerUI.scss
var init_LayerUI = __esm({
  "components/LayerUI.scss"() {
  }
});

// components/Toolbar.scss
var init_Toolbar = __esm({
  "components/Toolbar.scss"() {
  }
});

// components/LaserPointerButton.tsx
import clsx42 from "clsx";
import { jsx as jsx97, jsxs as jsxs56 } from "react/jsx-runtime";
var DEFAULT_SIZE3, LaserPointerButton;
var init_LaserPointerButton = __esm({
  "components/LaserPointerButton.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_ToolIcon();
    init_icons();
    DEFAULT_SIZE3 = "small";
    LaserPointerButton = (props) => {
      return /* @__PURE__ */ jsxs56(
        "label",
        {
          className: clsx42(
            "ToolIcon ToolIcon__LaserPointer",
            `ToolIcon_size_${DEFAULT_SIZE3}`,
            {
              "is-mobile": props.isMobile
            }
          ),
          title: `${props.title}`,
          children: [
            /* @__PURE__ */ jsx97(
              "input",
              {
                className: "ToolIcon_type_checkbox",
                type: "checkbox",
                name: props.name,
                onChange: props.onChange,
                checked: props.checked,
                "aria-label": props.title,
                "data-testid": "toolbar-LaserPointer"
              }
            ),
            /* @__PURE__ */ jsx97("div", { className: "ToolIcon__icon", children: laserPointerToolIcon })
          ]
        }
      );
    };
  }
});

// components/TextField.scss
var init_TextField = __esm({
  "components/TextField.scss"() {
  }
});

// components/TextField.tsx
import {
  forwardRef as forwardRef4,
  useRef as useRef21,
  useImperativeHandle as useImperativeHandle2,
  useLayoutEffect as useLayoutEffect8,
  useState as useState25
} from "react";
import clsx43 from "clsx";
import { jsx as jsx98, jsxs as jsxs57 } from "react/jsx-runtime";
var TextField;
var init_TextField2 = __esm({
  "components/TextField.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_TextField();
    init_Button2();
    init_icons();
    TextField = forwardRef4(
      ({
        onChange,
        label,
        fullWidth,
        placeholder,
        readonly,
        selectOnRender,
        onKeyDown,
        isRedacted = false,
        ...rest
      }, ref) => {
        const innerRef = useRef21(null);
        useImperativeHandle2(ref, () => innerRef.current);
        useLayoutEffect8(() => {
          if (selectOnRender) {
            innerRef.current?.select();
          }
        }, [selectOnRender]);
        const [isTemporarilyUnredacted, setIsTemporarilyUnredacted] = useState25(false);
        return /* @__PURE__ */ jsxs57(
          "div",
          {
            className: clsx43("ExcTextField", {
              "ExcTextField--fullWidth": fullWidth
            }),
            onClick: () => {
              innerRef.current?.focus();
            },
            children: [
              /* @__PURE__ */ jsx98("div", { className: "ExcTextField__label", children: label }),
              /* @__PURE__ */ jsxs57(
                "div",
                {
                  className: clsx43("ExcTextField__input", {
                    "ExcTextField__input--readonly": readonly
                  }),
                  children: [
                    /* @__PURE__ */ jsx98(
                      "input",
                      {
                        className: clsx43({
                          "is-redacted": "value" in rest && rest.value && isRedacted && !isTemporarilyUnredacted
                        }),
                        readOnly: readonly,
                        value: "value" in rest ? rest.value : void 0,
                        defaultValue: "defaultValue" in rest ? rest.defaultValue : void 0,
                        placeholder,
                        ref: innerRef,
                        onChange: (event) => onChange?.(event.target.value),
                        onKeyDown
                      }
                    ),
                    isRedacted && /* @__PURE__ */ jsx98(
                      Button,
                      {
                        onSelect: () => setIsTemporarilyUnredacted(!isTemporarilyUnredacted),
                        style: { border: 0, userSelect: "none" },
                        children: isTemporarilyUnredacted ? eyeClosedIcon : eyeIcon
                      }
                    )
                  ]
                }
              )
            ]
          }
        );
      }
    );
  }
});

// components/InlineIcon.tsx
import { jsx as jsx99 } from "react/jsx-runtime";
var InlineIcon;
var init_InlineIcon = __esm({
  "components/InlineIcon.tsx"() {
    "use strict";
    init_define_import_meta_env();
    InlineIcon = ({ icon }) => {
      return /* @__PURE__ */ jsx99(
        "span",
        {
          style: {
            width: "1em",
            margin: "0 0.5ex 0 0.5ex",
            display: "inline-block",
            lineHeight: 0,
            verticalAlign: "middle"
          },
          children: icon
        }
      );
    };
  }
});

// components/Paragraph.tsx
import { jsx as jsx100 } from "react/jsx-runtime";
var Paragraph;
var init_Paragraph = __esm({
  "components/Paragraph.tsx"() {
    "use strict";
    init_define_import_meta_env();
    Paragraph = (props) => {
      return /* @__PURE__ */ jsx100("p", { className: "excalidraw__paragraph", style: props.style, children: props.children });
    };
  }
});

// components/MagicSettings.scss
var init_MagicSettings = __esm({
  "components/MagicSettings.scss"() {
  }
});

// components/TTDDialog/TTDDialogTabs.tsx
import * as RadixTabs5 from "@radix-ui/react-tabs";
import { useRef as useRef22 } from "react";
import { jsx as jsx101 } from "react/jsx-runtime";
var TTDDialogTabs, TTDDialogTabs_default;
var init_TTDDialogTabs = __esm({
  "components/TTDDialog/TTDDialogTabs.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_App();
    init_utils();
    TTDDialogTabs = (props) => {
      const setAppState = useExcalidrawSetAppState();
      const rootRef = useRef22(null);
      const minHeightRef = useRef22(0);
      return /* @__PURE__ */ jsx101(
        RadixTabs5.Root,
        {
          ref: rootRef,
          className: "ttd-dialog-tabs-root",
          value: props.tab,
          onValueChange: (tab) => {
            if (!tab) {
              return;
            }
            const modalContentNode = rootRef.current?.closest(".Modal__content");
            if (modalContentNode) {
              const currHeight = modalContentNode.offsetHeight || 0;
              if (currHeight > minHeightRef.current) {
                minHeightRef.current = currHeight;
                modalContentNode.style.minHeight = `min(${minHeightRef.current}px, 100%)`;
              }
            }
            if (props.dialog === "settings" && isMemberOf(["text-to-diagram", "diagram-to-code"], tab)) {
              setAppState({
                openDialog: { name: props.dialog, tab, source: "settings" }
              });
            } else if (props.dialog === "ttd" && isMemberOf(["text-to-diagram", "mermaid"], tab)) {
              setAppState({
                openDialog: { name: props.dialog, tab }
              });
            }
          },
          children: props.children
        }
      );
    };
    TTDDialogTabs.displayName = "TTDDialogTabs";
    TTDDialogTabs_default = TTDDialogTabs;
  }
});

// components/TTDDialog/TTDDialogTab.tsx
import * as RadixTabs6 from "@radix-ui/react-tabs";
import { jsx as jsx102 } from "react/jsx-runtime";
var TTDDialogTab;
var init_TTDDialogTab = __esm({
  "components/TTDDialog/TTDDialogTab.tsx"() {
    "use strict";
    init_define_import_meta_env();
    TTDDialogTab = ({
      tab,
      children,
      ...rest
    }) => {
      return /* @__PURE__ */ jsx102(RadixTabs6.Content, { ...rest, value: tab, children });
    };
    TTDDialogTab.displayName = "TTDDialogTab";
  }
});

// components/MagicSettings.tsx
import { useState as useState26 } from "react";
import { jsx as jsx103, jsxs as jsxs58 } from "react/jsx-runtime";
var MagicSettings;
var init_MagicSettings2 = __esm({
  "components/MagicSettings.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_Dialog2();
    init_TextField2();
    init_icons();
    init_FilledButton2();
    init_CheckboxItem2();
    init_keys();
    init_ui_appState();
    init_InlineIcon();
    init_Paragraph();
    init_MagicSettings();
    init_TTDDialogTabs();
    init_TTDDialogTab();
    MagicSettings = (props) => {
      const [keyInputValue, setKeyInputValue] = useState26(props.openAIKey || "");
      const [shouldPersist, setShouldPersist] = useState26(
        props.isPersisted
      );
      const appState = useUIAppState();
      const onConfirm = () => {
        props.onConfirm(keyInputValue.trim(), shouldPersist);
      };
      if (appState.openDialog?.name !== "settings") {
        return null;
      }
      return /* @__PURE__ */ jsx103(
        Dialog,
        {
          onCloseRequest: () => {
            props.onClose();
            props.onConfirm(keyInputValue.trim(), shouldPersist);
          },
          title: /* @__PURE__ */ jsxs58("div", { style: { display: "flex" }, children: [
            "Wireframe to Code (AI)",
            " ",
            /* @__PURE__ */ jsx103(
              "div",
              {
                style: {
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "center",
                  padding: "0.1rem 0.5rem",
                  marginLeft: "1rem",
                  fontSize: 14,
                  borderRadius: "12px",
                  color: "#000",
                  background: "pink"
                },
                children: "Experimental"
              }
            )
          ] }),
          className: "MagicSettings",
          autofocus: false,
          children: /* @__PURE__ */ jsx103(TTDDialogTabs_default, { dialog: "settings", tab: appState.openDialog.tab, children: /* @__PURE__ */ jsxs58(
            TTDDialogTab,
            {
              tab: "diagram-to-code",
              children: [
                /* @__PURE__ */ jsxs58(Paragraph, { children: [
                  "For the diagram-to-code feature we use",
                  " ",
                  /* @__PURE__ */ jsx103(InlineIcon, { icon: OpenAIIcon }),
                  "OpenAI."
                ] }),
                /* @__PURE__ */ jsxs58(Paragraph, { children: [
                  "While the OpenAI API is in beta, its use is strictly limited \u2014 as such we require you use your own API key. You can create an",
                  " ",
                  /* @__PURE__ */ jsx103(
                    "a",
                    {
                      href: "https://platform.openai.com/login?launch",
                      rel: "noopener noreferrer",
                      target: "_blank",
                      children: "OpenAI account"
                    }
                  ),
                  ", add a small credit (5 USD minimum), and",
                  " ",
                  /* @__PURE__ */ jsx103(
                    "a",
                    {
                      href: "https://platform.openai.com/api-keys",
                      rel: "noopener noreferrer",
                      target: "_blank",
                      children: "generate your own API key"
                    }
                  ),
                  "."
                ] }),
                /* @__PURE__ */ jsx103(Paragraph, { children: "Your OpenAI key does not leave the browser, and you can also set your own limit in your OpenAI account dashboard if needed." }),
                /* @__PURE__ */ jsx103(
                  TextField,
                  {
                    isRedacted: true,
                    value: keyInputValue,
                    placeholder: "Paste your API key here",
                    label: "OpenAI API key",
                    onChange: (value) => {
                      setKeyInputValue(value);
                      props.onChange(value.trim(), shouldPersist);
                    },
                    selectOnRender: true,
                    onKeyDown: (event) => event.key === KEYS.ENTER && onConfirm()
                  }
                ),
                /* @__PURE__ */ jsx103(Paragraph, { children: "By default, your API token is not persisted anywhere so you'll need to insert it again after reload. But, you can persist locally in your browser below." }),
                /* @__PURE__ */ jsx103(CheckboxItem, { checked: shouldPersist, onChange: setShouldPersist, children: "Persist API key in browser storage" }),
                /* @__PURE__ */ jsxs58(Paragraph, { children: [
                  "Once API key is set, you can use the ",
                  /* @__PURE__ */ jsx103(InlineIcon, { icon: MagicIcon }),
                  " ",
                  "tool to wrap your elements in a frame that will then allow you to turn it into code. This dialog can be accessed using the",
                  " ",
                  /* @__PURE__ */ jsx103("b", { children: "AI Settings" }),
                  " ",
                  /* @__PURE__ */ jsx103(InlineIcon, { icon: OpenAIIcon }),
                  "."
                ] }),
                /* @__PURE__ */ jsx103(
                  FilledButton,
                  {
                    className: "MagicSettings__confirm",
                    size: "large",
                    label: "Confirm",
                    onClick: onConfirm
                  }
                )
              ]
            }
          ) })
        }
      );
    };
  }
});

// components/TTDDialog/MermaidToExcalidraw.scss
var init_MermaidToExcalidraw = __esm({
  "components/TTDDialog/MermaidToExcalidraw.scss"() {
  }
});

// components/TTDDialog/common.ts
var resetPreview, convertMermaidToExcalidraw, saveMermaidDataToStorage, insertToEditor;
var init_common3 = __esm({
  "components/TTDDialog/common.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_constants();
    init_excalidraw();
    init_blob();
    init_EditorLocalStorage();
    resetPreview = ({
      canvasRef,
      setError
    }) => {
      const canvasNode = canvasRef.current;
      if (!canvasNode) {
        return;
      }
      const parent = canvasNode.parentElement;
      if (!parent) {
        return;
      }
      parent.style.background = "";
      setError(null);
      canvasNode.replaceChildren();
    };
    convertMermaidToExcalidraw = async ({
      canvasRef,
      mermaidToExcalidrawLib,
      mermaidDefinition,
      setError,
      data
    }) => {
      const canvasNode = canvasRef.current;
      const parent = canvasNode?.parentElement;
      if (!canvasNode || !parent) {
        return;
      }
      if (!mermaidDefinition) {
        resetPreview({ canvasRef, setError });
        return;
      }
      try {
        const api = await mermaidToExcalidrawLib.api;
        let ret;
        try {
          ret = await api.parseMermaidToExcalidraw(mermaidDefinition, {
            fontSize: DEFAULT_FONT_SIZE
          });
        } catch (err) {
          ret = await api.parseMermaidToExcalidraw(
            mermaidDefinition.replace(/"/g, "'"),
            {
              fontSize: DEFAULT_FONT_SIZE
            }
          );
        }
        const { elements, files } = ret;
        setError(null);
        data.current = {
          elements: convertToExcalidrawElements(elements, {
            regenerateIds: true
          }),
          files
        };
        const canvas2 = await exportToCanvas2({
          elements: data.current.elements,
          files: data.current.files,
          exportPadding: DEFAULT_EXPORT_PADDING,
          maxWidthOrHeight: Math.max(parent.offsetWidth, parent.offsetHeight) * window.devicePixelRatio
        });
        await canvasToBlob(canvas2);
        parent.style.background = "var(--default-bg-color)";
        canvasNode.replaceChildren(canvas2);
      } catch (err) {
        parent.style.background = "var(--default-bg-color)";
        if (mermaidDefinition) {
          setError(err);
        }
        throw err;
      }
    };
    saveMermaidDataToStorage = (mermaidDefinition) => {
      EditorLocalStorage.set(
        EDITOR_LS_KEYS.MERMAID_TO_EXCALIDRAW,
        mermaidDefinition
      );
    };
    insertToEditor = ({
      app,
      data,
      text,
      shouldSaveMermaidDataToStorage
    }) => {
      const { elements: newElements, files } = data.current;
      if (!newElements.length) {
        return;
      }
      app.addElementsFromPasteOrLibrary({
        elements: newElements,
        files,
        position: "center",
        fitToContent: true
      });
      app.setOpenDialog(null);
      if (shouldSaveMermaidDataToStorage && text) {
        saveMermaidDataToStorage(text);
      }
    };
  }
});

// components/TTDDialog/TTDDialogPanels.tsx
import { jsx as jsx104 } from "react/jsx-runtime";
var TTDDialogPanels;
var init_TTDDialogPanels = __esm({
  "components/TTDDialog/TTDDialogPanels.tsx"() {
    "use strict";
    init_define_import_meta_env();
    TTDDialogPanels = ({ children }) => {
      return /* @__PURE__ */ jsx104("div", { className: "ttd-dialog-panels", children });
    };
  }
});

// components/TTDDialog/TTDDialogPanel.tsx
import clsx44 from "clsx";
import { jsx as jsx105, jsxs as jsxs59 } from "react/jsx-runtime";
var TTDDialogPanel;
var init_TTDDialogPanel = __esm({
  "components/TTDDialog/TTDDialogPanel.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_Button2();
    init_Spinner2();
    TTDDialogPanel = ({
      label,
      children,
      panelAction,
      panelActionDisabled = false,
      onTextSubmitInProgess,
      renderTopRight,
      renderSubmitShortcut,
      renderBottomRight
    }) => {
      return /* @__PURE__ */ jsxs59("div", { className: "ttd-dialog-panel", children: [
        /* @__PURE__ */ jsxs59("div", { className: "ttd-dialog-panel__header", children: [
          /* @__PURE__ */ jsx105("label", { children: label }),
          renderTopRight?.()
        ] }),
        children,
        /* @__PURE__ */ jsxs59(
          "div",
          {
            className: clsx44("ttd-dialog-panel-button-container", {
              invisible: !panelAction
            }),
            style: { display: "flex", alignItems: "center" },
            children: [
              /* @__PURE__ */ jsxs59(
                Button,
                {
                  className: "ttd-dialog-panel-button",
                  onSelect: panelAction ? panelAction.action : () => {
                  },
                  disabled: panelActionDisabled || onTextSubmitInProgess,
                  children: [
                    /* @__PURE__ */ jsxs59("div", { className: clsx44({ invisible: onTextSubmitInProgess }), children: [
                      panelAction?.label,
                      panelAction?.icon && /* @__PURE__ */ jsx105("span", { children: panelAction.icon })
                    ] }),
                    onTextSubmitInProgess && /* @__PURE__ */ jsx105(Spinner_default, {})
                  ]
                }
              ),
              !panelActionDisabled && !onTextSubmitInProgess && renderSubmitShortcut?.(),
              renderBottomRight?.()
            ]
          }
        )
      ] });
    };
  }
});

// components/TTDDialog/TTDDialogInput.tsx
import { useEffect as useEffect24, useRef as useRef23 } from "react";
import { jsx as jsx106 } from "react/jsx-runtime";
var TTDDialogInput;
var init_TTDDialogInput = __esm({
  "components/TTDDialog/TTDDialogInput.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_constants();
    init_keys();
    TTDDialogInput = ({
      input,
      placeholder,
      onChange,
      onKeyboardSubmit
    }) => {
      const ref = useRef23(null);
      const callbackRef = useRef23(onKeyboardSubmit);
      callbackRef.current = onKeyboardSubmit;
      useEffect24(() => {
        if (!callbackRef.current) {
          return;
        }
        const textarea = ref.current;
        if (textarea) {
          const handleKeyDown = (event) => {
            if (event[KEYS.CTRL_OR_CMD] && event.key === KEYS.ENTER) {
              event.preventDefault();
              callbackRef.current?.();
            }
          };
          textarea.addEventListener("keydown" /* KEYDOWN */, handleKeyDown);
          return () => {
            textarea.removeEventListener("keydown" /* KEYDOWN */, handleKeyDown);
          };
        }
      }, []);
      return /* @__PURE__ */ jsx106(
        "textarea",
        {
          className: "ttd-dialog-input",
          onChange,
          value: input,
          placeholder,
          autoFocus: true,
          ref
        }
      );
    };
  }
});

// components/TTDDialog/TTDDialogOutput.tsx
import { jsx as jsx107, jsxs as jsxs60 } from "react/jsx-runtime";
var ErrorComp, TTDDialogOutput;
var init_TTDDialogOutput = __esm({
  "components/TTDDialog/TTDDialogOutput.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_Spinner2();
    ErrorComp = ({ error }) => {
      return /* @__PURE__ */ jsxs60(
        "div",
        {
          "data-testid": "ttd-dialog-output-error",
          className: "ttd-dialog-output-error",
          children: [
            "Error! ",
            /* @__PURE__ */ jsx107("p", { children: error })
          ]
        }
      );
    };
    TTDDialogOutput = ({
      error,
      canvasRef,
      loaded
    }) => {
      return /* @__PURE__ */ jsxs60("div", { className: "ttd-dialog-output-wrapper", children: [
        error && /* @__PURE__ */ jsx107(ErrorComp, { error: error.message }),
        loaded ? /* @__PURE__ */ jsx107(
          "div",
          {
            ref: canvasRef,
            style: { opacity: error ? "0.15" : 1 },
            className: "ttd-dialog-output-canvas-container"
          }
        ) : /* @__PURE__ */ jsx107(Spinner_default, { size: "2rem" })
      ] });
    };
  }
});

// components/TTDDialog/TTDDialogSubmitShortcut.tsx
import { jsx as jsx108, jsxs as jsxs61 } from "react/jsx-runtime";
var TTDDialogSubmitShortcut;
var init_TTDDialogSubmitShortcut = __esm({
  "components/TTDDialog/TTDDialogSubmitShortcut.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_utils();
    TTDDialogSubmitShortcut = () => {
      return /* @__PURE__ */ jsxs61("div", { className: "ttd-dialog-submit-shortcut", children: [
        /* @__PURE__ */ jsx108("div", { className: "ttd-dialog-submit-shortcut__key", children: getShortcutKey("CtrlOrCmd") }),
        /* @__PURE__ */ jsx108("div", { className: "ttd-dialog-submit-shortcut__key", children: getShortcutKey("Enter") })
      ] });
    };
  }
});

// components/TTDDialog/MermaidToExcalidraw.tsx
import { useState as useState27, useRef as useRef24, useEffect as useEffect25, useDeferredValue } from "react";
import { Fragment as Fragment18, jsx as jsx109, jsxs as jsxs62 } from "react/jsx-runtime";
var MERMAID_EXAMPLE, debouncedSaveMermaidDefinition, MermaidToExcalidraw, MermaidToExcalidraw_default;
var init_MermaidToExcalidraw2 = __esm({
  "components/TTDDialog/MermaidToExcalidraw.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_App();
    init_icons();
    init_MermaidToExcalidraw();
    init_i18n();
    init_Trans();
    init_common3();
    init_TTDDialogPanels();
    init_TTDDialogPanel();
    init_TTDDialogInput();
    init_TTDDialogOutput();
    init_EditorLocalStorage();
    init_constants();
    init_utils();
    init_TTDDialogSubmitShortcut();
    MERMAID_EXAMPLE = "flowchart TD\n A[Christmas] -->|Get money| B(Go shopping)\n B --> C{Let me think}\n C -->|One| D[Laptop]\n C -->|Two| E[iPhone]\n C -->|Three| F[Car]";
    debouncedSaveMermaidDefinition = debounce(saveMermaidDataToStorage, 300);
    MermaidToExcalidraw = ({
      mermaidToExcalidrawLib
    }) => {
      const [text, setText] = useState27(
        () => EditorLocalStorage.get(EDITOR_LS_KEYS.MERMAID_TO_EXCALIDRAW) || MERMAID_EXAMPLE
      );
      const deferredText = useDeferredValue(text.trim());
      const [error, setError] = useState27(null);
      const canvasRef = useRef24(null);
      const data = useRef24({ elements: [], files: null });
      const app = useApp();
      useEffect25(() => {
        convertMermaidToExcalidraw({
          canvasRef,
          data,
          mermaidToExcalidrawLib,
          setError,
          mermaidDefinition: deferredText
        }).catch(() => {
        });
        debouncedSaveMermaidDefinition(deferredText);
      }, [deferredText, mermaidToExcalidrawLib]);
      useEffect25(
        () => () => {
          debouncedSaveMermaidDefinition.flush();
        },
        []
      );
      const onInsertToEditor = () => {
        insertToEditor({
          app,
          data,
          text,
          shouldSaveMermaidDataToStorage: true
        });
      };
      return /* @__PURE__ */ jsxs62(Fragment18, { children: [
        /* @__PURE__ */ jsx109("div", { className: "ttd-dialog-desc", children: /* @__PURE__ */ jsx109(
          Trans_default,
          {
            i18nKey: "mermaid.description",
            flowchartLink: (el) => /* @__PURE__ */ jsx109("a", { href: "https://mermaid.js.org/syntax/flowchart.html", children: el }),
            sequenceLink: (el) => /* @__PURE__ */ jsx109("a", { href: "https://mermaid.js.org/syntax/sequenceDiagram.html", children: el }),
            classLink: (el) => /* @__PURE__ */ jsx109("a", { href: "https://mermaid.js.org/syntax/classDiagram.html", children: el })
          }
        ) }),
        /* @__PURE__ */ jsxs62(TTDDialogPanels, { children: [
          /* @__PURE__ */ jsx109(TTDDialogPanel, { label: t("mermaid.syntax"), children: /* @__PURE__ */ jsx109(
            TTDDialogInput,
            {
              input: text,
              placeholder: "Write Mermaid diagram defintion here...",
              onChange: (event) => setText(event.target.value),
              onKeyboardSubmit: () => {
                onInsertToEditor();
              }
            }
          ) }),
          /* @__PURE__ */ jsx109(
            TTDDialogPanel,
            {
              label: t("mermaid.preview"),
              panelAction: {
                action: () => {
                  onInsertToEditor();
                },
                label: t("mermaid.button"),
                icon: ArrowRightIcon
              },
              renderSubmitShortcut: () => /* @__PURE__ */ jsx109(TTDDialogSubmitShortcut, {}),
              children: /* @__PURE__ */ jsx109(
                TTDDialogOutput,
                {
                  canvasRef,
                  loaded: mermaidToExcalidrawLib.loaded,
                  error
                }
              )
            }
          )
        ] })
      ] });
    };
    MermaidToExcalidraw_default = MermaidToExcalidraw;
  }
});

// components/TTDDialog/TTDDialogTabTriggers.tsx
import * as RadixTabs7 from "@radix-ui/react-tabs";
import { jsx as jsx110 } from "react/jsx-runtime";
var TTDDialogTabTriggers;
var init_TTDDialogTabTriggers = __esm({
  "components/TTDDialog/TTDDialogTabTriggers.tsx"() {
    "use strict";
    init_define_import_meta_env();
    TTDDialogTabTriggers = ({
      children,
      ...rest
    }) => {
      return /* @__PURE__ */ jsx110(RadixTabs7.List, { className: "ttd-dialog-triggers", ...rest, children });
    };
    TTDDialogTabTriggers.displayName = "TTDDialogTabTriggers";
  }
});

// components/TTDDialog/TTDDialogTabTrigger.tsx
import * as RadixTabs8 from "@radix-ui/react-tabs";
import { jsx as jsx111 } from "react/jsx-runtime";
var TTDDialogTabTrigger;
var init_TTDDialogTabTrigger = __esm({
  "components/TTDDialog/TTDDialogTabTrigger.tsx"() {
    "use strict";
    init_define_import_meta_env();
    TTDDialogTabTrigger = ({
      children,
      tab,
      onSelect,
      ...rest
    }) => {
      return /* @__PURE__ */ jsx111(RadixTabs8.Trigger, { value: tab, asChild: true, onSelect, children: /* @__PURE__ */ jsx111("button", { type: "button", className: "ttd-dialog-tab-trigger", ...rest, children }) });
    };
    TTDDialogTabTrigger.displayName = "TTDDialogTabTrigger";
  }
});

// components/TTDDialog/TTDDialog.scss
var init_TTDDialog = __esm({
  "components/TTDDialog/TTDDialog.scss"() {
  }
});

// components/TTDDialog/TTDDialog.tsx
import { useEffect as useEffect26, useRef as useRef25, useState as useState28 } from "react";
import { atom as atom12, useAtom as useAtom15 } from "jotai";
import { jsx as jsx112, jsxs as jsxs63 } from "react/jsx-runtime";
var MIN_PROMPT_LENGTH, MAX_PROMPT_LENGTH, rateLimitsAtom, ttdGenerationAtom, TTDDialog, TTDDialogBase;
var init_TTDDialog2 = __esm({
  "components/TTDDialog/TTDDialog.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_Dialog2();
    init_App();
    init_MermaidToExcalidraw2();
    init_TTDDialogTabs();
    init_ui_appState();
    init_withInternalFallback();
    init_TTDDialogTabTriggers();
    init_TTDDialogTabTrigger();
    init_TTDDialogTab();
    init_i18n();
    init_TTDDialogInput();
    init_TTDDialogOutput();
    init_TTDDialogPanel();
    init_TTDDialogPanels();
    init_common3();
    init_icons();
    init_TTDDialog();
    init_utils();
    init_analytics();
    init_InlineIcon();
    init_TTDDialogSubmitShortcut();
    MIN_PROMPT_LENGTH = 3;
    MAX_PROMPT_LENGTH = 1e3;
    rateLimitsAtom = atom12(null);
    ttdGenerationAtom = atom12(null);
    TTDDialog = (props) => {
      const appState = useUIAppState();
      if (appState.openDialog?.name !== "ttd") {
        return null;
      }
      return /* @__PURE__ */ jsx112(TTDDialogBase, { ...props, tab: appState.openDialog.tab });
    };
    TTDDialogBase = withInternalFallback(
      "TTDDialogBase",
      ({
        tab,
        ...rest
      }) => {
        const app = useApp();
        const setAppState = useExcalidrawSetAppState();
        const someRandomDivRef = useRef25(null);
        const [ttdGeneration, setTtdGeneration] = useAtom15(ttdGenerationAtom);
        const [text, setText] = useState28(ttdGeneration?.prompt ?? "");
        const prompt = text.trim();
        const handleTextChange = (event) => {
          setText(event.target.value);
          setTtdGeneration((s) => ({
            generatedResponse: s?.generatedResponse ?? null,
            prompt: event.target.value
          }));
        };
        const [onTextSubmitInProgess, setOnTextSubmitInProgess] = useState28(false);
        const [rateLimits, setRateLimits] = useAtom15(rateLimitsAtom);
        const onGenerate = async () => {
          if (prompt.length > MAX_PROMPT_LENGTH || prompt.length < MIN_PROMPT_LENGTH || onTextSubmitInProgess || rateLimits?.rateLimitRemaining === 0 || // means this is not a text-to-diagram dialog (needed for TS only)
          "__fallback" in rest) {
            if (prompt.length < MIN_PROMPT_LENGTH) {
              setError(
                new Error(
                  `Prompt is too short (min ${MIN_PROMPT_LENGTH} characters)`
                )
              );
            }
            if (prompt.length > MAX_PROMPT_LENGTH) {
              setError(
                new Error(
                  `Prompt is too long (max ${MAX_PROMPT_LENGTH} characters)`
                )
              );
            }
            return;
          }
          try {
            setOnTextSubmitInProgess(true);
            trackEvent("ai", "generate", "ttd");
            const { generatedResponse, error: error2, rateLimit, rateLimitRemaining } = await rest.onTextSubmit(prompt);
            if (typeof generatedResponse === "string") {
              setTtdGeneration((s) => ({
                generatedResponse,
                prompt: s?.prompt ?? null
              }));
            }
            if (isFiniteNumber(rateLimit) && isFiniteNumber(rateLimitRemaining)) {
              setRateLimits({ rateLimit, rateLimitRemaining });
            }
            if (error2) {
              setError(error2);
              return;
            }
            if (!generatedResponse) {
              setError(new Error("Generation failed"));
              return;
            }
            try {
              await convertMermaidToExcalidraw({
                canvasRef: someRandomDivRef,
                data,
                mermaidToExcalidrawLib,
                setError,
                mermaidDefinition: generatedResponse
              });
              trackEvent("ai", "mermaid parse success", "ttd");
            } catch (error3) {
              console.info(
                `%cTTD mermaid render errror: ${error3.message}`,
                "color: red"
              );
              console.info(
                `>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
TTD mermaid definition render errror: ${error3.message}`,
                "color: yellow"
              );
              trackEvent("ai", "mermaid parse failed", "ttd");
              setError(
                new Error(
                  "Generated an invalid diagram :(. You may also try a different prompt."
                )
              );
            }
          } catch (error2) {
            let message = error2.message;
            if (!message || message === "Failed to fetch") {
              message = "Request failed";
            }
            setError(new Error(message));
          } finally {
            setOnTextSubmitInProgess(false);
          }
        };
        const refOnGenerate = useRef25(onGenerate);
        refOnGenerate.current = onGenerate;
        const [mermaidToExcalidrawLib, setMermaidToExcalidrawLib] = useState28({
          loaded: false,
          api: import("@excalidraw/mermaid-to-excalidraw")
        });
        useEffect26(() => {
          const fn = async () => {
            await mermaidToExcalidrawLib.api;
            setMermaidToExcalidrawLib((prev) => ({ ...prev, loaded: true }));
          };
          fn();
        }, [mermaidToExcalidrawLib.api]);
        const data = useRef25({ elements: [], files: null });
        const [error, setError] = useState28(null);
        return /* @__PURE__ */ jsx112(
          Dialog,
          {
            className: "ttd-dialog",
            onCloseRequest: () => {
              app.setOpenDialog(null);
            },
            size: 1200,
            title: false,
            ...rest,
            autofocus: false,
            children: /* @__PURE__ */ jsxs63(TTDDialogTabs_default, { dialog: "ttd", tab, children: [
              "__fallback" in rest && rest.__fallback ? /* @__PURE__ */ jsx112("p", { className: "dialog-mermaid-title", children: t("mermaid.title") }) : /* @__PURE__ */ jsxs63(TTDDialogTabTriggers, { children: [
                /* @__PURE__ */ jsx112(TTDDialogTabTrigger, { tab: "text-to-diagram", children: /* @__PURE__ */ jsxs63("div", { style: { display: "flex", alignItems: "center" }, children: [
                  t("labels.textToDiagram"),
                  /* @__PURE__ */ jsx112(
                    "div",
                    {
                      style: {
                        display: "flex",
                        alignItems: "center",
                        justifyContent: "center",
                        padding: "1px 6px",
                        marginLeft: "10px",
                        fontSize: 10,
                        borderRadius: "12px",
                        background: "pink",
                        color: "#000"
                      },
                      children: "AI Beta"
                    }
                  )
                ] }) }),
                /* @__PURE__ */ jsx112(TTDDialogTabTrigger, { tab: "mermaid", children: "Mermaid" })
              ] }),
              /* @__PURE__ */ jsx112(TTDDialogTab, { className: "ttd-dialog-content", tab: "mermaid", children: /* @__PURE__ */ jsx112(
                MermaidToExcalidraw_default,
                {
                  mermaidToExcalidrawLib
                }
              ) }),
              !("__fallback" in rest) && /* @__PURE__ */ jsxs63(TTDDialogTab, { className: "ttd-dialog-content", tab: "text-to-diagram", children: [
                /* @__PURE__ */ jsx112("div", { className: "ttd-dialog-desc", children: "Currently we use Mermaid as a middle step, so you'll get best results if you describe a diagram, workflow, flow chart, and similar." }),
                /* @__PURE__ */ jsxs63(TTDDialogPanels, { children: [
                  /* @__PURE__ */ jsx112(
                    TTDDialogPanel,
                    {
                      label: t("labels.prompt"),
                      panelAction: {
                        action: onGenerate,
                        label: "Generate",
                        icon: ArrowRightIcon
                      },
                      onTextSubmitInProgess,
                      panelActionDisabled: prompt.length > MAX_PROMPT_LENGTH || rateLimits?.rateLimitRemaining === 0,
                      renderTopRight: () => {
                        if (!rateLimits) {
                          return null;
                        }
                        return /* @__PURE__ */ jsxs63(
                          "div",
                          {
                            className: "ttd-dialog-rate-limit",
                            style: {
                              fontSize: 12,
                              marginLeft: "auto",
                              color: rateLimits.rateLimitRemaining === 0 ? "var(--color-danger)" : void 0
                            },
                            children: [
                              rateLimits.rateLimitRemaining,
                              " requests left today"
                            ]
                          }
                        );
                      },
                      renderSubmitShortcut: () => /* @__PURE__ */ jsx112(TTDDialogSubmitShortcut, {}),
                      renderBottomRight: () => {
                        if (typeof ttdGeneration?.generatedResponse === "string") {
                          return /* @__PURE__ */ jsxs63(
                            "div",
                            {
                              className: "excalidraw-link",
                              style: { marginLeft: "auto", fontSize: 14 },
                              onClick: () => {
                                if (typeof ttdGeneration?.generatedResponse === "string") {
                                  saveMermaidDataToStorage(
                                    ttdGeneration.generatedResponse
                                  );
                                  setAppState({
                                    openDialog: { name: "ttd", tab: "mermaid" }
                                  });
                                }
                              },
                              children: [
                                "View as Mermaid",
                                /* @__PURE__ */ jsx112(InlineIcon, { icon: ArrowRightIcon })
                              ]
                            }
                          );
                        }
                        const ratio = prompt.length / MAX_PROMPT_LENGTH;
                        if (ratio > 0.8) {
                          return /* @__PURE__ */ jsxs63(
                            "div",
                            {
                              style: {
                                marginLeft: "auto",
                                fontSize: 12,
                                fontFamily: "monospace",
                                color: ratio > 1 ? "var(--color-danger)" : void 0
                              },
                              children: [
                                "Length: ",
                                prompt.length,
                                "/",
                                MAX_PROMPT_LENGTH
                              ]
                            }
                          );
                        }
                        return null;
                      },
                      children: /* @__PURE__ */ jsx112(
                        TTDDialogInput,
                        {
                          onChange: handleTextChange,
                          input: text,
                          placeholder: "Describe what you want to see...",
                          onKeyboardSubmit: () => {
                            refOnGenerate.current();
                          }
                        }
                      )
                    }
                  ),
                  /* @__PURE__ */ jsx112(
                    TTDDialogPanel,
                    {
                      label: "Preview",
                      panelAction: {
                        action: () => {
                          console.info("Panel action clicked");
                          insertToEditor({ app, data });
                        },
                        label: "Insert",
                        icon: ArrowRightIcon
                      },
                      children: /* @__PURE__ */ jsx112(
                        TTDDialogOutput,
                        {
                          canvasRef: someRandomDivRef,
                          error,
                          loaded: mermaidToExcalidrawLib.loaded
                        }
                      )
                    }
                  )
                ] })
              ] })
            ] })
          }
        );
      }
    );
  }
});

// components/LayerUI.tsx
import clsx45 from "clsx";
import React35 from "react";
import { Provider, useAtom as useAtom16, useAtomValue as useAtomValue2 } from "jotai";
import { Fragment as Fragment19, jsx as jsx113, jsxs as jsxs64 } from "react/jsx-runtime";
var DefaultMainMenu, DefaultOverwriteConfirmDialog, LayerUI, stripIrrelevantAppStateProps, areEqual, LayerUI_default;
var init_LayerUI2 = __esm({
  "components/LayerUI.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_constants();
    init_element();
    init_i18n();
    init_scene();
    init_utils();
    init_Actions2();
    init_ErrorDialog();
    init_ImageExportDialog2();
    init_FixedSideContainer2();
    init_HintViewer2();
    init_Island2();
    init_LoadingMessage();
    init_LockButton();
    init_MobileMenu();
    init_PasteChartDialog2();
    init_Section();
    init_HelpDialog2();
    init_Stack2();
    init_UserList2();
    init_JSONExportDialog();
    init_PenModeButton();
    init_analytics();
    init_App();
    init_Stats2();
    init_actionToggleStats();
    init_Footer();
    init_Sidebar2();
    init_jotai();
    init_MainMenu();
    init_ActiveConfirmDialog();
    init_OverwriteConfirm2();
    init_HandButton();
    init_appState();
    init_tunnels();
    init_icons();
    init_ui_appState();
    init_DefaultSidebar();
    init_EyeDropper2();
    init_LayerUI();
    init_Toolbar();
    init_mutateElement();
    init_ShapeCache();
    init_Scene();
    init_LaserPointerButton();
    init_MagicSettings2();
    init_TTDDialog2();
    DefaultMainMenu = ({ UIOptions }) => {
      return /* @__PURE__ */ jsxs64(MainMenu_default, { __fallback: true, children: [
        /* @__PURE__ */ jsx113(MainMenu_default.DefaultItems.LoadScene, {}),
        /* @__PURE__ */ jsx113(MainMenu_default.DefaultItems.SaveToActiveFile, {}),
        UIOptions.canvasActions.export && /* @__PURE__ */ jsx113(MainMenu_default.DefaultItems.Export, {}),
        UIOptions.canvasActions.saveAsImage && /* @__PURE__ */ jsx113(MainMenu_default.DefaultItems.SaveAsImage, {}),
        /* @__PURE__ */ jsx113(MainMenu_default.DefaultItems.Help, {}),
        /* @__PURE__ */ jsx113(MainMenu_default.DefaultItems.ClearCanvas, {}),
        /* @__PURE__ */ jsx113(MainMenu_default.Separator, {}),
        /* @__PURE__ */ jsx113(MainMenu_default.Group, { title: "Excalidraw links", children: /* @__PURE__ */ jsx113(MainMenu_default.DefaultItems.Socials, {}) }),
        /* @__PURE__ */ jsx113(MainMenu_default.Separator, {}),
        /* @__PURE__ */ jsx113(MainMenu_default.DefaultItems.ToggleTheme, {}),
        /* @__PURE__ */ jsx113(MainMenu_default.DefaultItems.ChangeCanvasBackground, {})
      ] });
    };
    DefaultOverwriteConfirmDialog = () => {
      return /* @__PURE__ */ jsxs64(OverwriteConfirmDialog, { __fallback: true, children: [
        /* @__PURE__ */ jsx113(OverwriteConfirmDialog.Actions.SaveToDisk, {}),
        /* @__PURE__ */ jsx113(OverwriteConfirmDialog.Actions.ExportToImage, {})
      ] });
    };
    LayerUI = ({
      actionManager,
      appState,
      files,
      setAppState,
      elements,
      canvas: canvas2,
      onLockToggle,
      onHandToolToggle,
      onPenModeToggle,
      showExitZenModeBtn,
      renderTopRightUI,
      renderCustomStats,
      UIOptions,
      onExportImage,
      renderWelcomeScreen,
      children,
      app,
      isCollaborating,
      openAIKey,
      isOpenAIKeyPersisted,
      onOpenAIAPIKeyChange,
      onMagicSettingsConfirm
    }) => {
      const device = useDevice();
      const tunnels = useInitializeTunnels();
      const [eyeDropperState, setEyeDropperState] = useAtom16(
        activeEyeDropperAtom,
        jotaiScope
      );
      const renderJSONExportDialog = () => {
        if (!UIOptions.canvasActions.export) {
          return null;
        }
        return /* @__PURE__ */ jsx113(
          JSONExportDialog,
          {
            elements,
            appState,
            files,
            actionManager,
            exportOpts: UIOptions.canvasActions.export,
            canvas: canvas2,
            setAppState
          }
        );
      };
      const renderImageExportDialog = () => {
        if (!UIOptions.canvasActions.saveAsImage || appState.openDialog?.name !== "imageExport") {
          return null;
        }
        return /* @__PURE__ */ jsx113(
          ImageExportDialog,
          {
            elements,
            appState,
            files,
            actionManager,
            onExportImage,
            onCloseRequest: () => setAppState({ openDialog: null }),
            name: app.getName()
          }
        );
      };
      const renderCanvasActions = () => /* @__PURE__ */ jsxs64("div", { style: { position: "relative" }, children: [
        /* @__PURE__ */ jsx113(tunnels.MainMenuTunnel.Out, {}),
        renderWelcomeScreen && /* @__PURE__ */ jsx113(tunnels.WelcomeScreenMenuHintTunnel.Out, {})
      ] });
      const renderSelectedShapeActions = () => /* @__PURE__ */ jsx113(
        Section,
        {
          heading: "selectedShapeActions",
          className: clsx45("selected-shape-actions zen-mode-transition", {
            "transition-left": appState.zenModeEnabled
          }),
          children: /* @__PURE__ */ jsx113(
            Island,
            {
              className: CLASSES.SHAPE_ACTIONS_MENU,
              padding: 2,
              style: {
                // we want to make sure this doesn't overflow so subtracting the
                // approximate height of hamburgerMenu + footer
                maxHeight: `${appState.height - 166}px`
              },
              children: /* @__PURE__ */ jsx113(
                SelectedShapeActions,
                {
                  appState,
                  elementsMap: app.scene.getNonDeletedElementsMap(),
                  renderAction: actionManager.renderAction
                }
              )
            }
          )
        }
      );
      const renderFixedSideContainer = () => {
        const shouldRenderSelectedShapeActions = showSelectedShapeActions(
          appState,
          elements
        );
        return /* @__PURE__ */ jsx113(FixedSideContainer, { side: "top", children: /* @__PURE__ */ jsxs64("div", { className: "App-menu App-menu_top", children: [
          /* @__PURE__ */ jsxs64(Stack_default.Col, { gap: 6, className: clsx45("App-menu_top__left"), children: [
            renderCanvasActions(),
            shouldRenderSelectedShapeActions && renderSelectedShapeActions()
          ] }),
          !appState.viewModeEnabled && /* @__PURE__ */ jsx113(Section, { heading: "shapes", className: "shapes-section", children: (heading) => /* @__PURE__ */ jsxs64("div", { style: { position: "relative" }, children: [
            renderWelcomeScreen && /* @__PURE__ */ jsx113(tunnels.WelcomeScreenToolbarHintTunnel.Out, {}),
            /* @__PURE__ */ jsx113(Stack_default.Col, { gap: 4, align: "start", children: /* @__PURE__ */ jsxs64(
              Stack_default.Row,
              {
                gap: 1,
                className: clsx45("App-toolbar-container", {
                  "zen-mode": appState.zenModeEnabled
                }),
                children: [
                  /* @__PURE__ */ jsxs64(
                    Island,
                    {
                      padding: 1,
                      className: clsx45("App-toolbar", {
                        "zen-mode": appState.zenModeEnabled
                      }),
                      children: [
                        /* @__PURE__ */ jsx113(
                          HintViewer,
                          {
                            appState,
                            isMobile: device.editor.isMobile,
                            device,
                            app
                          }
                        ),
                        heading,
                        /* @__PURE__ */ jsxs64(Stack_default.Row, { gap: 1, children: [
                          /* @__PURE__ */ jsx113(
                            PenModeButton,
                            {
                              zenModeEnabled: appState.zenModeEnabled,
                              checked: appState.penMode,
                              onChange: () => onPenModeToggle(null),
                              title: t("toolBar.penMode"),
                              penDetected: appState.penDetected
                            }
                          ),
                          /* @__PURE__ */ jsx113(
                            LockButton,
                            {
                              checked: appState.activeTool.locked,
                              onChange: onLockToggle,
                              title: t("toolBar.lock")
                            }
                          ),
                          /* @__PURE__ */ jsx113("div", { className: "App-toolbar__divider" }),
                          /* @__PURE__ */ jsx113(
                            HandButton,
                            {
                              checked: isHandToolActive(appState),
                              onChange: () => onHandToolToggle(),
                              title: t("toolBar.hand"),
                              isMobile: true
                            }
                          ),
                          /* @__PURE__ */ jsx113(
                            ShapesSwitcher,
                            {
                              appState,
                              activeTool: appState.activeTool,
                              UIOptions,
                              app
                            }
                          )
                        ] })
                      ]
                    }
                  ),
                  isCollaborating && /* @__PURE__ */ jsx113(
                    Island,
                    {
                      style: {
                        marginLeft: 8,
                        alignSelf: "center",
                        height: "fit-content"
                      },
                      children: /* @__PURE__ */ jsx113(
                        LaserPointerButton,
                        {
                          title: t("toolBar.laser"),
                          checked: appState.activeTool.type === TOOL_TYPE.laser,
                          onChange: () => app.setActiveTool({ type: TOOL_TYPE.laser }),
                          isMobile: true
                        }
                      )
                    }
                  )
                ]
              }
            ) })
          ] }) }),
          /* @__PURE__ */ jsxs64(
            "div",
            {
              className: clsx45(
                "layer-ui__wrapper__top-right zen-mode-transition",
                {
                  "transition-right": appState.zenModeEnabled
                }
              ),
              children: [
                appState.collaborators.size > 0 && /* @__PURE__ */ jsx113(
                  UserList,
                  {
                    collaborators: appState.collaborators,
                    userToFollow: appState.userToFollow?.socketId || null
                  }
                ),
                renderTopRightUI?.(device.editor.isMobile, appState),
                !appState.viewModeEnabled && // hide button when sidebar docked
                (!isSidebarDocked || appState.openSidebar?.name !== DEFAULT_SIDEBAR.name) && /* @__PURE__ */ jsx113(tunnels.DefaultSidebarTriggerTunnel.Out, {})
              ]
            }
          )
        ] }) });
      };
      const renderSidebars = () => {
        return /* @__PURE__ */ jsx113(
          DefaultSidebar,
          {
            __fallback: true,
            onDock: (docked) => {
              trackEvent(
                "sidebar",
                `toggleDock (${docked ? "dock" : "undock"})`,
                `(${device.editor.isMobile ? "mobile" : "desktop"})`
              );
            }
          }
        );
      };
      const isSidebarDocked = useAtomValue2(isSidebarDockedAtom, jotaiScope);
      const layerUIJSX = /* @__PURE__ */ jsxs64(Fragment19, { children: [
        children,
        /* @__PURE__ */ jsx113(DefaultMainMenu, { UIOptions }),
        /* @__PURE__ */ jsx113(
          DefaultSidebar.Trigger,
          {
            __fallback: true,
            icon: LibraryIcon,
            title: capitalizeString(t("toolBar.library")),
            onToggle: (open) => {
              if (open) {
                trackEvent(
                  "sidebar",
                  `${DEFAULT_SIDEBAR.name} (open)`,
                  `button (${device.editor.isMobile ? "mobile" : "desktop"})`
                );
              }
            },
            tab: DEFAULT_SIDEBAR.defaultTab,
            children: t("toolBar.library")
          }
        ),
        /* @__PURE__ */ jsx113(DefaultOverwriteConfirmDialog, {}),
        appState.openDialog?.name === "ttd" && /* @__PURE__ */ jsx113(TTDDialog, { __fallback: true }),
        appState.isLoading && /* @__PURE__ */ jsx113(LoadingMessage, { delay: 250 }),
        appState.errorMessage && /* @__PURE__ */ jsx113(ErrorDialog, { onClose: () => setAppState({ errorMessage: null }), children: appState.errorMessage }),
        eyeDropperState && !device.editor.isMobile && /* @__PURE__ */ jsx113(
          EyeDropper,
          {
            colorPickerType: eyeDropperState.colorPickerType,
            onCancel: () => {
              setEyeDropperState(null);
            },
            onChange: (colorPickerType, color, selectedElements, { altKey }) => {
              if (colorPickerType !== "elementBackground" && colorPickerType !== "elementStroke") {
                return;
              }
              if (selectedElements.length) {
                for (const element of selectedElements) {
                  mutateElement(
                    element,
                    {
                      [altKey && eyeDropperState.swapPreviewOnAlt ? colorPickerType === "elementBackground" ? "strokeColor" : "backgroundColor" : colorPickerType === "elementBackground" ? "backgroundColor" : "strokeColor"]: color
                    },
                    false
                  );
                  ShapeCache.delete(element);
                }
                Scene_default.getScene(selectedElements[0])?.informMutation();
              } else if (colorPickerType === "elementBackground") {
                setAppState({
                  currentItemBackgroundColor: color
                });
              } else {
                setAppState({ currentItemStrokeColor: color });
              }
            },
            onSelect: (color, event) => {
              setEyeDropperState((state) => {
                return state?.keepOpenOnAlt && event.altKey ? state : null;
              });
              eyeDropperState?.onSelect?.(color, event);
            }
          }
        ),
        appState.openDialog?.name === "help" && /* @__PURE__ */ jsx113(
          HelpDialog,
          {
            onClose: () => {
              setAppState({ openDialog: null });
            }
          }
        ),
        appState.openDialog?.name === "settings" && /* @__PURE__ */ jsx113(
          MagicSettings,
          {
            openAIKey,
            isPersisted: isOpenAIKeyPersisted,
            onChange: onOpenAIAPIKeyChange,
            onConfirm: (apiKey, shouldPersist) => {
              const source = appState.openDialog?.name === "settings" ? appState.openDialog?.source : "settings";
              setAppState({ openDialog: null }, () => {
                onMagicSettingsConfirm(apiKey, shouldPersist, source);
              });
            },
            onClose: () => {
              setAppState({ openDialog: null });
            }
          }
        ),
        /* @__PURE__ */ jsx113(ActiveConfirmDialog, {}),
        /* @__PURE__ */ jsx113(tunnels.OverwriteConfirmDialogTunnel.Out, {}),
        renderImageExportDialog(),
        renderJSONExportDialog(),
        appState.pasteDialog.shown && /* @__PURE__ */ jsx113(
          PasteChartDialog,
          {
            setAppState,
            appState,
            onClose: () => setAppState({
              pasteDialog: { shown: false, data: null }
            })
          }
        ),
        device.editor.isMobile && /* @__PURE__ */ jsx113(
          MobileMenu,
          {
            app,
            appState,
            elements,
            actionManager,
            renderJSONExportDialog,
            renderImageExportDialog,
            setAppState,
            onLockToggle,
            onHandToolToggle,
            onPenModeToggle,
            renderTopRightUI,
            renderCustomStats,
            renderSidebars,
            device,
            renderWelcomeScreen,
            UIOptions
          }
        ),
        !device.editor.isMobile && /* @__PURE__ */ jsxs64(Fragment19, { children: [
          /* @__PURE__ */ jsxs64(
            "div",
            {
              className: "layer-ui__wrapper",
              style: appState.openSidebar && isSidebarDocked && device.editor.canFitSidebar ? { width: `calc(100% - ${LIBRARY_SIDEBAR_WIDTH}px)` } : {},
              children: [
                renderWelcomeScreen && /* @__PURE__ */ jsx113(tunnels.WelcomeScreenCenterTunnel.Out, {}),
                renderFixedSideContainer(),
                /* @__PURE__ */ jsx113(
                  Footer_default,
                  {
                    appState,
                    actionManager,
                    showExitZenModeBtn,
                    renderWelcomeScreen
                  }
                ),
                appState.showStats && /* @__PURE__ */ jsx113(
                  Stats,
                  {
                    appState,
                    setAppState,
                    elements,
                    onClose: () => {
                      actionManager.executeAction(actionToggleStats);
                    },
                    renderCustomStats
                  }
                ),
                appState.scrolledOutside && /* @__PURE__ */ jsx113(
                  "button",
                  {
                    className: "scroll-back-to-content",
                    onClick: () => {
                      setAppState((appState2) => ({
                        ...calculateScrollCenter(elements, appState2)
                      }));
                    },
                    children: t("buttons.scrollBackToContent")
                  }
                )
              ]
            }
          ),
          renderSidebars()
        ] })
      ] });
      return /* @__PURE__ */ jsx113(UIAppStateContext.Provider, { value: appState, children: /* @__PURE__ */ jsx113(Provider, { scope: tunnels.jotaiScope, children: /* @__PURE__ */ jsx113(TunnelsContext.Provider, { value: tunnels, children: layerUIJSX }) }) });
    };
    stripIrrelevantAppStateProps = (appState) => {
      const {
        suggestedBindings,
        startBoundElement,
        cursorButton,
        scrollX,
        scrollY,
        ...ret
      } = appState;
      return ret;
    };
    areEqual = (prevProps, nextProps) => {
      if (prevProps.children !== nextProps.children) {
        return false;
      }
      const { canvas: _pC, appState: prevAppState, ...prev } = prevProps;
      const { canvas: _nC, appState: nextAppState, ...next } = nextProps;
      return isShallowEqual(
        // asserting AppState because we're being passed the whole AppState
        // but resolve to only the UI-relevant props
        stripIrrelevantAppStateProps(prevAppState),
        stripIrrelevantAppStateProps(nextAppState),
        {
          selectedElementIds: isShallowEqual,
          selectedGroupIds: isShallowEqual
        }
      ) && isShallowEqual(prev, next);
    };
    LayerUI_default = React35.memo(LayerUI, areEqual);
  }
});

// components/Toast.scss
var init_Toast = __esm({
  "components/Toast.scss"() {
  }
});

// components/Toast.tsx
import { useCallback as useCallback10, useEffect as useEffect27, useRef as useRef26 } from "react";
import { jsx as jsx114, jsxs as jsxs65 } from "react/jsx-runtime";
var DEFAULT_TOAST_TIMEOUT, Toast;
var init_Toast2 = __esm({
  "components/Toast.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_icons();
    init_Toast();
    init_ToolButton();
    DEFAULT_TOAST_TIMEOUT = 5e3;
    Toast = ({
      message,
      onClose,
      closable = false,
      // To prevent autoclose, pass duration as Infinity
      duration = DEFAULT_TOAST_TIMEOUT
    }) => {
      const timerRef = useRef26(0);
      const shouldAutoClose = duration !== Infinity;
      const scheduleTimeout = useCallback10(() => {
        if (!shouldAutoClose) {
          return;
        }
        timerRef.current = window.setTimeout(() => onClose(), duration);
      }, [onClose, duration, shouldAutoClose]);
      useEffect27(() => {
        if (!shouldAutoClose) {
          return;
        }
        scheduleTimeout();
        return () => clearTimeout(timerRef.current);
      }, [scheduleTimeout, message, duration, shouldAutoClose]);
      const onMouseEnter = shouldAutoClose ? () => clearTimeout(timerRef?.current) : void 0;
      const onMouseLeave = shouldAutoClose ? scheduleTimeout : void 0;
      return /* @__PURE__ */ jsxs65(
        "div",
        {
          className: "Toast",
          onMouseEnter,
          onMouseLeave,
          children: [
            /* @__PURE__ */ jsx114("p", { className: "Toast__message", children: message }),
            closable && /* @__PURE__ */ jsx114(
              ToolButton,
              {
                icon: CloseIcon,
                "aria-label": "close",
                type: "icon",
                onClick: onClose,
                className: "close"
              }
            )
          ]
        }
      );
    };
  }
});

// actions/actionToggleViewMode.tsx
var actionToggleViewMode;
var init_actionToggleViewMode = __esm({
  "actions/actionToggleViewMode.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_keys();
    init_register();
    actionToggleViewMode = register({
      name: "viewMode",
      viewMode: true,
      trackEvent: {
        category: "canvas",
        predicate: (appState) => !appState.viewModeEnabled
      },
      perform(elements, appState) {
        return {
          appState: {
            ...appState,
            viewModeEnabled: !this.checked(appState)
          },
          commitToHistory: false
        };
      },
      checked: (appState) => appState.viewModeEnabled,
      predicate: (elements, appState, appProps) => {
        return typeof appProps.viewModeEnabled === "undefined";
      },
      contextItemLabel: "labels.viewMode",
      keyTest: (event) => !event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.R
    });
  }
});

// scene/Fonts.ts
var Fonts;
var init_Fonts = __esm({
  "scene/Fonts.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_element();
    init_mutateElement();
    init_textElement();
    init_typeChecks();
    init_utils();
    init_ShapeCache();
    Fonts = class _Fonts {
      scene;
      onSceneUpdated;
      constructor({
        scene,
        onSceneUpdated
      }) {
        this.scene = scene;
        this.onSceneUpdated = onSceneUpdated;
      }
      // it's ok to track fonts across multiple instances only once, so let's use
      // a static member to reduce memory footprint
      static loadedFontFaces = /* @__PURE__ */ new Set();
      /**
       * if we load a (new) font, it's likely that text elements using it have
       * already been rendered using a fallback font. Thus, we want invalidate
       * their shapes and rerender. See #637.
       *
       * Invalidates text elements and rerenders scene, provided that at least one
       * of the supplied fontFaces has not already been processed.
       */
      onFontsLoaded = (fontFaces) => {
        if (
          // bail if all fonts with have been processed. We're checking just a
          // subset of the font properties (though it should be enough), so it
          // can technically bail on a false positive.
          fontFaces.every((fontFace) => {
            const sig = `${fontFace.family}-${fontFace.style}-${fontFace.weight}`;
            if (_Fonts.loadedFontFaces.has(sig)) {
              return true;
            }
            _Fonts.loadedFontFaces.add(sig);
            return false;
          })
        ) {
          return false;
        }
        let didUpdate = false;
        this.scene.mapElements((element) => {
          if (isTextElement(element) && !isBoundToContainer(element)) {
            ShapeCache.delete(element);
            didUpdate = true;
            return newElementWith(element, {
              ...refreshTextDimensions(
                element,
                getContainerElement(element, this.scene.getNonDeletedElementsMap()),
                this.scene.getNonDeletedElementsMap()
              )
            });
          }
          return element;
        });
        if (didUpdate) {
          this.onSceneUpdated();
        }
      };
      loadFontsForElements = async (elements) => {
        const fontFaces = await Promise.all(
          [
            ...new Set(
              elements.filter((element) => isTextElement(element)).map((element) => element.fontFamily)
            )
          ].map((fontFamily) => {
            const fontString = getFontString({
              fontFamily,
              fontSize: 16
            });
            if (!document.fonts?.check?.(fontString)) {
              return document.fonts?.load?.(fontString);
            }
            return void 0;
          })
        );
        this.onFontsLoaded(fontFaces.flat().filter(Boolean));
      };
    };
  }
});

// actions/actionFrame.ts
var isSingleFrameSelected, actionSelectAllElementsInFrame, actionRemoveAllElementsFromFrame, actionupdateFrameRendering, actionSetFrameAsActiveTool;
var init_actionFrame = __esm({
  "actions/actionFrame.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_element();
    init_frame();
    init_frame();
    init_keys();
    init_utils();
    init_cursor();
    init_register();
    init_typeChecks();
    isSingleFrameSelected = (appState, app) => {
      const selectedElements = app.scene.getSelectedElements(appState);
      return selectedElements.length === 1 && isFrameLikeElement(selectedElements[0]);
    };
    actionSelectAllElementsInFrame = register({
      name: "selectAllElementsInFrame",
      trackEvent: { category: "canvas" },
      perform: (elements, appState, _, app) => {
        const selectedElement = app.scene.getSelectedElements(appState).at(0) || null;
        if (isFrameLikeElement(selectedElement)) {
          const elementsInFrame = getFrameChildren(
            getNonDeletedElements3(elements),
            selectedElement.id
          ).filter((element) => !(element.type === "text" && element.containerId));
          return {
            elements,
            appState: {
              ...appState,
              selectedElementIds: elementsInFrame.reduce((acc, element) => {
                acc[element.id] = true;
                return acc;
              }, {})
            },
            commitToHistory: false
          };
        }
        return {
          elements,
          appState,
          commitToHistory: false
        };
      },
      contextItemLabel: "labels.selectAllElementsInFrame",
      predicate: (elements, appState, _, app) => isSingleFrameSelected(appState, app)
    });
    actionRemoveAllElementsFromFrame = register({
      name: "removeAllElementsFromFrame",
      trackEvent: { category: "history" },
      perform: (elements, appState, _, app) => {
        const selectedElement = app.scene.getSelectedElements(appState).at(0) || null;
        if (isFrameLikeElement(selectedElement)) {
          return {
            elements: removeAllElementsFromFrame(elements, selectedElement),
            appState: {
              ...appState,
              selectedElementIds: {
                [selectedElement.id]: true
              }
            },
            commitToHistory: true
          };
        }
        return {
          elements,
          appState,
          commitToHistory: false
        };
      },
      contextItemLabel: "labels.removeAllElementsFromFrame",
      predicate: (elements, appState, _, app) => isSingleFrameSelected(appState, app)
    });
    actionupdateFrameRendering = register({
      name: "updateFrameRendering",
      viewMode: true,
      trackEvent: { category: "canvas" },
      perform: (elements, appState) => {
        return {
          elements,
          appState: {
            ...appState,
            frameRendering: {
              ...appState.frameRendering,
              enabled: !appState.frameRendering.enabled
            }
          },
          commitToHistory: false
        };
      },
      contextItemLabel: "labels.updateFrameRendering",
      checked: (appState) => appState.frameRendering.enabled
    });
    actionSetFrameAsActiveTool = register({
      name: "setFrameAsActiveTool",
      trackEvent: { category: "toolbar" },
      perform: (elements, appState, _, app) => {
        const nextActiveTool = updateActiveTool(appState, {
          type: "frame"
        });
        setCursorForShape(app.interactiveCanvas, {
          ...appState,
          activeTool: nextActiveTool
        });
        return {
          elements,
          appState: {
            ...appState,
            activeTool: updateActiveTool(appState, {
              type: "frame"
            })
          },
          commitToHistory: false
        };
      },
      keyTest: (event) => !event[KEYS.CTRL_OR_CMD] && !event.shiftKey && !event.altKey && event.key.toLocaleLowerCase() === KEYS.F
    });
  }
});

// snapping.ts
var SNAP_DISTANCE, VISIBLE_GAPS_LIMIT_PER_AXIS, getSnapDistance, SnapCache, isSnappingEnabled, areRoughlyEqual, getElementsCorners, getReferenceElements, getVisibleGaps, getGapSnaps, getReferenceSnapPoints, getPointSnaps, snapDraggedElements, round, dedupePoints, createPointSnapLines, dedupeGapSnapLines, createGapSnapLines, snapResizingElements, snapNewElement, getSnapLinesAtPointer, isActiveToolNonLinearSnappable;
var init_snapping = __esm({
  "snapping.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_constants();
    init_bounds();
    init_typeChecks();
    init_groups();
    init_keys();
    init_math();
    init_selection();
    SNAP_DISTANCE = 8;
    VISIBLE_GAPS_LIMIT_PER_AXIS = 99999;
    getSnapDistance = (zoomValue) => {
      return SNAP_DISTANCE / zoomValue;
    };
    SnapCache = class _SnapCache {
      static referenceSnapPoints = null;
      static visibleGaps = null;
      static setReferenceSnapPoints = (snapPoints) => {
        _SnapCache.referenceSnapPoints = snapPoints;
      };
      static getReferenceSnapPoints = () => {
        return _SnapCache.referenceSnapPoints;
      };
      static setVisibleGaps = (gaps) => {
        _SnapCache.visibleGaps = gaps;
      };
      static getVisibleGaps = () => {
        return _SnapCache.visibleGaps;
      };
      static destroy = () => {
        _SnapCache.referenceSnapPoints = null;
        _SnapCache.visibleGaps = null;
      };
    };
    isSnappingEnabled = ({
      event,
      appState,
      selectedElements
    }) => {
      if (event) {
        return appState.objectsSnapModeEnabled && !event[KEYS.CTRL_OR_CMD] || !appState.objectsSnapModeEnabled && event[KEYS.CTRL_OR_CMD] && appState.gridSize === null;
      }
      if (selectedElements.length === 1 && selectedElements[0].type === "arrow") {
        return false;
      }
      return appState.objectsSnapModeEnabled;
    };
    areRoughlyEqual = (a, b, precision = 0.01) => {
      return Math.abs(a - b) <= precision;
    };
    getElementsCorners = (elements, elementsMap, {
      omitCenter,
      boundingBoxCorners,
      dragOffset
    } = {
      omitCenter: false,
      boundingBoxCorners: false
    }) => {
      let result = [];
      if (elements.length === 1) {
        const element = elements[0];
        let [x1, y1, x2, y2, cx, cy] = getElementAbsoluteCoords(
          element,
          elementsMap
        );
        if (dragOffset) {
          x1 += dragOffset.x;
          x2 += dragOffset.x;
          cx += dragOffset.x;
          y1 += dragOffset.y;
          y2 += dragOffset.y;
          cy += dragOffset.y;
        }
        const halfWidth = (x2 - x1) / 2;
        const halfHeight = (y2 - y1) / 2;
        if ((element.type === "diamond" || element.type === "ellipse") && !boundingBoxCorners) {
          const leftMid = rotatePoint(
            [x1, y1 + halfHeight],
            [cx, cy],
            element.angle
          );
          const topMid = rotatePoint([x1 + halfWidth, y1], [cx, cy], element.angle);
          const rightMid = rotatePoint(
            [x2, y1 + halfHeight],
            [cx, cy],
            element.angle
          );
          const bottomMid = rotatePoint(
            [x1 + halfWidth, y2],
            [cx, cy],
            element.angle
          );
          const center = [cx, cy];
          result = omitCenter ? [leftMid, topMid, rightMid, bottomMid] : [leftMid, topMid, rightMid, bottomMid, center];
        } else {
          const topLeft = rotatePoint([x1, y1], [cx, cy], element.angle);
          const topRight = rotatePoint([x2, y1], [cx, cy], element.angle);
          const bottomLeft = rotatePoint([x1, y2], [cx, cy], element.angle);
          const bottomRight = rotatePoint([x2, y2], [cx, cy], element.angle);
          const center = [cx, cy];
          result = omitCenter ? [topLeft, topRight, bottomLeft, bottomRight] : [topLeft, topRight, bottomLeft, bottomRight, center];
        }
      } else if (elements.length > 1) {
        const [minX, minY, maxX, maxY] = getDraggedElementsBounds(
          elements,
          dragOffset ?? { x: 0, y: 0 }
        );
        const width = maxX - minX;
        const height = maxY - minY;
        const topLeft = [minX, minY];
        const topRight = [maxX, minY];
        const bottomLeft = [minX, maxY];
        const bottomRight = [maxX, maxY];
        const center = [minX + width / 2, minY + height / 2];
        result = omitCenter ? [topLeft, topRight, bottomLeft, bottomRight] : [topLeft, topRight, bottomLeft, bottomRight, center];
      }
      return result.map((point2) => [round(point2[0]), round(point2[1])]);
    };
    getReferenceElements = (elements, selectedElements, appState, elementsMap) => {
      const selectedFrames = selectedElements.filter((element) => isFrameLikeElement(element)).map((frame) => frame.id);
      return getVisibleAndNonSelectedElements(
        elements,
        selectedElements,
        appState,
        elementsMap
      ).filter(
        (element) => !(element.frameId && selectedFrames.includes(element.frameId))
      );
    };
    getVisibleGaps = (elements, selectedElements, appState, elementsMap) => {
      const referenceElements = getReferenceElements(
        elements,
        selectedElements,
        appState,
        elementsMap
      );
      const referenceBounds = getMaximumGroups(referenceElements, elementsMap).filter(
        (elementsGroup) => !(elementsGroup.length === 1 && isBoundToContainer(elementsGroup[0]))
      ).map(
        (group) => getCommonBounds(group).map(
          (bound) => round(bound)
        )
      );
      const horizontallySorted = referenceBounds.sort((a, b) => a[0] - b[0]);
      const horizontalGaps = [];
      let c = 0;
      horizontal:
        for (let i = 0; i < horizontallySorted.length; i++) {
          const startBounds = horizontallySorted[i];
          for (let j = i + 1; j < horizontallySorted.length; j++) {
            if (++c > VISIBLE_GAPS_LIMIT_PER_AXIS) {
              break horizontal;
            }
            const endBounds = horizontallySorted[j];
            const [, startMinY, startMaxX, startMaxY] = startBounds;
            const [endMinX, endMinY, , endMaxY] = endBounds;
            if (startMaxX < endMinX && rangesOverlap([startMinY, startMaxY], [endMinY, endMaxY])) {
              horizontalGaps.push({
                startBounds,
                endBounds,
                startSide: [
                  [startMaxX, startMinY],
                  [startMaxX, startMaxY]
                ],
                endSide: [
                  [endMinX, endMinY],
                  [endMinX, endMaxY]
                ],
                length: endMinX - startMaxX,
                overlap: rangeIntersection(
                  [startMinY, startMaxY],
                  [endMinY, endMaxY]
                )
              });
            }
          }
        }
      const verticallySorted = referenceBounds.sort((a, b) => a[1] - b[1]);
      const verticalGaps = [];
      c = 0;
      vertical:
        for (let i = 0; i < verticallySorted.length; i++) {
          const startBounds = verticallySorted[i];
          for (let j = i + 1; j < verticallySorted.length; j++) {
            if (++c > VISIBLE_GAPS_LIMIT_PER_AXIS) {
              break vertical;
            }
            const endBounds = verticallySorted[j];
            const [startMinX, , startMaxX, startMaxY] = startBounds;
            const [endMinX, endMinY, endMaxX] = endBounds;
            if (startMaxY < endMinY && rangesOverlap([startMinX, startMaxX], [endMinX, endMaxX])) {
              verticalGaps.push({
                startBounds,
                endBounds,
                startSide: [
                  [startMinX, startMaxY],
                  [startMaxX, startMaxY]
                ],
                endSide: [
                  [endMinX, endMinY],
                  [endMaxX, endMinY]
                ],
                length: endMinY - startMaxY,
                overlap: rangeIntersection(
                  [startMinX, startMaxX],
                  [endMinX, endMaxX]
                )
              });
            }
          }
        }
      return {
        horizontalGaps,
        verticalGaps
      };
    };
    getGapSnaps = (selectedElements, dragOffset, appState, event, nearestSnapsX, nearestSnapsY, minOffset) => {
      if (!isSnappingEnabled({ appState, event, selectedElements })) {
        return [];
      }
      if (selectedElements.length === 0) {
        return [];
      }
      const visibleGaps = SnapCache.getVisibleGaps();
      if (visibleGaps) {
        const { horizontalGaps, verticalGaps } = visibleGaps;
        const [minX, minY, maxX, maxY] = getDraggedElementsBounds(
          selectedElements,
          dragOffset
        ).map((bound) => round(bound));
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        for (const gap of horizontalGaps) {
          if (!rangesOverlap([minY, maxY], gap.overlap)) {
            continue;
          }
          const gapMidX = gap.startSide[0][0] + gap.length / 2;
          const centerOffset = round(gapMidX - centerX);
          const gapIsLargerThanSelection = gap.length > maxX - minX;
          if (gapIsLargerThanSelection && Math.abs(centerOffset) <= minOffset.x) {
            if (Math.abs(centerOffset) < minOffset.x) {
              nearestSnapsX.length = 0;
            }
            minOffset.x = Math.abs(centerOffset);
            const snap = {
              type: "gap",
              direction: "center_horizontal",
              gap,
              offset: centerOffset
            };
            nearestSnapsX.push(snap);
            continue;
          }
          const [, , endMaxX] = gap.endBounds;
          const distanceToEndElementX = minX - endMaxX;
          const sideOffsetRight = round(gap.length - distanceToEndElementX);
          if (Math.abs(sideOffsetRight) <= minOffset.x) {
            if (Math.abs(sideOffsetRight) < minOffset.x) {
              nearestSnapsX.length = 0;
            }
            minOffset.x = Math.abs(sideOffsetRight);
            const snap = {
              type: "gap",
              direction: "side_right",
              gap,
              offset: sideOffsetRight
            };
            nearestSnapsX.push(snap);
            continue;
          }
          const [startMinX, , ,] = gap.startBounds;
          const distanceToStartElementX = startMinX - maxX;
          const sideOffsetLeft = round(distanceToStartElementX - gap.length);
          if (Math.abs(sideOffsetLeft) <= minOffset.x) {
            if (Math.abs(sideOffsetLeft) < minOffset.x) {
              nearestSnapsX.length = 0;
            }
            minOffset.x = Math.abs(sideOffsetLeft);
            const snap = {
              type: "gap",
              direction: "side_left",
              gap,
              offset: sideOffsetLeft
            };
            nearestSnapsX.push(snap);
            continue;
          }
        }
        for (const gap of verticalGaps) {
          if (!rangesOverlap([minX, maxX], gap.overlap)) {
            continue;
          }
          const gapMidY = gap.startSide[0][1] + gap.length / 2;
          const centerOffset = round(gapMidY - centerY);
          const gapIsLargerThanSelection = gap.length > maxY - minY;
          if (gapIsLargerThanSelection && Math.abs(centerOffset) <= minOffset.y) {
            if (Math.abs(centerOffset) < minOffset.y) {
              nearestSnapsY.length = 0;
            }
            minOffset.y = Math.abs(centerOffset);
            const snap = {
              type: "gap",
              direction: "center_vertical",
              gap,
              offset: centerOffset
            };
            nearestSnapsY.push(snap);
            continue;
          }
          const [, startMinY, ,] = gap.startBounds;
          const distanceToStartElementY = startMinY - maxY;
          const sideOffsetTop = round(distanceToStartElementY - gap.length);
          if (Math.abs(sideOffsetTop) <= minOffset.y) {
            if (Math.abs(sideOffsetTop) < minOffset.y) {
              nearestSnapsY.length = 0;
            }
            minOffset.y = Math.abs(sideOffsetTop);
            const snap = {
              type: "gap",
              direction: "side_top",
              gap,
              offset: sideOffsetTop
            };
            nearestSnapsY.push(snap);
            continue;
          }
          const [, , , endMaxY] = gap.endBounds;
          const distanceToEndElementY = round(minY - endMaxY);
          const sideOffsetBottom = gap.length - distanceToEndElementY;
          if (Math.abs(sideOffsetBottom) <= minOffset.y) {
            if (Math.abs(sideOffsetBottom) < minOffset.y) {
              nearestSnapsY.length = 0;
            }
            minOffset.y = Math.abs(sideOffsetBottom);
            const snap = {
              type: "gap",
              direction: "side_bottom",
              gap,
              offset: sideOffsetBottom
            };
            nearestSnapsY.push(snap);
            continue;
          }
        }
      }
    };
    getReferenceSnapPoints = (elements, selectedElements, appState, elementsMap) => {
      const referenceElements = getReferenceElements(
        elements,
        selectedElements,
        appState,
        elementsMap
      );
      return getMaximumGroups(referenceElements, elementsMap).filter(
        (elementsGroup) => !(elementsGroup.length === 1 && isBoundToContainer(elementsGroup[0]))
      ).flatMap((elementGroup) => getElementsCorners(elementGroup, elementsMap));
    };
    getPointSnaps = (selectedElements, selectionSnapPoints, appState, event, nearestSnapsX, nearestSnapsY, minOffset) => {
      if (!isSnappingEnabled({ appState, event, selectedElements }) || selectedElements.length === 0 && selectionSnapPoints.length === 0) {
        return [];
      }
      const referenceSnapPoints = SnapCache.getReferenceSnapPoints();
      if (referenceSnapPoints) {
        for (const thisSnapPoint of selectionSnapPoints) {
          for (const otherSnapPoint of referenceSnapPoints) {
            const offsetX = otherSnapPoint[0] - thisSnapPoint[0];
            const offsetY = otherSnapPoint[1] - thisSnapPoint[1];
            if (Math.abs(offsetX) <= minOffset.x) {
              if (Math.abs(offsetX) < minOffset.x) {
                nearestSnapsX.length = 0;
              }
              nearestSnapsX.push({
                type: "point",
                points: [thisSnapPoint, otherSnapPoint],
                offset: offsetX
              });
              minOffset.x = Math.abs(offsetX);
            }
            if (Math.abs(offsetY) <= minOffset.y) {
              if (Math.abs(offsetY) < minOffset.y) {
                nearestSnapsY.length = 0;
              }
              nearestSnapsY.push({
                type: "point",
                points: [thisSnapPoint, otherSnapPoint],
                offset: offsetY
              });
              minOffset.y = Math.abs(offsetY);
            }
          }
        }
      }
    };
    snapDraggedElements = (elements, dragOffset, appState, event, elementsMap) => {
      const selectedElements = getSelectedElements(elements, appState);
      if (!isSnappingEnabled({ appState, event, selectedElements }) || selectedElements.length === 0) {
        return {
          snapOffset: {
            x: 0,
            y: 0
          },
          snapLines: []
        };
      }
      dragOffset.x = round(dragOffset.x);
      dragOffset.y = round(dragOffset.y);
      const nearestSnapsX = [];
      const nearestSnapsY = [];
      const snapDistance = getSnapDistance(appState.zoom.value);
      const minOffset = {
        x: snapDistance,
        y: snapDistance
      };
      const selectionPoints = getElementsCorners(selectedElements, elementsMap, {
        dragOffset
      });
      getPointSnaps(
        selectedElements,
        selectionPoints,
        appState,
        event,
        nearestSnapsX,
        nearestSnapsY,
        minOffset
      );
      getGapSnaps(
        selectedElements,
        dragOffset,
        appState,
        event,
        nearestSnapsX,
        nearestSnapsY,
        minOffset
      );
      const snapOffset = {
        x: nearestSnapsX[0]?.offset ?? 0,
        y: nearestSnapsY[0]?.offset ?? 0
      };
      minOffset.x = 0;
      minOffset.y = 0;
      nearestSnapsX.length = 0;
      nearestSnapsY.length = 0;
      const newDragOffset = {
        x: round(dragOffset.x + snapOffset.x),
        y: round(dragOffset.y + snapOffset.y)
      };
      getPointSnaps(
        selectedElements,
        getElementsCorners(selectedElements, elementsMap, {
          dragOffset: newDragOffset
        }),
        appState,
        event,
        nearestSnapsX,
        nearestSnapsY,
        minOffset
      );
      getGapSnaps(
        selectedElements,
        newDragOffset,
        appState,
        event,
        nearestSnapsX,
        nearestSnapsY,
        minOffset
      );
      const pointSnapLines = createPointSnapLines(nearestSnapsX, nearestSnapsY);
      const gapSnapLines = createGapSnapLines(
        selectedElements,
        newDragOffset,
        [...nearestSnapsX, ...nearestSnapsY].filter(
          (snap) => snap.type === "gap"
        )
      );
      return {
        snapOffset,
        snapLines: [...pointSnapLines, ...gapSnapLines]
      };
    };
    round = (x) => {
      const decimalPlaces = 6;
      return Math.round(x * 10 ** decimalPlaces) / 10 ** decimalPlaces;
    };
    dedupePoints = (points) => {
      const map = /* @__PURE__ */ new Map();
      for (const point2 of points) {
        const key = point2.join(",");
        if (!map.has(key)) {
          map.set(key, point2);
        }
      }
      return Array.from(map.values());
    };
    createPointSnapLines = (nearestSnapsX, nearestSnapsY) => {
      const snapsX = {};
      const snapsY = {};
      if (nearestSnapsX.length > 0) {
        for (const snap of nearestSnapsX) {
          if (snap.type === "point") {
            const key = round(snap.points[0][0]);
            if (!snapsX[key]) {
              snapsX[key] = [];
            }
            snapsX[key].push(
              ...snap.points.map(
                (point2) => [round(point2[0]), round(point2[1])]
              )
            );
          }
        }
      }
      if (nearestSnapsY.length > 0) {
        for (const snap of nearestSnapsY) {
          if (snap.type === "point") {
            const key = round(snap.points[0][1]);
            if (!snapsY[key]) {
              snapsY[key] = [];
            }
            snapsY[key].push(
              ...snap.points.map(
                (point2) => [round(point2[0]), round(point2[1])]
              )
            );
          }
        }
      }
      return Object.entries(snapsX).map(([key, points]) => {
        return {
          type: "points",
          points: dedupePoints(
            points.map((point2) => {
              return [Number(key), point2[1]];
            }).sort((a, b) => a[1] - b[1])
          )
        };
      }).concat(
        Object.entries(snapsY).map(([key, points]) => {
          return {
            type: "points",
            points: dedupePoints(
              points.map((point2) => {
                return [point2[0], Number(key)];
              }).sort((a, b) => a[0] - b[0])
            )
          };
        })
      );
    };
    dedupeGapSnapLines = (gapSnapLines) => {
      const map = /* @__PURE__ */ new Map();
      for (const gapSnapLine of gapSnapLines) {
        const key = gapSnapLine.points.flat().map((point2) => [round(point2)]).join(",");
        if (!map.has(key)) {
          map.set(key, gapSnapLine);
        }
      }
      return Array.from(map.values());
    };
    createGapSnapLines = (selectedElements, dragOffset, gapSnaps) => {
      const [minX, minY, maxX, maxY] = getDraggedElementsBounds(
        selectedElements,
        dragOffset
      );
      const gapSnapLines = [];
      for (const gapSnap of gapSnaps) {
        const [startMinX, startMinY, startMaxX, startMaxY] = gapSnap.gap.startBounds;
        const [endMinX, endMinY, endMaxX, endMaxY] = gapSnap.gap.endBounds;
        const verticalIntersection = rangeIntersection(
          [minY, maxY],
          gapSnap.gap.overlap
        );
        const horizontalGapIntersection = rangeIntersection(
          [minX, maxX],
          gapSnap.gap.overlap
        );
        switch (gapSnap.direction) {
          case "center_horizontal": {
            if (verticalIntersection) {
              const gapLineY = (verticalIntersection[0] + verticalIntersection[1]) / 2;
              gapSnapLines.push(
                {
                  type: "gap",
                  direction: "horizontal",
                  points: [
                    [gapSnap.gap.startSide[0][0], gapLineY],
                    [minX, gapLineY]
                  ]
                },
                {
                  type: "gap",
                  direction: "horizontal",
                  points: [
                    [maxX, gapLineY],
                    [gapSnap.gap.endSide[0][0], gapLineY]
                  ]
                }
              );
            }
            break;
          }
          case "center_vertical": {
            if (horizontalGapIntersection) {
              const gapLineX = (horizontalGapIntersection[0] + horizontalGapIntersection[1]) / 2;
              gapSnapLines.push(
                {
                  type: "gap",
                  direction: "vertical",
                  points: [
                    [gapLineX, gapSnap.gap.startSide[0][1]],
                    [gapLineX, minY]
                  ]
                },
                {
                  type: "gap",
                  direction: "vertical",
                  points: [
                    [gapLineX, maxY],
                    [gapLineX, gapSnap.gap.endSide[0][1]]
                  ]
                }
              );
            }
            break;
          }
          case "side_right": {
            if (verticalIntersection) {
              const gapLineY = (verticalIntersection[0] + verticalIntersection[1]) / 2;
              gapSnapLines.push(
                {
                  type: "gap",
                  direction: "horizontal",
                  points: [
                    [startMaxX, gapLineY],
                    [endMinX, gapLineY]
                  ]
                },
                {
                  type: "gap",
                  direction: "horizontal",
                  points: [
                    [endMaxX, gapLineY],
                    [minX, gapLineY]
                  ]
                }
              );
            }
            break;
          }
          case "side_left": {
            if (verticalIntersection) {
              const gapLineY = (verticalIntersection[0] + verticalIntersection[1]) / 2;
              gapSnapLines.push(
                {
                  type: "gap",
                  direction: "horizontal",
                  points: [
                    [maxX, gapLineY],
                    [startMinX, gapLineY]
                  ]
                },
                {
                  type: "gap",
                  direction: "horizontal",
                  points: [
                    [startMaxX, gapLineY],
                    [endMinX, gapLineY]
                  ]
                }
              );
            }
            break;
          }
          case "side_top": {
            if (horizontalGapIntersection) {
              const gapLineX = (horizontalGapIntersection[0] + horizontalGapIntersection[1]) / 2;
              gapSnapLines.push(
                {
                  type: "gap",
                  direction: "vertical",
                  points: [
                    [gapLineX, maxY],
                    [gapLineX, startMinY]
                  ]
                },
                {
                  type: "gap",
                  direction: "vertical",
                  points: [
                    [gapLineX, startMaxY],
                    [gapLineX, endMinY]
                  ]
                }
              );
            }
            break;
          }
          case "side_bottom": {
            if (horizontalGapIntersection) {
              const gapLineX = (horizontalGapIntersection[0] + horizontalGapIntersection[1]) / 2;
              gapSnapLines.push(
                {
                  type: "gap",
                  direction: "vertical",
                  points: [
                    [gapLineX, startMaxY],
                    [gapLineX, endMinY]
                  ]
                },
                {
                  type: "gap",
                  direction: "vertical",
                  points: [
                    [gapLineX, endMaxY],
                    [gapLineX, minY]
                  ]
                }
              );
            }
            break;
          }
        }
      }
      return dedupeGapSnapLines(
        gapSnapLines.map((gapSnapLine) => {
          return {
            ...gapSnapLine,
            points: gapSnapLine.points.map(
              (point2) => [round(point2[0]), round(point2[1])]
            )
          };
        })
      );
    };
    snapResizingElements = (selectedElements, selectedOriginalElements, appState, event, dragOffset, transformHandle) => {
      if (!isSnappingEnabled({ event, selectedElements, appState }) || selectedElements.length === 0 || selectedElements.length === 1 && !areRoughlyEqual(selectedElements[0].angle, 0)) {
        return {
          snapOffset: { x: 0, y: 0 },
          snapLines: []
        };
      }
      let [minX, minY, maxX, maxY] = getCommonBounds(selectedOriginalElements);
      if (transformHandle) {
        if (transformHandle.includes("e")) {
          maxX += dragOffset.x;
        } else if (transformHandle.includes("w")) {
          minX += dragOffset.x;
        }
        if (transformHandle.includes("n")) {
          minY += dragOffset.y;
        } else if (transformHandle.includes("s")) {
          maxY += dragOffset.y;
        }
      }
      const selectionSnapPoints = [];
      if (transformHandle) {
        switch (transformHandle) {
          case "e": {
            selectionSnapPoints.push([maxX, minY], [maxX, maxY]);
            break;
          }
          case "w": {
            selectionSnapPoints.push([minX, minY], [minX, maxY]);
            break;
          }
          case "n": {
            selectionSnapPoints.push([minX, minY], [maxX, minY]);
            break;
          }
          case "s": {
            selectionSnapPoints.push([minX, maxY], [maxX, maxY]);
            break;
          }
          case "ne": {
            selectionSnapPoints.push([maxX, minY]);
            break;
          }
          case "nw": {
            selectionSnapPoints.push([minX, minY]);
            break;
          }
          case "se": {
            selectionSnapPoints.push([maxX, maxY]);
            break;
          }
          case "sw": {
            selectionSnapPoints.push([minX, maxY]);
            break;
          }
        }
      }
      const snapDistance = getSnapDistance(appState.zoom.value);
      const minOffset = {
        x: snapDistance,
        y: snapDistance
      };
      const nearestSnapsX = [];
      const nearestSnapsY = [];
      getPointSnaps(
        selectedOriginalElements,
        selectionSnapPoints,
        appState,
        event,
        nearestSnapsX,
        nearestSnapsY,
        minOffset
      );
      const snapOffset = {
        x: nearestSnapsX[0]?.offset ?? 0,
        y: nearestSnapsY[0]?.offset ?? 0
      };
      minOffset.x = 0;
      minOffset.y = 0;
      nearestSnapsX.length = 0;
      nearestSnapsY.length = 0;
      const [x1, y1, x2, y2] = getCommonBounds(selectedElements).map(
        (bound) => round(bound)
      );
      const corners = [
        [x1, y1],
        [x1, y2],
        [x2, y1],
        [x2, y2]
      ];
      getPointSnaps(
        selectedElements,
        corners,
        appState,
        event,
        nearestSnapsX,
        nearestSnapsY,
        minOffset
      );
      const pointSnapLines = createPointSnapLines(nearestSnapsX, nearestSnapsY);
      return {
        snapOffset,
        snapLines: pointSnapLines
      };
    };
    snapNewElement = (draggingElement, appState, event, origin, dragOffset, elementsMap) => {
      if (!isSnappingEnabled({ event, selectedElements: [draggingElement], appState })) {
        return {
          snapOffset: { x: 0, y: 0 },
          snapLines: []
        };
      }
      const selectionSnapPoints = [
        [origin.x + dragOffset.x, origin.y + dragOffset.y]
      ];
      const snapDistance = getSnapDistance(appState.zoom.value);
      const minOffset = {
        x: snapDistance,
        y: snapDistance
      };
      const nearestSnapsX = [];
      const nearestSnapsY = [];
      getPointSnaps(
        [draggingElement],
        selectionSnapPoints,
        appState,
        event,
        nearestSnapsX,
        nearestSnapsY,
        minOffset
      );
      const snapOffset = {
        x: nearestSnapsX[0]?.offset ?? 0,
        y: nearestSnapsY[0]?.offset ?? 0
      };
      minOffset.x = 0;
      minOffset.y = 0;
      nearestSnapsX.length = 0;
      nearestSnapsY.length = 0;
      const corners = getElementsCorners([draggingElement], elementsMap, {
        boundingBoxCorners: true,
        omitCenter: true
      });
      getPointSnaps(
        [draggingElement],
        corners,
        appState,
        event,
        nearestSnapsX,
        nearestSnapsY,
        minOffset
      );
      const pointSnapLines = createPointSnapLines(nearestSnapsX, nearestSnapsY);
      return {
        snapOffset,
        snapLines: pointSnapLines
      };
    };
    getSnapLinesAtPointer = (elements, appState, pointer, event, elementsMap) => {
      if (!isSnappingEnabled({ event, selectedElements: [], appState })) {
        return {
          originOffset: { x: 0, y: 0 },
          snapLines: []
        };
      }
      const referenceElements = getVisibleAndNonSelectedElements(
        elements,
        [],
        appState,
        elementsMap
      );
      const snapDistance = getSnapDistance(appState.zoom.value);
      const minOffset = {
        x: snapDistance,
        y: snapDistance
      };
      const horizontalSnapLines = [];
      const verticalSnapLines = [];
      for (const referenceElement of referenceElements) {
        const corners = getElementsCorners([referenceElement], elementsMap);
        for (const corner of corners) {
          const offsetX = corner[0] - pointer.x;
          if (Math.abs(offsetX) <= Math.abs(minOffset.x)) {
            if (Math.abs(offsetX) < Math.abs(minOffset.x)) {
              verticalSnapLines.length = 0;
            }
            verticalSnapLines.push({
              type: "pointer",
              points: [corner, [corner[0], pointer.y]],
              direction: "vertical"
            });
            minOffset.x = offsetX;
          }
          const offsetY = corner[1] - pointer.y;
          if (Math.abs(offsetY) <= Math.abs(minOffset.y)) {
            if (Math.abs(offsetY) < Math.abs(minOffset.y)) {
              horizontalSnapLines.length = 0;
            }
            horizontalSnapLines.push({
              type: "pointer",
              points: [corner, [pointer.x, corner[1]]],
              direction: "horizontal"
            });
            minOffset.y = offsetY;
          }
        }
      }
      return {
        originOffset: {
          x: verticalSnapLines.length > 0 ? verticalSnapLines[0].points[0][0] - pointer.x : 0,
          y: horizontalSnapLines.length > 0 ? horizontalSnapLines[0].points[0][1] - pointer.y : 0
        },
        snapLines: [...verticalSnapLines, ...horizontalSnapLines]
      };
    };
    isActiveToolNonLinearSnappable = (activeToolType) => {
      return activeToolType === TOOL_TYPE.rectangle || activeToolType === TOOL_TYPE.ellipse || activeToolType === TOOL_TYPE.diamond || activeToolType === TOOL_TYPE.frame || activeToolType === TOOL_TYPE.magicframe || activeToolType === TOOL_TYPE.image;
    };
  }
});

// components/BraveMeasureTextError.tsx
import { jsx as jsx115, jsxs as jsxs66 } from "react/jsx-runtime";
var BraveMeasureTextError, BraveMeasureTextError_default;
var init_BraveMeasureTextError = __esm({
  "components/BraveMeasureTextError.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_Trans();
    BraveMeasureTextError = () => {
      return /* @__PURE__ */ jsxs66("div", { "data-testid": "brave-measure-text-error", children: [
        /* @__PURE__ */ jsx115("p", { children: /* @__PURE__ */ jsx115(
          Trans_default,
          {
            i18nKey: "errors.brave_measure_text_error.line1",
            bold: (el) => /* @__PURE__ */ jsx115("span", { style: { fontWeight: 600 }, children: el })
          }
        ) }),
        /* @__PURE__ */ jsx115("p", { children: /* @__PURE__ */ jsx115(
          Trans_default,
          {
            i18nKey: "errors.brave_measure_text_error.line2",
            bold: (el) => /* @__PURE__ */ jsx115("span", { style: { fontWeight: 600 }, children: el })
          }
        ) }),
        /* @__PURE__ */ jsx115("p", { children: /* @__PURE__ */ jsx115(
          Trans_default,
          {
            i18nKey: "errors.brave_measure_text_error.line3",
            link: (el) => /* @__PURE__ */ jsx115("a", { href: "http://docs.excalidraw.com/docs/@excalidraw/excalidraw/faq#turning-off-aggresive-block-fingerprinting-in-brave-browser", children: el })
          }
        ) }),
        /* @__PURE__ */ jsx115("p", { children: /* @__PURE__ */ jsx115(
          Trans_default,
          {
            i18nKey: "errors.brave_measure_text_error.line4",
            issueLink: (el) => /* @__PURE__ */ jsx115("a", { href: "https://github.com/excalidraw/excalidraw/issues/new", children: el }),
            discordLink: (el) => /* @__PURE__ */ jsxs66("a", { href: "https://discord.gg/UexuTaE", children: [
              el,
              "."
            ] })
          }
        ) })
      ] });
    };
    BraveMeasureTextError_default = BraveMeasureTextError;
  }
});

// data/transform.ts
var DEFAULT_LINEAR_ELEMENT_PROPS, DEFAULT_DIMENSION, bindTextToContainer, bindLinearElementToElement, ElementStore, convertToExcalidrawElements;
var init_transform = __esm({
  "data/transform.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_constants();
    init_element();
    init_binding();
    init_newElement();
    init_textElement();
    init_utils();
    init_points();
    init_random();
    DEFAULT_LINEAR_ELEMENT_PROPS = {
      width: 100,
      height: 0
    };
    DEFAULT_DIMENSION = 100;
    bindTextToContainer = (container, textProps, elementsMap) => {
      const textElement = newTextElement({
        x: 0,
        y: 0,
        textAlign: TEXT_ALIGN.CENTER,
        verticalAlign: VERTICAL_ALIGN.MIDDLE,
        ...textProps,
        containerId: container.id,
        strokeColor: textProps.strokeColor || container.strokeColor
      });
      Object.assign(container, {
        boundElements: (container.boundElements || []).concat({
          type: "text",
          id: textElement.id
        })
      });
      redrawTextBoundingBox(textElement, container, elementsMap);
      return [container, textElement];
    };
    bindLinearElementToElement = (linearElement, start2, end, elementStore, elementsMap) => {
      let startBoundElement;
      let endBoundElement;
      Object.assign(linearElement, {
        startBinding: linearElement?.startBinding || null,
        endBinding: linearElement.endBinding || null
      });
      if (start2) {
        const width = start2?.width ?? DEFAULT_DIMENSION;
        const height = start2?.height ?? DEFAULT_DIMENSION;
        let existingElement;
        if (start2.id) {
          existingElement = elementStore.getElement(start2.id);
          if (!existingElement) {
            console.error(`No element for start binding with id ${start2.id} found`);
          }
        }
        const startX = start2.x || linearElement.x - width;
        const startY = start2.y || linearElement.y - height / 2;
        const startType = existingElement ? existingElement.type : start2.type;
        if (startType) {
          if (startType === "text") {
            let text = "";
            if (existingElement && existingElement.type === "text") {
              text = existingElement.text;
            } else if (start2.type === "text") {
              text = start2.text;
            }
            if (!text) {
              console.error(
                `No text found for start binding text element for ${linearElement.id}`
              );
            }
            startBoundElement = newTextElement({
              x: startX,
              y: startY,
              type: "text",
              ...existingElement,
              ...start2,
              text
            });
            Object.assign(startBoundElement, {
              x: start2.x || linearElement.x - startBoundElement.width,
              y: start2.y || linearElement.y - startBoundElement.height / 2
            });
          } else {
            switch (startType) {
              case "rectangle":
              case "ellipse":
              case "diamond": {
                startBoundElement = newElement({
                  x: startX,
                  y: startY,
                  width,
                  height,
                  ...existingElement,
                  ...start2,
                  type: startType
                });
                break;
              }
              default: {
                assertNever(
                  linearElement,
                  `Unhandled element start type "${start2.type}"`,
                  true
                );
              }
            }
          }
          bindLinearElement(
            linearElement,
            startBoundElement,
            "start",
            elementsMap
          );
        }
      }
      if (end) {
        const height = end?.height ?? DEFAULT_DIMENSION;
        const width = end?.width ?? DEFAULT_DIMENSION;
        let existingElement;
        if (end.id) {
          existingElement = elementStore.getElement(end.id);
          if (!existingElement) {
            console.error(`No element for end binding with id ${end.id} found`);
          }
        }
        const endX = end.x || linearElement.x + linearElement.width;
        const endY = end.y || linearElement.y - height / 2;
        const endType = existingElement ? existingElement.type : end.type;
        if (endType) {
          if (endType === "text") {
            let text = "";
            if (existingElement && existingElement.type === "text") {
              text = existingElement.text;
            } else if (end.type === "text") {
              text = end.text;
            }
            if (!text) {
              console.error(
                `No text found for end binding text element for ${linearElement.id}`
              );
            }
            endBoundElement = newTextElement({
              x: endX,
              y: endY,
              type: "text",
              ...existingElement,
              ...end,
              text
            });
            Object.assign(endBoundElement, {
              y: end.y || linearElement.y - endBoundElement.height / 2
            });
          } else {
            switch (endType) {
              case "rectangle":
              case "ellipse":
              case "diamond": {
                endBoundElement = newElement({
                  x: endX,
                  y: endY,
                  width,
                  height,
                  ...existingElement,
                  ...end,
                  type: endType
                });
                break;
              }
              default: {
                assertNever(
                  linearElement,
                  `Unhandled element end type "${endType}"`,
                  true
                );
              }
            }
          }
          bindLinearElement(
            linearElement,
            endBoundElement,
            "end",
            elementsMap
          );
        }
      }
      const endPointIndex = linearElement.points.length - 1;
      const delta = 0.5;
      const newPoints = cloneJSON(linearElement.points);
      if (linearElement.points[endPointIndex][0] > linearElement.points[endPointIndex - 1][0]) {
        newPoints[0][0] = delta;
        newPoints[endPointIndex][0] -= delta;
      }
      if (linearElement.points[endPointIndex][0] < linearElement.points[endPointIndex - 1][0]) {
        newPoints[0][0] = -delta;
        newPoints[endPointIndex][0] += delta;
      }
      if (linearElement.points[endPointIndex][1] > linearElement.points[endPointIndex - 1][1]) {
        newPoints[0][1] = delta;
        newPoints[endPointIndex][1] -= delta;
      }
      if (linearElement.points[endPointIndex][1] < linearElement.points[endPointIndex - 1][1]) {
        newPoints[0][1] = -delta;
        newPoints[endPointIndex][1] += delta;
      }
      Object.assign(linearElement, { points: newPoints });
      return {
        linearElement,
        startBoundElement,
        endBoundElement
      };
    };
    ElementStore = class {
      excalidrawElements = /* @__PURE__ */ new Map();
      add = (ele) => {
        if (!ele) {
          return;
        }
        this.excalidrawElements.set(ele.id, ele);
      };
      getElements = () => {
        return Array.from(this.excalidrawElements.values());
      };
      getElementsMap = () => {
        return toBrandedType(this.excalidrawElements);
      };
      getElement = (id) => {
        return this.excalidrawElements.get(id);
      };
    };
    convertToExcalidrawElements = (elementsSkeleton, opts) => {
      if (!elementsSkeleton) {
        return [];
      }
      const elements = cloneJSON(elementsSkeleton);
      const elementStore = new ElementStore();
      const elementsWithIds = /* @__PURE__ */ new Map();
      const oldToNewElementIdMap = /* @__PURE__ */ new Map();
      for (const element of elements) {
        let excalidrawElement;
        const originalId = element.id;
        if (opts?.regenerateIds !== false) {
          Object.assign(element, { id: randomId() });
        }
        switch (element.type) {
          case "rectangle":
          case "ellipse":
          case "diamond": {
            const width = element?.label?.text && element.width === void 0 ? 0 : element?.width || DEFAULT_DIMENSION;
            const height = element?.label?.text && element.height === void 0 ? 0 : element?.height || DEFAULT_DIMENSION;
            excalidrawElement = newElement({
              ...element,
              width,
              height
            });
            break;
          }
          case "line": {
            const width = element.width || DEFAULT_LINEAR_ELEMENT_PROPS.width;
            const height = element.height || DEFAULT_LINEAR_ELEMENT_PROPS.height;
            excalidrawElement = newLinearElement({
              width,
              height,
              points: [
                [0, 0],
                [width, height]
              ],
              ...element
            });
            break;
          }
          case "arrow": {
            const width = element.width || DEFAULT_LINEAR_ELEMENT_PROPS.width;
            const height = element.height || DEFAULT_LINEAR_ELEMENT_PROPS.height;
            excalidrawElement = newLinearElement({
              width,
              height,
              endArrowhead: "arrow",
              points: [
                [0, 0],
                [width, height]
              ],
              ...element
            });
            Object.assign(
              excalidrawElement,
              getSizeFromPoints(excalidrawElement.points)
            );
            break;
          }
          case "text": {
            const fontFamily = element?.fontFamily || DEFAULT_FONT_FAMILY;
            const fontSize = element?.fontSize || DEFAULT_FONT_SIZE;
            const lineHeight = element?.lineHeight || getDefaultLineHeight(fontFamily);
            const text = element.text ?? "";
            const normalizedText = normalizeText(text);
            const metrics = measureText(
              normalizedText,
              getFontString({ fontFamily, fontSize }),
              lineHeight
            );
            excalidrawElement = newTextElement({
              width: metrics.width,
              height: metrics.height,
              fontFamily,
              fontSize,
              ...element
            });
            break;
          }
          case "image": {
            excalidrawElement = newImageElement({
              width: element?.width || DEFAULT_DIMENSION,
              height: element?.height || DEFAULT_DIMENSION,
              ...element
            });
            break;
          }
          case "frame": {
            excalidrawElement = newFrameElement({
              x: 0,
              y: 0,
              ...element
            });
            break;
          }
          case "magicframe": {
            excalidrawElement = newMagicFrameElement({
              x: 0,
              y: 0,
              ...element
            });
            break;
          }
          case "freedraw":
          case "iframe":
          case "embeddable": {
            excalidrawElement = element;
            break;
          }
          default: {
            excalidrawElement = element;
            assertNever(
              element,
              `Unhandled element type "${element.type}"`,
              true
            );
          }
        }
        const existingElement = elementStore.getElement(excalidrawElement.id);
        if (existingElement) {
          console.error(`Duplicate id found for ${excalidrawElement.id}`);
        } else {
          elementStore.add(excalidrawElement);
          elementsWithIds.set(excalidrawElement.id, element);
          if (originalId) {
            oldToNewElementIdMap.set(originalId, excalidrawElement.id);
          }
        }
      }
      const elementsMap = elementStore.getElementsMap();
      for (const [id, element] of elementsWithIds) {
        const excalidrawElement = elementStore.getElement(id);
        switch (element.type) {
          case "rectangle":
          case "ellipse":
          case "diamond":
          case "arrow": {
            if (element.label?.text) {
              let [container, text] = bindTextToContainer(
                excalidrawElement,
                element?.label,
                elementsMap
              );
              elementStore.add(container);
              elementStore.add(text);
              if (container.type === "arrow") {
                const originalStart = element.type === "arrow" ? element?.start : void 0;
                const originalEnd = element.type === "arrow" ? element?.end : void 0;
                if (originalStart && originalStart.id) {
                  const newStartId = oldToNewElementIdMap.get(originalStart.id);
                  if (newStartId) {
                    Object.assign(originalStart, { id: newStartId });
                  }
                }
                if (originalEnd && originalEnd.id) {
                  const newEndId = oldToNewElementIdMap.get(originalEnd.id);
                  if (newEndId) {
                    Object.assign(originalEnd, { id: newEndId });
                  }
                }
                const { linearElement, startBoundElement, endBoundElement } = bindLinearElementToElement(
                  container,
                  originalStart,
                  originalEnd,
                  elementStore,
                  elementsMap
                );
                container = linearElement;
                elementStore.add(linearElement);
                elementStore.add(startBoundElement);
                elementStore.add(endBoundElement);
              }
            } else {
              switch (element.type) {
                case "arrow": {
                  const { start: start2, end } = element;
                  if (start2 && start2.id) {
                    const newStartId = oldToNewElementIdMap.get(start2.id);
                    Object.assign(start2, { id: newStartId });
                  }
                  if (end && end.id) {
                    const newEndId = oldToNewElementIdMap.get(end.id);
                    Object.assign(end, { id: newEndId });
                  }
                  const { linearElement, startBoundElement, endBoundElement } = bindLinearElementToElement(
                    excalidrawElement,
                    start2,
                    end,
                    elementStore,
                    elementsMap
                  );
                  elementStore.add(linearElement);
                  elementStore.add(startBoundElement);
                  elementStore.add(endBoundElement);
                  break;
                }
              }
            }
            break;
          }
        }
      }
      for (const [id, element] of elementsWithIds) {
        if (element.type !== "frame" && element.type !== "magicframe") {
          continue;
        }
        const frame = elementStore.getElement(id);
        if (!frame) {
          throw new Error(`Excalidraw element with id ${id} doesn't exist`);
        }
        const childrenElements = [];
        element.children.forEach((id2) => {
          const newElementId = oldToNewElementIdMap.get(id2);
          if (!newElementId) {
            throw new Error(`Element with ${id2} wasn't mapped correctly`);
          }
          const elementInFrame = elementStore.getElement(newElementId);
          if (!elementInFrame) {
            throw new Error(`Frame element with id ${newElementId} doesn't exist`);
          }
          Object.assign(elementInFrame, { frameId: frame.id });
          elementInFrame?.boundElements?.forEach((boundElement) => {
            const ele = elementStore.getElement(boundElement.id);
            if (!ele) {
              throw new Error(
                `Bound element with id ${boundElement.id} doesn't exist`
              );
            }
            Object.assign(ele, { frameId: frame.id });
            childrenElements.push(ele);
          });
          childrenElements.push(elementInFrame);
        });
        let [minX, minY, maxX, maxY] = getCommonBounds(childrenElements);
        const PADDING = 10;
        minX = minX - PADDING;
        minY = minY - PADDING;
        maxX = maxX + PADDING;
        maxY = maxY + PADDING;
        const width = Math.max(frame?.width, maxX - minX);
        const height = Math.max(frame?.height, maxY - minY);
        Object.assign(frame, { x: minX, y: minY, width, height });
      }
      return elementStore.getElements();
    };
  }
});

// reactUtils.ts
import { unstable_batchedUpdates as unstable_batchedUpdates2 } from "react-dom";
import { version as ReactVersion } from "react";
var withBatchedUpdates, withBatchedUpdatesThrottled, isRenderThrottlingEnabled;
var init_reactUtils = __esm({
  "reactUtils.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_utils();
    withBatchedUpdates = (func) => (event) => {
      unstable_batchedUpdates2(func, event);
    };
    withBatchedUpdatesThrottled = (func) => {
      return throttleRAF((event) => {
        unstable_batchedUpdates2(func, event);
      });
    };
    isRenderThrottlingEnabled = (() => {
      let IS_REACT_18_AND_UP;
      try {
        const version = ReactVersion.split(".");
        IS_REACT_18_AND_UP = Number(version[0]) > 17;
      } catch {
        IS_REACT_18_AND_UP = false;
      }
      let hasWarned = false;
      return () => {
        if (window.EXCALIDRAW_THROTTLE_RENDER === true) {
          if (!IS_REACT_18_AND_UP) {
            if (!hasWarned) {
              hasWarned = true;
              console.warn(
                "Excalidraw: render throttling is disabled on React versions < 18."
              );
            }
            return false;
          }
          return true;
        }
        return false;
      };
    })();
  }
});

// components/canvases/InteractiveCanvas.tsx
import React36, { useEffect as useEffect28, useRef as useRef27 } from "react";
import { jsx as jsx116 } from "react/jsx-runtime";
var InteractiveCanvas, getRelevantAppStateProps, areEqual2, InteractiveCanvas_default;
var init_InteractiveCanvas = __esm({
  "components/canvases/InteractiveCanvas.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_renderScene();
    init_utils();
    init_constants();
    init_i18n();
    init_reactUtils();
    InteractiveCanvas = (props) => {
      const isComponentMounted = useRef27(false);
      useEffect28(() => {
        if (!isComponentMounted.current) {
          isComponentMounted.current = true;
          return;
        }
        const cursorButton = {};
        const pointerViewportCoords = {};
        const remoteSelectedElementIds = {};
        const pointerUsernames = {};
        const pointerUserStates = {};
        props.appState.collaborators.forEach((user, socketId) => {
          if (user.selectedElementIds) {
            for (const id of Object.keys(user.selectedElementIds)) {
              if (!(id in remoteSelectedElementIds)) {
                remoteSelectedElementIds[id] = [];
              }
              remoteSelectedElementIds[id].push(socketId);
            }
          }
          if (!user.pointer) {
            return;
          }
          if (user.username) {
            pointerUsernames[socketId] = user.username;
          }
          if (user.userState) {
            pointerUserStates[socketId] = user.userState;
          }
          pointerViewportCoords[socketId] = sceneCoordsToViewportCoords(
            {
              sceneX: user.pointer.x,
              sceneY: user.pointer.y
            },
            props.appState
          );
          cursorButton[socketId] = user.button;
        });
        const selectionColor = props.containerRef?.current && getComputedStyle(props.containerRef.current).getPropertyValue(
          "--color-selection"
        ) || "#6965db";
        renderInteractiveScene(
          {
            canvas: props.canvas,
            elementsMap: props.elementsMap,
            visibleElements: props.visibleElements,
            selectedElements: props.selectedElements,
            scale: window.devicePixelRatio,
            appState: props.appState,
            renderConfig: {
              remotePointerViewportCoords: pointerViewportCoords,
              remotePointerButton: cursorButton,
              remoteSelectedElementIds,
              remotePointerUsernames: pointerUsernames,
              remotePointerUserStates: pointerUserStates,
              selectionColor,
              renderScrollbars: false
            },
            callback: props.renderInteractiveSceneCallback
          },
          isRenderThrottlingEnabled()
        );
      });
      return /* @__PURE__ */ jsx116(
        "canvas",
        {
          className: "excalidraw__canvas interactive",
          style: {
            width: props.appState.width,
            height: props.appState.height,
            cursor: props.appState.viewModeEnabled ? CURSOR_TYPE.GRAB : CURSOR_TYPE.AUTO
          },
          width: props.appState.width * props.scale,
          height: props.appState.height * props.scale,
          ref: props.handleCanvasRef,
          onContextMenu: props.onContextMenu,
          onPointerMove: props.onPointerMove,
          onPointerUp: props.onPointerUp,
          onPointerCancel: props.onPointerCancel,
          onTouchMove: props.onTouchMove,
          onPointerDown: props.onPointerDown,
          onDoubleClick: props.appState.viewModeEnabled ? void 0 : props.onDoubleClick,
          children: t("labels.drawingCanvas")
        }
      );
    };
    getRelevantAppStateProps = (appState) => ({
      zoom: appState.zoom,
      scrollX: appState.scrollX,
      scrollY: appState.scrollY,
      width: appState.width,
      height: appState.height,
      viewModeEnabled: appState.viewModeEnabled,
      editingGroupId: appState.editingGroupId,
      editingLinearElement: appState.editingLinearElement,
      selectedElementIds: appState.selectedElementIds,
      frameToHighlight: appState.frameToHighlight,
      offsetLeft: appState.offsetLeft,
      offsetTop: appState.offsetTop,
      theme: appState.theme,
      pendingImageElementId: appState.pendingImageElementId,
      selectionElement: appState.selectionElement,
      selectedGroupIds: appState.selectedGroupIds,
      selectedLinearElement: appState.selectedLinearElement,
      multiElement: appState.multiElement,
      isBindingEnabled: appState.isBindingEnabled,
      suggestedBindings: appState.suggestedBindings,
      isRotating: appState.isRotating,
      elementsToHighlight: appState.elementsToHighlight,
      collaborators: appState.collaborators,
      // Necessary for collab. sessions
      activeEmbeddable: appState.activeEmbeddable,
      snapLines: appState.snapLines,
      zenModeEnabled: appState.zenModeEnabled
    });
    areEqual2 = (prevProps, nextProps) => {
      if (prevProps.selectionNonce !== nextProps.selectionNonce || prevProps.versionNonce !== nextProps.versionNonce || prevProps.scale !== nextProps.scale || // we need to memoize on elementsMap because they may have renewed
      // even if versionNonce didn't change (e.g. we filter elements out based
      // on appState)
      prevProps.elementsMap !== nextProps.elementsMap || prevProps.visibleElements !== nextProps.visibleElements || prevProps.selectedElements !== nextProps.selectedElements) {
        return false;
      }
      return isShallowEqual(
        // asserting AppState because we're being passed the whole AppState
        // but resolve to only the InteractiveCanvas-relevant props
        getRelevantAppStateProps(prevProps.appState),
        getRelevantAppStateProps(nextProps.appState)
      );
    };
    InteractiveCanvas_default = React36.memo(InteractiveCanvas, areEqual2);
  }
});

// components/canvases/StaticCanvas.tsx
import React37, { useEffect as useEffect29, useRef as useRef28 } from "react";
import { jsx as jsx117 } from "react/jsx-runtime";
var StaticCanvas, getRelevantAppStateProps2, areEqual3, StaticCanvas_default;
var init_StaticCanvas = __esm({
  "components/canvases/StaticCanvas.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_renderScene();
    init_utils();
    init_reactUtils();
    StaticCanvas = (props) => {
      const wrapperRef = useRef28(null);
      const isComponentMounted = useRef28(false);
      useEffect29(() => {
        const wrapper = wrapperRef.current;
        if (!wrapper) {
          return;
        }
        const canvas2 = props.canvas;
        if (!isComponentMounted.current) {
          isComponentMounted.current = true;
          wrapper.replaceChildren(canvas2);
          canvas2.classList.add("excalidraw__canvas", "static");
        }
        const widthString = `${props.appState.width}px`;
        const heightString = `${props.appState.height}px`;
        if (canvas2.style.width !== widthString) {
          canvas2.style.width = widthString;
        }
        if (canvas2.style.height !== heightString) {
          canvas2.style.height = heightString;
        }
        const scaledWidth = props.appState.width * props.scale;
        const scaledHeight = props.appState.height * props.scale;
        if (canvas2.width !== scaledWidth) {
          canvas2.width = scaledWidth;
        }
        if (canvas2.height !== scaledHeight) {
          canvas2.height = scaledHeight;
        }
        renderStaticScene(
          {
            canvas: canvas2,
            rc: props.rc,
            scale: props.scale,
            elementsMap: props.elementsMap,
            allElementsMap: props.allElementsMap,
            visibleElements: props.visibleElements,
            appState: props.appState,
            renderConfig: props.renderConfig
          },
          isRenderThrottlingEnabled()
        );
      });
      return /* @__PURE__ */ jsx117("div", { className: "excalidraw__canvas-wrapper", ref: wrapperRef });
    };
    getRelevantAppStateProps2 = (appState) => ({
      zoom: appState.zoom,
      scrollX: appState.scrollX,
      scrollY: appState.scrollY,
      width: appState.width,
      height: appState.height,
      viewModeEnabled: appState.viewModeEnabled,
      offsetLeft: appState.offsetLeft,
      offsetTop: appState.offsetTop,
      theme: appState.theme,
      pendingImageElementId: appState.pendingImageElementId,
      shouldCacheIgnoreZoom: appState.shouldCacheIgnoreZoom,
      viewBackgroundColor: appState.viewBackgroundColor,
      exportScale: appState.exportScale,
      selectedElementsAreBeingDragged: appState.selectedElementsAreBeingDragged,
      gridSize: appState.gridSize,
      frameRendering: appState.frameRendering,
      selectedElementIds: appState.selectedElementIds,
      frameToHighlight: appState.frameToHighlight,
      editingGroupId: appState.editingGroupId
    });
    areEqual3 = (prevProps, nextProps) => {
      if (prevProps.versionNonce !== nextProps.versionNonce || prevProps.scale !== nextProps.scale || // we need to memoize on elementsMap because they may have renewed
      // even if versionNonce didn't change (e.g. we filter elements out based
      // on appState)
      prevProps.elementsMap !== nextProps.elementsMap || prevProps.visibleElements !== nextProps.visibleElements) {
        return false;
      }
      return isShallowEqual(
        // asserting AppState because we're being passed the whole AppState
        // but resolve to only the StaticCanvas-relevant props
        getRelevantAppStateProps2(prevProps.appState),
        getRelevantAppStateProps2(nextProps.appState)
      ) && isShallowEqual(prevProps.renderConfig, nextProps.renderConfig);
    };
    StaticCanvas_default = React37.memo(StaticCanvas, areEqual3);
  }
});

// components/canvases/index.tsx
var init_canvases = __esm({
  "components/canvases/index.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_InteractiveCanvas();
    init_StaticCanvas();
  }
});

// scene/Renderer.ts
var Renderer;
var init_Renderer = __esm({
  "scene/Renderer.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_sizeHelpers();
    init_typeChecks();
    init_renderScene();
    init_utils();
    Renderer = class {
      scene;
      constructor(scene) {
        this.scene = scene;
      }
      getRenderableElements = (() => {
        const getVisibleCanvasElements = ({
          elementsMap,
          zoom,
          offsetLeft,
          offsetTop,
          scrollX,
          scrollY,
          height,
          width
        }) => {
          const visibleElements = [];
          for (const element of elementsMap.values()) {
            if (isElementInViewport(
              element,
              width,
              height,
              {
                zoom,
                offsetLeft,
                offsetTop,
                scrollX,
                scrollY
              },
              elementsMap
            )) {
              visibleElements.push(element);
            }
          }
          return visibleElements;
        };
        const getRenderableElements = ({
          elements,
          editingElement,
          pendingImageElementId
        }) => {
          const elementsMap = toBrandedType(/* @__PURE__ */ new Map());
          for (const element of elements) {
            if (isImageElement(element)) {
              if (
                // => not placed on canvas yet (but in elements array)
                pendingImageElementId === element.id
              ) {
                continue;
              }
            }
            if (!editingElement || editingElement.type !== "text" || element.id !== editingElement.id) {
              elementsMap.set(element.id, element);
            }
          }
          return elementsMap;
        };
        return memoize(
          ({
            zoom,
            offsetLeft,
            offsetTop,
            scrollX,
            scrollY,
            height,
            width,
            editingElement,
            pendingImageElementId,
            // unused but serves we cache on it to invalidate elements if they
            // get mutated
            versionNonce: _versionNonce
          }) => {
            const elements = this.scene.getNonDeletedElements();
            const elementsMap = getRenderableElements({
              elements,
              editingElement,
              pendingImageElementId
            });
            const visibleElements = getVisibleCanvasElements({
              elementsMap,
              zoom,
              offsetLeft,
              offsetTop,
              scrollX,
              scrollY,
              height,
              width
            });
            return { elementsMap, visibleElements };
          }
        );
      })();
      // NOTE Doesn't destroy everything (scene, rc, etc.) because it may not be
      // safe to break TS contract here (for upstream cases)
      destroy() {
        cancelRender();
        this.getRenderableElements.clear();
      }
    };
  }
});

// components/SVGLayer.scss
var init_SVGLayer = __esm({
  "components/SVGLayer.scss"() {
  }
});

// components/SVGLayer.tsx
import { useEffect as useEffect30, useRef as useRef29 } from "react";
import { jsx as jsx118 } from "react/jsx-runtime";
var SVGLayer;
var init_SVGLayer2 = __esm({
  "components/SVGLayer.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_SVGLayer();
    SVGLayer = ({ trails }) => {
      const svgRef = useRef29(null);
      useEffect30(() => {
        if (svgRef.current) {
          for (const trail of trails) {
            trail.start(svgRef.current);
          }
        }
        return () => {
          for (const trail of trails) {
            trail.stop();
          }
        };
      }, trails);
      return /* @__PURE__ */ jsx118("div", { className: "SVGLayer", children: /* @__PURE__ */ jsx118("svg", { ref: svgRef }) });
    };
  }
});

// emitter.ts
var Emitter;
var init_emitter = __esm({
  "emitter.ts"() {
    "use strict";
    init_define_import_meta_env();
    Emitter = class {
      subscribers = [];
      /**
       * Attaches subscriber
       *
       * @returns unsubscribe function
       */
      on(...handlers) {
        const _handlers = handlers.flat().filter((item) => typeof item === "function");
        this.subscribers.push(..._handlers);
        return () => this.off(_handlers);
      }
      once(...handlers) {
        const _handlers = handlers.flat().filter((item) => typeof item === "function");
        _handlers.push(() => detach());
        const detach = this.on(..._handlers);
        return detach;
      }
      off(...handlers) {
        const _handlers = handlers.flat();
        this.subscribers = this.subscribers.filter(
          (handler) => !_handlers.includes(handler)
        );
      }
      trigger(...payload) {
        for (const handler of this.subscribers) {
          handler(...payload);
        }
        return this;
      }
      clear() {
        this.subscribers = [];
      }
    };
  }
});

// element/ElementCanvasButtons.scss
var init_ElementCanvasButtons = __esm({
  "element/ElementCanvasButtons.scss"() {
  }
});

// element/ElementCanvasButtons.tsx
import { jsx as jsx119 } from "react/jsx-runtime";
var CONTAINER_PADDING2, getContainerCoords2, ElementCanvasButtons;
var init_ElementCanvasButtons2 = __esm({
  "element/ElementCanvasButtons.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_utils();
    init_element();
    init_App();
    init_ElementCanvasButtons();
    CONTAINER_PADDING2 = 5;
    getContainerCoords2 = (element, appState, elementsMap) => {
      const [x1, y1] = getElementAbsoluteCoords(element, elementsMap);
      const { x: viewportX, y: viewportY } = sceneCoordsToViewportCoords(
        { sceneX: x1 + element.width, sceneY: y1 },
        appState
      );
      const x = viewportX - appState.offsetLeft + 10;
      const y = viewportY - appState.offsetTop;
      return { x, y };
    };
    ElementCanvasButtons = ({
      children,
      element,
      elementsMap
    }) => {
      const appState = useExcalidrawAppState();
      if (appState.contextMenu || appState.draggingElement || appState.resizingElement || appState.isRotating || appState.openMenu || appState.viewModeEnabled) {
        return null;
      }
      const { x, y } = getContainerCoords2(element, appState, elementsMap);
      return /* @__PURE__ */ jsx119(
        "div",
        {
          className: "excalidraw-canvas-buttons",
          style: {
            top: `${y}px`,
            left: `${x}px`,
            // width: CONTAINER_WIDTH,
            padding: CONTAINER_PADDING2
          },
          children
        }
      );
    };
  }
});

// data/magic.ts
async function diagramToHTML({
  image,
  apiKey,
  text,
  theme = "light"
}) {
  const body = {
    model: "gpt-4-vision-preview",
    // 4096 are max output tokens allowed for `gpt-4-vision-preview` currently
    max_tokens: 4096,
    temperature: 0.1,
    messages: [
      {
        role: "system",
        content: SYSTEM_PROMPT
      },
      {
        role: "user",
        content: [
          {
            type: "image_url",
            image_url: {
              url: image,
              detail: "high"
            }
          },
          {
            type: "text",
            text: `Above is the reference wireframe. Please make a new website based on these and return just the HTML file. Also, please make it for the ${theme} theme. What follows are the wireframe's text annotations (if any)...`
          },
          {
            type: "text",
            text
          }
        ]
      }
    ]
  };
  let result;
  const resp = await fetch("https://api.openai.com/v1/chat/completions", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${apiKey}`
    },
    body: JSON.stringify(body)
  });
  if (resp.ok) {
    const json = await resp.json();
    result = { ...json, ok: true };
  } else {
    const json = await resp.json();
    result = { ...json, ok: false };
  }
  return result;
}
var SYSTEM_PROMPT;
var init_magic = __esm({
  "data/magic.ts"() {
    "use strict";
    init_define_import_meta_env();
    SYSTEM_PROMPT = `You are a skilled front-end developer who builds interactive prototypes from wireframes, and is an expert at CSS Grid and Flex design.
Your role is to transform low-fidelity wireframes into working front-end HTML code.

YOU MUST FOLLOW FOLLOWING RULES:

- Use HTML, CSS, JavaScript to build a responsive, accessible, polished prototype
- Leverage Tailwind for styling and layout (import as script <script src="https://cdn.tailwindcss.com"><\/script>)
- Inline JavaScript when needed
- Fetch dependencies from CDNs when needed (using unpkg or skypack)
- Source images from Unsplash or create applicable placeholders
- Interpret annotations as intended vs literal UI
- Fill gaps using your expertise in UX and business logic
- generate primarily for desktop UI, but make it responsive.
- Use grid and flexbox wherever applicable.
- Convert the wireframe in its entirety, don't omit elements if possible.

If the wireframes, diagrams, or text is unclear or unreadable, refer to provided text for clarification.

Your goal is a production-ready prototype that brings the wireframes to life.

Please output JUST THE HTML file containing your best attempt at implementing the provided wireframes.`;
  }
});

// components/MagicButton.tsx
import clsx46 from "clsx";
import { jsx as jsx120, jsxs as jsxs67 } from "react/jsx-runtime";
var DEFAULT_SIZE4, ElementCanvasButton;
var init_MagicButton = __esm({
  "components/MagicButton.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_ToolIcon();
    DEFAULT_SIZE4 = "small";
    ElementCanvasButton = (props) => {
      return /* @__PURE__ */ jsxs67(
        "label",
        {
          className: clsx46(
            "ToolIcon ToolIcon__MagicButton",
            `ToolIcon_size_${DEFAULT_SIZE4}`,
            {
              "is-mobile": props.isMobile
            }
          ),
          title: `${props.title}`,
          children: [
            /* @__PURE__ */ jsx120(
              "input",
              {
                className: "ToolIcon_type_checkbox",
                type: "checkbox",
                name: props.name,
                onChange: props.onChange,
                checked: props.checked,
                "aria-label": props.title
              }
            ),
            /* @__PURE__ */ jsx120("div", { className: "ToolIcon__icon", children: props.icon })
          ]
        }
      );
    };
  }
});

// components/FollowMode/FollowMode.scss
var init_FollowMode = __esm({
  "components/FollowMode/FollowMode.scss"() {
  }
});

// components/FollowMode/FollowMode.tsx
import { jsx as jsx121, jsxs as jsxs68 } from "react/jsx-runtime";
var FollowMode, FollowMode_default;
var init_FollowMode2 = __esm({
  "components/FollowMode/FollowMode.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_icons();
    init_FollowMode();
    FollowMode = ({
      height,
      width,
      userToFollow,
      onDisconnect
    }) => {
      return /* @__PURE__ */ jsx121("div", { className: "follow-mode", style: { width, height }, children: /* @__PURE__ */ jsxs68("div", { className: "follow-mode__badge", children: [
        /* @__PURE__ */ jsxs68("div", { className: "follow-mode__badge__label", children: [
          "Following",
          " ",
          /* @__PURE__ */ jsx121(
            "span",
            {
              className: "follow-mode__badge__username",
              title: userToFollow.username,
              children: userToFollow.username
            }
          )
        ] }),
        /* @__PURE__ */ jsx121("button", { onClick: onDisconnect, className: "follow-mode__disconnect-btn", children: CloseIcon })
      ] }) });
    };
    FollowMode_default = FollowMode;
  }
});

// animation-frame-handler.ts
var AnimationFrameHandler;
var init_animation_frame_handler = __esm({
  "animation-frame-handler.ts"() {
    "use strict";
    init_define_import_meta_env();
    AnimationFrameHandler = class {
      targets = /* @__PURE__ */ new WeakMap();
      rafIds = /* @__PURE__ */ new WeakMap();
      register(key, callback) {
        this.targets.set(key, { callback, stopped: true });
      }
      start(key) {
        const target = this.targets.get(key);
        if (!target) {
          return;
        }
        if (this.rafIds.has(key)) {
          return;
        }
        this.targets.set(key, { ...target, stopped: false });
        this.scheduleFrame(key);
      }
      stop(key) {
        const target = this.targets.get(key);
        if (target && !target.stopped) {
          this.targets.set(key, { ...target, stopped: true });
        }
        this.cancelFrame(key);
      }
      constructFrame(key) {
        return (timestamp) => {
          const target = this.targets.get(key);
          if (!target) {
            return;
          }
          const shouldAbort = this.onFrame(target, timestamp);
          if (!target.stopped && !shouldAbort) {
            this.scheduleFrame(key);
          } else {
            this.cancelFrame(key);
          }
        };
      }
      scheduleFrame(key) {
        const rafId = requestAnimationFrame(this.constructFrame(key));
        this.rafIds.set(key, rafId);
      }
      cancelFrame(key) {
        if (this.rafIds.has(key)) {
          const rafId = this.rafIds.get(key);
          cancelAnimationFrame(rafId);
        }
        this.rafIds.delete(key);
      }
      onFrame(target, timestamp) {
        const shouldAbort = target.callback(timestamp);
        return shouldAbort ?? false;
      }
    };
  }
});

// animated-trail.ts
import { LaserPointer } from "@excalidraw/laser-pointer";
var AnimatedTrail;
var init_animated_trail = __esm({
  "animated-trail.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_utils();
    init_constants();
    AnimatedTrail = class {
      constructor(animationFrameHandler, app, options) {
        this.animationFrameHandler = animationFrameHandler;
        this.app = app;
        this.options = options;
        this.animationFrameHandler.register(this, this.onFrame.bind(this));
        this.trailElement = document.createElementNS(SVG_NS, "path");
      }
      currentTrail;
      pastTrails = [];
      container;
      trailElement;
      get hasCurrentTrail() {
        return !!this.currentTrail;
      }
      hasLastPoint(x, y) {
        if (this.currentTrail) {
          const len = this.currentTrail.originalPoints.length;
          return this.currentTrail.originalPoints[len - 1][0] === x && this.currentTrail.originalPoints[len - 1][1] === y;
        }
        return false;
      }
      start(container) {
        if (container) {
          this.container = container;
        }
        if (this.trailElement.parentNode !== this.container && this.container) {
          this.container.appendChild(this.trailElement);
        }
        this.animationFrameHandler.start(this);
      }
      stop() {
        this.animationFrameHandler.stop(this);
        if (this.trailElement.parentNode === this.container) {
          this.container?.removeChild(this.trailElement);
        }
      }
      startPath(x, y) {
        this.currentTrail = new LaserPointer(this.options);
        this.currentTrail.addPoint([x, y, performance.now()]);
        this.update();
      }
      addPointToPath(x, y) {
        if (this.currentTrail) {
          this.currentTrail.addPoint([x, y, performance.now()]);
          this.update();
        }
      }
      endPath() {
        if (this.currentTrail) {
          this.currentTrail.close();
          this.currentTrail.options.keepHead = false;
          this.pastTrails.push(this.currentTrail);
          this.currentTrail = void 0;
          this.update();
        }
      }
      update() {
        this.start();
      }
      onFrame() {
        const paths = [];
        for (const trail of this.pastTrails) {
          paths.push(this.drawTrail(trail, this.app.state));
        }
        if (this.currentTrail) {
          const currentPath = this.drawTrail(this.currentTrail, this.app.state);
          paths.push(currentPath);
        }
        this.pastTrails = this.pastTrails.filter((trail) => {
          return trail.getStrokeOutline().length !== 0;
        });
        if (paths.length === 0) {
          this.stop();
        }
        const svgPaths = paths.join(" ").trim();
        this.trailElement.setAttribute("d", svgPaths);
        this.trailElement.setAttribute(
          "fill",
          (this.options.fill ?? (() => "black"))(this)
        );
      }
      drawTrail(trail, state) {
        const stroke = trail.getStrokeOutline(trail.options.size / state.zoom.value).map(([x, y]) => {
          const result = sceneCoordsToViewportCoords(
            { sceneX: x, sceneY: y },
            state
          );
          return [result.x, result.y];
        });
        return getSvgPathFromStroke(stroke, true);
      }
    };
  }
});

// laser-trails.ts
var LaserTrails;
var init_laser_trails = __esm({
  "laser-trails.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_animated_trail();
    init_utils();
    init_clients();
    LaserTrails = class {
      constructor(animationFrameHandler, app) {
        this.animationFrameHandler = animationFrameHandler;
        this.app = app;
        this.animationFrameHandler.register(this, this.onFrame.bind(this));
        this.localTrail = new AnimatedTrail(animationFrameHandler, app, {
          ...this.getTrailOptions(),
          fill: () => "red"
        });
      }
      localTrail;
      collabTrails = /* @__PURE__ */ new Map();
      container;
      getTrailOptions() {
        return {
          simplify: 0,
          streamline: 0.4,
          sizeMapping: (c) => {
            const DECAY_TIME = 1e3;
            const DECAY_LENGTH = 50;
            const t2 = Math.max(
              0,
              1 - (performance.now() - c.pressure) / DECAY_TIME
            );
            const l = (DECAY_LENGTH - Math.min(DECAY_LENGTH, c.totalLength - c.currentIndex)) / DECAY_LENGTH;
            return Math.min(easeOut(l), easeOut(t2));
          }
        };
      }
      startPath(x, y) {
        this.localTrail.startPath(x, y);
      }
      addPointToPath(x, y) {
        this.localTrail.addPointToPath(x, y);
      }
      endPath() {
        this.localTrail.endPath();
      }
      start(container) {
        this.container = container;
        this.animationFrameHandler.start(this);
        this.localTrail.start(container);
      }
      stop() {
        this.animationFrameHandler.stop(this);
        this.localTrail.stop();
      }
      onFrame() {
        this.updateCollabTrails();
      }
      updateCollabTrails() {
        if (!this.container || this.app.state.collaborators.size === 0) {
          return;
        }
        for (const [key, collabolator] of this.app.state.collaborators.entries()) {
          let trail;
          if (!this.collabTrails.has(key)) {
            trail = new AnimatedTrail(this.animationFrameHandler, this.app, {
              ...this.getTrailOptions(),
              fill: () => getClientColor(key)
            });
            trail.start(this.container);
            this.collabTrails.set(key, trail);
          } else {
            trail = this.collabTrails.get(key);
          }
          if (collabolator.pointer && collabolator.pointer.tool === "laser") {
            if (collabolator.button === "down" && !trail.hasCurrentTrail) {
              trail.startPath(collabolator.pointer.x, collabolator.pointer.y);
            }
            if (collabolator.button === "down" && trail.hasCurrentTrail && !trail.hasLastPoint(collabolator.pointer.x, collabolator.pointer.y)) {
              trail.addPointToPath(collabolator.pointer.x, collabolator.pointer.y);
            }
            if (collabolator.button === "up" && trail.hasCurrentTrail) {
              trail.addPointToPath(collabolator.pointer.x, collabolator.pointer.y);
              trail.endPath();
            }
          }
        }
        for (const key of this.collabTrails.keys()) {
          if (!this.app.state.collaborators.has(key)) {
            const trail = this.collabTrails.get(key);
            trail.stop();
            this.collabTrails.delete(key);
          }
        }
      }
    };
  }
});

// element/textWysiwyg.tsx
var getTransform, textWysiwyg;
var init_textWysiwyg = __esm({
  "element/textWysiwyg.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_keys();
    init_utils();
    init_Scene();
    init_typeChecks();
    init_constants();
    init_mutateElement();
    init_textElement();
    init_actionProperties();
    init_actionCanvas();
    init_linearElementEditor();
    init_clipboard();
    init_containerCache();
    getTransform = (width, height, angle, appState, maxWidth, maxHeight) => {
      const { zoom } = appState;
      const degree = 180 * angle / Math.PI;
      let translateX = width * (zoom.value - 1) / 2;
      let translateY = height * (zoom.value - 1) / 2;
      if (width > maxWidth && zoom.value !== 1) {
        translateX = maxWidth * (zoom.value - 1) / 2;
      }
      if (height > maxHeight && zoom.value !== 1) {
        translateY = maxHeight * (zoom.value - 1) / 2;
      }
      return `translate(${translateX}px, ${translateY}px) scale(${zoom.value}) rotate(${degree}deg)`;
    };
    textWysiwyg = ({
      id,
      onChange,
      onSubmit,
      getViewportCoords,
      element,
      canvas: canvas2,
      excalidrawContainer,
      app
    }) => {
      const textPropertiesUpdated = (updatedTextElement, editable2) => {
        if (!editable2.style.fontFamily || !editable2.style.fontSize) {
          return false;
        }
        const currentFont = editable2.style.fontFamily.replace(/"/g, "");
        if (getFontFamilyString({ fontFamily: updatedTextElement.fontFamily }) !== currentFont) {
          return true;
        }
        if (`${updatedTextElement.fontSize}px` !== editable2.style.fontSize) {
          return true;
        }
        return false;
      };
      const updateWysiwygStyle = () => {
        const appState = app.state;
        const updatedTextElement = Scene_default.getScene(element)?.getElement(id);
        if (!updatedTextElement) {
          return;
        }
        const { textAlign, verticalAlign } = updatedTextElement;
        const elementsMap = app.scene.getNonDeletedElementsMap();
        if (updatedTextElement && isTextElement(updatedTextElement)) {
          let coordX = updatedTextElement.x;
          let coordY = updatedTextElement.y;
          const container = getContainerElement(
            updatedTextElement,
            app.scene.getNonDeletedElementsMap()
          );
          let maxWidth = updatedTextElement.width;
          let maxHeight = updatedTextElement.height;
          let textElementWidth = updatedTextElement.width;
          const textElementHeight = updatedTextElement.height;
          if (container && updatedTextElement.containerId) {
            if (isArrowElement(container)) {
              const boundTextCoords = LinearElementEditor.getBoundTextElementPosition(
                container,
                updatedTextElement,
                elementsMap
              );
              coordX = boundTextCoords.x;
              coordY = boundTextCoords.y;
            }
            const propertiesUpdated = textPropertiesUpdated(
              updatedTextElement,
              editable
            );
            let originalContainerData;
            if (propertiesUpdated) {
              originalContainerData = updateOriginalContainerCache(
                container.id,
                container.height
              );
            } else {
              originalContainerData = originalContainerCache[container.id];
              if (!originalContainerData) {
                originalContainerData = updateOriginalContainerCache(
                  container.id,
                  container.height
                );
              }
            }
            maxWidth = getBoundTextMaxWidth(container, updatedTextElement);
            maxHeight = getBoundTextMaxHeight(
              container,
              updatedTextElement
            );
            if (!isArrowElement(container) && textElementHeight > maxHeight) {
              const targetContainerHeight = computeContainerDimensionForBoundText(
                textElementHeight,
                container.type
              );
              mutateElement(container, { height: targetContainerHeight });
              return;
            } else if (
              // autoshrink container height until original container height
              // is reached when text is removed
              !isArrowElement(container) && container.height > originalContainerData.height && textElementHeight < maxHeight
            ) {
              const targetContainerHeight = computeContainerDimensionForBoundText(
                textElementHeight,
                container.type
              );
              mutateElement(container, { height: targetContainerHeight });
            } else {
              const { y } = computeBoundTextPosition(
                container,
                updatedTextElement,
                elementsMap
              );
              coordY = y;
            }
          }
          const [viewportX, viewportY] = getViewportCoords(coordX, coordY);
          const initialSelectionStart = editable.selectionStart;
          const initialSelectionEnd = editable.selectionEnd;
          const initialLength = editable.value.length;
          if (initialSelectionStart === initialSelectionEnd && initialSelectionEnd !== initialLength) {
            const diff = initialLength - initialSelectionEnd;
            editable.selectionStart = editable.value.length - diff;
            editable.selectionEnd = editable.value.length - diff;
          }
          if (!container) {
            maxWidth = (appState.width - 8 - viewportX) / appState.zoom.value;
            textElementWidth = Math.min(textElementWidth, maxWidth);
          } else {
            textElementWidth += 0.5;
          }
          let lineHeight = updatedTextElement.lineHeight;
          if (isSafari) {
            lineHeight = detectLineHeight({
              ...updatedTextElement,
              fontSize: Math.round(updatedTextElement.fontSize)
            });
          }
          const editorMaxHeight = (appState.height - viewportY) / appState.zoom.value;
          Object.assign(editable.style, {
            font: getFontString(updatedTextElement),
            // must be defined *after* font \_()_/
            lineHeight,
            width: `${textElementWidth}px`,
            height: `${textElementHeight}px`,
            left: `${viewportX}px`,
            top: `${viewportY}px`,
            transform: getTransform(
              textElementWidth,
              textElementHeight,
              getTextElementAngle(updatedTextElement, container),
              appState,
              maxWidth,
              editorMaxHeight
            ),
            textAlign,
            verticalAlign,
            color: updatedTextElement.strokeColor,
            opacity: updatedTextElement.opacity / 100,
            filter: "var(--theme-filter)",
            maxHeight: `${editorMaxHeight}px`
          });
          editable.scrollTop = 0;
          if (isTestEnv()) {
            editable.style.fontFamily = getFontFamilyString(updatedTextElement);
          }
          mutateElement(updatedTextElement, { x: coordX, y: coordY });
        }
      };
      const editable = document.createElement("textarea");
      editable.dir = "auto";
      editable.tabIndex = 0;
      editable.dataset.type = "wysiwyg";
      editable.wrap = "off";
      editable.classList.add("excalidraw-wysiwyg");
      let whiteSpace = "pre";
      let wordBreak = "normal";
      if (isBoundToContainer(element)) {
        whiteSpace = "pre-wrap";
        wordBreak = "break-word";
      }
      Object.assign(editable.style, {
        position: "absolute",
        display: "inline-block",
        minHeight: "1em",
        backfaceVisibility: "hidden",
        margin: 0,
        padding: 0,
        border: 0,
        outline: 0,
        resize: "none",
        background: "transparent",
        overflow: "hidden",
        // must be specified because in dark mode canvas creates a stacking context
        zIndex: "var(--zIndex-wysiwyg)",
        wordBreak,
        // prevent line wrapping (`whitespace: nowrap` doesn't work on FF)
        whiteSpace,
        overflowWrap: "break-word",
        boxSizing: "content-box"
      });
      editable.value = element.originalText;
      updateWysiwygStyle();
      if (onChange) {
        editable.onpaste = async (event) => {
          const clipboardData = await parseClipboard(event, true);
          if (!clipboardData.text) {
            return;
          }
          const data = normalizeText(clipboardData.text);
          if (!data) {
            return;
          }
          const container = getContainerElement(
            element,
            app.scene.getNonDeletedElementsMap()
          );
          const font = getFontString({
            fontSize: app.state.currentItemFontSize,
            fontFamily: app.state.currentItemFontFamily
          });
          if (container) {
            const boundTextElement = getBoundTextElement(
              container,
              app.scene.getNonDeletedElementsMap()
            );
            const wrappedText = wrapText(
              `${editable.value}${data}`,
              font,
              getBoundTextMaxWidth(container, boundTextElement)
            );
            const width = getTextWidth(wrappedText, font);
            editable.style.width = `${width}px`;
          }
        };
        editable.oninput = () => {
          onChange(normalizeText(editable.value));
        };
      }
      editable.onkeydown = (event) => {
        if (!event.shiftKey && actionZoomIn.keyTest(event)) {
          event.preventDefault();
          app.actionManager.executeAction(actionZoomIn);
          updateWysiwygStyle();
        } else if (!event.shiftKey && actionZoomOut.keyTest(event)) {
          event.preventDefault();
          app.actionManager.executeAction(actionZoomOut);
          updateWysiwygStyle();
        } else if (actionDecreaseFontSize.keyTest(event)) {
          app.actionManager.executeAction(actionDecreaseFontSize);
        } else if (actionIncreaseFontSize.keyTest(event)) {
          app.actionManager.executeAction(actionIncreaseFontSize);
        } else if (event.key === KEYS.ESCAPE) {
          event.preventDefault();
          submittedViaKeyboard = true;
          handleSubmit();
        } else if (event.key === KEYS.ENTER && event[KEYS.CTRL_OR_CMD]) {
          event.preventDefault();
          if (event.isComposing || event.keyCode === 229) {
            return;
          }
          submittedViaKeyboard = true;
          handleSubmit();
        } else if (event.key === KEYS.TAB || event[KEYS.CTRL_OR_CMD] && (event.code === CODES.BRACKET_LEFT || event.code === CODES.BRACKET_RIGHT)) {
          event.preventDefault();
          if (event.isComposing) {
            return;
          } else if (event.shiftKey || event.code === CODES.BRACKET_LEFT) {
            outdent();
          } else {
            indent();
          }
          editable.dispatchEvent(new Event("input"));
        }
      };
      const TAB_SIZE = 4;
      const TAB = " ".repeat(TAB_SIZE);
      const RE_LEADING_TAB = new RegExp(`^ {1,${TAB_SIZE}}`);
      const indent = () => {
        const { selectionStart, selectionEnd } = editable;
        const linesStartIndices = getSelectedLinesStartIndices();
        let value = editable.value;
        linesStartIndices.forEach((startIndex) => {
          const startValue = value.slice(0, startIndex);
          const endValue = value.slice(startIndex);
          value = `${startValue}${TAB}${endValue}`;
        });
        editable.value = value;
        editable.selectionStart = selectionStart + TAB_SIZE;
        editable.selectionEnd = selectionEnd + TAB_SIZE * linesStartIndices.length;
      };
      const outdent = () => {
        const { selectionStart, selectionEnd } = editable;
        const linesStartIndices = getSelectedLinesStartIndices();
        const removedTabs = [];
        let value = editable.value;
        linesStartIndices.forEach((startIndex) => {
          const tabMatch = value.slice(startIndex, startIndex + TAB_SIZE).match(RE_LEADING_TAB);
          if (tabMatch) {
            const startValue = value.slice(0, startIndex);
            const endValue = value.slice(startIndex + tabMatch[0].length);
            value = `${startValue}${endValue}`;
            removedTabs.push(startIndex);
          }
        });
        editable.value = value;
        if (removedTabs.length) {
          if (selectionStart > removedTabs[removedTabs.length - 1]) {
            editable.selectionStart = Math.max(
              selectionStart - TAB_SIZE,
              removedTabs[removedTabs.length - 1]
            );
          } else {
            editable.selectionStart = selectionStart;
          }
          editable.selectionEnd = Math.max(
            editable.selectionStart,
            selectionEnd - TAB_SIZE * removedTabs.length
          );
        }
      };
      const getSelectedLinesStartIndices = () => {
        let { selectionStart, selectionEnd, value } = editable;
        const startOffset = value.slice(0, selectionStart).match(/[^\n]*$/)[0].length;
        selectionStart = selectionStart - startOffset;
        const selected = value.slice(selectionStart, selectionEnd);
        return selected.split("\n").reduce(
          (startIndices, line, idx, lines) => startIndices.concat(
            idx ? (
              // curr line index is prev line's start + prev line's length + \n
              startIndices[idx - 1] + lines[idx - 1].length + 1
            ) : (
              // first selected line
              selectionStart
            )
          ),
          []
        ).reverse();
      };
      const stopEvent = (event) => {
        event.preventDefault();
        event.stopPropagation();
      };
      let submittedViaKeyboard = false;
      const handleSubmit = () => {
        cleanup();
        const updateElement = Scene_default.getScene(element)?.getElement(
          element.id
        );
        if (!updateElement) {
          return;
        }
        let text = editable.value;
        const container = getContainerElement(
          updateElement,
          app.scene.getNonDeletedElementsMap()
        );
        if (container) {
          text = updateElement.text;
          if (editable.value.trim()) {
            const boundTextElementId = getBoundTextElementId(container);
            if (!boundTextElementId || boundTextElementId !== element.id) {
              mutateElement(container, {
                boundElements: (container.boundElements || []).concat({
                  type: "text",
                  id: element.id
                })
              });
            } else if (isArrowElement(container)) {
              bumpVersion(container);
            }
          } else {
            mutateElement(container, {
              boundElements: container.boundElements?.filter(
                (ele) => !isTextElement(
                  ele
                )
              )
            });
          }
          redrawTextBoundingBox(
            updateElement,
            container,
            app.scene.getNonDeletedElementsMap()
          );
        }
        onSubmit({
          text,
          viaKeyboard: submittedViaKeyboard,
          originalText: editable.value
        });
      };
      const cleanup = () => {
        if (isDestroyed) {
          return;
        }
        isDestroyed = true;
        editable.onblur = null;
        editable.oninput = null;
        editable.onkeydown = null;
        if (observer) {
          observer.disconnect();
        }
        window.removeEventListener("resize", updateWysiwygStyle);
        window.removeEventListener("wheel", stopEvent, true);
        window.removeEventListener("pointerdown", onPointerDown);
        window.removeEventListener("pointerup", bindBlurEvent);
        window.removeEventListener("blur", handleSubmit);
        window.removeEventListener("beforeunload", handleSubmit);
        unbindUpdate();
        editable.remove();
      };
      const bindBlurEvent = (event) => {
        window.removeEventListener("pointerup", bindBlurEvent);
        const target = event?.target;
        const isTargetPickerTrigger = target instanceof HTMLElement && target.classList.contains("active-color");
        setTimeout(() => {
          editable.onblur = handleSubmit;
          if (isTargetPickerTrigger) {
            const callback = (mutationList, observer3) => {
              const radixIsRemoved = mutationList.find(
                (mutation) => mutation.removedNodes.length > 0 && mutation.removedNodes[0].dataset?.radixPopperContentWrapper !== void 0
              );
              if (radixIsRemoved) {
                setTimeout(() => {
                  editable.focus();
                });
                observer3.disconnect();
              }
            };
            const observer2 = new MutationObserver(callback);
            observer2.observe(document.querySelector(".excalidraw-container"), {
              childList: true
            });
          }
          if (!isTargetPickerTrigger) {
            editable.focus();
          }
        });
      };
      const onPointerDown = (event) => {
        const isTargetPickerTrigger = event.target instanceof HTMLElement && event.target.classList.contains("active-color");
        if ((event.target instanceof HTMLElement || event.target instanceof SVGElement) && event.target.closest(`.${CLASSES.SHAPE_ACTIONS_MENU}`) && !isWritableElement(event.target) || isTargetPickerTrigger) {
          editable.onblur = null;
          window.addEventListener("pointerup", bindBlurEvent);
          window.addEventListener("blur", handleSubmit);
        }
      };
      const unbindUpdate = Scene_default.getScene(element).addCallback(() => {
        updateWysiwygStyle();
        const isColorPickerActive = !!document.activeElement?.closest(
          ".color-picker-content"
        );
        if (!isColorPickerActive) {
          editable.focus();
        }
      });
      let isDestroyed = false;
      editable.select();
      bindBlurEvent();
      let observer = null;
      if (canvas2 && "ResizeObserver" in window) {
        observer = new window.ResizeObserver(() => {
          updateWysiwygStyle();
        });
        observer.observe(canvas2);
      } else {
        window.addEventListener("resize", updateWysiwygStyle);
      }
      window.addEventListener("pointerdown", onPointerDown);
      window.addEventListener("wheel", stopEvent, {
        passive: false,
        capture: true
      });
      window.addEventListener("beforeunload", handleSubmit);
      excalidrawContainer?.querySelector(".excalidraw-textEditorContainer").appendChild(editable);
    };
  }
});

// components/App.tsx
import React38, { useContext as useContext3 } from "react";
import { flushSync } from "react-dom";
import rough4 from "roughjs/bin/rough";
import clsx47 from "clsx";
import { nanoid as nanoid3 } from "nanoid";
import throttle2 from "lodash.throttle";
import { Fragment as Fragment20, jsx as jsx122, jsxs as jsxs69 } from "react/jsx-runtime";
var AppContext, AppPropsContext, deviceContextInitialValue, DeviceContext, ExcalidrawContainerContext, ExcalidrawElementsContext, ExcalidrawAppStateContext, ExcalidrawSetAppStateContext, ExcalidrawActionManagerContext, useApp, useAppProps, useDevice, useExcalidrawContainer, useExcalidrawElements, useExcalidrawAppState, useExcalidrawSetAppState, useExcalidrawActionManager, supportsResizeObserver, didTapTwice, tappedTwiceTimer, isHoldingSpace, isPanning, isDraggingScrollBar, currentScrollBars, touchTimeout, invalidateContextMenu, YOUTUBE_VIDEO_STATES, IS_PLAIN_PASTE, IS_PLAIN_PASTE_TIMER, PLAIN_PASTE_TOAST_SHOWN, lastPointerUp, gesture, App, App_default;
var init_App = __esm({
  "components/App.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_actions();
    init_actionHistory();
    init_manager();
    init_register();
    init_analytics();
    init_appState();
    init_clipboard();
    init_constants();
    init_data();
    init_library();
    init_restore();
    init_element();
    init_binding();
    init_linearElementEditor();
    init_mutateElement();
    init_newElement();
    init_typeChecks();
    init_gesture();
    init_groups();
    init_history();
    init_i18n();
    init_keys();
    init_sizeHelpers();
    init_math();
    init_scene();
    init_Scene();
    init_zoom();
    init_shapes();
    init_utils();
    init_embeddable();
    init_ContextMenu2();
    init_LayerUI2();
    init_Toast2();
    init_actionToggleViewMode();
    init_blob();
    init_image2();
    init_filesystem();
    init_textElement();
    init_collision();
    init_Hyperlink2();
    init_url();
    init_transformHandles();
    init_actionElementLock();
    init_Fonts();
    init_frame();
    init_selection();
    init_actionClipboard();
    init_actionFrame();
    init_actionCanvas();
    init_jotai();
    init_ActiveConfirmDialog();
    init_errors();
    init_snapping();
    init_actionBoundText();
    init_BraveMeasureTextError();
    init_EyeDropper2();
    init_transform();
    init_Sidebar2();
    init_canvases();
    init_Renderer();
    init_ShapeCache();
    init_SVGLayer2();
    init_cursor();
    init_emitter();
    init_ElementCanvasButtons2();
    init_magic();
    init_export2();
    init_colors();
    init_MagicButton();
    init_icons();
    init_EditorLocalStorage();
    init_FollowMode2();
    init_animation_frame_handler();
    init_animated_trail();
    init_laser_trails();
    init_reactUtils();
    init_renderElement();
    init_textWysiwyg();
    init_scrollbars();
    AppContext = React38.createContext(null);
    AppPropsContext = React38.createContext(null);
    deviceContextInitialValue = {
      viewport: {
        isMobile: false,
        isLandscape: false
      },
      editor: {
        isMobile: false,
        canFitSidebar: false
      },
      isTouchScreen: false
    };
    DeviceContext = React38.createContext(deviceContextInitialValue);
    DeviceContext.displayName = "DeviceContext";
    ExcalidrawContainerContext = React38.createContext({ container: null, id: null });
    ExcalidrawContainerContext.displayName = "ExcalidrawContainerContext";
    ExcalidrawElementsContext = React38.createContext([]);
    ExcalidrawElementsContext.displayName = "ExcalidrawElementsContext";
    ExcalidrawAppStateContext = React38.createContext({
      ...getDefaultAppState(),
      width: 0,
      height: 0,
      offsetLeft: 0,
      offsetTop: 0
    });
    ExcalidrawAppStateContext.displayName = "ExcalidrawAppStateContext";
    ExcalidrawSetAppStateContext = React38.createContext(() => {
      console.warn("Uninitialized ExcalidrawSetAppStateContext context!");
    });
    ExcalidrawSetAppStateContext.displayName = "ExcalidrawSetAppStateContext";
    ExcalidrawActionManagerContext = React38.createContext(
      null
    );
    ExcalidrawActionManagerContext.displayName = "ExcalidrawActionManagerContext";
    useApp = () => useContext3(AppContext);
    useAppProps = () => useContext3(AppPropsContext);
    useDevice = () => useContext3(DeviceContext);
    useExcalidrawContainer = () => useContext3(ExcalidrawContainerContext);
    useExcalidrawElements = () => useContext3(ExcalidrawElementsContext);
    useExcalidrawAppState = () => useContext3(ExcalidrawAppStateContext);
    useExcalidrawSetAppState = () => useContext3(ExcalidrawSetAppStateContext);
    useExcalidrawActionManager = () => useContext3(ExcalidrawActionManagerContext);
    supportsResizeObserver = typeof window !== "undefined" && "ResizeObserver" in window;
    didTapTwice = false;
    tappedTwiceTimer = 0;
    isHoldingSpace = false;
    isPanning = false;
    isDraggingScrollBar = false;
    currentScrollBars = { horizontal: null, vertical: null };
    touchTimeout = 0;
    invalidateContextMenu = false;
    YOUTUBE_VIDEO_STATES = /* @__PURE__ */ new Map();
    IS_PLAIN_PASTE = false;
    IS_PLAIN_PASTE_TIMER = 0;
    PLAIN_PASTE_TOAST_SHOWN = false;
    lastPointerUp = null;
    gesture = {
      pointers: /* @__PURE__ */ new Map(),
      lastCenter: null,
      initialDistance: null,
      initialScale: null
    };
    App = class _App extends React38.Component {
      canvas;
      interactiveCanvas = null;
      rc;
      unmounted = false;
      actionManager;
      device = deviceContextInitialValue;
      excalidrawContainerRef = React38.createRef();
      scene;
      renderer;
      fonts;
      resizeObserver;
      nearestScrollableContainer;
      library;
      libraryItemsFromStorage;
      id;
      history;
      excalidrawContainerValue;
      files = {};
      imageCache = /* @__PURE__ */ new Map();
      iFrameRefs = /* @__PURE__ */ new Map();
      /**
       * Indicates whether the embeddable's url has been validated for rendering.
       * If value not set, indicates that the validation is pending.
       * Initially or on url change the flag is not reset so that we can guarantee
       * the validation came from a trusted source (the editor).
       **/
      embedsValidationStatus = /* @__PURE__ */ new Map();
      /** embeds that have been inserted to DOM (as a perf optim, we don't want to
       * insert to DOM before user initially scrolls to them) */
      initializedEmbeds = /* @__PURE__ */ new Set();
      elementsPendingErasure = /* @__PURE__ */ new Set();
      hitLinkElement;
      lastPointerDownEvent = null;
      lastPointerUpEvent = null;
      lastPointerMoveEvent = null;
      lastViewportPosition = { x: 0, y: 0 };
      animationFrameHandler = new AnimationFrameHandler();
      laserTrails = new LaserTrails(this.animationFrameHandler, this);
      eraserTrail = new AnimatedTrail(this.animationFrameHandler, this, {
        streamline: 0.2,
        size: 5,
        keepHead: true,
        sizeMapping: (c) => {
          const DECAY_TIME = 200;
          const DECAY_LENGTH = 10;
          const t2 = Math.max(0, 1 - (performance.now() - c.pressure) / DECAY_TIME);
          const l = (DECAY_LENGTH - Math.min(DECAY_LENGTH, c.totalLength - c.currentIndex)) / DECAY_LENGTH;
          return Math.min(easeOut(l), easeOut(t2));
        },
        fill: () => this.state.theme === THEME.LIGHT ? "rgba(0, 0, 0, 0.2)" : "rgba(255, 255, 255, 0.2)"
      });
      onChangeEmitter = new Emitter();
      onPointerDownEmitter = new Emitter();
      onPointerUpEmitter = new Emitter();
      onUserFollowEmitter = new Emitter();
      onScrollChangeEmitter = new Emitter();
      missingPointerEventCleanupEmitter = new Emitter();
      onRemoveEventListenersEmitter = new Emitter();
      constructor(props) {
        super(props);
        const defaultAppState2 = getDefaultAppState();
        const {
          excalidrawAPI,
          viewModeEnabled = false,
          zenModeEnabled = false,
          gridModeEnabled = false,
          objectsSnapModeEnabled = false,
          theme = defaultAppState2.theme,
          name = `${t("labels.untitled")}-${getDateTime()}`
        } = props;
        this.state = {
          ...defaultAppState2,
          theme,
          isLoading: true,
          ...this.getCanvasOffsets(),
          viewModeEnabled,
          zenModeEnabled,
          objectsSnapModeEnabled,
          gridSize: gridModeEnabled ? GRID_SIZE : null,
          name,
          width: window.innerWidth,
          height: window.innerHeight
        };
        this.id = nanoid3();
        this.library = new library_default(this);
        this.actionManager = new ActionManager(
          this.syncActionResult,
          () => this.state,
          () => this.scene.getElementsIncludingDeleted(),
          this
        );
        this.scene = new Scene_default();
        this.canvas = document.createElement("canvas");
        this.rc = rough4.canvas(this.canvas);
        this.renderer = new Renderer(this.scene);
        if (excalidrawAPI) {
          const api = {
            updateScene: this.updateScene,
            updateLibrary: this.library.updateLibrary,
            addFiles: this.addFiles,
            resetScene: this.resetScene,
            getSceneElementsIncludingDeleted: this.getSceneElementsIncludingDeleted,
            history: {
              clear: this.resetHistory
            },
            scrollToContent: this.scrollToContent,
            getSceneElements: this.getSceneElements,
            getAppState: () => this.state,
            getFiles: () => this.files,
            getName: this.getName,
            registerAction: (action) => {
              this.actionManager.registerAction(action);
            },
            refresh: this.refresh,
            setToast: this.setToast,
            id: this.id,
            setActiveTool: this.setActiveTool,
            setCursor: this.setCursor,
            resetCursor: this.resetCursor,
            updateFrameRendering: this.updateFrameRendering,
            toggleSidebar: this.toggleSidebar,
            onChange: (cb) => this.onChangeEmitter.on(cb),
            onPointerDown: (cb) => this.onPointerDownEmitter.on(cb),
            onPointerUp: (cb) => this.onPointerUpEmitter.on(cb),
            onScrollChange: (cb) => this.onScrollChangeEmitter.on(cb),
            onUserFollow: (cb) => this.onUserFollowEmitter.on(cb)
          };
          if (typeof excalidrawAPI === "function") {
            excalidrawAPI(api);
          } else {
            console.error("excalidrawAPI should be a function!");
          }
        }
        this.excalidrawContainerValue = {
          container: this.excalidrawContainerRef.current,
          id: this.id
        };
        this.fonts = new Fonts({
          scene: this.scene,
          onSceneUpdated: this.onSceneUpdated
        });
        this.history = new history_default();
        this.actionManager.registerAll(actions);
        this.actionManager.registerAction(createUndoAction(this.history));
        this.actionManager.registerAction(createRedoAction(this.history));
      }
      onWindowMessage(event) {
        if (event.origin !== "https://player.vimeo.com" && event.origin !== "https://www.youtube.com") {
          return;
        }
        let data = null;
        try {
          data = JSON.parse(event.data);
        } catch (e) {
        }
        if (!data) {
          return;
        }
        switch (event.origin) {
          case "https://player.vimeo.com":
            if (data.method === "paused") {
              let source = null;
              const iframes = document.body.querySelectorAll(
                "iframe.excalidraw__embeddable"
              );
              if (!iframes) {
                break;
              }
              for (const iframe of iframes) {
                if (iframe.contentWindow === event.source) {
                  source = iframe.contentWindow;
                }
              }
              source?.postMessage(
                JSON.stringify({
                  method: data.value ? "play" : "pause",
                  value: true
                }),
                "*"
              );
            }
            break;
          case "https://www.youtube.com":
            if (data.event === "infoDelivery" && data.info && data.id && typeof data.info.playerState === "number") {
              const id = data.id;
              const playerState = data.info.playerState;
              if (Object.values(YOUTUBE_STATES).includes(playerState)) {
                YOUTUBE_VIDEO_STATES.set(
                  id,
                  playerState
                );
              }
            }
            break;
        }
      }
      cacheEmbeddableRef(element, ref) {
        if (ref) {
          this.iFrameRefs.set(element.id, ref);
        }
      }
      getHTMLIFrameElement(element) {
        return this.iFrameRefs.get(element.id);
      }
      handleEmbeddableCenterClick(element) {
        if (this.state.activeEmbeddable?.element === element && this.state.activeEmbeddable?.state === "active") {
          return;
        }
        setTimeout(() => {
          this.setState({
            activeEmbeddable: { element, state: "active" },
            selectedElementIds: { [element.id]: true },
            draggingElement: null,
            selectionElement: null
          });
        }, 100);
        if (isIframeElement(element)) {
          return;
        }
        const iframe = this.getHTMLIFrameElement(element);
        if (!iframe?.contentWindow) {
          return;
        }
        if (iframe.src.includes("youtube")) {
          const state = YOUTUBE_VIDEO_STATES.get(element.id);
          if (!state) {
            YOUTUBE_VIDEO_STATES.set(element.id, YOUTUBE_STATES.UNSTARTED);
            iframe.contentWindow.postMessage(
              JSON.stringify({
                event: "listening",
                id: element.id
              }),
              "*"
            );
          }
          switch (state) {
            case YOUTUBE_STATES.PLAYING:
            case YOUTUBE_STATES.BUFFERING:
              iframe.contentWindow?.postMessage(
                JSON.stringify({
                  event: "command",
                  func: "pauseVideo",
                  args: ""
                }),
                "*"
              );
              break;
            default:
              iframe.contentWindow?.postMessage(
                JSON.stringify({
                  event: "command",
                  func: "playVideo",
                  args: ""
                }),
                "*"
              );
          }
        }
        if (iframe.src.includes("player.vimeo.com")) {
          iframe.contentWindow.postMessage(
            JSON.stringify({
              method: "paused"
              //video play/pause in onWindowMessage handler
            }),
            "*"
          );
        }
      }
      isIframeLikeElementCenter(el, event, sceneX, sceneY) {
        return el && !event.altKey && !event.shiftKey && !event.metaKey && !event.ctrlKey && (this.state.activeEmbeddable?.element !== el || this.state.activeEmbeddable?.state === "hover" || !this.state.activeEmbeddable) && sceneX >= el.x + el.width / 3 && sceneX <= el.x + 2 * el.width / 3 && sceneY >= el.y + el.height / 3 && sceneY <= el.y + 2 * el.height / 3;
      }
      updateEmbedValidationStatus = (element, status) => {
        this.embedsValidationStatus.set(element.id, status);
        ShapeCache.delete(element);
      };
      updateEmbeddables = () => {
        const iframeLikes = /* @__PURE__ */ new Set();
        let updated = false;
        this.scene.getNonDeletedElements().filter((element) => {
          if (isEmbeddableElement(element)) {
            iframeLikes.add(element.id);
            if (!this.embedsValidationStatus.has(element.id)) {
              updated = true;
              const validated = embeddableURLValidator(
                element.link,
                this.props.validateEmbeddable
              );
              this.updateEmbedValidationStatus(element, validated);
            }
          } else if (isIframeElement(element)) {
            iframeLikes.add(element.id);
          }
          return false;
        });
        if (updated) {
          this.scene.informMutation();
        }
        this.iFrameRefs.forEach((ref, id) => {
          if (!iframeLikes.has(id)) {
            this.iFrameRefs.delete(id);
          }
        });
      };
      renderEmbeddables() {
        const scale = this.state.zoom.value;
        const normalizedWidth = this.state.width;
        const normalizedHeight = this.state.height;
        const embeddableElements = this.scene.getNonDeletedElements().filter(
          (el) => isEmbeddableElement(el) && this.embedsValidationStatus.get(el.id) === true || isIframeElement(el)
        );
        return /* @__PURE__ */ jsx122(Fragment20, { children: embeddableElements.map((el) => {
          const { x, y } = sceneCoordsToViewportCoords(
            { sceneX: el.x, sceneY: el.y },
            this.state
          );
          const isVisible = isElementInViewport(
            el,
            normalizedWidth,
            normalizedHeight,
            this.state,
            this.scene.getNonDeletedElementsMap()
          );
          const hasBeenInitialized = this.initializedEmbeds.has(el.id);
          if (isVisible && !hasBeenInitialized) {
            this.initializedEmbeds.add(el.id);
          }
          const shouldRender = isVisible || hasBeenInitialized;
          if (!shouldRender) {
            return null;
          }
          let src;
          if (isIframeElement(el)) {
            src = null;
            const data = (el.customData?.generationData ?? this.magicGenerations.get(el.id)) || {
              status: "error",
              message: "No generation data",
              code: "ERR_NO_GENERATION_DATA"
            };
            if (data.status === "done") {
              const html = data.html;
              src = {
                intrinsicSize: { w: el.width, h: el.height },
                type: "document",
                srcdoc: () => {
                  return html;
                }
              };
            } else if (data.status === "pending") {
              src = {
                intrinsicSize: { w: el.width, h: el.height },
                type: "document",
                srcdoc: () => {
                  return createSrcDoc(`
                    <style>
                      html, body {
                        width: 100%;
                        height: 100%;
                        color: ${this.state.theme === "dark" ? "white" : "black"};
                      }
                      body {
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        flex-direction: column;
                        gap: 1rem;
                      }

                      .Spinner {
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        margin-left: auto;
                        margin-right: auto;
                      }

                      .Spinner svg {
                        animation: rotate 1.6s linear infinite;
                        transform-origin: center center;
                        width: 40px;
                        height: 40px;
                      }

                      .Spinner circle {
                        stroke: currentColor;
                        animation: dash 1.6s linear 0s infinite;
                        stroke-linecap: round;
                      }

                      @keyframes rotate {
                        100% {
                          transform: rotate(360deg);
                        }
                      }

                      @keyframes dash {
                        0% {
                          stroke-dasharray: 1, 300;
                          stroke-dashoffset: 0;
                        }
                        50% {
                          stroke-dasharray: 150, 300;
                          stroke-dashoffset: -200;
                        }
                        100% {
                          stroke-dasharray: 1, 300;
                          stroke-dashoffset: -280;
                        }
                      }
                    </style>
                    <div class="Spinner">
                      <svg
                        viewBox="0 0 100 100"
                      >
                        <circle
                          cx="50"
                          cy="50"
                          r="46"
                          stroke-width="8"
                          fill="none"
                          stroke-miter-limit="10"
                        />
                      </svg>
                    </div>
                    <div>Generating...</div>
                  `);
                }
              };
            } else {
              let message;
              if (data.code === "ERR_GENERATION_INTERRUPTED") {
                message = "Generation was interrupted...";
              } else {
                message = data.message || "Generation failed";
              }
              src = {
                intrinsicSize: { w: el.width, h: el.height },
                type: "document",
                srcdoc: () => {
                  return createSrcDoc(`
                    <style>
                    html, body {
                      height: 100%;
                    }
                      body {
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                        justify-content: center;
                        color: ${COLOR_PALETTE.red[3]};
                      }
                      h1, h3 {
                        margin-top: 0;
                        margin-bottom: 0.5rem;
                      }
                    </style>
                    <h1>Error!</h1>
                    <h3>${message}</h3>
                  `);
                }
              };
            }
          } else {
            src = getEmbedLink(toValidURL(el.link || ""));
          }
          const isActive = this.state.activeEmbeddable?.element === el && this.state.activeEmbeddable?.state === "active";
          const isHovered = this.state.activeEmbeddable?.element === el && this.state.activeEmbeddable?.state === "hover";
          return /* @__PURE__ */ jsx122(
            "div",
            {
              className: clsx47("excalidraw__embeddable-container", {
                "is-hovered": isHovered
              }),
              style: {
                transform: isVisible ? `translate(${x - this.state.offsetLeft}px, ${y - this.state.offsetTop}px) scale(${scale})` : "none",
                display: isVisible ? "block" : "none",
                opacity: getRenderOpacity(
                  el,
                  getContainingFrame(el),
                  this.elementsPendingErasure
                ),
                ["--embeddable-radius"]: `${getCornerRadius(
                  Math.min(el.width, el.height),
                  el
                )}px`
              },
              children: /* @__PURE__ */ jsxs69(
                "div",
                {
                  className: "excalidraw__embeddable-container__inner",
                  style: {
                    width: isVisible ? `${el.width}px` : 0,
                    height: isVisible ? `${el.height}px` : 0,
                    transform: isVisible ? `rotate(${el.angle}rad)` : "none",
                    pointerEvents: isActive ? POINTER_EVENTS.enabled : POINTER_EVENTS.disabled
                  },
                  children: [
                    isHovered && /* @__PURE__ */ jsx122("div", { className: "excalidraw__embeddable-hint", children: t("buttons.embeddableInteractionButton") }),
                    /* @__PURE__ */ jsx122(
                      "div",
                      {
                        className: "excalidraw__embeddable__outer",
                        style: {
                          padding: `${el.strokeWidth}px`
                        },
                        children: (isEmbeddableElement(el) ? this.props.renderEmbeddable?.(el, this.state) : null) ?? /* @__PURE__ */ jsx122(
                          "iframe",
                          {
                            ref: (ref) => this.cacheEmbeddableRef(el, ref),
                            className: "excalidraw__embeddable",
                            srcDoc: src?.type === "document" ? src.srcdoc(this.state.theme) : void 0,
                            src: src?.type !== "document" ? src?.link ?? "" : void 0,
                            scrolling: "no",
                            referrerPolicy: "no-referrer-when-downgrade",
                            title: "Excalidraw Embedded Content",
                            allow: "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture",
                            allowFullScreen: true,
                            sandbox: "allow-same-origin allow-scripts allow-forms allow-popups allow-popups-to-escape-sandbox allow-presentation allow-downloads"
                          }
                        )
                      }
                    )
                  ]
                }
              )
            },
            el.id
          );
        }) });
      }
      getFrameNameDOMId = (frameElement) => {
        return `${this.id}-frame-name-${frameElement.id}`;
      };
      frameNameBoundsCache = {
        get: (frameElement) => {
          let bounds = this.frameNameBoundsCache._cache.get(frameElement.id);
          if (!bounds || bounds.zoom !== this.state.zoom.value || bounds.versionNonce !== frameElement.versionNonce) {
            const frameNameDiv = document.getElementById(
              this.getFrameNameDOMId(frameElement)
            );
            if (frameNameDiv) {
              const box = frameNameDiv.getBoundingClientRect();
              const boxSceneTopLeft = viewportCoordsToSceneCoords(
                { clientX: box.x, clientY: box.y },
                this.state
              );
              const boxSceneBottomRight = viewportCoordsToSceneCoords(
                { clientX: box.right, clientY: box.bottom },
                this.state
              );
              bounds = {
                x: boxSceneTopLeft.x,
                y: boxSceneTopLeft.y,
                width: boxSceneBottomRight.x - boxSceneTopLeft.x,
                height: boxSceneBottomRight.y - boxSceneTopLeft.y,
                angle: 0,
                zoom: this.state.zoom.value,
                versionNonce: frameElement.versionNonce
              };
              this.frameNameBoundsCache._cache.set(frameElement.id, bounds);
              return bounds;
            }
            return null;
          }
          return bounds;
        },
        /**
         * @private
         */
        _cache: /* @__PURE__ */ new Map()
      };
      renderFrameNames = () => {
        if (!this.state.frameRendering.enabled || !this.state.frameRendering.name) {
          return null;
        }
        const isDarkTheme = this.state.theme === "dark";
        let frameIndex = 0;
        let magicFrameIndex = 0;
        return this.scene.getNonDeletedFramesLikes().map((f) => {
          if (isFrameElement(f)) {
            frameIndex++;
          } else {
            magicFrameIndex++;
          }
          if (!isElementInViewport(
            f,
            this.canvas.width / window.devicePixelRatio,
            this.canvas.height / window.devicePixelRatio,
            {
              offsetLeft: this.state.offsetLeft,
              offsetTop: this.state.offsetTop,
              scrollX: this.state.scrollX,
              scrollY: this.state.scrollY,
              zoom: this.state.zoom
            },
            this.scene.getNonDeletedElementsMap()
          )) {
            return null;
          }
          const { x: x1, y: y1 } = sceneCoordsToViewportCoords(
            { sceneX: f.x, sceneY: f.y },
            this.state
          );
          const FRAME_NAME_EDIT_PADDING = 6;
          const reset = () => {
            mutateElement(f, { name: f.name?.trim() || null });
            this.setState({ editingFrame: null });
          };
          let frameNameJSX;
          const frameName = getFrameLikeTitle(
            f,
            isFrameElement(f) ? frameIndex : magicFrameIndex
          );
          if (f.id === this.state.editingFrame) {
            const frameNameInEdit = frameName;
            frameNameJSX = /* @__PURE__ */ jsx122(
              "input",
              {
                autoFocus: true,
                value: frameNameInEdit,
                onChange: (e) => {
                  mutateElement(f, {
                    name: e.target.value
                  });
                },
                onFocus: (e) => e.target.select(),
                onBlur: () => reset(),
                onKeyDown: (event) => {
                  if (event.key === KEYS.ESCAPE || event.key === KEYS.ENTER) {
                    reset();
                  }
                },
                style: {
                  background: this.state.viewBackgroundColor,
                  filter: isDarkTheme ? THEME_FILTER : "none",
                  zIndex: 2,
                  border: "none",
                  display: "block",
                  padding: `${FRAME_NAME_EDIT_PADDING}px`,
                  borderRadius: 4,
                  boxShadow: "inset 0 0 0 1px var(--color-primary)",
                  fontFamily: "Assistant",
                  fontSize: "14px",
                  transform: `translate(-${FRAME_NAME_EDIT_PADDING}px, ${FRAME_NAME_EDIT_PADDING}px)`,
                  color: "var(--color-gray-80)",
                  overflow: "hidden",
                  maxWidth: `${document.body.clientWidth - x1 - FRAME_NAME_EDIT_PADDING}px`
                },
                size: frameNameInEdit.length + 1 || 1,
                dir: "auto",
                autoComplete: "off",
                autoCapitalize: "off",
                autoCorrect: "off"
              }
            );
          } else {
            frameNameJSX = frameName;
          }
          return /* @__PURE__ */ jsx122(
            "div",
            {
              id: this.getFrameNameDOMId(f),
              style: {
                position: "absolute",
                // Positioning from bottom so that we don't to either
                // calculate text height or adjust using transform (which)
                // messes up input position when editing the frame name.
                // This makes the positioning deterministic and we can calculate
                // the same position when rendering to canvas / svg.
                bottom: `${this.state.height + FRAME_STYLE.nameOffsetY - y1 + this.state.offsetTop}px`,
                left: `${x1 - this.state.offsetLeft}px`,
                zIndex: 2,
                fontSize: FRAME_STYLE.nameFontSize,
                color: isDarkTheme ? FRAME_STYLE.nameColorDarkTheme : FRAME_STYLE.nameColorLightTheme,
                lineHeight: FRAME_STYLE.nameLineHeight,
                width: "max-content",
                maxWidth: `${f.width}px`,
                overflow: f.id === this.state.editingFrame ? "visible" : "hidden",
                whiteSpace: "nowrap",
                textOverflow: "ellipsis",
                cursor: CURSOR_TYPE.MOVE,
                pointerEvents: this.state.viewModeEnabled ? POINTER_EVENTS.disabled : POINTER_EVENTS.enabled
              },
              onPointerDown: (event) => this.handleCanvasPointerDown(event),
              onWheel: (event) => this.handleWheel(event),
              onContextMenu: this.handleCanvasContextMenu,
              onDoubleClick: () => {
                this.setState({
                  editingFrame: f.id
                });
              },
              children: frameNameJSX
            },
            f.id
          );
        });
      };
      toggleOverscrollBehavior(event) {
        document.documentElement.style.overscrollBehaviorX = event.type === "pointerenter" ? "none" : "auto";
      }
      render() {
        const selectedElements = this.scene.getSelectedElements(this.state);
        const { renderTopRightUI, renderCustomStats } = this.props;
        const versionNonce = this.scene.getVersionNonce();
        const { elementsMap, visibleElements } = this.renderer.getRenderableElements({
          versionNonce,
          zoom: this.state.zoom,
          offsetLeft: this.state.offsetLeft,
          offsetTop: this.state.offsetTop,
          scrollX: this.state.scrollX,
          scrollY: this.state.scrollY,
          height: this.state.height,
          width: this.state.width,
          editingElement: this.state.editingElement,
          pendingImageElementId: this.state.pendingImageElementId
        });
        const allElementsMap = this.scene.getNonDeletedElementsMap();
        const shouldBlockPointerEvents = !(this.state.editingElement && isLinearElement(this.state.editingElement)) && (this.state.selectionElement || this.state.draggingElement || this.state.resizingElement || this.state.activeTool.type === "laser" && // technically we can just test on this once we make it more safe
        this.state.cursorButton === "down" || this.state.editingElement && !isTextElement(this.state.editingElement));
        const firstSelectedElement = selectedElements[0];
        return /* @__PURE__ */ jsx122(
          "div",
          {
            className: clsx47("excalidraw excalidraw-container", {
              "excalidraw--view-mode": this.state.viewModeEnabled,
              "excalidraw--mobile": this.device.editor.isMobile
            }),
            style: {
              ["--ui-pointerEvents"]: shouldBlockPointerEvents ? POINTER_EVENTS.disabled : POINTER_EVENTS.enabled
            },
            ref: this.excalidrawContainerRef,
            onDrop: this.handleAppOnDrop,
            tabIndex: 0,
            onKeyDown: this.props.handleKeyboardGlobally ? void 0 : this.onKeyDown,
            onPointerEnter: this.toggleOverscrollBehavior,
            onPointerLeave: this.toggleOverscrollBehavior,
            children: /* @__PURE__ */ jsx122(AppContext.Provider, { value: this, children: /* @__PURE__ */ jsx122(AppPropsContext.Provider, { value: this.props, children: /* @__PURE__ */ jsx122(
              ExcalidrawContainerContext.Provider,
              {
                value: this.excalidrawContainerValue,
                children: /* @__PURE__ */ jsx122(DeviceContext.Provider, { value: this.device, children: /* @__PURE__ */ jsx122(ExcalidrawSetAppStateContext.Provider, { value: this.setAppState, children: /* @__PURE__ */ jsx122(ExcalidrawAppStateContext.Provider, { value: this.state, children: /* @__PURE__ */ jsxs69(
                  ExcalidrawElementsContext.Provider,
                  {
                    value: this.scene.getNonDeletedElements(),
                    children: [
                      /* @__PURE__ */ jsxs69(
                        ExcalidrawActionManagerContext.Provider,
                        {
                          value: this.actionManager,
                          children: [
                            /* @__PURE__ */ jsx122(
                              LayerUI_default,
                              {
                                canvas: this.canvas,
                                appState: this.state,
                                files: this.files,
                                setAppState: this.setAppState,
                                actionManager: this.actionManager,
                                elements: this.scene.getNonDeletedElements(),
                                onLockToggle: this.toggleLock,
                                onPenModeToggle: this.togglePenMode,
                                onHandToolToggle: this.onHandToolToggle,
                                langCode: getLanguage().code,
                                renderTopRightUI,
                                renderCustomStats,
                                showExitZenModeBtn: typeof this.props?.zenModeEnabled === "undefined" && this.state.zenModeEnabled,
                                UIOptions: this.props.UIOptions,
                                onExportImage: this.onExportImage,
                                renderWelcomeScreen: !this.state.isLoading && this.state.showWelcomeScreen && this.state.activeTool.type === "selection" && !this.state.zenModeEnabled && !this.scene.getElementsIncludingDeleted().length,
                                app: this,
                                isCollaborating: this.props.isCollaborating,
                                openAIKey: this.OPENAI_KEY,
                                isOpenAIKeyPersisted: this.OPENAI_KEY_IS_PERSISTED,
                                onOpenAIAPIKeyChange: this.onOpenAIKeyChange,
                                onMagicSettingsConfirm: this.onMagicSettingsConfirm,
                                children: this.props.children
                              }
                            ),
                            /* @__PURE__ */ jsx122("div", { className: "excalidraw-textEditorContainer" }),
                            /* @__PURE__ */ jsx122("div", { className: "excalidraw-contextMenuContainer" }),
                            /* @__PURE__ */ jsx122("div", { className: "excalidraw-eye-dropper-container" }),
                            /* @__PURE__ */ jsx122(
                              SVGLayer,
                              {
                                trails: [this.laserTrails, this.eraserTrail]
                              }
                            ),
                            selectedElements.length === 1 && this.state.showHyperlinkPopup && /* @__PURE__ */ jsx122(
                              Hyperlink,
                              {
                                element: firstSelectedElement,
                                elementsMap: allElementsMap,
                                setAppState: this.setAppState,
                                onLinkOpen: this.props.onLinkOpen,
                                setToast: this.setToast,
                                updateEmbedValidationStatus: this.updateEmbedValidationStatus
                              },
                              firstSelectedElement.id
                            ),
                            this.props.aiEnabled !== false && selectedElements.length === 1 && isMagicFrameElement(firstSelectedElement) && /* @__PURE__ */ jsx122(
                              ElementCanvasButtons,
                              {
                                element: firstSelectedElement,
                                elementsMap,
                                children: /* @__PURE__ */ jsx122(
                                  ElementCanvasButton,
                                  {
                                    title: t("labels.convertToCode"),
                                    icon: MagicIcon,
                                    checked: false,
                                    onChange: () => this.onMagicFrameGenerate(
                                      firstSelectedElement,
                                      "button"
                                    )
                                  }
                                )
                              }
                            ),
                            selectedElements.length === 1 && isIframeElement(firstSelectedElement) && firstSelectedElement.customData?.generationData?.status === "done" && /* @__PURE__ */ jsxs69(
                              ElementCanvasButtons,
                              {
                                element: firstSelectedElement,
                                elementsMap,
                                children: [
                                  /* @__PURE__ */ jsx122(
                                    ElementCanvasButton,
                                    {
                                      title: t("labels.copySource"),
                                      icon: copyIcon,
                                      checked: false,
                                      onChange: () => this.onIframeSrcCopy(firstSelectedElement)
                                    }
                                  ),
                                  /* @__PURE__ */ jsx122(
                                    ElementCanvasButton,
                                    {
                                      title: "Enter fullscreen",
                                      icon: fullscreenIcon,
                                      checked: false,
                                      onChange: () => {
                                        const iframe = this.getHTMLIFrameElement(
                                          firstSelectedElement
                                        );
                                        if (iframe) {
                                          try {
                                            iframe.requestFullscreen();
                                            this.setState({
                                              activeEmbeddable: {
                                                element: firstSelectedElement,
                                                state: "active"
                                              },
                                              selectedElementIds: {
                                                [firstSelectedElement.id]: true
                                              },
                                              draggingElement: null,
                                              selectionElement: null
                                            });
                                          } catch (err) {
                                            console.warn(err);
                                            this.setState({
                                              errorMessage: "Couldn't enter fullscreen"
                                            });
                                          }
                                        }
                                      }
                                    }
                                  )
                                ]
                              }
                            ),
                            this.state.toast !== null && /* @__PURE__ */ jsx122(
                              Toast,
                              {
                                message: this.state.toast.message,
                                onClose: () => this.setToast(null),
                                duration: this.state.toast.duration,
                                closable: this.state.toast.closable
                              }
                            ),
                            this.state.contextMenu && /* @__PURE__ */ jsx122(
                              ContextMenu,
                              {
                                items: this.state.contextMenu.items,
                                top: this.state.contextMenu.top,
                                left: this.state.contextMenu.left,
                                actionManager: this.actionManager,
                                onClose: (callback) => {
                                  this.setState({ contextMenu: null }, () => {
                                    this.focusContainer();
                                    callback?.();
                                  });
                                }
                              }
                            ),
                            /* @__PURE__ */ jsx122(
                              StaticCanvas_default,
                              {
                                canvas: this.canvas,
                                rc: this.rc,
                                elementsMap,
                                allElementsMap,
                                visibleElements,
                                versionNonce,
                                selectionNonce: this.state.selectionElement?.versionNonce,
                                scale: window.devicePixelRatio,
                                appState: this.state,
                                renderConfig: {
                                  imageCache: this.imageCache,
                                  isExporting: false,
                                  renderGrid: true,
                                  canvasBackgroundColor: this.state.viewBackgroundColor,
                                  embedsValidationStatus: this.embedsValidationStatus,
                                  elementsPendingErasure: this.elementsPendingErasure
                                }
                              }
                            ),
                            /* @__PURE__ */ jsx122(
                              InteractiveCanvas_default,
                              {
                                containerRef: this.excalidrawContainerRef,
                                canvas: this.interactiveCanvas,
                                elementsMap,
                                visibleElements,
                                selectedElements,
                                versionNonce,
                                selectionNonce: this.state.selectionElement?.versionNonce,
                                scale: window.devicePixelRatio,
                                appState: this.state,
                                renderInteractiveSceneCallback: this.renderInteractiveSceneCallback,
                                handleCanvasRef: this.handleInteractiveCanvasRef,
                                onContextMenu: this.handleCanvasContextMenu,
                                onPointerMove: this.handleCanvasPointerMove,
                                onPointerUp: this.handleCanvasPointerUp,
                                onPointerCancel: this.removePointer,
                                onTouchMove: this.handleTouchMove,
                                onPointerDown: this.handleCanvasPointerDown,
                                onDoubleClick: this.handleCanvasDoubleClick
                              }
                            ),
                            this.state.userToFollow && /* @__PURE__ */ jsx122(
                              FollowMode_default,
                              {
                                width: this.state.width,
                                height: this.state.height,
                                userToFollow: this.state.userToFollow,
                                onDisconnect: this.maybeUnfollowRemoteUser
                              }
                            ),
                            this.renderFrameNames()
                          ]
                        }
                      ),
                      this.renderEmbeddables()
                    ]
                  }
                ) }) }) })
              }
            ) }) })
          }
        );
      }
      focusContainer = () => {
        this.excalidrawContainerRef.current?.focus();
      };
      getSceneElementsIncludingDeleted = () => {
        return this.scene.getElementsIncludingDeleted();
      };
      getSceneElements = () => {
        return this.scene.getNonDeletedElements();
      };
      onInsertElements = (elements) => {
        this.addElementsFromPasteOrLibrary({
          elements,
          position: "center",
          files: null
        });
      };
      onExportImage = async (type, elements, opts) => {
        trackEvent("export", type, "ui");
        const fileHandle = await exportCanvas(
          type,
          elements,
          this.state,
          this.files,
          {
            exportBackground: this.state.exportBackground,
            name: this.getName(),
            viewBackgroundColor: this.state.viewBackgroundColor,
            exportingFrame: opts.exportingFrame
          }
        ).catch(muteFSAbortError).catch((error) => {
          console.error(error);
          this.setState({ errorMessage: error.message });
        });
        if (this.state.exportEmbedScene && fileHandle && isImageFileHandle(fileHandle)) {
          this.setState({ fileHandle });
        }
      };
      magicGenerations = /* @__PURE__ */ new Map();
      updateMagicGeneration = ({
        frameElement,
        data
      }) => {
        if (data.status === "pending") {
          mutateElement(
            frameElement,
            { customData: { generationData: void 0 } },
            false
          );
        } else {
          mutateElement(
            frameElement,
            { customData: { generationData: data } },
            false
          );
        }
        this.magicGenerations.set(frameElement.id, data);
        this.onSceneUpdated();
      };
      getTextFromElements(elements) {
        const text = elements.reduce((acc, element) => {
          if (isTextElement(element)) {
            acc.push(element.text);
          }
          return acc;
        }, []).join("\n\n");
        return text;
      }
      async onMagicFrameGenerate(magicFrame, source) {
        if (!this.OPENAI_KEY) {
          this.setState({
            openDialog: {
              name: "settings",
              tab: "diagram-to-code",
              source: "generation"
            }
          });
          trackEvent("ai", "generate (missing key)", "d2c");
          return;
        }
        const magicFrameChildren = getElementsOverlappingFrame(
          this.scene.getNonDeletedElements(),
          magicFrame
        ).filter((el) => !isMagicFrameElement(el));
        if (!magicFrameChildren.length) {
          if (source === "button") {
            this.setState({ errorMessage: "Cannot generate from an empty frame" });
            trackEvent("ai", "generate (no-children)", "d2c");
          } else {
            this.setActiveTool({ type: "magicframe" });
          }
          return;
        }
        const frameElement = this.insertIframeElement({
          sceneX: magicFrame.x + magicFrame.width + 30,
          sceneY: magicFrame.y,
          width: magicFrame.width,
          height: magicFrame.height
        });
        if (!frameElement) {
          return;
        }
        this.updateMagicGeneration({
          frameElement,
          data: { status: "pending" }
        });
        this.setState({
          selectedElementIds: { [frameElement.id]: true }
        });
        const blob = await exportToBlob({
          elements: this.scene.getNonDeletedElements(),
          appState: {
            ...this.state,
            exportBackground: true,
            viewBackgroundColor: this.state.viewBackgroundColor
          },
          exportingFrame: magicFrame,
          files: this.files
        });
        const dataURL = await getDataURL(blob);
        const textFromFrameChildren = this.getTextFromElements(magicFrameChildren);
        trackEvent("ai", "generate (start)", "d2c");
        const result = await diagramToHTML({
          image: dataURL,
          apiKey: this.OPENAI_KEY,
          text: textFromFrameChildren,
          theme: this.state.theme
        });
        if (!result.ok) {
          trackEvent("ai", "generate (failed)", "d2c");
          console.error(result.error);
          this.updateMagicGeneration({
            frameElement,
            data: {
              status: "error",
              code: "ERR_OAI",
              message: result.error?.message || "Unknown error during generation"
            }
          });
          return;
        }
        trackEvent("ai", "generate (success)", "d2c");
        if (result.choices[0].message.content == null) {
          this.updateMagicGeneration({
            frameElement,
            data: {
              status: "error",
              code: "ERR_OAI",
              message: "Nothing genereated :("
            }
          });
          return;
        }
        const message = result.choices[0].message.content;
        const html = message.slice(
          message.indexOf("<!DOCTYPE html>"),
          message.indexOf("</html>") + "</html>".length
        );
        this.updateMagicGeneration({
          frameElement,
          data: { status: "done", html }
        });
      }
      onIframeSrcCopy(element) {
        if (element.customData?.generationData?.status === "done") {
          copyTextToSystemClipboard(element.customData.generationData.html);
          this.setToast({
            message: "copied to clipboard",
            closable: false,
            duration: 1500
          });
        }
      }
      OPENAI_KEY = EditorLocalStorage.get(
        EDITOR_LS_KEYS.OAI_API_KEY
      );
      OPENAI_KEY_IS_PERSISTED = EditorLocalStorage.has(EDITOR_LS_KEYS.OAI_API_KEY) || false;
      onOpenAIKeyChange = (openAIKey, shouldPersist) => {
        this.OPENAI_KEY = openAIKey || null;
        if (shouldPersist) {
          const didPersist = EditorLocalStorage.set(
            EDITOR_LS_KEYS.OAI_API_KEY,
            openAIKey
          );
          this.OPENAI_KEY_IS_PERSISTED = didPersist;
        } else {
          this.OPENAI_KEY_IS_PERSISTED = false;
        }
      };
      onMagicSettingsConfirm = (apiKey, shouldPersist, source) => {
        this.OPENAI_KEY = apiKey || null;
        this.onOpenAIKeyChange(this.OPENAI_KEY, shouldPersist);
        if (source === "settings") {
          return;
        }
        const selectedElements = this.scene.getSelectedElements({
          selectedElementIds: this.state.selectedElementIds
        });
        if (apiKey) {
          if (selectedElements.length) {
            this.onMagicframeToolSelect();
          } else {
            this.setActiveTool({ type: "magicframe" });
          }
        } else if (!isMagicFrameElement(selectedElements[0])) {
          this.setActiveTool({ type: "magicframe" });
        }
      };
      onMagicframeToolSelect = () => {
        if (!this.OPENAI_KEY) {
          this.setState({
            openDialog: {
              name: "settings",
              tab: "diagram-to-code",
              source: "tool"
            }
          });
          trackEvent("ai", "tool-select (missing key)", "d2c");
          return;
        }
        const selectedElements = this.scene.getSelectedElements({
          selectedElementIds: this.state.selectedElementIds
        });
        if (selectedElements.length === 0) {
          this.setActiveTool({ type: TOOL_TYPE.magicframe });
          trackEvent("ai", "tool-select (empty-selection)", "d2c");
        } else {
          const selectedMagicFrame = selectedElements.length === 1 && isMagicFrameElement(selectedElements[0]) && selectedElements[0];
          if (!selectedMagicFrame && selectedElements.some((el) => isFrameLikeElement(el) || el.frameId)) {
            this.setActiveTool({ type: TOOL_TYPE.magicframe });
            return;
          }
          trackEvent("ai", "tool-select (existing selection)", "d2c");
          let frame;
          if (selectedMagicFrame) {
            frame = selectedMagicFrame;
          } else {
            const [minX, minY, maxX, maxY] = getCommonBounds(selectedElements);
            const padding = 50;
            frame = newMagicFrameElement({
              ...FRAME_STYLE,
              x: minX - padding,
              y: minY - padding,
              width: maxX - minX + padding * 2,
              height: maxY - minY + padding * 2,
              opacity: 100,
              locked: false
            });
            this.scene.addNewElement(frame);
            for (const child of selectedElements) {
              mutateElement(child, { frameId: frame.id });
            }
            this.setState({
              selectedElementIds: { [frame.id]: true }
            });
          }
          this.onMagicFrameGenerate(frame, "upstream");
        }
      };
      openEyeDropper = ({ type }) => {
        jotaiStore.set(activeEyeDropperAtom, {
          swapPreviewOnAlt: true,
          colorPickerType: type === "stroke" ? "elementStroke" : "elementBackground",
          onSelect: (color, event) => {
            const shouldUpdateStrokeColor = type === "background" && event.altKey || type === "stroke" && !event.altKey;
            const selectedElements = this.scene.getSelectedElements(this.state);
            if (!selectedElements.length || this.state.activeTool.type !== "selection") {
              if (shouldUpdateStrokeColor) {
                this.syncActionResult({
                  appState: { ...this.state, currentItemStrokeColor: color },
                  commitToHistory: true
                });
              } else {
                this.syncActionResult({
                  appState: { ...this.state, currentItemBackgroundColor: color },
                  commitToHistory: true
                });
              }
            } else {
              this.updateScene({
                elements: this.scene.getElementsIncludingDeleted().map((el) => {
                  if (this.state.selectedElementIds[el.id]) {
                    return newElementWith(el, {
                      [shouldUpdateStrokeColor ? "strokeColor" : "backgroundColor"]: color
                    });
                  }
                  return el;
                })
              });
            }
          },
          keepOpenOnAlt: false
        });
      };
      syncActionResult = withBatchedUpdates(
        (actionResult) => {
          if (this.unmounted || actionResult === false) {
            return;
          }
          let editingElement = null;
          if (actionResult.elements) {
            actionResult.elements.forEach((element) => {
              if (this.state.editingElement?.id === element.id && this.state.editingElement !== element && isNonDeletedElement(element)) {
                editingElement = element;
              }
            });
            this.scene.replaceAllElements(actionResult.elements);
            if (actionResult.commitToHistory) {
              this.history.resumeRecording();
            }
          }
          if (actionResult.files) {
            this.files = actionResult.replaceFiles ? actionResult.files : { ...this.files, ...actionResult.files };
            this.addNewImagesToImageCache();
          }
          if (actionResult.appState || editingElement || this.state.contextMenu) {
            if (actionResult.commitToHistory) {
              this.history.resumeRecording();
            }
            let viewModeEnabled = actionResult?.appState?.viewModeEnabled || false;
            let zenModeEnabled = actionResult?.appState?.zenModeEnabled || false;
            let gridSize = actionResult?.appState?.gridSize || null;
            const theme = actionResult?.appState?.theme || this.props.theme || THEME.LIGHT;
            const name = actionResult?.appState?.name ?? this.state.name;
            const errorMessage = actionResult?.appState?.errorMessage ?? this.state.errorMessage;
            if (typeof this.props.viewModeEnabled !== "undefined") {
              viewModeEnabled = this.props.viewModeEnabled;
            }
            if (typeof this.props.zenModeEnabled !== "undefined") {
              zenModeEnabled = this.props.zenModeEnabled;
            }
            if (typeof this.props.gridModeEnabled !== "undefined") {
              gridSize = this.props.gridModeEnabled ? GRID_SIZE : null;
            }
            editingElement = editingElement || actionResult.appState?.editingElement || null;
            if (editingElement?.isDeleted) {
              editingElement = null;
            }
            this.setState(
              (state) => {
                return Object.assign(actionResult.appState || {}, {
                  // NOTE this will prevent opening context menu using an action
                  // or programmatically from the host, so it will need to be
                  // rewritten later
                  contextMenu: null,
                  editingElement,
                  viewModeEnabled,
                  zenModeEnabled,
                  gridSize,
                  theme,
                  name,
                  errorMessage
                });
              },
              () => {
                if (actionResult.syncHistory) {
                  this.history.setCurrentState(
                    this.state,
                    this.scene.getElementsIncludingDeleted()
                  );
                }
              }
            );
          }
        }
      );
      // Lifecycle
      onBlur = withBatchedUpdates(() => {
        isHoldingSpace = false;
        this.setState({ isBindingEnabled: true });
      });
      onUnload = () => {
        this.onBlur();
      };
      disableEvent = (event) => {
        event.preventDefault();
      };
      resetHistory = () => {
        this.history.clear();
      };
      /**
       * Resets scene & history.
       * ! Do not use to clear scene user action !
       */
      resetScene = withBatchedUpdates(
        (opts) => {
          this.scene.replaceAllElements([]);
          this.setState((state) => ({
            ...getDefaultAppState(),
            isLoading: opts?.resetLoadingState ? false : state.isLoading,
            theme: this.state.theme
          }));
          this.resetHistory();
        }
      );
      initializeScene = async () => {
        if ("launchQueue" in window && "LaunchParams" in window) {
          window.launchQueue.setConsumer(
            async (launchParams) => {
              if (!launchParams.files.length) {
                return;
              }
              const fileHandle = launchParams.files[0];
              const blob = await fileHandle.getFile();
              this.loadFileToCanvas(
                new File([blob], blob.name || "", { type: blob.type }),
                fileHandle
              );
            }
          );
        }
        if (this.props.theme) {
          this.setState({ theme: this.props.theme });
        }
        if (!this.state.isLoading) {
          this.setState({ isLoading: true });
        }
        let initialData = null;
        try {
          initialData = await this.props.initialData || null;
          if (initialData?.libraryItems) {
            this.library.updateLibrary({
              libraryItems: initialData.libraryItems,
              merge: true
            }).catch((error) => {
              console.error(error);
            });
          }
        } catch (error) {
          console.error(error);
          initialData = {
            appState: {
              errorMessage: error.message || "Encountered an error during importing or restoring scene data"
            }
          };
        }
        const scene = restore(initialData, null, null, { repairBindings: true });
        scene.appState = {
          ...scene.appState,
          theme: this.props.theme || scene.appState.theme,
          // we're falling back to current (pre-init) state when deciding
          // whether to open the library, to handle a case where we
          // update the state outside of initialData (e.g. when loading the app
          // with a library install link, which should auto-open the library)
          openSidebar: scene.appState?.openSidebar || this.state.openSidebar,
          activeTool: scene.appState.activeTool.type === "image" ? { ...scene.appState.activeTool, type: "selection" } : scene.appState.activeTool,
          isLoading: false,
          toast: this.state.toast
        };
        if (initialData?.scrollToContent) {
          scene.appState = {
            ...scene.appState,
            ...calculateScrollCenter(scene.elements, {
              ...scene.appState,
              width: this.state.width,
              height: this.state.height,
              offsetTop: this.state.offsetTop,
              offsetLeft: this.state.offsetLeft
            })
          };
        }
        this.fonts.loadFontsForElements(scene.elements);
        this.resetHistory();
        this.syncActionResult({
          ...scene,
          commitToHistory: true
        });
      };
      isMobileBreakpoint = (width, height) => {
        return width < MQ_MAX_WIDTH_PORTRAIT || height < MQ_MAX_HEIGHT_LANDSCAPE && width < MQ_MAX_WIDTH_LANDSCAPE;
      };
      refreshViewportBreakpoints = () => {
        const container = this.excalidrawContainerRef.current;
        if (!container) {
          return;
        }
        const { clientWidth: viewportWidth, clientHeight: viewportHeight } = document.body;
        const prevViewportState = this.device.viewport;
        const nextViewportState = updateObject(prevViewportState, {
          isLandscape: viewportWidth > viewportHeight,
          isMobile: this.isMobileBreakpoint(viewportWidth, viewportHeight)
        });
        if (prevViewportState !== nextViewportState) {
          this.device = { ...this.device, viewport: nextViewportState };
          return true;
        }
        return false;
      };
      refreshEditorBreakpoints = () => {
        const container = this.excalidrawContainerRef.current;
        if (!container) {
          return;
        }
        const { width: editorWidth, height: editorHeight } = container.getBoundingClientRect();
        const sidebarBreakpoint = this.props.UIOptions.dockedSidebarBreakpoint != null ? this.props.UIOptions.dockedSidebarBreakpoint : MQ_RIGHT_SIDEBAR_MIN_WIDTH;
        const prevEditorState = this.device.editor;
        const nextEditorState = updateObject(prevEditorState, {
          isMobile: this.isMobileBreakpoint(editorWidth, editorHeight),
          canFitSidebar: editorWidth > sidebarBreakpoint
        });
        if (prevEditorState !== nextEditorState) {
          this.device = { ...this.device, editor: nextEditorState };
          return true;
        }
        return false;
      };
      async componentDidMount() {
        this.unmounted = false;
        this.excalidrawContainerValue.container = this.excalidrawContainerRef.current;
        if (define_import_meta_env_default.MODE === ENV.TEST || define_import_meta_env_default.DEV) {
          const setState = this.setState.bind(this);
          Object.defineProperties(window.h, {
            state: {
              configurable: true,
              get: () => {
                return this.state;
              }
            },
            setState: {
              configurable: true,
              value: (...args) => {
                return this.setState(...args);
              }
            },
            app: {
              configurable: true,
              value: this
            },
            history: {
              configurable: true,
              value: this.history
            }
          });
        }
        this.scene.addCallback(this.onSceneUpdated);
        this.addEventListeners();
        if (this.props.autoFocus && this.excalidrawContainerRef.current) {
          this.focusContainer();
        }
        if (
          // bounding rects don't work in tests so updating
          // the state on init would result in making the test enviro run
          // in mobile breakpoint (0 width/height), making everything fail
          !isTestEnv()
        ) {
          this.refreshViewportBreakpoints();
          this.refreshEditorBreakpoints();
        }
        if (supportsResizeObserver && this.excalidrawContainerRef.current) {
          this.resizeObserver = new ResizeObserver(() => {
            this.refreshEditorBreakpoints();
            this.updateDOMRect();
          });
          this.resizeObserver?.observe(this.excalidrawContainerRef.current);
        }
        const searchParams = new URLSearchParams(window.location.search.slice(1));
        if (searchParams.has("web-share-target")) {
          this.restoreFileFromShare();
        } else {
          this.updateDOMRect(this.initializeScene);
        }
        if (isBrave() && !isMeasureTextSupported()) {
          this.setState({
            errorMessage: /* @__PURE__ */ jsx122(BraveMeasureTextError_default, {})
          });
        }
      }
      componentWillUnmount() {
        this.renderer.destroy();
        this.scene = new Scene_default();
        this.renderer = new Renderer(this.scene);
        this.files = {};
        this.imageCache.clear();
        this.resizeObserver?.disconnect();
        this.unmounted = true;
        this.removeEventListeners();
        this.scene.destroy();
        this.library.destroy();
        this.laserTrails.stop();
        this.eraserTrail.stop();
        this.onChangeEmitter.clear();
        ShapeCache.destroy();
        SnapCache.destroy();
        clearTimeout(touchTimeout);
        isSomeElementSelected.clearCache();
        selectGroupsForSelectedElements.clearCache();
        touchTimeout = 0;
        document.documentElement.style.overscrollBehaviorX = "";
      }
      onResize = withBatchedUpdates(() => {
        this.scene.getElementsIncludingDeleted().forEach((element) => ShapeCache.delete(element));
        this.refreshViewportBreakpoints();
        this.updateDOMRect();
        if (!supportsResizeObserver) {
          this.refreshEditorBreakpoints();
        }
        this.setState({});
      });
      /** generally invoked only if fullscreen was invoked programmatically */
      onFullscreenChange = () => {
        if (
          // points to the iframe element we fullscreened
          !document.fullscreenElement && this.state.activeEmbeddable?.state === "active"
        ) {
          this.setState({
            activeEmbeddable: null
          });
        }
      };
      removeEventListeners() {
        this.onRemoveEventListenersEmitter.trigger();
      }
      addEventListeners() {
        this.removeEventListeners();
        if (this.props.handleKeyboardGlobally) {
          this.onRemoveEventListenersEmitter.once(
            addEventListener(document, "keydown" /* KEYDOWN */, this.onKeyDown, false)
          );
        }
        this.onRemoveEventListenersEmitter.once(
          addEventListener(
            this.excalidrawContainerRef.current,
            "wheel" /* WHEEL */,
            this.onWheel,
            { passive: false }
          ),
          addEventListener(window, "message" /* MESSAGE */, this.onWindowMessage, false),
          addEventListener(document, "pointerup" /* POINTER_UP */, this.removePointer),
          // #3553
          addEventListener(document, "copy" /* COPY */, this.onCopy),
          addEventListener(document, "keyup" /* KEYUP */, this.onKeyUp, { passive: true }),
          addEventListener(
            document,
            "mousemove" /* MOUSE_MOVE */,
            this.updateCurrentCursorPosition
          ),
          // rerender text elements on font load to fix #637 && #1553
          addEventListener(document.fonts, "loadingdone", (event) => {
            const loadedFontFaces = event.fontfaces;
            this.fonts.onFontsLoaded(loadedFontFaces);
          }),
          // Safari-only desktop pinch zoom
          addEventListener(
            document,
            "gesturestart" /* GESTURE_START */,
            this.onGestureStart,
            false
          ),
          addEventListener(
            document,
            "gesturechange" /* GESTURE_CHANGE */,
            this.onGestureChange,
            false
          ),
          addEventListener(
            document,
            "gestureend" /* GESTURE_END */,
            this.onGestureEnd,
            false
          ),
          addEventListener(window, "focus" /* FOCUS */, () => {
            this.maybeCleanupAfterMissingPointerUp(null);
          })
        );
        if (this.state.viewModeEnabled) {
          return;
        }
        this.onRemoveEventListenersEmitter.once(
          addEventListener(
            document,
            "fullscreenchange" /* FULLSCREENCHANGE */,
            this.onFullscreenChange
          ),
          addEventListener(document, "paste" /* PASTE */, this.pasteFromClipboard),
          addEventListener(document, "cut" /* CUT */, this.onCut),
          addEventListener(window, "resize" /* RESIZE */, this.onResize, false),
          addEventListener(window, "unload" /* UNLOAD */, this.onUnload, false),
          addEventListener(window, "blur" /* BLUR */, this.onBlur, false),
          addEventListener(
            this.excalidrawContainerRef.current,
            "dragover" /* DRAG_OVER */,
            this.disableEvent,
            false
          ),
          addEventListener(
            this.excalidrawContainerRef.current,
            "drop" /* DROP */,
            this.disableEvent,
            false
          )
        );
        if (this.props.detectScroll) {
          this.onRemoveEventListenersEmitter.once(
            addEventListener(
              getNearestScrollableContainer(this.excalidrawContainerRef.current),
              "scroll" /* SCROLL */,
              this.onScroll
            )
          );
        }
      }
      componentDidUpdate(prevProps, prevState) {
        this.updateEmbeddables();
        const elements = this.scene.getElementsIncludingDeleted();
        const elementsMap = this.scene.getNonDeletedElementsMap();
        if (!this.state.showWelcomeScreen && !elements.length) {
          this.setState({ showWelcomeScreen: true });
        }
        if (prevProps.UIOptions.dockedSidebarBreakpoint !== this.props.UIOptions.dockedSidebarBreakpoint) {
          this.refreshEditorBreakpoints();
        }
        const hasFollowedPersonLeft = prevState.userToFollow && !this.state.collaborators.has(prevState.userToFollow.socketId);
        if (hasFollowedPersonLeft) {
          this.maybeUnfollowRemoteUser();
        }
        if (prevState.zoom.value !== this.state.zoom.value || prevState.scrollX !== this.state.scrollX || prevState.scrollY !== this.state.scrollY) {
          this.props?.onScrollChange?.(
            this.state.scrollX,
            this.state.scrollY,
            this.state.zoom
          );
          this.onScrollChangeEmitter.trigger(
            this.state.scrollX,
            this.state.scrollY,
            this.state.zoom
          );
        }
        if (prevState.userToFollow !== this.state.userToFollow) {
          if (prevState.userToFollow) {
            this.onUserFollowEmitter.trigger({
              userToFollow: prevState.userToFollow,
              action: "UNFOLLOW"
            });
          }
          if (this.state.userToFollow) {
            this.onUserFollowEmitter.trigger({
              userToFollow: this.state.userToFollow,
              action: "FOLLOW"
            });
          }
        }
        if (Object.keys(this.state.selectedElementIds).length && isEraserActive(this.state)) {
          this.setState({
            activeTool: updateActiveTool(this.state, { type: "selection" })
          });
        }
        if (this.state.activeTool.type === "eraser" && prevState.theme !== this.state.theme) {
          setEraserCursor(this.interactiveCanvas, this.state.theme);
        }
        if (prevState.activeTool.type === "selection" && this.state.activeTool.type !== "selection" && this.state.showHyperlinkPopup) {
          this.setState({ showHyperlinkPopup: false });
        }
        if (prevProps.langCode !== this.props.langCode) {
          this.updateLanguage();
        }
        if (isEraserActive(prevState) && !isEraserActive(this.state)) {
          this.eraserTrail.endPath();
        }
        if (prevProps.viewModeEnabled !== this.props.viewModeEnabled) {
          this.setState({ viewModeEnabled: !!this.props.viewModeEnabled });
        }
        if (prevState.viewModeEnabled !== this.state.viewModeEnabled) {
          this.addEventListeners();
          this.deselectElements();
        }
        if (prevProps.zenModeEnabled !== this.props.zenModeEnabled) {
          this.setState({ zenModeEnabled: !!this.props.zenModeEnabled });
        }
        if (prevProps.theme !== this.props.theme && this.props.theme) {
          this.setState({ theme: this.props.theme });
        }
        if (prevProps.gridModeEnabled !== this.props.gridModeEnabled) {
          this.setState({
            gridSize: this.props.gridModeEnabled ? GRID_SIZE : null
          });
        }
        this.excalidrawContainerRef.current?.classList.toggle(
          "theme--dark",
          this.state.theme === "dark"
        );
        if (this.state.editingLinearElement && !this.state.selectedElementIds[this.state.editingLinearElement.elementId]) {
          setTimeout(() => {
            this.state.editingLinearElement && this.actionManager.executeAction(actionFinalize);
          });
        }
        if (this.state.editingElement?.isDeleted) {
          this.setState({ editingElement: null });
        }
        if (this.state.selectedLinearElement && !this.state.selectedElementIds[this.state.selectedLinearElement.elementId]) {
          this.setState({ selectedLinearElement: null });
        }
        const { multiElement } = prevState;
        if (prevState.activeTool !== this.state.activeTool && multiElement != null && isBindingEnabled(this.state) && isBindingElement(multiElement, false)) {
          maybeBindLinearElement(
            multiElement,
            this.state,
            this.scene,
            tupleToCoors(
              LinearElementEditor.getPointAtIndexGlobalCoordinates(
                multiElement,
                -1,
                elementsMap
              )
            ),
            elementsMap
          );
        }
        this.history.record(this.state, elements);
        if (!this.state.isLoading) {
          this.props.onChange?.(elements, this.state, this.files);
          this.onChangeEmitter.trigger(elements, this.state, this.files);
        }
      }
      renderInteractiveSceneCallback = ({
        atLeastOneVisibleElement,
        scrollBars,
        elementsMap
      }) => {
        if (scrollBars) {
          currentScrollBars = scrollBars;
        }
        const scrolledOutside = (
          // hide when editing text
          isTextElement(this.state.editingElement) ? false : !atLeastOneVisibleElement && elementsMap.size > 0
        );
        if (this.state.scrolledOutside !== scrolledOutside) {
          this.setState({ scrolledOutside });
        }
        this.scheduleImageRefresh();
      };
      onScroll = debounce(() => {
        const { offsetTop, offsetLeft } = this.getCanvasOffsets();
        this.setState((state) => {
          if (state.offsetLeft === offsetLeft && state.offsetTop === offsetTop) {
            return null;
          }
          return { offsetTop, offsetLeft };
        });
      }, SCROLL_TIMEOUT);
      // Copy/paste
      onCut = withBatchedUpdates((event) => {
        const isExcalidrawActive = this.excalidrawContainerRef.current?.contains(
          document.activeElement
        );
        if (!isExcalidrawActive || isWritableElement(event.target)) {
          return;
        }
        this.actionManager.executeAction(actionCut, "keyboard", event);
        event.preventDefault();
        event.stopPropagation();
      });
      onCopy = withBatchedUpdates((event) => {
        const isExcalidrawActive = this.excalidrawContainerRef.current?.contains(
          document.activeElement
        );
        if (!isExcalidrawActive || isWritableElement(event.target)) {
          return;
        }
        this.actionManager.executeAction(actionCopy, "keyboard", event);
        event.preventDefault();
        event.stopPropagation();
      });
      static resetTapTwice() {
        didTapTwice = false;
      }
      onTouchStart = (event) => {
        if (isIOS) {
          event.preventDefault();
        }
        if (!didTapTwice) {
          didTapTwice = true;
          clearTimeout(tappedTwiceTimer);
          tappedTwiceTimer = window.setTimeout(
            _App.resetTapTwice,
            TAP_TWICE_TIMEOUT
          );
          return;
        }
        if (didTapTwice && event.touches.length === 1) {
          const touch = event.touches[0];
          this.handleCanvasDoubleClick({
            clientX: touch.clientX,
            clientY: touch.clientY
          });
          didTapTwice = false;
          clearTimeout(tappedTwiceTimer);
        }
        if (event.touches.length === 2) {
          this.setState({
            selectedElementIds: makeNextSelectedElementIds({}, this.state),
            activeEmbeddable: null
          });
        }
      };
      onTouchEnd = (event) => {
        this.resetContextMenuTimer();
        if (event.touches.length > 0) {
          this.setState({
            previousSelectedElementIds: {},
            selectedElementIds: makeNextSelectedElementIds(
              this.state.previousSelectedElementIds,
              this.state
            )
          });
        } else {
          gesture.pointers.clear();
        }
      };
      pasteFromClipboard = withBatchedUpdates(
        async (event) => {
          const isPlainPaste = !!IS_PLAIN_PASTE;
          const target = document.activeElement;
          const isExcalidrawActive = this.excalidrawContainerRef.current?.contains(target);
          if (event && !isExcalidrawActive) {
            return;
          }
          const elementUnderCursor = document.elementFromPoint(
            this.lastViewportPosition.x,
            this.lastViewportPosition.y
          );
          if (event && (!(elementUnderCursor instanceof HTMLCanvasElement) || isWritableElement(target))) {
            return;
          }
          const { x: sceneX, y: sceneY } = viewportCoordsToSceneCoords(
            {
              clientX: this.lastViewportPosition.x,
              clientY: this.lastViewportPosition.y
            },
            this.state
          );
          let file2 = event?.clipboardData?.files[0];
          const data = await parseClipboard(event, isPlainPaste);
          if (!file2 && !isPlainPaste) {
            if (data.mixedContent) {
              return this.addElementsFromMixedContentPaste(data.mixedContent, {
                isPlainPaste,
                sceneX,
                sceneY
              });
            } else if (data.text) {
              const string = data.text.trim();
              if (string.startsWith("<svg") && string.endsWith("</svg>")) {
                file2 = SVGStringToFile(string);
              }
            }
          }
          if (isSupportedImageFile(file2) && !data.spreadsheet) {
            if (!this.isToolSupported("image")) {
              this.setState({ errorMessage: t("errors.imageToolNotSupported") });
              return;
            }
            const imageElement = this.createImageElement({ sceneX, sceneY });
            this.insertImageElement(imageElement, file2);
            this.initializeImageDimensions(imageElement);
            this.setState({
              selectedElementIds: makeNextSelectedElementIds(
                {
                  [imageElement.id]: true
                },
                this.state
              )
            });
            return;
          }
          if (this.props.onPaste) {
            try {
              if (await this.props.onPaste(data, event) === false) {
                return;
              }
            } catch (error) {
              console.error(error);
            }
          }
          if (data.errorMessage) {
            this.setState({ errorMessage: data.errorMessage });
          } else if (data.spreadsheet && !isPlainPaste) {
            this.setState({
              pasteDialog: {
                data: data.spreadsheet,
                shown: true
              }
            });
          } else if (data.elements) {
            const elements = data.programmaticAPI ? convertToExcalidrawElements(
              data.elements
            ) : data.elements;
            this.addElementsFromPasteOrLibrary({
              elements,
              files: data.files || null,
              position: "cursor",
              retainSeed: isPlainPaste
            });
          } else if (data.text) {
            const nonEmptyLines = normalizeEOL(data.text).split(/\n+/).map((s) => s.trim()).filter(Boolean);
            const embbeddableUrls = nonEmptyLines.map((str) => maybeParseEmbedSrc(str)).filter((string) => {
              return embeddableURLValidator(string, this.props.validateEmbeddable) && (/^(http|https):\/\/[^\s/$.?#].[^\s]*$/.test(string) || getEmbedLink(string)?.type === "video");
            });
            if (!IS_PLAIN_PASTE && embbeddableUrls.length > 0 && // if there were non-embeddable text (lines) mixed in with embeddable
            // urls, ignore and paste as text
            embbeddableUrls.length === nonEmptyLines.length) {
              const embeddables = [];
              for (const url of embbeddableUrls) {
                const prevEmbeddable = embeddables[embeddables.length - 1];
                const embeddable = this.insertEmbeddableElement({
                  sceneX: prevEmbeddable ? prevEmbeddable.x + prevEmbeddable.width + 20 : sceneX,
                  sceneY,
                  link: normalizeLink(url)
                });
                if (embeddable) {
                  embeddables.push(embeddable);
                }
              }
              if (embeddables.length) {
                this.setState({
                  selectedElementIds: Object.fromEntries(
                    embeddables.map((embeddable) => [embeddable.id, true])
                  )
                });
              }
              return;
            }
            this.addTextFromPaste(data.text, isPlainPaste);
          }
          this.setActiveTool({ type: "selection" });
          event?.preventDefault();
        }
      );
      addElementsFromPasteOrLibrary = (opts) => {
        const elements = restoreElements(opts.elements, null, void 0);
        const [minX, minY, maxX, maxY] = getCommonBounds(elements);
        const elementsCenterX = distance(minX, maxX) / 2;
        const elementsCenterY = distance(minY, maxY) / 2;
        const clientX = typeof opts.position === "object" ? opts.position.clientX : opts.position === "cursor" ? this.lastViewportPosition.x : this.state.width / 2 + this.state.offsetLeft;
        const clientY = typeof opts.position === "object" ? opts.position.clientY : opts.position === "cursor" ? this.lastViewportPosition.y : this.state.height / 2 + this.state.offsetTop;
        const { x, y } = viewportCoordsToSceneCoords(
          { clientX, clientY },
          this.state
        );
        const dx = x - elementsCenterX;
        const dy = y - elementsCenterY;
        const [gridX, gridY] = getGridPoint(dx, dy, this.state.gridSize);
        const newElements = duplicateElements(
          elements.map((element) => {
            return newElementWith(element, {
              x: element.x + gridX - minX,
              y: element.y + gridY - minY
            });
          }),
          {
            randomizeSeed: !opts.retainSeed
          }
        );
        const allElements = [
          ...this.scene.getElementsIncludingDeleted(),
          ...newElements
        ];
        const topLayerFrame = this.getTopLayerFrameAtSceneCoords({ x, y });
        if (topLayerFrame) {
          const eligibleElements = filterElementsEligibleAsFrameChildren(
            newElements,
            topLayerFrame
          );
          addElementsToFrame(allElements, eligibleElements, topLayerFrame);
        }
        this.scene.replaceAllElements(allElements);
        newElements.forEach((newElement2) => {
          if (isTextElement(newElement2) && isBoundToContainer(newElement2)) {
            const container = getContainerElement(
              newElement2,
              this.scene.getElementsMapIncludingDeleted()
            );
            redrawTextBoundingBox(
              newElement2,
              container,
              this.scene.getElementsMapIncludingDeleted()
            );
          }
        });
        if (opts.files) {
          this.files = { ...this.files, ...opts.files };
        }
        this.history.resumeRecording();
        const nextElementsToSelect = excludeElementsInFramesFromSelection(newElements);
        this.setState(
          {
            ...this.state,
            // keep sidebar (presumably the library) open if it's docked and
            // can fit.
            //
            // Note, we should close the sidebar only if we're dropping items
            // from library, not when pasting from clipboard. Alas.
            openSidebar: this.state.openSidebar && this.device.editor.canFitSidebar && jotaiStore.get(isSidebarDockedAtom) ? this.state.openSidebar : null,
            ...selectGroupsForSelectedElements(
              {
                editingGroupId: null,
                selectedElementIds: nextElementsToSelect.reduce(
                  (acc, element) => {
                    if (!isBoundToContainer(element)) {
                      acc[element.id] = true;
                    }
                    return acc;
                  },
                  {}
                )
              },
              this.scene.getNonDeletedElements(),
              this.state,
              this
            )
          },
          () => {
            if (opts.files) {
              this.addNewImagesToImageCache();
            }
          }
        );
        this.setActiveTool({ type: "selection" });
        if (opts.fitToContent) {
          this.scrollToContent(newElements, {
            fitToContent: true
          });
        }
      };
      // TODO rewrite this to paste both text & images at the same time if
      // pasted data contains both
      async addElementsFromMixedContentPaste(mixedContent, {
        isPlainPaste,
        sceneX,
        sceneY
      }) {
        if (!isPlainPaste && mixedContent.some((node) => node.type === "imageUrl") && this.isToolSupported("image")) {
          const imageURLs = mixedContent.filter((node) => node.type === "imageUrl").map((node) => node.value);
          const responses = await Promise.all(
            imageURLs.map(async (url) => {
              try {
                return { file: await ImageURLToFile(url) };
              } catch (error2) {
                return { errorMessage: error2.message };
              }
            })
          );
          let y = sceneY;
          let firstImageYOffsetDone = false;
          const nextSelectedIds = {};
          for (const response of responses) {
            if (response.file) {
              const imageElement = this.createImageElement({
                sceneX,
                sceneY: y
              });
              const initializedImageElement = await this.insertImageElement(
                imageElement,
                response.file
              );
              if (initializedImageElement) {
                if (!firstImageYOffsetDone) {
                  firstImageYOffsetDone = true;
                  y -= initializedImageElement.height / 2;
                }
                mutateElement(initializedImageElement, { y }, false);
                y = imageElement.y + imageElement.height + 25;
                nextSelectedIds[imageElement.id] = true;
              }
            }
          }
          this.setState({
            selectedElementIds: makeNextSelectedElementIds(
              nextSelectedIds,
              this.state
            )
          });
          const error = responses.find((response) => !!response.errorMessage);
          if (error && error.errorMessage) {
            this.setState({ errorMessage: error.errorMessage });
          }
        } else {
          const textNodes = mixedContent.filter((node) => node.type === "text");
          if (textNodes.length) {
            this.addTextFromPaste(
              textNodes.map((node) => node.value).join("\n\n"),
              isPlainPaste
            );
          }
        }
      }
      addTextFromPaste(text, isPlainPaste = false) {
        const { x, y } = viewportCoordsToSceneCoords(
          {
            clientX: this.lastViewportPosition.x,
            clientY: this.lastViewportPosition.y
          },
          this.state
        );
        const textElementProps = {
          x,
          y,
          strokeColor: this.state.currentItemStrokeColor,
          backgroundColor: this.state.currentItemBackgroundColor,
          fillStyle: this.state.currentItemFillStyle,
          strokeWidth: this.state.currentItemStrokeWidth,
          strokeStyle: this.state.currentItemStrokeStyle,
          roundness: null,
          roughness: this.state.currentItemRoughness,
          opacity: this.state.currentItemOpacity,
          text,
          fontSize: this.state.currentItemFontSize,
          fontFamily: this.state.currentItemFontFamily,
          textAlign: this.state.currentItemTextAlign,
          verticalAlign: DEFAULT_VERTICAL_ALIGN,
          locked: false
        };
        const LINE_GAP = 10;
        let currentY = y;
        const lines = isPlainPaste ? [text] : text.split("\n");
        const textElements = lines.reduce(
          (acc, line, idx) => {
            const text2 = line.trim();
            const lineHeight = getDefaultLineHeight(textElementProps.fontFamily);
            if (text2.length) {
              const topLayerFrame = this.getTopLayerFrameAtSceneCoords({
                x,
                y: currentY
              });
              const element = newTextElement({
                ...textElementProps,
                x,
                y: currentY,
                text: text2,
                lineHeight,
                frameId: topLayerFrame ? topLayerFrame.id : null
              });
              acc.push(element);
              currentY += element.height + LINE_GAP;
            } else {
              const prevLine = lines[idx - 1]?.trim();
              if (prevLine) {
                currentY += getLineHeightInPx(textElementProps.fontSize, lineHeight) + LINE_GAP;
              }
            }
            return acc;
          },
          []
        );
        if (textElements.length === 0) {
          return;
        }
        const frameId = textElements[0].frameId;
        if (frameId) {
          this.scene.insertElementsAtIndex(
            textElements,
            this.scene.getElementIndex(frameId)
          );
        } else {
          this.scene.replaceAllElements([
            ...this.scene.getElementsIncludingDeleted(),
            ...textElements
          ]);
        }
        this.setState({
          selectedElementIds: makeNextSelectedElementIds(
            Object.fromEntries(textElements.map((el) => [el.id, true])),
            this.state
          )
        });
        if (!isPlainPaste && textElements.length > 1 && PLAIN_PASTE_TOAST_SHOWN === false && !this.device.editor.isMobile) {
          this.setToast({
            message: t("toast.pasteAsSingleElement", {
              shortcut: getShortcutKey("CtrlOrCmd+Shift+V")
            }),
            duration: 5e3
          });
          PLAIN_PASTE_TOAST_SHOWN = true;
        }
        this.history.resumeRecording();
      }
      setAppState = (state, callback) => {
        this.setState(state, callback);
      };
      removePointer = (event) => {
        if (touchTimeout) {
          this.resetContextMenuTimer();
        }
        gesture.pointers.delete(event.pointerId);
      };
      toggleLock = (source = "ui") => {
        if (!this.state.activeTool.locked) {
          trackEvent(
            "toolbar",
            "toggleLock",
            `${source} (${this.device.editor.isMobile ? "mobile" : "desktop"})`
          );
        }
        this.setState((prevState) => {
          return {
            activeTool: {
              ...prevState.activeTool,
              ...updateActiveTool(
                this.state,
                prevState.activeTool.locked ? { type: "selection" } : prevState.activeTool
              ),
              locked: !prevState.activeTool.locked
            }
          };
        });
      };
      updateFrameRendering = (opts) => {
        this.setState((prevState) => {
          const next = typeof opts === "function" ? opts(prevState.frameRendering) : opts;
          return {
            frameRendering: {
              enabled: next?.enabled ?? prevState.frameRendering.enabled,
              clip: next?.clip ?? prevState.frameRendering.clip,
              name: next?.name ?? prevState.frameRendering.name,
              outline: next?.outline ?? prevState.frameRendering.outline
            }
          };
        });
      };
      togglePenMode = (force) => {
        this.setState((prevState) => {
          return {
            penMode: force ?? !prevState.penMode,
            penDetected: true
          };
        });
      };
      onHandToolToggle = () => {
        this.actionManager.executeAction(actionToggleHandTool);
      };
      /**
       * Zooms on canvas viewport center
       */
      zoomCanvas = (value) => {
        this.setState({
          ...getStateForZoom(
            {
              viewportX: this.state.width / 2 + this.state.offsetLeft,
              viewportY: this.state.height / 2 + this.state.offsetTop,
              nextZoom: getNormalizedZoom(value)
            },
            this.state
          )
        });
      };
      cancelInProgressAnimation = null;
      scrollToContent = (target = this.scene.getNonDeletedElements(), opts) => {
        this.cancelInProgressAnimation?.();
        const targetElements = Array.isArray(target) ? target : [target];
        let zoom = this.state.zoom;
        let scrollX = this.state.scrollX;
        let scrollY = this.state.scrollY;
        if (opts?.fitToContent || opts?.fitToViewport) {
          const { appState } = zoomToFit({
            targetElements,
            appState: this.state,
            fitToViewport: !!opts?.fitToViewport,
            viewportZoomFactor: opts?.viewportZoomFactor
          });
          zoom = appState.zoom;
          scrollX = appState.scrollX;
          scrollY = appState.scrollY;
        } else {
          const scroll = calculateScrollCenter(targetElements, this.state);
          scrollX = scroll.scrollX;
          scrollY = scroll.scrollY;
        }
        if (opts?.animate) {
          const origScrollX = this.state.scrollX;
          const origScrollY = this.state.scrollY;
          const origZoom = this.state.zoom.value;
          const cancel = easeToValuesRAF({
            fromValues: {
              scrollX: origScrollX,
              scrollY: origScrollY,
              zoom: origZoom
            },
            toValues: { scrollX, scrollY, zoom: zoom.value },
            interpolateValue: (from3, to, progress, key) => {
              if (key === "zoom") {
                return from3 * Math.pow(to / from3, easeOut(progress));
              }
              return void 0;
            },
            onStep: ({ scrollX: scrollX2, scrollY: scrollY2, zoom: zoom2 }) => {
              this.setState({
                scrollX: scrollX2,
                scrollY: scrollY2,
                zoom: { value: zoom2 }
              });
            },
            onStart: () => {
              this.setState({ shouldCacheIgnoreZoom: true });
            },
            onEnd: () => {
              this.setState({ shouldCacheIgnoreZoom: false });
            },
            onCancel: () => {
              this.setState({ shouldCacheIgnoreZoom: false });
            },
            duration: opts?.duration ?? 500
          });
          this.cancelInProgressAnimation = () => {
            cancel();
            this.cancelInProgressAnimation = null;
          };
        } else {
          this.setState({ scrollX, scrollY, zoom });
        }
      };
      maybeUnfollowRemoteUser = () => {
        if (this.state.userToFollow) {
          this.setState({ userToFollow: null });
        }
      };
      /** use when changing scrollX/scrollY/zoom based on user interaction */
      translateCanvas = (state) => {
        this.cancelInProgressAnimation?.();
        this.maybeUnfollowRemoteUser();
        this.setState(state);
      };
      setToast = (toast) => {
        this.setState({ toast });
      };
      restoreFileFromShare = async () => {
        try {
          const webShareTargetCache = await caches.open("web-share-target");
          const response = await webShareTargetCache.match("shared-file");
          if (response) {
            const blob = await response.blob();
            const file2 = new File([blob], blob.name || "", { type: blob.type });
            this.loadFileToCanvas(file2, null);
            await webShareTargetCache.delete("shared-file");
            window.history.replaceState(null, APP_NAME, window.location.pathname);
          }
        } catch (error) {
          this.setState({ errorMessage: error.message });
        }
      };
      /** adds supplied files to existing files in the appState */
      addFiles = withBatchedUpdates(
        (files) => {
          const filesMap = files.reduce((acc, fileData) => {
            acc.set(fileData.id, fileData);
            return acc;
          }, /* @__PURE__ */ new Map());
          this.files = { ...this.files, ...Object.fromEntries(filesMap) };
          this.scene.getNonDeletedElements().forEach((element) => {
            if (isInitializedImageElement(element) && filesMap.has(element.fileId)) {
              this.imageCache.delete(element.fileId);
              ShapeCache.delete(element);
            }
          });
          this.scene.informMutation();
          this.addNewImagesToImageCache();
        }
      );
      updateScene = withBatchedUpdates(
        (sceneData) => {
          if (sceneData.commitToHistory) {
            this.history.resumeRecording();
          }
          if (sceneData.appState) {
            this.setState(sceneData.appState);
          }
          if (sceneData.elements) {
            this.scene.replaceAllElements(sceneData.elements);
          }
          if (sceneData.collaborators) {
            this.setState({ collaborators: sceneData.collaborators });
          }
        }
      );
      onSceneUpdated = () => {
        this.setState({});
      };
      /**
       * @returns whether the menu was toggled on or off
       */
      toggleSidebar = ({
        name,
        tab,
        force
      }) => {
        let nextName;
        if (force === void 0) {
          nextName = this.state.openSidebar?.name === name ? null : name;
        } else {
          nextName = force ? name : null;
        }
        this.setState({ openSidebar: nextName ? { name: nextName, tab } : null });
        return !!nextName;
      };
      updateCurrentCursorPosition = withBatchedUpdates(
        (event) => {
          this.lastViewportPosition.x = event.clientX;
          this.lastViewportPosition.y = event.clientY;
        }
      );
      // Input handling
      onKeyDown = withBatchedUpdates(
        (event) => {
          if ("Proxy" in window && (!event.shiftKey && /^[A-Z]$/.test(event.key) || event.shiftKey && /^[a-z]$/.test(event.key))) {
            event = new Proxy(event, {
              get(ev, prop) {
                const value = ev[prop];
                if (typeof value === "function") {
                  return value.bind(ev);
                }
                return prop === "key" ? (
                  // CapsLock inverts capitalization based on ShiftKey, so invert
                  // it back
                  event.shiftKey ? ev.key.toUpperCase() : ev.key.toLowerCase()
                ) : value;
              }
            });
          }
          if (event[KEYS.CTRL_OR_CMD] && event.key.toLowerCase() === KEYS.V) {
            IS_PLAIN_PASTE = event.shiftKey;
            clearTimeout(IS_PLAIN_PASTE_TIMER);
            IS_PLAIN_PASTE_TIMER = window.setTimeout(() => {
              IS_PLAIN_PASTE = false;
            }, 100);
          }
          if (event[KEYS.CTRL_OR_CMD] && isWritableElement(event.target)) {
            if (event.code === CODES.MINUS || event.code === CODES.EQUAL) {
              event.preventDefault();
              return;
            }
          }
          if (
            // inside an input
            isWritableElement(event.target) && // unless pressing escape (finalize action)
            event.key !== KEYS.ESCAPE || // or unless using arrows (to move between buttons)
            isArrowKey(event.key) && isInputLike(event.target)
          ) {
            return;
          }
          if (event.key === KEYS.QUESTION_MARK) {
            this.setState({
              openDialog: { name: "help" }
            });
            return;
          } else if (event.key.toLowerCase() === KEYS.E && event.shiftKey && event[KEYS.CTRL_OR_CMD]) {
            event.preventDefault();
            this.setState({ openDialog: { name: "imageExport" } });
            return;
          }
          if (event.key === KEYS.PAGE_UP || event.key === KEYS.PAGE_DOWN) {
            let offset2 = (event.shiftKey ? this.state.width : this.state.height) / this.state.zoom.value;
            if (event.key === KEYS.PAGE_DOWN) {
              offset2 = -offset2;
            }
            if (event.shiftKey) {
              this.translateCanvas((state) => ({
                scrollX: state.scrollX + offset2
              }));
            } else {
              this.translateCanvas((state) => ({
                scrollY: state.scrollY + offset2
              }));
            }
          }
          if (this.actionManager.handleKeyDown(event)) {
            return;
          }
          if (this.state.viewModeEnabled) {
            return;
          }
          if (event[KEYS.CTRL_OR_CMD] && this.state.isBindingEnabled) {
            this.setState({ isBindingEnabled: false });
          }
          if (isArrowKey(event.key)) {
            const step = this.state.gridSize && (event.shiftKey ? ELEMENT_TRANSLATE_AMOUNT : this.state.gridSize) || (event.shiftKey ? ELEMENT_SHIFT_TRANSLATE_AMOUNT : ELEMENT_TRANSLATE_AMOUNT);
            let offsetX = 0;
            let offsetY = 0;
            if (event.key === KEYS.ARROW_LEFT) {
              offsetX = -step;
            } else if (event.key === KEYS.ARROW_RIGHT) {
              offsetX = step;
            } else if (event.key === KEYS.ARROW_UP) {
              offsetY = -step;
            } else if (event.key === KEYS.ARROW_DOWN) {
              offsetY = step;
            }
            const selectedElements = this.scene.getSelectedElements({
              selectedElementIds: this.state.selectedElementIds,
              includeBoundTextElement: true,
              includeElementsInFrames: true
            });
            selectedElements.forEach((element) => {
              mutateElement(element, {
                x: element.x + offsetX,
                y: element.y + offsetY
              });
              updateBoundElements(element, this.scene.getNonDeletedElementsMap(), {
                simultaneouslyUpdated: selectedElements
              });
            });
            this.maybeSuggestBindingForAll(selectedElements);
            event.preventDefault();
          } else if (event.key === KEYS.ENTER) {
            const selectedElements = this.scene.getSelectedElements(this.state);
            if (selectedElements.length === 1) {
              const selectedElement = selectedElements[0];
              if (event[KEYS.CTRL_OR_CMD]) {
                if (isLinearElement(selectedElement)) {
                  if (!this.state.editingLinearElement || this.state.editingLinearElement.elementId !== selectedElements[0].id) {
                    this.history.resumeRecording();
                    this.setState({
                      editingLinearElement: new LinearElementEditor(
                        selectedElement
                      )
                    });
                  }
                }
              } else if (isTextElement(selectedElement) || isValidTextContainer(selectedElement)) {
                let container;
                if (!isTextElement(selectedElement)) {
                  container = selectedElement;
                }
                const midPoint = getContainerCenter(
                  selectedElement,
                  this.state,
                  this.scene.getNonDeletedElementsMap()
                );
                const sceneX = midPoint.x;
                const sceneY = midPoint.y;
                this.startTextEditing({
                  sceneX,
                  sceneY,
                  container
                });
                event.preventDefault();
                return;
              } else if (isFrameLikeElement(selectedElement)) {
                this.setState({
                  editingFrame: selectedElement.id
                });
              }
            }
          } else if (!event.ctrlKey && !event.altKey && !event.metaKey && this.state.draggingElement === null) {
            const shape = findShapeByKey(event.key);
            if (shape) {
              if (this.state.activeTool.type !== shape) {
                trackEvent(
                  "toolbar",
                  shape,
                  `keyboard (${this.device.editor.isMobile ? "mobile" : "desktop"})`
                );
              }
              this.setActiveTool({ type: shape });
              event.stopPropagation();
            } else if (event.key === KEYS.Q) {
              this.toggleLock("keyboard");
              event.stopPropagation();
            }
          }
          if (event.key === KEYS.SPACE && gesture.pointers.size === 0) {
            isHoldingSpace = true;
            setCursor(this.interactiveCanvas, CURSOR_TYPE.GRAB);
            event.preventDefault();
          }
          if ((event.key === KEYS.G || event.key === KEYS.S) && !event.altKey && !event[KEYS.CTRL_OR_CMD]) {
            const selectedElements = this.scene.getSelectedElements(this.state);
            if (this.state.activeTool.type === "selection" && !selectedElements.length) {
              return;
            }
            if (event.key === KEYS.G && (hasBackground(this.state.activeTool.type) || selectedElements.some((element) => hasBackground(element.type)))) {
              this.setState({ openPopup: "elementBackground" });
              event.stopPropagation();
            }
            if (event.key === KEYS.S) {
              this.setState({ openPopup: "elementStroke" });
              event.stopPropagation();
            }
          }
          if (event.key === KEYS.K && !event.altKey && !event[KEYS.CTRL_OR_CMD]) {
            if (this.state.activeTool.type === "laser") {
              this.setActiveTool({ type: "selection" });
            } else {
              this.setActiveTool({ type: "laser" });
            }
            return;
          }
          if (event[KEYS.CTRL_OR_CMD] && (event.key === KEYS.BACKSPACE || event.key === KEYS.DELETE)) {
            jotaiStore.set(activeConfirmDialogAtom, "clearCanvas");
          }
          const lowerCased = event.key.toLocaleLowerCase();
          const isPickingStroke = lowerCased === KEYS.S && event.shiftKey;
          const isPickingBackground = event.key === KEYS.I || lowerCased === KEYS.G && event.shiftKey;
          if (isPickingStroke || isPickingBackground) {
            this.openEyeDropper({
              type: isPickingStroke ? "stroke" : "background"
            });
          }
        }
      );
      onWheel = withBatchedUpdates((event) => {
        if (!(event.target instanceof HTMLCanvasElement) && event.ctrlKey) {
          event.preventDefault();
        }
      });
      onKeyUp = withBatchedUpdates((event) => {
        if (event.key === KEYS.SPACE) {
          if (this.state.viewModeEnabled) {
            setCursor(this.interactiveCanvas, CURSOR_TYPE.GRAB);
          } else if (this.state.activeTool.type === "selection") {
            resetCursor(this.interactiveCanvas);
          } else {
            setCursorForShape(this.interactiveCanvas, this.state);
            this.setState({
              selectedElementIds: makeNextSelectedElementIds({}, this.state),
              selectedGroupIds: {},
              editingGroupId: null,
              activeEmbeddable: null
            });
          }
          isHoldingSpace = false;
        }
        if (!event[KEYS.CTRL_OR_CMD] && !this.state.isBindingEnabled) {
          this.setState({ isBindingEnabled: true });
        }
        if (isArrowKey(event.key)) {
          const selectedElements = this.scene.getSelectedElements(this.state);
          const elementsMap = this.scene.getNonDeletedElementsMap();
          isBindingEnabled(this.state) ? bindOrUnbindSelectedElements(
            selectedElements,
            this.scene.getNonDeletedElements(),
            elementsMap
          ) : unbindLinearElements(selectedElements, elementsMap);
          this.setState({ suggestedBindings: [] });
        }
      });
      // We purposely widen the `tool` type so this helper can be called with
      // any tool without having to type check it
      isToolSupported = (tool) => {
        return this.props.UIOptions.tools?.[tool] !== false;
      };
      setActiveTool = (tool) => {
        if (!this.isToolSupported(tool.type)) {
          console.warn(
            `"${tool.type}" tool is disabled via "UIOptions.canvasActions.tools.${tool.type}"`
          );
          return;
        }
        const nextActiveTool = updateActiveTool(this.state, tool);
        if (nextActiveTool.type === "hand") {
          setCursor(this.interactiveCanvas, CURSOR_TYPE.GRAB);
        } else if (!isHoldingSpace) {
          setCursorForShape(this.interactiveCanvas, this.state);
        }
        if (isToolIcon(document.activeElement)) {
          this.focusContainer();
        }
        if (!isLinearElementType(nextActiveTool.type)) {
          this.setState({ suggestedBindings: [] });
        }
        if (nextActiveTool.type === "image") {
          this.onImageAction({
            insertOnCanvasDirectly: (tool.type === "image" && tool.insertOnCanvasDirectly) ?? false
          });
        }
        this.setState((prevState) => {
          const commonResets = {
            snapLines: prevState.snapLines.length ? [] : prevState.snapLines,
            originSnapOffset: null,
            activeEmbeddable: null
          };
          if (nextActiveTool.type !== "selection") {
            return {
              ...prevState,
              activeTool: nextActiveTool,
              selectedElementIds: makeNextSelectedElementIds({}, prevState),
              selectedGroupIds: makeNextSelectedElementIds({}, prevState),
              editingGroupId: null,
              multiElement: null,
              ...commonResets
            };
          }
          return {
            ...prevState,
            activeTool: nextActiveTool,
            ...commonResets
          };
        });
      };
      setOpenDialog = (dialogType) => {
        this.setState({ openDialog: dialogType });
      };
      setCursor = (cursor) => {
        setCursor(this.interactiveCanvas, cursor);
      };
      resetCursor = () => {
        resetCursor(this.interactiveCanvas);
      };
      /**
       * returns whether user is making a gesture with >= 2 fingers (points)
       * on o touch screen (not on a trackpad). Currently only relates to Darwin
       * (iOS/iPadOS,MacOS), but may work on other devices in the future if
       * GestureEvent is standardized.
       */
      isTouchScreenMultiTouchGesture = () => {
        return gesture.pointers.size >= 2;
      };
      getName = () => {
        return this.state.name || this.props.name || `${t("labels.untitled")}-${getDateTime()}`;
      };
      // fires only on Safari
      onGestureStart = withBatchedUpdates((event) => {
        event.preventDefault();
        if (this.isTouchScreenMultiTouchGesture()) {
          this.setState({
            selectedElementIds: makeNextSelectedElementIds({}, this.state),
            activeEmbeddable: null
          });
        }
        gesture.initialScale = this.state.zoom.value;
      });
      // fires only on Safari
      onGestureChange = withBatchedUpdates((event) => {
        event.preventDefault();
        if (this.isTouchScreenMultiTouchGesture()) {
          return;
        }
        const initialScale = gesture.initialScale;
        if (initialScale) {
          this.setState((state) => ({
            ...getStateForZoom(
              {
                viewportX: this.lastViewportPosition.x,
                viewportY: this.lastViewportPosition.y,
                nextZoom: getNormalizedZoom(initialScale * event.scale)
              },
              state
            )
          }));
        }
      });
      // fires only on Safari
      onGestureEnd = withBatchedUpdates((event) => {
        event.preventDefault();
        if (this.isTouchScreenMultiTouchGesture()) {
          this.setState({
            previousSelectedElementIds: {},
            selectedElementIds: makeNextSelectedElementIds(
              this.state.previousSelectedElementIds,
              this.state
            )
          });
        }
        gesture.initialScale = null;
      });
      handleTextWysiwyg(element, {
        isExistingElement = false
      }) {
        const elementsMap = this.scene.getElementsMapIncludingDeleted();
        const updateElement = (text, originalText, isDeleted) => {
          this.scene.replaceAllElements([
            // Not sure why we include deleted elements as well hence using deleted elements map
            ...this.scene.getElementsIncludingDeleted().map((_element) => {
              if (_element.id === element.id && isTextElement(_element)) {
                return updateTextElement(
                  _element,
                  getContainerElement(_element, elementsMap),
                  elementsMap,
                  {
                    text,
                    isDeleted,
                    originalText
                  }
                );
              }
              return _element;
            })
          ]);
        };
        textWysiwyg({
          id: element.id,
          canvas: this.canvas,
          getViewportCoords: (x, y) => {
            const { x: viewportX, y: viewportY } = sceneCoordsToViewportCoords(
              {
                sceneX: x,
                sceneY: y
              },
              this.state
            );
            return [
              viewportX - this.state.offsetLeft,
              viewportY - this.state.offsetTop
            ];
          },
          onChange: withBatchedUpdates((text) => {
            updateElement(text, text, false);
            if (isNonDeletedElement(element)) {
              updateBoundElements(element, elementsMap);
            }
          }),
          onSubmit: withBatchedUpdates(({ text, viaKeyboard, originalText }) => {
            const isDeleted = !text.trim();
            updateElement(text, originalText, isDeleted);
            if (!isDeleted && viaKeyboard) {
              const elementIdToSelect = element.containerId ? element.containerId : element.id;
              this.setState((prevState) => ({
                selectedElementIds: makeNextSelectedElementIds(
                  {
                    ...prevState.selectedElementIds,
                    [elementIdToSelect]: true
                  },
                  prevState
                )
              }));
            }
            if (isDeleted) {
              fixBindingsAfterDeletion(this.scene.getNonDeletedElements(), [
                element
              ]);
            }
            if (!isDeleted || isExistingElement) {
              this.history.resumeRecording();
            }
            this.setState({
              draggingElement: null,
              editingElement: null
            });
            if (this.state.activeTool.locked) {
              setCursorForShape(this.interactiveCanvas, this.state);
            }
            this.focusContainer();
          }),
          element,
          excalidrawContainer: this.excalidrawContainerRef.current,
          app: this
        });
        this.deselectElements();
        updateElement(element.text, element.originalText, false);
      }
      deselectElements() {
        this.setState({
          selectedElementIds: makeNextSelectedElementIds({}, this.state),
          selectedGroupIds: {},
          editingGroupId: null,
          activeEmbeddable: null
        });
      }
      getTextElementAtPosition(x, y) {
        const element = this.getElementAtPosition(x, y, {
          includeBoundTextElement: true
        });
        if (element && isTextElement(element) && !element.isDeleted) {
          return element;
        }
        return null;
      }
      getElementAtPosition(x, y, opts) {
        const allHitElements = this.getElementsAtPosition(
          x,
          y,
          opts?.includeBoundTextElement,
          opts?.includeLockedElements
        );
        if (allHitElements.length > 1) {
          if (opts?.preferSelected) {
            for (let index = allHitElements.length - 1; index > -1; index--) {
              if (this.state.selectedElementIds[allHitElements[index].id]) {
                return allHitElements[index];
              }
            }
          }
          const elementWithHighestZIndex = allHitElements[allHitElements.length - 1];
          return isHittingElementBoundingBoxWithoutHittingElement(
            elementWithHighestZIndex,
            this.state,
            this.frameNameBoundsCache,
            x,
            y,
            this.scene.getNonDeletedElementsMap()
          ) ? allHitElements[allHitElements.length - 2] : elementWithHighestZIndex;
        }
        if (allHitElements.length === 1) {
          return allHitElements[0];
        }
        return null;
      }
      getElementsAtPosition(x, y, includeBoundTextElement = false, includeLockedElements = false) {
        const elements = includeBoundTextElement && includeLockedElements ? this.scene.getNonDeletedElements() : this.scene.getNonDeletedElements().filter(
          (element) => (includeLockedElements || !element.locked) && (includeBoundTextElement || !(isTextElement(element) && element.containerId))
        );
        const elementsMap = this.scene.getNonDeletedElementsMap();
        return getElementsAtPosition(
          elements,
          (element) => hitTest(
            element,
            this.state,
            this.frameNameBoundsCache,
            x,
            y,
            elementsMap
          )
        ).filter((element) => {
          const containingFrame = getContainingFrame(element);
          return containingFrame && this.state.frameRendering.enabled && this.state.frameRendering.clip ? isCursorInFrame({ x, y }, containingFrame, elementsMap) : true;
        });
      }
      startTextEditing = ({
        sceneX,
        sceneY,
        insertAtParentCenter = true,
        container
      }) => {
        let shouldBindToContainer = false;
        let parentCenterPosition = insertAtParentCenter && this.getTextWysiwygSnappedToCenterPosition(
          sceneX,
          sceneY,
          this.state,
          container
        );
        if (container && parentCenterPosition) {
          const boundTextElementToContainer = getBoundTextElement(
            container,
            this.scene.getNonDeletedElementsMap()
          );
          if (!boundTextElementToContainer) {
            shouldBindToContainer = true;
          }
        }
        let existingTextElement = null;
        const selectedElements = this.scene.getSelectedElements(this.state);
        if (selectedElements.length === 1) {
          if (isTextElement(selectedElements[0])) {
            existingTextElement = selectedElements[0];
          } else if (container) {
            existingTextElement = getBoundTextElement(
              selectedElements[0],
              this.scene.getNonDeletedElementsMap()
            );
          } else {
            existingTextElement = this.getTextElementAtPosition(sceneX, sceneY);
          }
        } else {
          existingTextElement = this.getTextElementAtPosition(sceneX, sceneY);
        }
        const fontFamily = existingTextElement?.fontFamily || this.state.currentItemFontFamily;
        const lineHeight = existingTextElement?.lineHeight || getDefaultLineHeight(fontFamily);
        const fontSize = this.state.currentItemFontSize;
        if (!existingTextElement && shouldBindToContainer && container && !isArrowElement(container)) {
          const fontString = {
            fontSize,
            fontFamily
          };
          const minWidth = getApproxMinLineWidth(
            getFontString(fontString),
            lineHeight
          );
          const minHeight = getApproxMinLineHeight(fontSize, lineHeight);
          const newHeight = Math.max(container.height, minHeight);
          const newWidth = Math.max(container.width, minWidth);
          mutateElement(container, { height: newHeight, width: newWidth });
          sceneX = container.x + newWidth / 2;
          sceneY = container.y + newHeight / 2;
          if (parentCenterPosition) {
            parentCenterPosition = this.getTextWysiwygSnappedToCenterPosition(
              sceneX,
              sceneY,
              this.state,
              container
            );
          }
        }
        const topLayerFrame = this.getTopLayerFrameAtSceneCoords({
          x: sceneX,
          y: sceneY
        });
        const element = existingTextElement ? existingTextElement : newTextElement({
          x: parentCenterPosition ? parentCenterPosition.elementCenterX : sceneX,
          y: parentCenterPosition ? parentCenterPosition.elementCenterY : sceneY,
          strokeColor: this.state.currentItemStrokeColor,
          backgroundColor: this.state.currentItemBackgroundColor,
          fillStyle: this.state.currentItemFillStyle,
          strokeWidth: this.state.currentItemStrokeWidth,
          strokeStyle: this.state.currentItemStrokeStyle,
          roughness: this.state.currentItemRoughness,
          opacity: this.state.currentItemOpacity,
          text: "",
          fontSize,
          fontFamily,
          textAlign: parentCenterPosition ? "center" : this.state.currentItemTextAlign,
          verticalAlign: parentCenterPosition ? VERTICAL_ALIGN.MIDDLE : DEFAULT_VERTICAL_ALIGN,
          containerId: shouldBindToContainer ? container?.id : void 0,
          groupIds: container?.groupIds ?? [],
          lineHeight,
          angle: container?.angle ?? 0,
          frameId: topLayerFrame ? topLayerFrame.id : null
        });
        if (!existingTextElement && shouldBindToContainer && container) {
          mutateElement(container, {
            boundElements: (container.boundElements || []).concat({
              type: "text",
              id: element.id
            })
          });
        }
        this.setState({ editingElement: element });
        if (!existingTextElement) {
          if (container && shouldBindToContainer) {
            const containerIndex = this.scene.getElementIndex(container.id);
            this.scene.insertElementAtIndex(element, containerIndex + 1);
          } else {
            this.scene.addNewElement(element);
          }
        }
        this.setState({
          editingElement: element
        });
        this.handleTextWysiwyg(element, {
          isExistingElement: !!existingTextElement
        });
      };
      handleCanvasDoubleClick = (event) => {
        if (this.state.multiElement) {
          return;
        }
        if (this.state.activeTool.type !== "selection") {
          return;
        }
        const selectedElements = this.scene.getSelectedElements(this.state);
        if (selectedElements.length === 1 && isLinearElement(selectedElements[0])) {
          if (event[KEYS.CTRL_OR_CMD] && (!this.state.editingLinearElement || this.state.editingLinearElement.elementId !== selectedElements[0].id)) {
            this.history.resumeRecording();
            this.setState({
              editingLinearElement: new LinearElementEditor(selectedElements[0])
            });
            return;
          } else if (this.state.editingLinearElement && this.state.editingLinearElement.elementId === selectedElements[0].id) {
            return;
          }
        }
        resetCursor(this.interactiveCanvas);
        let { x: sceneX, y: sceneY } = viewportCoordsToSceneCoords(
          event,
          this.state
        );
        const selectedGroupIds = getSelectedGroupIds(this.state);
        if (selectedGroupIds.length > 0) {
          const hitElement = this.getElementAtPosition(sceneX, sceneY);
          const selectedGroupId = hitElement && getSelectedGroupIdForElement(hitElement, this.state.selectedGroupIds);
          if (selectedGroupId) {
            this.setState((prevState) => ({
              ...prevState,
              ...selectGroupsForSelectedElements(
                {
                  editingGroupId: selectedGroupId,
                  selectedElementIds: { [hitElement.id]: true }
                },
                this.scene.getNonDeletedElements(),
                prevState,
                this
              )
            }));
            return;
          }
        }
        resetCursor(this.interactiveCanvas);
        if (!event[KEYS.CTRL_OR_CMD] && !this.state.viewModeEnabled) {
          const hitElement = this.getElementAtPosition(sceneX, sceneY);
          if (isIframeLikeElement(hitElement)) {
            this.setState({
              activeEmbeddable: { element: hitElement, state: "active" }
            });
            return;
          }
          const container = getTextBindableContainerAtPosition(
            this.scene.getNonDeletedElements(),
            this.state,
            sceneX,
            sceneY,
            this.scene.getNonDeletedElementsMap()
          );
          if (container) {
            if (hasBoundTextElement(container) || !isTransparent(container.backgroundColor) || isHittingElementNotConsideringBoundingBox(
              container,
              this.state,
              this.frameNameBoundsCache,
              [sceneX, sceneY],
              this.scene.getNonDeletedElementsMap()
            )) {
              const midPoint = getContainerCenter(
                container,
                this.state,
                this.scene.getNonDeletedElementsMap()
              );
              sceneX = midPoint.x;
              sceneY = midPoint.y;
            }
          }
          this.startTextEditing({
            sceneX,
            sceneY,
            insertAtParentCenter: !event.altKey,
            container
          });
        }
      };
      getElementLinkAtPosition = (scenePointer, hitElement) => {
        const elements = this.scene.getNonDeletedElements().slice().reverse();
        let hitElementIndex = Infinity;
        return elements.find((element, index) => {
          if (hitElement && element.id === hitElement.id) {
            hitElementIndex = index;
          }
          return element.link && index <= hitElementIndex && isPointHittingLink(
            element,
            this.scene.getNonDeletedElementsMap(),
            this.state,
            [scenePointer.x, scenePointer.y],
            this.device.editor.isMobile
          );
        });
      };
      redirectToLink = (event, isTouchScreen) => {
        const draggedDistance = distance2d(
          this.lastPointerDownEvent.clientX,
          this.lastPointerDownEvent.clientY,
          this.lastPointerUpEvent.clientX,
          this.lastPointerUpEvent.clientY
        );
        if (!this.hitLinkElement || // For touch screen allow dragging threshold else strict check
        isTouchScreen && draggedDistance > DRAGGING_THRESHOLD || !isTouchScreen && draggedDistance !== 0) {
          return;
        }
        const lastPointerDownCoords = viewportCoordsToSceneCoords(
          this.lastPointerDownEvent,
          this.state
        );
        const elementsMap = this.scene.getNonDeletedElementsMap();
        const lastPointerDownHittingLinkIcon = isPointHittingLink(
          this.hitLinkElement,
          elementsMap,
          this.state,
          [lastPointerDownCoords.x, lastPointerDownCoords.y],
          this.device.editor.isMobile
        );
        const lastPointerUpCoords = viewportCoordsToSceneCoords(
          this.lastPointerUpEvent,
          this.state
        );
        const lastPointerUpHittingLinkIcon = isPointHittingLink(
          this.hitLinkElement,
          elementsMap,
          this.state,
          [lastPointerUpCoords.x, lastPointerUpCoords.y],
          this.device.editor.isMobile
        );
        if (lastPointerDownHittingLinkIcon && lastPointerUpHittingLinkIcon) {
          let url = this.hitLinkElement.link;
          if (url) {
            url = normalizeLink(url);
            let customEvent;
            if (this.props.onLinkOpen) {
              customEvent = wrapEvent("excalidraw-link" /* EXCALIDRAW_LINK */, event.nativeEvent);
              this.props.onLinkOpen(
                {
                  ...this.hitLinkElement,
                  link: url
                },
                customEvent
              );
            }
            if (!customEvent?.defaultPrevented) {
              const target = isLocalLink(url) ? "_self" : "_blank";
              const newWindow = window.open(void 0, target);
              if (newWindow) {
                newWindow.opener = null;
                newWindow.location = url;
              }
            }
          }
        }
      };
      getTopLayerFrameAtSceneCoords = (sceneCoords) => {
        const elementsMap = this.scene.getNonDeletedElementsMap();
        const frames = this.scene.getNonDeletedFramesLikes().filter(
          (frame) => isCursorInFrame(sceneCoords, frame, elementsMap)
        );
        return frames.length ? frames[frames.length - 1] : null;
      };
      handleCanvasPointerMove = (event) => {
        this.savePointer(event.clientX, event.clientY, this.state.cursorButton);
        this.lastPointerMoveEvent = event.nativeEvent;
        if (gesture.pointers.has(event.pointerId)) {
          gesture.pointers.set(event.pointerId, {
            x: event.clientX,
            y: event.clientY
          });
        }
        const initialScale = gesture.initialScale;
        if (gesture.pointers.size === 2 && gesture.lastCenter && initialScale && gesture.initialDistance) {
          const center = getCenter(gesture.pointers);
          const deltaX = center.x - gesture.lastCenter.x;
          const deltaY = center.y - gesture.lastCenter.y;
          gesture.lastCenter = center;
          const distance3 = getDistance(Array.from(gesture.pointers.values()));
          const scaleFactor = this.state.activeTool.type === "freedraw" && this.state.penMode ? 1 : distance3 / gesture.initialDistance;
          const nextZoom = scaleFactor ? getNormalizedZoom(initialScale * scaleFactor) : this.state.zoom.value;
          this.setState((state) => {
            const zoomState = getStateForZoom(
              {
                viewportX: center.x,
                viewportY: center.y,
                nextZoom
              },
              state
            );
            this.translateCanvas({
              zoom: zoomState.zoom,
              scrollX: zoomState.scrollX + deltaX / nextZoom,
              scrollY: zoomState.scrollY + deltaY / nextZoom,
              shouldCacheIgnoreZoom: true
            });
          });
          this.resetShouldCacheIgnoreZoomDebounced();
        } else {
          gesture.lastCenter = gesture.initialDistance = gesture.initialScale = null;
        }
        if (isHoldingSpace || isPanning || isDraggingScrollBar || isHandToolActive(this.state)) {
          return;
        }
        const isPointerOverScrollBars = isOverScrollBars(
          currentScrollBars,
          event.clientX - this.state.offsetLeft,
          event.clientY - this.state.offsetTop
        );
        const isOverScrollBar = isPointerOverScrollBars.isOverEither;
        if (!this.state.draggingElement && !this.state.multiElement) {
          if (isOverScrollBar) {
            resetCursor(this.interactiveCanvas);
          } else {
            setCursorForShape(this.interactiveCanvas, this.state);
          }
        }
        const scenePointer = viewportCoordsToSceneCoords(event, this.state);
        const { x: scenePointerX, y: scenePointerY } = scenePointer;
        if (!this.state.draggingElement && isActiveToolNonLinearSnappable(this.state.activeTool.type)) {
          const { originOffset, snapLines } = getSnapLinesAtPointer(
            this.scene.getNonDeletedElements(),
            this.state,
            {
              x: scenePointerX,
              y: scenePointerY
            },
            event,
            this.scene.getNonDeletedElementsMap()
          );
          this.setState((prevState) => {
            const nextSnapLines = updateStable(prevState.snapLines, snapLines);
            const nextOriginOffset = prevState.originSnapOffset ? updateStable(prevState.originSnapOffset, originOffset) : originOffset;
            if (prevState.snapLines === nextSnapLines && prevState.originSnapOffset === nextOriginOffset) {
              return null;
            }
            return {
              snapLines: nextSnapLines,
              originSnapOffset: nextOriginOffset
            };
          });
        } else if (!this.state.draggingElement) {
          this.setState((prevState) => {
            if (prevState.snapLines.length) {
              return {
                snapLines: []
              };
            }
            return null;
          });
        }
        if (this.state.editingLinearElement && !this.state.editingLinearElement.isDragging) {
          const editingLinearElement = LinearElementEditor.handlePointerMove(
            event,
            scenePointerX,
            scenePointerY,
            this.state,
            this.scene.getNonDeletedElementsMap()
          );
          if (editingLinearElement && editingLinearElement !== this.state.editingLinearElement) {
            flushSync(() => {
              this.setState({
                editingLinearElement
              });
            });
          }
          if (editingLinearElement?.lastUncommittedPoint != null) {
            this.maybeSuggestBindingAtCursor(scenePointer);
          } else {
            flushSync(() => {
              this.setState({ suggestedBindings: [] });
            });
          }
        }
        if (isBindingElementType(this.state.activeTool.type)) {
          const { draggingElement } = this.state;
          if (isBindingElement(draggingElement, false)) {
            this.maybeSuggestBindingsForLinearElementAtCoords(
              draggingElement,
              [scenePointer],
              this.state.startBoundElement
            );
          } else {
            this.maybeSuggestBindingAtCursor(scenePointer);
          }
        }
        if (this.state.multiElement) {
          const { multiElement } = this.state;
          const { x: rx, y: ry } = multiElement;
          const { points, lastCommittedPoint } = multiElement;
          const lastPoint = points[points.length - 1];
          setCursorForShape(this.interactiveCanvas, this.state);
          if (lastPoint === lastCommittedPoint) {
            if (distance2d(
              scenePointerX - rx,
              scenePointerY - ry,
              lastPoint[0],
              lastPoint[1]
            ) >= LINE_CONFIRM_THRESHOLD) {
              mutateElement(multiElement, {
                points: [...points, [scenePointerX - rx, scenePointerY - ry]]
              });
            } else {
              setCursor(this.interactiveCanvas, CURSOR_TYPE.POINTER);
            }
          } else if (points.length > 2 && lastCommittedPoint && distance2d(
            scenePointerX - rx,
            scenePointerY - ry,
            lastCommittedPoint[0],
            lastCommittedPoint[1]
          ) < LINE_CONFIRM_THRESHOLD) {
            setCursor(this.interactiveCanvas, CURSOR_TYPE.POINTER);
            mutateElement(multiElement, {
              points: points.slice(0, -1)
            });
          } else {
            const [gridX, gridY] = getGridPoint(
              scenePointerX,
              scenePointerY,
              event[KEYS.CTRL_OR_CMD] ? null : this.state.gridSize
            );
            const [lastCommittedX, lastCommittedY] = multiElement?.lastCommittedPoint ?? [0, 0];
            let dxFromLastCommitted = gridX - rx - lastCommittedX;
            let dyFromLastCommitted = gridY - ry - lastCommittedY;
            if (shouldRotateWithDiscreteAngle(event)) {
              ({ width: dxFromLastCommitted, height: dyFromLastCommitted } = getLockedLinearCursorAlignSize(
                // actual coordinate of the last committed point
                lastCommittedX + rx,
                lastCommittedY + ry,
                // cursor-grid coordinate
                gridX,
                gridY
              ));
            }
            if (isPathALoop(points, this.state.zoom.value)) {
              setCursor(this.interactiveCanvas, CURSOR_TYPE.POINTER);
            }
            mutateElement(multiElement, {
              points: [
                ...points.slice(0, -1),
                [
                  lastCommittedX + dxFromLastCommitted,
                  lastCommittedY + dyFromLastCommitted
                ]
              ]
            });
          }
          return;
        }
        const hasDeselectedButton = Boolean(event.buttons);
        if (hasDeselectedButton || this.state.activeTool.type !== "selection" && this.state.activeTool.type !== "text" && this.state.activeTool.type !== "eraser") {
          return;
        }
        const elements = this.scene.getNonDeletedElements();
        const selectedElements = this.scene.getSelectedElements(this.state);
        if (selectedElements.length === 1 && !isOverScrollBar && !this.state.editingLinearElement) {
          const elementWithTransformHandleType = getElementWithTransformHandleType(
            elements,
            this.state,
            scenePointerX,
            scenePointerY,
            this.state.zoom,
            event.pointerType,
            this.scene.getNonDeletedElementsMap()
          );
          if (elementWithTransformHandleType && elementWithTransformHandleType.transformHandleType) {
            setCursor(
              this.interactiveCanvas,
              getCursorForResizingElement(elementWithTransformHandleType)
            );
            return;
          }
        } else if (selectedElements.length > 1 && !isOverScrollBar) {
          const transformHandleType = getTransformHandleTypeFromCoords(
            getCommonBounds(selectedElements),
            scenePointerX,
            scenePointerY,
            this.state.zoom,
            event.pointerType
          );
          if (transformHandleType) {
            setCursor(
              this.interactiveCanvas,
              getCursorForResizingElement({
                transformHandleType
              })
            );
            return;
          }
        }
        const hitElement = this.getElementAtPosition(
          scenePointer.x,
          scenePointer.y
        );
        this.hitLinkElement = this.getElementLinkAtPosition(
          scenePointer,
          hitElement
        );
        if (isEraserActive(this.state)) {
          return;
        }
        if (this.hitLinkElement && !this.state.selectedElementIds[this.hitLinkElement.id]) {
          setCursor(this.interactiveCanvas, CURSOR_TYPE.POINTER);
          showHyperlinkTooltip(
            this.hitLinkElement,
            this.state,
            this.scene.getNonDeletedElementsMap()
          );
        } else {
          hideHyperlinkToolip();
          if (hitElement && (hitElement.link || isEmbeddableElement(hitElement)) && this.state.selectedElementIds[hitElement.id] && !this.state.contextMenu && !this.state.showHyperlinkPopup) {
            this.setState({ showHyperlinkPopup: "info" });
          } else if (this.state.activeTool.type === "text") {
            setCursor(
              this.interactiveCanvas,
              isTextElement(hitElement) ? CURSOR_TYPE.TEXT : CURSOR_TYPE.CROSSHAIR
            );
          } else if (this.state.viewModeEnabled) {
            setCursor(this.interactiveCanvas, CURSOR_TYPE.GRAB);
          } else if (isOverScrollBar) {
            setCursor(this.interactiveCanvas, CURSOR_TYPE.AUTO);
          } else if (this.state.selectedLinearElement) {
            this.handleHoverSelectedLinearElement(
              this.state.selectedLinearElement,
              scenePointerX,
              scenePointerY
            );
          } else if (
            // if using cmd/ctrl, we're not dragging
            !event[KEYS.CTRL_OR_CMD]
          ) {
            if ((hitElement || this.isHittingCommonBoundingBoxOfSelectedElements(
              scenePointer,
              selectedElements
            )) && !hitElement?.locked) {
              if (hitElement && isIframeLikeElement(hitElement) && this.isIframeLikeElementCenter(
                hitElement,
                event,
                scenePointerX,
                scenePointerY
              )) {
                setCursor(this.interactiveCanvas, CURSOR_TYPE.POINTER);
                this.setState({
                  activeEmbeddable: { element: hitElement, state: "hover" }
                });
              } else {
                setCursor(this.interactiveCanvas, CURSOR_TYPE.MOVE);
                if (this.state.activeEmbeddable?.state === "hover") {
                  this.setState({ activeEmbeddable: null });
                }
              }
            }
          } else {
            setCursor(this.interactiveCanvas, CURSOR_TYPE.AUTO);
          }
        }
      };
      handleEraser = (event, pointerDownState, scenePointer) => {
        this.eraserTrail.addPointToPath(scenePointer.x, scenePointer.y);
        let didChange = false;
        const processedGroups = /* @__PURE__ */ new Set();
        const nonDeletedElements = this.scene.getNonDeletedElements();
        const processElements = (elements) => {
          for (const element of elements) {
            if (element.locked) {
              return;
            }
            if (event.altKey) {
              if (this.elementsPendingErasure.delete(element.id)) {
                didChange = true;
              }
            } else if (!this.elementsPendingErasure.has(element.id)) {
              didChange = true;
              this.elementsPendingErasure.add(element.id);
            }
            if (didChange && element.groupIds?.length) {
              const shallowestGroupId = element.groupIds.at(-1);
              if (!processedGroups.has(shallowestGroupId)) {
                processedGroups.add(shallowestGroupId);
                const elems = getElementsInGroup(
                  nonDeletedElements,
                  shallowestGroupId
                );
                for (const elem of elems) {
                  if (event.altKey) {
                    this.elementsPendingErasure.delete(elem.id);
                  } else {
                    this.elementsPendingErasure.add(elem.id);
                  }
                }
              }
            }
          }
        };
        const distance3 = distance2d(
          pointerDownState.lastCoords.x,
          pointerDownState.lastCoords.y,
          scenePointer.x,
          scenePointer.y
        );
        const threshold = 10 / this.state.zoom.value;
        const point2 = { ...pointerDownState.lastCoords };
        let samplingInterval = 0;
        while (samplingInterval <= distance3) {
          const hitElements = this.getElementsAtPosition(point2.x, point2.y);
          processElements(hitElements);
          if (samplingInterval === distance3) {
            break;
          }
          samplingInterval = Math.min(samplingInterval + threshold, distance3);
          const distanceRatio = samplingInterval / distance3;
          const nextX = (1 - distanceRatio) * point2.x + distanceRatio * scenePointer.x;
          const nextY = (1 - distanceRatio) * point2.y + distanceRatio * scenePointer.y;
          point2.x = nextX;
          point2.y = nextY;
        }
        pointerDownState.lastCoords.x = scenePointer.x;
        pointerDownState.lastCoords.y = scenePointer.y;
        if (didChange) {
          for (const element of this.scene.getNonDeletedElements()) {
            if (isBoundToContainer(element) && (this.elementsPendingErasure.has(element.id) || this.elementsPendingErasure.has(element.containerId))) {
              if (event.altKey) {
                this.elementsPendingErasure.delete(element.id);
                this.elementsPendingErasure.delete(element.containerId);
              } else {
                this.elementsPendingErasure.add(element.id);
                this.elementsPendingErasure.add(element.containerId);
              }
            }
          }
          this.elementsPendingErasure = new Set(this.elementsPendingErasure);
          this.onSceneUpdated();
        }
      };
      // set touch moving for mobile context menu
      handleTouchMove = (event) => {
        invalidateContextMenu = true;
      };
      handleHoverSelectedLinearElement(linearElementEditor, scenePointerX, scenePointerY) {
        const elementsMap = this.scene.getNonDeletedElementsMap();
        const element = LinearElementEditor.getElement(
          linearElementEditor.elementId,
          elementsMap
        );
        const boundTextElement = getBoundTextElement(element, elementsMap);
        if (!element) {
          return;
        }
        if (this.state.selectedLinearElement) {
          let hoverPointIndex = -1;
          let segmentMidPointHoveredCoords = null;
          if (isHittingElementNotConsideringBoundingBox(
            element,
            this.state,
            this.frameNameBoundsCache,
            [scenePointerX, scenePointerY],
            elementsMap
          )) {
            hoverPointIndex = LinearElementEditor.getPointIndexUnderCursor(
              element,
              elementsMap,
              this.state.zoom,
              scenePointerX,
              scenePointerY
            );
            segmentMidPointHoveredCoords = LinearElementEditor.getSegmentMidpointHitCoords(
              linearElementEditor,
              { x: scenePointerX, y: scenePointerY },
              this.state,
              this.scene.getNonDeletedElementsMap()
            );
            if (hoverPointIndex >= 0 || segmentMidPointHoveredCoords) {
              setCursor(this.interactiveCanvas, CURSOR_TYPE.POINTER);
            } else {
              setCursor(this.interactiveCanvas, CURSOR_TYPE.MOVE);
            }
          } else if (shouldShowBoundingBox([element], this.state) && isHittingElementBoundingBoxWithoutHittingElement(
            element,
            this.state,
            this.frameNameBoundsCache,
            scenePointerX,
            scenePointerY,
            elementsMap
          )) {
            setCursor(this.interactiveCanvas, CURSOR_TYPE.MOVE);
          } else if (boundTextElement && hitTest(
            boundTextElement,
            this.state,
            this.frameNameBoundsCache,
            scenePointerX,
            scenePointerY,
            this.scene.getNonDeletedElementsMap()
          )) {
            setCursor(this.interactiveCanvas, CURSOR_TYPE.MOVE);
          }
          if (this.state.selectedLinearElement.hoverPointIndex !== hoverPointIndex) {
            this.setState({
              selectedLinearElement: {
                ...this.state.selectedLinearElement,
                hoverPointIndex
              }
            });
          }
          if (!LinearElementEditor.arePointsEqual(
            this.state.selectedLinearElement.segmentMidPointHoveredCoords,
            segmentMidPointHoveredCoords
          )) {
            this.setState({
              selectedLinearElement: {
                ...this.state.selectedLinearElement,
                segmentMidPointHoveredCoords
              }
            });
          }
        } else {
          setCursor(this.interactiveCanvas, CURSOR_TYPE.AUTO);
        }
      }
      handleCanvasPointerDown = (event) => {
        this.maybeCleanupAfterMissingPointerUp(event.nativeEvent);
        this.maybeUnfollowRemoteUser();
        if (this.state.contextMenu) {
          this.setState({ contextMenu: null });
        }
        if (this.state.snapLines) {
          this.setAppState({ snapLines: [] });
        }
        this.updateGestureOnPointerDown(event);
        if (event.pointerType === "touch" && this.state.draggingElement && this.state.draggingElement.type === "freedraw") {
          const element = this.state.draggingElement;
          this.updateScene({
            ...element.points.length < 10 ? {
              elements: this.scene.getElementsIncludingDeleted().filter((el) => el.id !== element.id)
            } : {},
            appState: {
              draggingElement: null,
              editingElement: null,
              startBoundElement: null,
              suggestedBindings: [],
              selectedElementIds: makeNextSelectedElementIds(
                Object.keys(this.state.selectedElementIds).filter((key) => key !== element.id).reduce((obj, key) => {
                  obj[key] = this.state.selectedElementIds[key];
                  return obj;
                }, {}),
                this.state
              )
            }
          });
          return;
        }
        const selection = document.getSelection();
        if (selection?.anchorNode) {
          selection.removeAllRanges();
        }
        this.maybeOpenContextMenuAfterPointerDownOnTouchDevices(event);
        if (!this.state.penDetected && event.pointerType === "pen") {
          this.setState((prevState) => {
            return {
              penMode: true,
              penDetected: true
            };
          });
        }
        if (!this.device.isTouchScreen && ["pen", "touch"].includes(event.pointerType)) {
          this.device = updateObject(this.device, { isTouchScreen: true });
        }
        if (isPanning) {
          return;
        }
        this.lastPointerDownEvent = event;
        if (this.handleCanvasPanUsingWheelOrSpaceDrag(event)) {
          return;
        }
        this.setState({
          lastPointerDownWith: event.pointerType,
          cursorButton: "down"
        });
        this.savePointer(event.clientX, event.clientY, "down");
        if (event.button === POINTER_BUTTON.ERASER && this.state.activeTool.type !== TOOL_TYPE.eraser) {
          this.setState(
            {
              activeTool: updateActiveTool(this.state, {
                type: TOOL_TYPE.eraser,
                lastActiveToolBeforeEraser: this.state.activeTool
              })
            },
            () => {
              this.handleCanvasPointerDown(event);
              const onPointerUp2 = () => {
                unsubPointerUp();
                unsubCleanup?.();
                if (isEraserActive(this.state)) {
                  this.setState({
                    activeTool: updateActiveTool(this.state, {
                      ...this.state.activeTool.lastActiveTool || {
                        type: TOOL_TYPE.selection
                      },
                      lastActiveToolBeforeEraser: null
                    })
                  });
                }
              };
              const unsubPointerUp = addEventListener(
                window,
                "pointerup" /* POINTER_UP */,
                onPointerUp2,
                {
                  once: true
                }
              );
              let unsubCleanup;
              requestAnimationFrame(() => {
                unsubCleanup = this.missingPointerEventCleanupEmitter.once(onPointerUp2);
              });
            }
          );
          return;
        }
        if (event.button !== POINTER_BUTTON.MAIN && event.button !== POINTER_BUTTON.TOUCH && event.button !== POINTER_BUTTON.ERASER) {
          return;
        }
        if (gesture.pointers.size > 1) {
          return;
        }
        const pointerDownState = this.initialPointerDownState(event);
        this.setState({
          selectedElementsAreBeingDragged: false
        });
        if (this.handleDraggingScrollBar(event, pointerDownState)) {
          return;
        }
        this.clearSelectionIfNotUsingSelection();
        this.updateBindingEnabledOnPointerMove(event);
        if (this.handleSelectionOnPointerDown(event, pointerDownState)) {
          return;
        }
        const allowOnPointerDown = !this.state.penMode || event.pointerType !== "touch" || this.state.activeTool.type === "selection" || this.state.activeTool.type === "text" || this.state.activeTool.type === "image";
        if (!allowOnPointerDown) {
          return;
        }
        if (this.state.activeTool.type === "text") {
          this.handleTextOnPointerDown(event, pointerDownState);
          return;
        } else if (this.state.activeTool.type === "arrow" || this.state.activeTool.type === "line") {
          this.handleLinearElementOnPointerDown(
            event,
            this.state.activeTool.type,
            pointerDownState
          );
        } else if (this.state.activeTool.type === "image") {
          setCursor(this.interactiveCanvas, CURSOR_TYPE.CROSSHAIR);
          const pendingImageElement = this.state.pendingImageElementId && this.scene.getElement(this.state.pendingImageElementId);
          if (!pendingImageElement) {
            return;
          }
          this.setState({
            draggingElement: pendingImageElement,
            editingElement: pendingImageElement,
            pendingImageElementId: null,
            multiElement: null
          });
          const { x, y } = viewportCoordsToSceneCoords(event, this.state);
          const frame = this.getTopLayerFrameAtSceneCoords({ x, y });
          mutateElement(pendingImageElement, {
            x,
            y,
            frameId: frame ? frame.id : null
          });
        } else if (this.state.activeTool.type === "freedraw") {
          this.handleFreeDrawElementOnPointerDown(
            event,
            this.state.activeTool.type,
            pointerDownState
          );
        } else if (this.state.activeTool.type === "custom") {
          setCursorForShape(this.interactiveCanvas, this.state);
        } else if (this.state.activeTool.type === TOOL_TYPE.frame || this.state.activeTool.type === TOOL_TYPE.magicframe) {
          this.createFrameElementOnPointerDown(
            pointerDownState,
            this.state.activeTool.type
          );
        } else if (this.state.activeTool.type === "laser") {
          this.laserTrails.startPath(
            pointerDownState.lastCoords.x,
            pointerDownState.lastCoords.y
          );
        } else if (this.state.activeTool.type !== "eraser" && this.state.activeTool.type !== "hand") {
          this.createGenericElementOnPointerDown(
            this.state.activeTool.type,
            pointerDownState
          );
        }
        this.props?.onPointerDown?.(this.state.activeTool, pointerDownState);
        this.onPointerDownEmitter.trigger(
          this.state.activeTool,
          pointerDownState,
          event
        );
        if (this.state.activeTool.type === "eraser") {
          this.eraserTrail.startPath(
            pointerDownState.lastCoords.x,
            pointerDownState.lastCoords.y
          );
        }
        const onPointerMove = this.onPointerMoveFromPointerDownHandler(pointerDownState);
        const onPointerUp = this.onPointerUpFromPointerDownHandler(pointerDownState);
        const onKeyDown = this.onKeyDownFromPointerDownHandler(pointerDownState);
        const onKeyUp = this.onKeyUpFromPointerDownHandler(pointerDownState);
        this.missingPointerEventCleanupEmitter.once(
          (_event) => onPointerUp(_event || event.nativeEvent)
        );
        if (!this.state.viewModeEnabled || this.state.activeTool.type === "laser") {
          window.addEventListener("pointermove" /* POINTER_MOVE */, onPointerMove);
          window.addEventListener("pointerup" /* POINTER_UP */, onPointerUp);
          window.addEventListener("keydown" /* KEYDOWN */, onKeyDown);
          window.addEventListener("keyup" /* KEYUP */, onKeyUp);
          pointerDownState.eventListeners.onMove = onPointerMove;
          pointerDownState.eventListeners.onUp = onPointerUp;
          pointerDownState.eventListeners.onKeyUp = onKeyUp;
          pointerDownState.eventListeners.onKeyDown = onKeyDown;
        }
      };
      handleCanvasPointerUp = (event) => {
        this.removePointer(event);
        this.lastPointerUpEvent = event;
        const scenePointer = viewportCoordsToSceneCoords(
          { clientX: event.clientX, clientY: event.clientY },
          this.state
        );
        const clicklength = event.timeStamp - (this.lastPointerDownEvent?.timeStamp ?? 0);
        if (this.device.editor.isMobile && clicklength < 300) {
          const hitElement = this.getElementAtPosition(
            scenePointer.x,
            scenePointer.y
          );
          if (isIframeLikeElement(hitElement) && this.isIframeLikeElementCenter(
            hitElement,
            event,
            scenePointer.x,
            scenePointer.y
          )) {
            this.handleEmbeddableCenterClick(hitElement);
            return;
          }
        }
        if (this.device.isTouchScreen) {
          const hitElement = this.getElementAtPosition(
            scenePointer.x,
            scenePointer.y
          );
          this.hitLinkElement = this.getElementLinkAtPosition(
            scenePointer,
            hitElement
          );
        }
        if (this.hitLinkElement && !this.state.selectedElementIds[this.hitLinkElement.id]) {
          if (clicklength < 300 && isIframeLikeElement(this.hitLinkElement) && !isPointHittingLinkIcon(
            this.hitLinkElement,
            this.scene.getNonDeletedElementsMap(),
            this.state,
            [scenePointer.x, scenePointer.y]
          )) {
            this.handleEmbeddableCenterClick(this.hitLinkElement);
          } else {
            this.redirectToLink(event, this.device.isTouchScreen);
          }
        } else if (this.state.viewModeEnabled) {
          this.setState({
            activeEmbeddable: null,
            selectedElementIds: {}
          });
        }
      };
      maybeOpenContextMenuAfterPointerDownOnTouchDevices = (event) => {
        if (event.pointerType === "touch") {
          invalidateContextMenu = false;
          if (touchTimeout) {
            invalidateContextMenu = true;
          } else {
            touchTimeout = window.setTimeout(() => {
              touchTimeout = 0;
              if (!invalidateContextMenu) {
                this.handleCanvasContextMenu(event);
              }
            }, TOUCH_CTX_MENU_TIMEOUT);
          }
        }
      };
      resetContextMenuTimer = () => {
        clearTimeout(touchTimeout);
        touchTimeout = 0;
        invalidateContextMenu = false;
      };
      /**
       * pointerup may not fire in certian cases (user tabs away...), so in order
       * to properly cleanup pointerdown state, we need to fire any hanging
       * pointerup handlers manually
       */
      maybeCleanupAfterMissingPointerUp = (event) => {
        lastPointerUp?.();
        this.missingPointerEventCleanupEmitter.trigger(event).clear();
      };
      // Returns whether the event is a panning
      handleCanvasPanUsingWheelOrSpaceDrag = (event) => {
        if (!(gesture.pointers.size <= 1 && (event.button === POINTER_BUTTON.WHEEL || event.button === POINTER_BUTTON.MAIN && isHoldingSpace || isHandToolActive(this.state) || this.state.viewModeEnabled)) || isTextElement(this.state.editingElement)) {
          return false;
        }
        isPanning = true;
        event.preventDefault();
        let nextPastePrevented = false;
        const isLinux = typeof window === void 0 ? false : /Linux/.test(window.navigator.platform);
        setCursor(this.interactiveCanvas, CURSOR_TYPE.GRABBING);
        let { clientX: lastX, clientY: lastY } = event;
        const onPointerMove = withBatchedUpdatesThrottled((event2) => {
          const deltaX = lastX - event2.clientX;
          const deltaY = lastY - event2.clientY;
          lastX = event2.clientX;
          lastY = event2.clientY;
          if (isLinux && !nextPastePrevented && (Math.abs(deltaX) > 1 || Math.abs(deltaY) > 1)) {
            nextPastePrevented = true;
            const preventNextPaste = (event3) => {
              document.body.removeEventListener("paste" /* PASTE */, preventNextPaste);
              event3.stopPropagation();
            };
            const enableNextPaste = () => {
              setTimeout(() => {
                document.body.removeEventListener("paste" /* PASTE */, preventNextPaste);
                window.removeEventListener("pointerup" /* POINTER_UP */, enableNextPaste);
              }, 100);
            };
            document.body.addEventListener("paste" /* PASTE */, preventNextPaste);
            window.addEventListener("pointerup" /* POINTER_UP */, enableNextPaste);
          }
          this.translateCanvas({
            scrollX: this.state.scrollX - deltaX / this.state.zoom.value,
            scrollY: this.state.scrollY - deltaY / this.state.zoom.value
          });
        });
        const teardown = withBatchedUpdates(
          lastPointerUp = () => {
            lastPointerUp = null;
            isPanning = false;
            if (!isHoldingSpace) {
              if (this.state.viewModeEnabled) {
                setCursor(this.interactiveCanvas, CURSOR_TYPE.GRAB);
              } else {
                setCursorForShape(this.interactiveCanvas, this.state);
              }
            }
            this.setState({
              cursorButton: "up"
            });
            this.savePointer(event.clientX, event.clientY, "up");
            window.removeEventListener("pointermove" /* POINTER_MOVE */, onPointerMove);
            window.removeEventListener("pointerup" /* POINTER_UP */, teardown);
            window.removeEventListener("blur" /* BLUR */, teardown);
            onPointerMove.flush();
          }
        );
        window.addEventListener("blur" /* BLUR */, teardown);
        window.addEventListener("pointermove" /* POINTER_MOVE */, onPointerMove, {
          passive: true
        });
        window.addEventListener("pointerup" /* POINTER_UP */, teardown);
        return true;
      };
      updateGestureOnPointerDown(event) {
        gesture.pointers.set(event.pointerId, {
          x: event.clientX,
          y: event.clientY
        });
        if (gesture.pointers.size === 2) {
          gesture.lastCenter = getCenter(gesture.pointers);
          gesture.initialScale = this.state.zoom.value;
          gesture.initialDistance = getDistance(
            Array.from(gesture.pointers.values())
          );
        }
      }
      initialPointerDownState(event) {
        const origin = viewportCoordsToSceneCoords(event, this.state);
        const selectedElements = this.scene.getSelectedElements(this.state);
        const [minX, minY, maxX, maxY] = getCommonBounds(selectedElements);
        return {
          origin,
          withCmdOrCtrl: event[KEYS.CTRL_OR_CMD],
          originInGrid: tupleToCoors(
            getGridPoint(
              origin.x,
              origin.y,
              event[KEYS.CTRL_OR_CMD] ? null : this.state.gridSize
            )
          ),
          scrollbars: isOverScrollBars(
            currentScrollBars,
            event.clientX - this.state.offsetLeft,
            event.clientY - this.state.offsetTop
          ),
          // we need to duplicate because we'll be updating this state
          lastCoords: { ...origin },
          originalElements: this.scene.getNonDeletedElements().reduce((acc, element) => {
            acc.set(element.id, deepCopyElement(element));
            return acc;
          }, /* @__PURE__ */ new Map()),
          resize: {
            handleType: false,
            isResizing: false,
            offset: { x: 0, y: 0 },
            arrowDirection: "origin",
            center: { x: (maxX + minX) / 2, y: (maxY + minY) / 2 }
          },
          hit: {
            element: null,
            allHitElements: [],
            wasAddedToSelection: false,
            hasBeenDuplicated: false,
            hasHitCommonBoundingBoxOfSelectedElements: this.isHittingCommonBoundingBoxOfSelectedElements(
              origin,
              selectedElements
            )
          },
          drag: {
            hasOccurred: false,
            offset: null
          },
          eventListeners: {
            onMove: null,
            onUp: null,
            onKeyUp: null,
            onKeyDown: null
          },
          boxSelection: {
            hasOccurred: false
          }
        };
      }
      // Returns whether the event is a dragging a scrollbar
      handleDraggingScrollBar(event, pointerDownState) {
        if (!(pointerDownState.scrollbars.isOverEither && !this.state.multiElement)) {
          return false;
        }
        isDraggingScrollBar = true;
        pointerDownState.lastCoords.x = event.clientX;
        pointerDownState.lastCoords.y = event.clientY;
        const onPointerMove = withBatchedUpdatesThrottled((event2) => {
          const target = event2.target;
          if (!(target instanceof HTMLElement)) {
            return;
          }
          this.handlePointerMoveOverScrollbars(event2, pointerDownState);
        });
        const onPointerUp = withBatchedUpdates(() => {
          lastPointerUp = null;
          isDraggingScrollBar = false;
          setCursorForShape(this.interactiveCanvas, this.state);
          this.setState({
            cursorButton: "up"
          });
          this.savePointer(event.clientX, event.clientY, "up");
          window.removeEventListener("pointermove" /* POINTER_MOVE */, onPointerMove);
          window.removeEventListener("pointerup" /* POINTER_UP */, onPointerUp);
          onPointerMove.flush();
        });
        lastPointerUp = onPointerUp;
        window.addEventListener("pointermove" /* POINTER_MOVE */, onPointerMove);
        window.addEventListener("pointerup" /* POINTER_UP */, onPointerUp);
        return true;
      }
      clearSelectionIfNotUsingSelection = () => {
        if (this.state.activeTool.type !== "selection") {
          this.setState({
            selectedElementIds: makeNextSelectedElementIds({}, this.state),
            selectedGroupIds: {},
            editingGroupId: null,
            activeEmbeddable: null
          });
        }
      };
      /**
       * @returns whether the pointer event has been completely handled
       */
      handleSelectionOnPointerDown = (event, pointerDownState) => {
        if (this.state.activeTool.type === "selection") {
          const elements = this.scene.getNonDeletedElements();
          const elementsMap = this.scene.getNonDeletedElementsMap();
          const selectedElements = this.scene.getSelectedElements(this.state);
          if (selectedElements.length === 1 && !this.state.editingLinearElement) {
            const elementWithTransformHandleType = getElementWithTransformHandleType(
              elements,
              this.state,
              pointerDownState.origin.x,
              pointerDownState.origin.y,
              this.state.zoom,
              event.pointerType,
              this.scene.getNonDeletedElementsMap()
            );
            if (elementWithTransformHandleType != null) {
              this.setState({
                resizingElement: elementWithTransformHandleType.element
              });
              pointerDownState.resize.handleType = elementWithTransformHandleType.transformHandleType;
            }
          } else if (selectedElements.length > 1) {
            pointerDownState.resize.handleType = getTransformHandleTypeFromCoords(
              getCommonBounds(selectedElements),
              pointerDownState.origin.x,
              pointerDownState.origin.y,
              this.state.zoom,
              event.pointerType
            );
          }
          if (pointerDownState.resize.handleType) {
            pointerDownState.resize.isResizing = true;
            pointerDownState.resize.offset = tupleToCoors(
              getResizeOffsetXY(
                pointerDownState.resize.handleType,
                selectedElements,
                elementsMap,
                pointerDownState.origin.x,
                pointerDownState.origin.y
              )
            );
            if (selectedElements.length === 1 && isLinearElement(selectedElements[0]) && selectedElements[0].points.length === 2) {
              pointerDownState.resize.arrowDirection = getResizeArrowDirection(
                pointerDownState.resize.handleType,
                selectedElements[0]
              );
            }
          } else {
            if (this.state.selectedLinearElement) {
              const linearElementEditor = this.state.editingLinearElement || this.state.selectedLinearElement;
              const ret = LinearElementEditor.handlePointerDown(
                event,
                this.state,
                this.history,
                pointerDownState.origin,
                linearElementEditor,
                this.scene.getNonDeletedElements(),
                elementsMap
              );
              if (ret.hitElement) {
                pointerDownState.hit.element = ret.hitElement;
              }
              if (ret.linearElementEditor) {
                this.setState({ selectedLinearElement: ret.linearElementEditor });
                if (this.state.editingLinearElement) {
                  this.setState({ editingLinearElement: ret.linearElementEditor });
                }
              }
              if (ret.didAddPoint) {
                return true;
              }
            }
            pointerDownState.hit.element = pointerDownState.hit.element ?? this.getElementAtPosition(
              pointerDownState.origin.x,
              pointerDownState.origin.y
            );
            if (pointerDownState.hit.element) {
              const hitLinkElement = this.getElementLinkAtPosition(
                {
                  x: pointerDownState.origin.x,
                  y: pointerDownState.origin.y
                },
                pointerDownState.hit.element
              );
              if (hitLinkElement) {
                return false;
              }
            }
            pointerDownState.hit.allHitElements = this.getElementsAtPosition(
              pointerDownState.origin.x,
              pointerDownState.origin.y
            );
            const hitElement = pointerDownState.hit.element;
            const someHitElementIsSelected = pointerDownState.hit.allHitElements.some(
              (element) => this.isASelectedElement(element)
            );
            if ((hitElement === null || !someHitElementIsSelected) && !event.shiftKey && !pointerDownState.hit.hasHitCommonBoundingBoxOfSelectedElements) {
              this.clearSelection(hitElement);
            }
            if (this.state.editingLinearElement) {
              this.setState({
                selectedElementIds: makeNextSelectedElementIds(
                  {
                    [this.state.editingLinearElement.elementId]: true
                  },
                  this.state
                )
              });
            } else if (hitElement != null) {
              if (event[KEYS.CTRL_OR_CMD]) {
                if (!this.state.selectedElementIds[hitElement.id]) {
                  pointerDownState.hit.wasAddedToSelection = true;
                }
                this.setState((prevState) => ({
                  ...editGroupForSelectedElement(prevState, hitElement),
                  previousSelectedElementIds: this.state.selectedElementIds
                }));
                return false;
              }
              if (!this.state.selectedElementIds[hitElement.id]) {
                if (this.state.editingGroupId && !isElementInGroup(hitElement, this.state.editingGroupId)) {
                  this.setState({
                    selectedElementIds: makeNextSelectedElementIds({}, this.state),
                    selectedGroupIds: {},
                    editingGroupId: null,
                    activeEmbeddable: null
                  });
                }
                if (!someHitElementIsSelected && !pointerDownState.hit.hasHitCommonBoundingBoxOfSelectedElements) {
                  this.setState((prevState) => {
                    const nextSelectedElementIds = {
                      ...prevState.selectedElementIds,
                      [hitElement.id]: true
                    };
                    const previouslySelectedElements = [];
                    Object.keys(prevState.selectedElementIds).forEach((id) => {
                      const element = this.scene.getElement(id);
                      element && previouslySelectedElements.push(element);
                    });
                    if (isFrameLikeElement(hitElement)) {
                      getFrameChildren(
                        previouslySelectedElements,
                        hitElement.id
                      ).forEach((element) => {
                        delete nextSelectedElementIds[element.id];
                      });
                    } else if (hitElement.frameId) {
                      if (nextSelectedElementIds[hitElement.frameId]) {
                        delete nextSelectedElementIds[hitElement.id];
                      }
                    } else {
                      const groupIds = hitElement.groupIds;
                      const framesInGroups = new Set(
                        groupIds.flatMap(
                          (gid) => getElementsInGroup(
                            this.scene.getNonDeletedElements(),
                            gid
                          )
                        ).filter((element) => isFrameLikeElement(element)).map((frame) => frame.id)
                      );
                      if (framesInGroups.size > 0) {
                        previouslySelectedElements.forEach((element) => {
                          if (element.frameId && framesInGroups.has(element.frameId)) {
                            delete nextSelectedElementIds[element.id];
                            element.groupIds.flatMap(
                              (gid) => getElementsInGroup(
                                this.scene.getNonDeletedElements(),
                                gid
                              )
                            ).forEach((element2) => {
                              delete nextSelectedElementIds[element2.id];
                            });
                          }
                        });
                      }
                    }
                    return {
                      ...selectGroupsForSelectedElements(
                        {
                          editingGroupId: prevState.editingGroupId,
                          selectedElementIds: nextSelectedElementIds
                        },
                        this.scene.getNonDeletedElements(),
                        prevState,
                        this
                      ),
                      showHyperlinkPopup: hitElement.link || isEmbeddableElement(hitElement) ? "info" : false
                    };
                  });
                  pointerDownState.hit.wasAddedToSelection = true;
                }
              }
            }
            this.setState({
              previousSelectedElementIds: this.state.selectedElementIds
            });
          }
        }
        return false;
      };
      isASelectedElement(hitElement) {
        return hitElement != null && this.state.selectedElementIds[hitElement.id];
      }
      isHittingCommonBoundingBoxOfSelectedElements(point2, selectedElements) {
        if (selectedElements.length < 2) {
          return false;
        }
        const threshold = 10 / this.state.zoom.value;
        const [x1, y1, x2, y2] = getCommonBounds(selectedElements);
        return point2.x > x1 - threshold && point2.x < x2 + threshold && point2.y > y1 - threshold && point2.y < y2 + threshold;
      }
      handleTextOnPointerDown = (event, pointerDownState) => {
        if (isTextElement(this.state.editingElement)) {
          return;
        }
        let sceneX = pointerDownState.origin.x;
        let sceneY = pointerDownState.origin.y;
        const element = this.getElementAtPosition(sceneX, sceneY, {
          includeBoundTextElement: true
        });
        let container = getTextBindableContainerAtPosition(
          this.scene.getNonDeletedElements(),
          this.state,
          sceneX,
          sceneY,
          this.scene.getNonDeletedElementsMap()
        );
        if (hasBoundTextElement(element)) {
          container = element;
          sceneX = element.x + element.width / 2;
          sceneY = element.y + element.height / 2;
        }
        this.startTextEditing({
          sceneX,
          sceneY,
          insertAtParentCenter: !event.altKey,
          container
        });
        resetCursor(this.interactiveCanvas);
        if (!this.state.activeTool.locked) {
          this.setState({
            activeTool: updateActiveTool(this.state, { type: "selection" })
          });
        }
      };
      handleFreeDrawElementOnPointerDown = (event, elementType, pointerDownState) => {
        const [gridX, gridY] = getGridPoint(
          pointerDownState.origin.x,
          pointerDownState.origin.y,
          null
        );
        const topLayerFrame = this.getTopLayerFrameAtSceneCoords({
          x: gridX,
          y: gridY
        });
        const element = newFreeDrawElement({
          type: elementType,
          x: gridX,
          y: gridY,
          strokeColor: this.state.currentItemStrokeColor,
          backgroundColor: this.state.currentItemBackgroundColor,
          fillStyle: this.state.currentItemFillStyle,
          strokeWidth: this.state.currentItemStrokeWidth,
          strokeStyle: this.state.currentItemStrokeStyle,
          roughness: this.state.currentItemRoughness,
          opacity: this.state.currentItemOpacity,
          roundness: null,
          simulatePressure: event.pressure === 0.5,
          locked: false,
          frameId: topLayerFrame ? topLayerFrame.id : null
        });
        this.setState((prevState) => {
          const nextSelectedElementIds = {
            ...prevState.selectedElementIds
          };
          delete nextSelectedElementIds[element.id];
          return {
            selectedElementIds: makeNextSelectedElementIds(
              nextSelectedElementIds,
              prevState
            )
          };
        });
        const pressures = element.simulatePressure ? element.pressures : [...element.pressures, event.pressure];
        mutateElement(element, {
          points: [[0, 0]],
          pressures
        });
        const boundElement = getHoveredElementForBinding(
          pointerDownState.origin,
          this.scene.getNonDeletedElements(),
          this.scene.getNonDeletedElementsMap()
        );
        this.scene.addNewElement(element);
        this.setState({
          draggingElement: element,
          editingElement: element,
          startBoundElement: boundElement,
          suggestedBindings: []
        });
      };
      insertIframeElement = ({
        sceneX,
        sceneY,
        width,
        height
      }) => {
        const [gridX, gridY] = getGridPoint(
          sceneX,
          sceneY,
          this.lastPointerDownEvent?.[KEYS.CTRL_OR_CMD] ? null : this.state.gridSize
        );
        const element = newIframeElement({
          type: "iframe",
          x: gridX,
          y: gridY,
          strokeColor: "transparent",
          backgroundColor: "transparent",
          fillStyle: this.state.currentItemFillStyle,
          strokeWidth: this.state.currentItemStrokeWidth,
          strokeStyle: this.state.currentItemStrokeStyle,
          roughness: this.state.currentItemRoughness,
          roundness: this.getCurrentItemRoundness("iframe"),
          opacity: this.state.currentItemOpacity,
          locked: false,
          width,
          height
        });
        this.scene.replaceAllElements([
          ...this.scene.getElementsIncludingDeleted(),
          element
        ]);
        return element;
      };
      //create rectangle element with youtube top left on nearest grid point width / hight 640/360
      insertEmbeddableElement = ({
        sceneX,
        sceneY,
        link
      }) => {
        const [gridX, gridY] = getGridPoint(
          sceneX,
          sceneY,
          this.lastPointerDownEvent?.[KEYS.CTRL_OR_CMD] ? null : this.state.gridSize
        );
        const embedLink = getEmbedLink(link);
        if (!embedLink) {
          return;
        }
        if (embedLink.error instanceof URIError) {
          this.setToast({
            message: t("toast.unrecognizedLinkFormat"),
            closable: true
          });
        }
        const element = newEmbeddableElement({
          type: "embeddable",
          x: gridX,
          y: gridY,
          strokeColor: "transparent",
          backgroundColor: "transparent",
          fillStyle: this.state.currentItemFillStyle,
          strokeWidth: this.state.currentItemStrokeWidth,
          strokeStyle: this.state.currentItemStrokeStyle,
          roughness: this.state.currentItemRoughness,
          roundness: this.getCurrentItemRoundness("embeddable"),
          opacity: this.state.currentItemOpacity,
          locked: false,
          width: embedLink.intrinsicSize.w,
          height: embedLink.intrinsicSize.h,
          link
        });
        this.scene.replaceAllElements([
          ...this.scene.getElementsIncludingDeleted(),
          element
        ]);
        return element;
      };
      createImageElement = ({
        sceneX,
        sceneY,
        addToFrameUnderCursor = true
      }) => {
        const [gridX, gridY] = getGridPoint(
          sceneX,
          sceneY,
          this.lastPointerDownEvent?.[KEYS.CTRL_OR_CMD] ? null : this.state.gridSize
        );
        const topLayerFrame = addToFrameUnderCursor ? this.getTopLayerFrameAtSceneCoords({
          x: gridX,
          y: gridY
        }) : null;
        const element = newImageElement({
          type: "image",
          x: gridX,
          y: gridY,
          strokeColor: this.state.currentItemStrokeColor,
          backgroundColor: this.state.currentItemBackgroundColor,
          fillStyle: this.state.currentItemFillStyle,
          strokeWidth: this.state.currentItemStrokeWidth,
          strokeStyle: this.state.currentItemStrokeStyle,
          roughness: this.state.currentItemRoughness,
          roundness: null,
          opacity: this.state.currentItemOpacity,
          locked: false,
          frameId: topLayerFrame ? topLayerFrame.id : null
        });
        return element;
      };
      handleLinearElementOnPointerDown = (event, elementType, pointerDownState) => {
        if (this.state.multiElement) {
          const { multiElement } = this.state;
          if (multiElement.type === "line" && isPathALoop(multiElement.points, this.state.zoom.value)) {
            mutateElement(multiElement, {
              lastCommittedPoint: multiElement.points[multiElement.points.length - 1]
            });
            this.actionManager.executeAction(actionFinalize);
            return;
          }
          const { x: rx, y: ry, lastCommittedPoint } = multiElement;
          if (multiElement.points.length > 1 && lastCommittedPoint && distance2d(
            pointerDownState.origin.x - rx,
            pointerDownState.origin.y - ry,
            lastCommittedPoint[0],
            lastCommittedPoint[1]
          ) < LINE_CONFIRM_THRESHOLD) {
            this.actionManager.executeAction(actionFinalize);
            return;
          }
          this.setState((prevState) => ({
            selectedElementIds: makeNextSelectedElementIds(
              {
                ...prevState.selectedElementIds,
                [multiElement.id]: true
              },
              prevState
            )
          }));
          mutateElement(multiElement, {
            lastCommittedPoint: multiElement.points[multiElement.points.length - 1]
          });
          setCursor(this.interactiveCanvas, CURSOR_TYPE.POINTER);
        } else {
          const [gridX, gridY] = getGridPoint(
            pointerDownState.origin.x,
            pointerDownState.origin.y,
            event[KEYS.CTRL_OR_CMD] ? null : this.state.gridSize
          );
          const topLayerFrame = this.getTopLayerFrameAtSceneCoords({
            x: gridX,
            y: gridY
          });
          const { currentItemStartArrowhead, currentItemEndArrowhead } = this.state;
          const [startArrowhead, endArrowhead] = elementType === "arrow" ? [currentItemStartArrowhead, currentItemEndArrowhead] : [null, null];
          const element = newLinearElement({
            type: elementType,
            x: gridX,
            y: gridY,
            strokeColor: this.state.currentItemStrokeColor,
            backgroundColor: this.state.currentItemBackgroundColor,
            fillStyle: this.state.currentItemFillStyle,
            strokeWidth: this.state.currentItemStrokeWidth,
            strokeStyle: this.state.currentItemStrokeStyle,
            roughness: this.state.currentItemRoughness,
            opacity: this.state.currentItemOpacity,
            roundness: this.state.currentItemRoundness === "round" ? { type: ROUNDNESS.PROPORTIONAL_RADIUS } : null,
            startArrowhead,
            endArrowhead,
            locked: false,
            frameId: topLayerFrame ? topLayerFrame.id : null
          });
          this.setState((prevState) => {
            const nextSelectedElementIds = {
              ...prevState.selectedElementIds
            };
            delete nextSelectedElementIds[element.id];
            return {
              selectedElementIds: makeNextSelectedElementIds(
                nextSelectedElementIds,
                prevState
              )
            };
          });
          mutateElement(element, {
            points: [...element.points, [0, 0]]
          });
          const boundElement = getHoveredElementForBinding(
            pointerDownState.origin,
            this.scene.getNonDeletedElements(),
            this.scene.getNonDeletedElementsMap()
          );
          this.scene.addNewElement(element);
          this.setState({
            draggingElement: element,
            editingElement: element,
            startBoundElement: boundElement,
            suggestedBindings: []
          });
        }
      };
      getCurrentItemRoundness(elementType) {
        return this.state.currentItemRoundness === "round" ? {
          type: isUsingAdaptiveRadius(elementType) ? ROUNDNESS.ADAPTIVE_RADIUS : ROUNDNESS.PROPORTIONAL_RADIUS
        } : null;
      }
      createGenericElementOnPointerDown = (elementType, pointerDownState) => {
        const [gridX, gridY] = getGridPoint(
          pointerDownState.origin.x,
          pointerDownState.origin.y,
          this.lastPointerDownEvent?.[KEYS.CTRL_OR_CMD] ? null : this.state.gridSize
        );
        const topLayerFrame = this.getTopLayerFrameAtSceneCoords({
          x: gridX,
          y: gridY
        });
        const baseElementAttributes = {
          x: gridX,
          y: gridY,
          strokeColor: this.state.currentItemStrokeColor,
          backgroundColor: this.state.currentItemBackgroundColor,
          fillStyle: this.state.currentItemFillStyle,
          strokeWidth: this.state.currentItemStrokeWidth,
          strokeStyle: this.state.currentItemStrokeStyle,
          roughness: this.state.currentItemRoughness,
          opacity: this.state.currentItemOpacity,
          roundness: this.getCurrentItemRoundness(elementType),
          locked: false,
          frameId: topLayerFrame ? topLayerFrame.id : null
        };
        let element;
        if (elementType === "embeddable") {
          element = newEmbeddableElement({
            type: "embeddable",
            ...baseElementAttributes
          });
        } else {
          element = newElement({
            type: elementType,
            ...baseElementAttributes
          });
        }
        if (element.type === "selection") {
          this.setState({
            selectionElement: element,
            draggingElement: element
          });
        } else {
          this.scene.addNewElement(element);
          this.setState({
            multiElement: null,
            draggingElement: element,
            editingElement: element
          });
        }
      };
      createFrameElementOnPointerDown = (pointerDownState, type) => {
        const [gridX, gridY] = getGridPoint(
          pointerDownState.origin.x,
          pointerDownState.origin.y,
          this.lastPointerDownEvent?.[KEYS.CTRL_OR_CMD] ? null : this.state.gridSize
        );
        const constructorOpts = {
          x: gridX,
          y: gridY,
          opacity: this.state.currentItemOpacity,
          locked: false,
          ...FRAME_STYLE
        };
        const frame = type === TOOL_TYPE.magicframe ? newMagicFrameElement(constructorOpts) : newFrameElement(constructorOpts);
        this.scene.replaceAllElements([
          ...this.scene.getElementsIncludingDeleted(),
          frame
        ]);
        this.setState({
          multiElement: null,
          draggingElement: frame,
          editingElement: frame
        });
      };
      maybeCacheReferenceSnapPoints(event, selectedElements, recomputeAnyways = false) {
        if (isSnappingEnabled({
          event,
          appState: this.state,
          selectedElements
        }) && (recomputeAnyways || !SnapCache.getReferenceSnapPoints())) {
          SnapCache.setReferenceSnapPoints(
            getReferenceSnapPoints(
              this.scene.getNonDeletedElements(),
              selectedElements,
              this.state,
              this.scene.getNonDeletedElementsMap()
            )
          );
        }
      }
      maybeCacheVisibleGaps(event, selectedElements, recomputeAnyways = false) {
        if (isSnappingEnabled({
          event,
          appState: this.state,
          selectedElements
        }) && (recomputeAnyways || !SnapCache.getVisibleGaps())) {
          SnapCache.setVisibleGaps(
            getVisibleGaps(
              this.scene.getNonDeletedElements(),
              selectedElements,
              this.state,
              this.scene.getNonDeletedElementsMap()
            )
          );
        }
      }
      onKeyDownFromPointerDownHandler(pointerDownState) {
        return withBatchedUpdates((event) => {
          if (this.maybeHandleResize(pointerDownState, event)) {
            return;
          }
          this.maybeDragNewGenericElement(pointerDownState, event);
        });
      }
      onKeyUpFromPointerDownHandler(pointerDownState) {
        return withBatchedUpdates((event) => {
          event.key === KEYS.ALT && event.preventDefault();
          if (this.maybeHandleResize(pointerDownState, event)) {
            return;
          }
          this.maybeDragNewGenericElement(pointerDownState, event);
        });
      }
      onPointerMoveFromPointerDownHandler(pointerDownState) {
        return withBatchedUpdatesThrottled((event) => {
          if (pointerDownState.drag.offset === null) {
            pointerDownState.drag.offset = tupleToCoors(
              getDragOffsetXY(
                this.scene.getSelectedElements(this.state),
                pointerDownState.origin.x,
                pointerDownState.origin.y
              )
            );
          }
          const target = event.target;
          if (!(target instanceof HTMLElement)) {
            return;
          }
          if (this.handlePointerMoveOverScrollbars(event, pointerDownState)) {
            return;
          }
          const pointerCoords = viewportCoordsToSceneCoords(event, this.state);
          if (isEraserActive(this.state)) {
            this.handleEraser(event, pointerDownState, pointerCoords);
            return;
          }
          if (this.state.activeTool.type === "laser") {
            this.laserTrails.addPointToPath(pointerCoords.x, pointerCoords.y);
          }
          const [gridX, gridY] = getGridPoint(
            pointerCoords.x,
            pointerCoords.y,
            event[KEYS.CTRL_OR_CMD] ? null : this.state.gridSize
          );
          if (!pointerDownState.drag.hasOccurred && (this.state.activeTool.type === "arrow" || this.state.activeTool.type === "line")) {
            if (distance2d(
              pointerCoords.x,
              pointerCoords.y,
              pointerDownState.origin.x,
              pointerDownState.origin.y
            ) < DRAGGING_THRESHOLD) {
              return;
            }
          }
          if (pointerDownState.resize.isResizing) {
            pointerDownState.lastCoords.x = pointerCoords.x;
            pointerDownState.lastCoords.y = pointerCoords.y;
            if (this.maybeHandleResize(pointerDownState, event)) {
              return true;
            }
          }
          const elementsMap = this.scene.getNonDeletedElementsMap();
          if (this.state.selectedLinearElement) {
            const linearElementEditor = this.state.editingLinearElement || this.state.selectedLinearElement;
            if (LinearElementEditor.shouldAddMidpoint(
              this.state.selectedLinearElement,
              pointerCoords,
              this.state,
              elementsMap
            )) {
              const ret = LinearElementEditor.addMidpoint(
                this.state.selectedLinearElement,
                pointerCoords,
                this.state,
                !event[KEYS.CTRL_OR_CMD],
                elementsMap
              );
              if (!ret) {
                return;
              }
              flushSync(() => {
                if (this.state.selectedLinearElement) {
                  this.setState({
                    selectedLinearElement: {
                      ...this.state.selectedLinearElement,
                      pointerDownState: ret.pointerDownState,
                      selectedPointsIndices: ret.selectedPointsIndices
                    }
                  });
                }
                if (this.state.editingLinearElement) {
                  this.setState({
                    editingLinearElement: {
                      ...this.state.editingLinearElement,
                      pointerDownState: ret.pointerDownState,
                      selectedPointsIndices: ret.selectedPointsIndices
                    }
                  });
                }
              });
              return;
            } else if (linearElementEditor.pointerDownState.segmentMidpoint.value !== null && !linearElementEditor.pointerDownState.segmentMidpoint.added) {
              return;
            }
            const didDrag = LinearElementEditor.handlePointDragging(
              event,
              this.state,
              pointerCoords.x,
              pointerCoords.y,
              (element, pointsSceneCoords) => {
                this.maybeSuggestBindingsForLinearElementAtCoords(
                  element,
                  pointsSceneCoords
                );
              },
              linearElementEditor,
              this.scene.getNonDeletedElementsMap()
            );
            if (didDrag) {
              pointerDownState.lastCoords.x = pointerCoords.x;
              pointerDownState.lastCoords.y = pointerCoords.y;
              pointerDownState.drag.hasOccurred = true;
              if (this.state.editingLinearElement && !this.state.editingLinearElement.isDragging) {
                this.setState({
                  editingLinearElement: {
                    ...this.state.editingLinearElement,
                    isDragging: true
                  }
                });
              }
              if (!this.state.selectedLinearElement.isDragging) {
                this.setState({
                  selectedLinearElement: {
                    ...this.state.selectedLinearElement,
                    isDragging: true
                  }
                });
              }
              return;
            }
          }
          const hasHitASelectedElement = pointerDownState.hit.allHitElements.some(
            (element) => this.isASelectedElement(element)
          );
          const isSelectingPointsInLineEditor = this.state.editingLinearElement && event.shiftKey && this.state.editingLinearElement.elementId === pointerDownState.hit.element?.id;
          if ((hasHitASelectedElement || pointerDownState.hit.hasHitCommonBoundingBoxOfSelectedElements) && !isSelectingPointsInLineEditor) {
            const selectedElements = this.scene.getSelectedElements(this.state);
            if (selectedElements.every((element) => element.locked)) {
              return;
            }
            const selectedElementsHasAFrame = selectedElements.find(
              (e) => isFrameLikeElement(e)
            );
            const topLayerFrame = this.getTopLayerFrameAtSceneCoords(pointerCoords);
            this.setState({
              frameToHighlight: topLayerFrame && !selectedElementsHasAFrame ? topLayerFrame : null
            });
            pointerDownState.drag.hasOccurred = true;
            this.setState({
              selectedElementsAreBeingDragged: true
            });
            if (selectedElements.length > 0 && !pointerDownState.withCmdOrCtrl && !this.state.editingElement && this.state.activeEmbeddable?.state !== "active") {
              const dragOffset = {
                x: pointerCoords.x - pointerDownState.origin.x,
                y: pointerCoords.y - pointerDownState.origin.y
              };
              const originalElements = [
                ...pointerDownState.originalElements.values()
              ];
              const lockDirection = event.shiftKey;
              if (lockDirection) {
                const distanceX = Math.abs(dragOffset.x);
                const distanceY = Math.abs(dragOffset.y);
                const lockX = lockDirection && distanceX < distanceY;
                const lockY = lockDirection && distanceX > distanceY;
                if (lockX) {
                  dragOffset.x = 0;
                }
                if (lockY) {
                  dragOffset.y = 0;
                }
              }
              this.maybeCacheVisibleGaps(event, selectedElements);
              this.maybeCacheReferenceSnapPoints(event, selectedElements);
              const { snapOffset, snapLines } = snapDraggedElements(
                originalElements,
                dragOffset,
                this.state,
                event,
                this.scene.getNonDeletedElementsMap()
              );
              this.setState({ snapLines });
              !this.state.editingFrame && dragSelectedElements(
                pointerDownState,
                selectedElements,
                dragOffset,
                this.state,
                this.scene,
                snapOffset,
                event[KEYS.CTRL_OR_CMD] ? null : this.state.gridSize
              );
              this.maybeSuggestBindingForAll(selectedElements);
              if (event.altKey && !pointerDownState.hit.hasBeenDuplicated) {
                pointerDownState.hit.hasBeenDuplicated = true;
                const nextElements = [];
                const elementsToAppend = [];
                const groupIdMap = /* @__PURE__ */ new Map();
                const oldIdToDuplicatedId = /* @__PURE__ */ new Map();
                const hitElement = pointerDownState.hit.element;
                const selectedElementIds = new Set(
                  this.scene.getSelectedElements({
                    selectedElementIds: this.state.selectedElementIds,
                    includeBoundTextElement: true,
                    includeElementsInFrames: true
                  }).map((element) => element.id)
                );
                const elements = this.scene.getElementsIncludingDeleted();
                for (const element of elements) {
                  if (selectedElementIds.has(element.id) || // case: the state.selectedElementIds might not have been
                  // updated yet by the time this mousemove event is fired
                  element.id === hitElement?.id && pointerDownState.hit.wasAddedToSelection) {
                    const duplicatedElement = duplicateElement(
                      this.state.editingGroupId,
                      groupIdMap,
                      element
                    );
                    const origElement = pointerDownState.originalElements.get(
                      element.id
                    );
                    mutateElement(duplicatedElement, {
                      x: origElement.x,
                      y: origElement.y
                    });
                    pointerDownState.originalElements.set(
                      duplicatedElement.id,
                      duplicatedElement
                    );
                    nextElements.push(duplicatedElement);
                    elementsToAppend.push(element);
                    oldIdToDuplicatedId.set(element.id, duplicatedElement.id);
                  } else {
                    nextElements.push(element);
                  }
                }
                const nextSceneElements = [...nextElements, ...elementsToAppend];
                bindTextToShapeAfterDuplication(
                  nextElements,
                  elementsToAppend,
                  oldIdToDuplicatedId
                );
                fixBindingsAfterDuplication(
                  nextSceneElements,
                  elementsToAppend,
                  oldIdToDuplicatedId,
                  "duplicatesServeAsOld"
                );
                bindElementsToFramesAfterDuplication(
                  nextSceneElements,
                  elementsToAppend,
                  oldIdToDuplicatedId
                );
                this.scene.replaceAllElements(nextSceneElements);
                this.maybeCacheVisibleGaps(event, selectedElements, true);
                this.maybeCacheReferenceSnapPoints(event, selectedElements, true);
              }
              return;
            }
          }
          const draggingElement = this.state.draggingElement;
          if (!draggingElement) {
            return;
          }
          if (draggingElement.type === "freedraw") {
            const points = draggingElement.points;
            const dx = pointerCoords.x - draggingElement.x;
            const dy = pointerCoords.y - draggingElement.y;
            const lastPoint = points.length > 0 && points[points.length - 1];
            const discardPoint = lastPoint && lastPoint[0] === dx && lastPoint[1] === dy;
            if (!discardPoint) {
              const pressures = draggingElement.simulatePressure ? draggingElement.pressures : [...draggingElement.pressures, event.pressure];
              mutateElement(draggingElement, {
                points: [...points, [dx, dy]],
                pressures
              });
            }
          } else if (isLinearElement(draggingElement)) {
            pointerDownState.drag.hasOccurred = true;
            this.setState({
              selectedElementsAreBeingDragged: true
            });
            const points = draggingElement.points;
            let dx = gridX - draggingElement.x;
            let dy = gridY - draggingElement.y;
            if (shouldRotateWithDiscreteAngle(event) && points.length === 2) {
              ({ width: dx, height: dy } = getLockedLinearCursorAlignSize(
                draggingElement.x,
                draggingElement.y,
                pointerCoords.x,
                pointerCoords.y
              ));
            }
            if (points.length === 1) {
              mutateElement(draggingElement, {
                points: [...points, [dx, dy]]
              });
            } else if (points.length === 2) {
              mutateElement(draggingElement, {
                points: [...points.slice(0, -1), [dx, dy]]
              });
            }
            if (isBindingElement(draggingElement, false)) {
              this.maybeSuggestBindingsForLinearElementAtCoords(
                draggingElement,
                [pointerCoords],
                this.state.startBoundElement
              );
            }
          } else {
            pointerDownState.lastCoords.x = pointerCoords.x;
            pointerDownState.lastCoords.y = pointerCoords.y;
            this.maybeDragNewGenericElement(pointerDownState, event);
          }
          if (this.state.activeTool.type === "selection") {
            pointerDownState.boxSelection.hasOccurred = true;
            const elements = this.scene.getNonDeletedElements();
            if (this.state.editingLinearElement) {
              LinearElementEditor.handleBoxSelection(
                event,
                this.state,
                this.setState.bind(this),
                this.scene.getNonDeletedElementsMap()
              );
            } else {
              let shouldReuseSelection = true;
              if (!event.shiftKey && isSomeElementSelected(elements, this.state)) {
                if (pointerDownState.withCmdOrCtrl && pointerDownState.hit.element) {
                  this.setState(
                    (prevState) => selectGroupsForSelectedElements(
                      {
                        ...prevState,
                        selectedElementIds: {
                          [pointerDownState.hit.element.id]: true
                        }
                      },
                      this.scene.getNonDeletedElements(),
                      prevState,
                      this
                    )
                  );
                } else {
                  shouldReuseSelection = false;
                }
              }
              const elementsWithinSelection = getElementsWithinSelection(
                elements,
                draggingElement,
                this.scene.getNonDeletedElementsMap()
              );
              this.setState((prevState) => {
                const nextSelectedElementIds = {
                  ...shouldReuseSelection && prevState.selectedElementIds,
                  ...elementsWithinSelection.reduce(
                    (acc, element) => {
                      acc[element.id] = true;
                      return acc;
                    },
                    {}
                  )
                };
                if (pointerDownState.hit.element) {
                  if (!elementsWithinSelection.length) {
                    nextSelectedElementIds[pointerDownState.hit.element.id] = true;
                  } else {
                    delete nextSelectedElementIds[pointerDownState.hit.element.id];
                  }
                }
                prevState = !shouldReuseSelection ? { ...prevState, selectedGroupIds: {}, editingGroupId: null } : prevState;
                return {
                  ...selectGroupsForSelectedElements(
                    {
                      editingGroupId: prevState.editingGroupId,
                      selectedElementIds: nextSelectedElementIds
                    },
                    this.scene.getNonDeletedElements(),
                    prevState,
                    this
                  ),
                  // select linear element only when we haven't box-selected anything else
                  selectedLinearElement: elementsWithinSelection.length === 1 && isLinearElement(elementsWithinSelection[0]) ? new LinearElementEditor(elementsWithinSelection[0]) : null,
                  showHyperlinkPopup: elementsWithinSelection.length === 1 && (elementsWithinSelection[0].link || isEmbeddableElement(elementsWithinSelection[0])) ? "info" : false
                };
              });
            }
          }
        });
      }
      // Returns whether the pointer move happened over either scrollbar
      handlePointerMoveOverScrollbars(event, pointerDownState) {
        if (pointerDownState.scrollbars.isOverHorizontal) {
          const x = event.clientX;
          const dx = x - pointerDownState.lastCoords.x;
          this.translateCanvas({
            scrollX: this.state.scrollX - dx / this.state.zoom.value
          });
          pointerDownState.lastCoords.x = x;
          return true;
        }
        if (pointerDownState.scrollbars.isOverVertical) {
          const y = event.clientY;
          const dy = y - pointerDownState.lastCoords.y;
          this.translateCanvas({
            scrollY: this.state.scrollY - dy / this.state.zoom.value
          });
          pointerDownState.lastCoords.y = y;
          return true;
        }
        return false;
      }
      onPointerUpFromPointerDownHandler(pointerDownState) {
        return withBatchedUpdates((childEvent) => {
          this.removePointer(childEvent);
          if (pointerDownState.eventListeners.onMove) {
            pointerDownState.eventListeners.onMove.flush();
          }
          const {
            draggingElement,
            resizingElement,
            multiElement,
            activeTool,
            isResizing,
            isRotating
          } = this.state;
          this.setState((prevState) => ({
            isResizing: false,
            isRotating: false,
            resizingElement: null,
            selectionElement: null,
            frameToHighlight: null,
            elementsToHighlight: null,
            cursorButton: "up",
            // text elements are reset on finalize, and resetting on pointerup
            // may cause issues with double taps
            editingElement: multiElement || isTextElement(this.state.editingElement) ? this.state.editingElement : null,
            snapLines: updateStable(prevState.snapLines, []),
            originSnapOffset: null
          }));
          SnapCache.setReferenceSnapPoints(null);
          SnapCache.setVisibleGaps(null);
          this.savePointer(childEvent.clientX, childEvent.clientY, "up");
          this.setState({
            selectedElementsAreBeingDragged: false
          });
          const elementsMap = this.scene.getNonDeletedElementsMap();
          if (this.state.editingLinearElement) {
            if (!pointerDownState.boxSelection.hasOccurred && pointerDownState.hit?.element?.id !== this.state.editingLinearElement.elementId) {
              this.actionManager.executeAction(actionFinalize);
            } else {
              const editingLinearElement = LinearElementEditor.handlePointerUp(
                childEvent,
                this.state.editingLinearElement,
                this.state,
                this.scene.getNonDeletedElements(),
                elementsMap
              );
              if (editingLinearElement !== this.state.editingLinearElement) {
                this.setState({
                  editingLinearElement,
                  suggestedBindings: []
                });
              }
            }
          } else if (this.state.selectedLinearElement) {
            if (pointerDownState.hit?.element?.id !== this.state.selectedLinearElement.elementId) {
              const selectedELements = this.scene.getSelectedElements(this.state);
              if (selectedELements.length > 1) {
                this.setState({ selectedLinearElement: null });
              }
            } else {
              const linearElementEditor = LinearElementEditor.handlePointerUp(
                childEvent,
                this.state.selectedLinearElement,
                this.state,
                this.scene.getNonDeletedElements(),
                elementsMap
              );
              const { startBindingElement, endBindingElement } = linearElementEditor;
              const element = this.scene.getElement(linearElementEditor.elementId);
              if (isBindingElement(element)) {
                bindOrUnbindLinearElement(
                  element,
                  startBindingElement,
                  endBindingElement,
                  elementsMap
                );
              }
              if (linearElementEditor !== this.state.selectedLinearElement) {
                this.setState({
                  selectedLinearElement: {
                    ...linearElementEditor,
                    selectedPointsIndices: null
                  },
                  suggestedBindings: []
                });
              }
            }
          }
          this.missingPointerEventCleanupEmitter.clear();
          window.removeEventListener(
            "pointermove" /* POINTER_MOVE */,
            pointerDownState.eventListeners.onMove
          );
          window.removeEventListener(
            "pointerup" /* POINTER_UP */,
            pointerDownState.eventListeners.onUp
          );
          window.removeEventListener(
            "keydown" /* KEYDOWN */,
            pointerDownState.eventListeners.onKeyDown
          );
          window.removeEventListener(
            "keyup" /* KEYUP */,
            pointerDownState.eventListeners.onKeyUp
          );
          if (this.state.pendingImageElementId) {
            this.setState({ pendingImageElementId: null });
          }
          this.props?.onPointerUp?.(activeTool, pointerDownState);
          this.onPointerUpEmitter.trigger(
            this.state.activeTool,
            pointerDownState,
            childEvent
          );
          if (draggingElement?.type === "freedraw") {
            const pointerCoords = viewportCoordsToSceneCoords(
              childEvent,
              this.state
            );
            const points = draggingElement.points;
            let dx = pointerCoords.x - draggingElement.x;
            let dy = pointerCoords.y - draggingElement.y;
            if (dx === points[0][0] && dy === points[0][1]) {
              dy += 1e-4;
              dx += 1e-4;
            }
            const pressures = draggingElement.simulatePressure ? [] : [...draggingElement.pressures, childEvent.pressure];
            mutateElement(draggingElement, {
              points: [...points, [dx, dy]],
              pressures,
              lastCommittedPoint: [dx, dy]
            });
            this.actionManager.executeAction(actionFinalize);
            return;
          }
          if (isImageElement(draggingElement)) {
            const imageElement = draggingElement;
            try {
              this.initializeImageDimensions(imageElement);
              this.setState(
                {
                  selectedElementIds: makeNextSelectedElementIds(
                    { [imageElement.id]: true },
                    this.state
                  )
                },
                () => {
                  this.actionManager.executeAction(actionFinalize);
                }
              );
            } catch (error) {
              console.error(error);
              this.scene.replaceAllElements(
                this.scene.getElementsIncludingDeleted().filter((el) => el.id !== imageElement.id)
              );
              this.actionManager.executeAction(actionFinalize);
            }
            return;
          }
          if (isLinearElement(draggingElement)) {
            if (draggingElement.points.length > 1) {
              this.history.resumeRecording();
            }
            const pointerCoords = viewportCoordsToSceneCoords(
              childEvent,
              this.state
            );
            if (!pointerDownState.drag.hasOccurred && draggingElement && !multiElement) {
              mutateElement(draggingElement, {
                points: [
                  ...draggingElement.points,
                  [
                    pointerCoords.x - draggingElement.x,
                    pointerCoords.y - draggingElement.y
                  ]
                ]
              });
              this.setState({
                multiElement: draggingElement,
                editingElement: this.state.draggingElement
              });
            } else if (pointerDownState.drag.hasOccurred && !multiElement) {
              if (isBindingEnabled(this.state) && isBindingElement(draggingElement, false)) {
                maybeBindLinearElement(
                  draggingElement,
                  this.state,
                  this.scene,
                  pointerCoords,
                  elementsMap
                );
              }
              this.setState({ suggestedBindings: [], startBoundElement: null });
              if (!activeTool.locked) {
                resetCursor(this.interactiveCanvas);
                this.setState((prevState) => ({
                  draggingElement: null,
                  activeTool: updateActiveTool(this.state, {
                    type: "selection"
                  }),
                  selectedElementIds: makeNextSelectedElementIds(
                    {
                      ...prevState.selectedElementIds,
                      [draggingElement.id]: true
                    },
                    prevState
                  ),
                  selectedLinearElement: new LinearElementEditor(draggingElement)
                }));
              } else {
                this.setState((prevState) => ({
                  draggingElement: null
                }));
              }
            }
            return;
          }
          if (activeTool.type !== "selection" && draggingElement && isInvisiblySmallElement(draggingElement)) {
            this.scene.replaceAllElements(
              this.scene.getElementsIncludingDeleted().filter((el) => el.id !== draggingElement.id)
            );
            this.setState({
              draggingElement: null
            });
            return;
          }
          if (draggingElement) {
            if (pointerDownState.drag.hasOccurred) {
              const sceneCoords = viewportCoordsToSceneCoords(
                childEvent,
                this.state
              );
              if (this.state.selectedLinearElement && this.state.selectedLinearElement.isDragging) {
                const linearElement = this.scene.getElement(
                  this.state.selectedLinearElement.elementId
                );
                if (linearElement?.frameId) {
                  const frame = getContainingFrame(linearElement);
                  if (frame && linearElement) {
                    if (!elementOverlapsWithFrame(
                      linearElement,
                      frame,
                      this.scene.getNonDeletedElementsMap()
                    )) {
                      mutateElement(linearElement, {
                        groupIds: []
                      });
                      removeElementsFromFrame(
                        [linearElement],
                        this.scene.getNonDeletedElementsMap()
                      );
                      this.scene.informMutation();
                    }
                  }
                }
              } else {
                const topLayerFrame = this.getTopLayerFrameAtSceneCoords(sceneCoords);
                const selectedElements = this.scene.getSelectedElements(this.state);
                let nextElements = this.scene.getElementsMapIncludingDeleted();
                const updateGroupIdsAfterEditingGroup = (elements) => {
                  if (elements.length > 0) {
                    for (const element of elements) {
                      const index = element.groupIds.indexOf(
                        this.state.editingGroupId
                      );
                      mutateElement(
                        element,
                        {
                          groupIds: element.groupIds.slice(0, index)
                        },
                        false
                      );
                    }
                    nextElements.forEach((element) => {
                      if (element.groupIds.length && getElementsInGroup(
                        nextElements,
                        element.groupIds[element.groupIds.length - 1]
                      ).length < 2) {
                        mutateElement(
                          element,
                          {
                            groupIds: []
                          },
                          false
                        );
                      }
                    });
                    this.setState({
                      editingGroupId: null
                    });
                  }
                };
                if (topLayerFrame && !this.state.selectedElementIds[topLayerFrame.id]) {
                  const elementsToAdd = selectedElements.filter(
                    (element) => element.frameId !== topLayerFrame.id && isElementInFrame(element, nextElements, this.state)
                  );
                  if (this.state.editingGroupId) {
                    updateGroupIdsAfterEditingGroup(elementsToAdd);
                  }
                  nextElements = addElementsToFrame(
                    nextElements,
                    elementsToAdd,
                    topLayerFrame
                  );
                } else if (!topLayerFrame) {
                  if (this.state.editingGroupId) {
                    const elementsToRemove = selectedElements.filter(
                      (element) => element.frameId && !isElementInFrame(element, nextElements, this.state)
                    );
                    updateGroupIdsAfterEditingGroup(elementsToRemove);
                  }
                }
                nextElements = updateFrameMembershipOfSelectedElements(
                  nextElements,
                  this.state,
                  this
                );
                this.scene.replaceAllElements(nextElements);
              }
            }
            if (isFrameLikeElement(draggingElement)) {
              const elementsInsideFrame = getElementsInNewFrame(
                this.scene.getElementsIncludingDeleted(),
                draggingElement,
                this.scene.getNonDeletedElementsMap()
              );
              this.scene.replaceAllElements(
                addElementsToFrame(
                  this.scene.getElementsMapIncludingDeleted(),
                  elementsInsideFrame,
                  draggingElement
                )
              );
            }
            mutateElement(
              draggingElement,
              getNormalizedDimensions(draggingElement)
            );
          }
          if (resizingElement) {
            this.history.resumeRecording();
          }
          if (resizingElement && isInvisiblySmallElement(resizingElement)) {
            this.scene.replaceAllElements(
              this.scene.getElementsIncludingDeleted().filter((el) => el.id !== resizingElement.id)
            );
          }
          if (pointerDownState.resize.isResizing) {
            let nextElements = updateFrameMembershipOfSelectedElements(
              this.scene.getElementsIncludingDeleted(),
              this.state,
              this
            );
            const selectedFrames = this.scene.getSelectedElements(this.state).filter(
              (element) => isFrameLikeElement(element)
            );
            for (const frame of selectedFrames) {
              nextElements = replaceAllElementsInFrame(
                nextElements,
                getElementsInResizingFrame(
                  this.scene.getElementsIncludingDeleted(),
                  frame,
                  this.state,
                  elementsMap
                ),
                frame,
                this
              );
            }
            this.scene.replaceAllElements(nextElements);
          }
          const hitElement = pointerDownState.hit.element;
          if (this.state.selectedLinearElement?.elementId !== hitElement?.id && isLinearElement(hitElement)) {
            const selectedELements = this.scene.getSelectedElements(this.state);
            if (selectedELements.length === 1) {
              this.setState({
                selectedLinearElement: new LinearElementEditor(hitElement)
              });
            }
          }
          const pointerStart = this.lastPointerDownEvent;
          const pointerEnd = this.lastPointerUpEvent || this.lastPointerMoveEvent;
          if (isEraserActive(this.state) && pointerStart && pointerEnd) {
            this.eraserTrail.endPath();
            const draggedDistance = distance2d(
              pointerStart.clientX,
              pointerStart.clientY,
              pointerEnd.clientX,
              pointerEnd.clientY
            );
            if (draggedDistance === 0) {
              const scenePointer = viewportCoordsToSceneCoords(
                {
                  clientX: pointerEnd.clientX,
                  clientY: pointerEnd.clientY
                },
                this.state
              );
              const hitElements = this.getElementsAtPosition(
                scenePointer.x,
                scenePointer.y
              );
              hitElements.forEach(
                (hitElement2) => this.elementsPendingErasure.add(hitElement2.id)
              );
            }
            this.eraseElements();
            return;
          } else if (this.elementsPendingErasure.size) {
            this.restoreReadyToEraseElements();
          }
          if (hitElement && !pointerDownState.drag.hasOccurred && !pointerDownState.hit.wasAddedToSelection && // if we're editing a line, pointerup shouldn't switch selection if
          // box selected
          (!this.state.editingLinearElement || !pointerDownState.boxSelection.hasOccurred)) {
            if (childEvent.shiftKey && !this.state.editingLinearElement) {
              if (this.state.selectedElementIds[hitElement.id]) {
                if (isSelectedViaGroup(this.state, hitElement)) {
                  this.setState((_prevState) => {
                    const nextSelectedElementIds = {
                      ..._prevState.selectedElementIds
                    };
                    for (const groupedElement of hitElement.groupIds.flatMap(
                      (groupId) => getElementsInGroup(
                        this.scene.getNonDeletedElements(),
                        groupId
                      )
                    )) {
                      delete nextSelectedElementIds[groupedElement.id];
                    }
                    return {
                      selectedGroupIds: {
                        ..._prevState.selectedElementIds,
                        ...hitElement.groupIds.map((gId) => ({ [gId]: false })).reduce((prev, acc) => ({ ...prev, ...acc }), {})
                      },
                      selectedElementIds: makeNextSelectedElementIds(
                        nextSelectedElementIds,
                        _prevState
                      )
                    };
                  });
                } else if (!this.state.selectedLinearElement?.isDragging) {
                  this.setState((prevState) => {
                    const newSelectedElementIds = {
                      ...prevState.selectedElementIds
                    };
                    delete newSelectedElementIds[hitElement.id];
                    const newSelectedElements = getSelectedElements(
                      this.scene.getNonDeletedElements(),
                      { selectedElementIds: newSelectedElementIds }
                    );
                    return {
                      ...selectGroupsForSelectedElements(
                        {
                          editingGroupId: prevState.editingGroupId,
                          selectedElementIds: newSelectedElementIds
                        },
                        this.scene.getNonDeletedElements(),
                        prevState,
                        this
                      ),
                      // set selectedLinearElement only if thats the only element selected
                      selectedLinearElement: newSelectedElements.length === 1 && isLinearElement(newSelectedElements[0]) ? new LinearElementEditor(newSelectedElements[0]) : prevState.selectedLinearElement
                    };
                  });
                }
              } else if (hitElement.frameId && this.state.selectedElementIds[hitElement.frameId]) {
                this.setState((prevState) => {
                  const nextSelectedElementIds = {
                    ...prevState.selectedElementIds,
                    [hitElement.id]: true
                  };
                  delete nextSelectedElementIds[hitElement.frameId];
                  (this.scene.getElement(hitElement.frameId)?.groupIds ?? []).flatMap(
                    (gid) => getElementsInGroup(this.scene.getNonDeletedElements(), gid)
                  ).forEach((element) => {
                    delete nextSelectedElementIds[element.id];
                  });
                  return {
                    ...selectGroupsForSelectedElements(
                      {
                        editingGroupId: prevState.editingGroupId,
                        selectedElementIds: nextSelectedElementIds
                      },
                      this.scene.getNonDeletedElements(),
                      prevState,
                      this
                    ),
                    showHyperlinkPopup: hitElement.link || isEmbeddableElement(hitElement) ? "info" : false
                  };
                });
              } else {
                this.setState((_prevState) => ({
                  selectedElementIds: makeNextSelectedElementIds(
                    {
                      ..._prevState.selectedElementIds,
                      [hitElement.id]: true
                    },
                    _prevState
                  )
                }));
              }
            } else {
              this.setState((prevState) => ({
                ...selectGroupsForSelectedElements(
                  {
                    editingGroupId: prevState.editingGroupId,
                    selectedElementIds: { [hitElement.id]: true }
                  },
                  this.scene.getNonDeletedElements(),
                  prevState,
                  this
                ),
                selectedLinearElement: isLinearElement(hitElement) && // Don't set `selectedLinearElement` if its same as the hitElement, this is mainly to prevent resetting the `hoverPointIndex` to -1.
                // Future we should update the API to take care of setting the correct `hoverPointIndex` when initialized
                prevState.selectedLinearElement?.elementId !== hitElement.id ? new LinearElementEditor(hitElement) : prevState.selectedLinearElement
              }));
            }
          }
          if (!pointerDownState.drag.hasOccurred && !this.state.isResizing && (hitElement && isHittingElementBoundingBoxWithoutHittingElement(
            hitElement,
            this.state,
            this.frameNameBoundsCache,
            pointerDownState.origin.x,
            pointerDownState.origin.y,
            this.scene.getNonDeletedElementsMap()
          ) || !hitElement && pointerDownState.hit.hasHitCommonBoundingBoxOfSelectedElements)) {
            if (this.state.editingLinearElement) {
              this.setState({ editingLinearElement: null });
            } else {
              this.setState({
                selectedElementIds: makeNextSelectedElementIds({}, this.state),
                selectedGroupIds: {},
                editingGroupId: null,
                activeEmbeddable: null
              });
            }
            return;
          }
          if (!activeTool.locked && activeTool.type !== "freedraw" && draggingElement && draggingElement.type !== "selection") {
            this.setState((prevState) => ({
              selectedElementIds: makeNextSelectedElementIds(
                {
                  ...prevState.selectedElementIds,
                  [draggingElement.id]: true
                },
                prevState
              ),
              showHyperlinkPopup: isEmbeddableElement(draggingElement) && !draggingElement.link ? "editor" : prevState.showHyperlinkPopup
            }));
          }
          if (activeTool.type !== "selection" || isSomeElementSelected(this.scene.getNonDeletedElements(), this.state)) {
            this.history.resumeRecording();
          }
          if (pointerDownState.drag.hasOccurred || isResizing || isRotating) {
            isBindingEnabled(this.state) ? bindOrUnbindSelectedElements(
              this.scene.getSelectedElements(this.state),
              this.scene.getNonDeletedElements(),
              elementsMap
            ) : unbindLinearElements(
              this.scene.getSelectedElements(this.state),
              elementsMap
            );
          }
          if (activeTool.type === "laser") {
            this.laserTrails.endPath();
            return;
          }
          if (!activeTool.locked && activeTool.type !== "freedraw") {
            resetCursor(this.interactiveCanvas);
            this.setState({
              draggingElement: null,
              suggestedBindings: [],
              activeTool: updateActiveTool(this.state, { type: "selection" })
            });
          } else {
            this.setState({
              draggingElement: null,
              suggestedBindings: []
            });
          }
          if (hitElement && this.lastPointerUpEvent && this.lastPointerDownEvent && this.lastPointerUpEvent.timeStamp - this.lastPointerDownEvent.timeStamp < 300 && gesture.pointers.size <= 1 && isIframeLikeElement(hitElement) && this.isIframeLikeElementCenter(
            hitElement,
            this.lastPointerUpEvent,
            pointerDownState.origin.x,
            pointerDownState.origin.y
          )) {
            this.handleEmbeddableCenterClick(hitElement);
          }
        });
      }
      restoreReadyToEraseElements = () => {
        this.elementsPendingErasure = /* @__PURE__ */ new Set();
        this.onSceneUpdated();
      };
      eraseElements = () => {
        let didChange = false;
        const elements = this.scene.getElementsIncludingDeleted().map((ele) => {
          if (this.elementsPendingErasure.has(ele.id) || ele.frameId && this.elementsPendingErasure.has(ele.frameId) || isBoundToContainer(ele) && this.elementsPendingErasure.has(ele.containerId)) {
            didChange = true;
            return newElementWith(ele, { isDeleted: true });
          }
          return ele;
        });
        this.elementsPendingErasure = /* @__PURE__ */ new Set();
        if (didChange) {
          this.history.resumeRecording();
          this.scene.replaceAllElements(elements);
        }
      };
      initializeImage = async ({
        imageFile,
        imageElement: _imageElement,
        showCursorImagePreview = false
      }) => {
        if (!isSupportedImageFile(imageFile)) {
          throw new Error(t("errors.unsupportedFileType"));
        }
        const mimeType = imageFile.type;
        setCursor(this.interactiveCanvas, "wait");
        if (mimeType === MIME_TYPES.svg) {
          try {
            imageFile = SVGStringToFile(
              await normalizeSVG(await imageFile.text()),
              imageFile.name
            );
          } catch (error) {
            console.warn(error);
            throw new Error(t("errors.svgImageInsertError"));
          }
        }
        const fileId = await (this.props.generateIdForFile?.(
          imageFile
        ) || generateIdFromFile(imageFile));
        if (!fileId) {
          console.warn(
            "Couldn't generate file id or the supplied `generateIdForFile` didn't resolve to one."
          );
          throw new Error(t("errors.imageInsertError"));
        }
        const existingFileData = this.files[fileId];
        if (!existingFileData?.dataURL) {
          try {
            imageFile = await resizeImageFile(imageFile, {
              maxWidthOrHeight: DEFAULT_MAX_IMAGE_WIDTH_OR_HEIGHT
            });
          } catch (error) {
            console.error(
              "Error trying to resizing image file on insertion",
              error
            );
          }
          if (imageFile.size > MAX_ALLOWED_FILE_BYTES) {
            throw new Error(
              t("errors.fileTooBig", {
                maxSize: `${Math.trunc(MAX_ALLOWED_FILE_BYTES / 1024 / 1024)}MB`
              })
            );
          }
        }
        if (showCursorImagePreview) {
          const dataURL2 = this.files[fileId]?.dataURL;
          const resizedFile = dataURL2 && dataURLToFile(dataURL2);
          this.setImagePreviewCursor(resizedFile || imageFile);
        }
        const dataURL = this.files[fileId]?.dataURL || await getDataURL(imageFile);
        const imageElement = mutateElement(
          _imageElement,
          {
            fileId
          },
          false
        );
        return new Promise(
          async (resolve, reject) => {
            try {
              this.files = {
                ...this.files,
                [fileId]: {
                  mimeType,
                  id: fileId,
                  dataURL,
                  created: Date.now(),
                  lastRetrieved: Date.now()
                }
              };
              const cachedImageData = this.imageCache.get(fileId);
              if (!cachedImageData) {
                this.addNewImagesToImageCache();
                await this.updateImageCache([imageElement]);
              }
              if (cachedImageData?.image instanceof Promise) {
                await cachedImageData.image;
              }
              if (this.state.pendingImageElementId !== imageElement.id && this.state.draggingElement?.id !== imageElement.id) {
                this.initializeImageDimensions(imageElement, true);
              }
              resolve(imageElement);
            } catch (error) {
              console.error(error);
              reject(new Error(t("errors.imageInsertError")));
            } finally {
              if (!showCursorImagePreview) {
                resetCursor(this.interactiveCanvas);
              }
            }
          }
        );
      };
      /**
       * inserts image into elements array and rerenders
       */
      insertImageElement = async (imageElement, imageFile, showCursorImagePreview) => {
        if (!this.isToolSupported("image")) {
          this.setState({ errorMessage: t("errors.imageToolNotSupported") });
          return;
        }
        this.scene.addNewElement(imageElement);
        try {
          return await this.initializeImage({
            imageFile,
            imageElement,
            showCursorImagePreview
          });
        } catch (error) {
          mutateElement(imageElement, {
            isDeleted: true
          });
          this.actionManager.executeAction(actionFinalize);
          this.setState({
            errorMessage: error.message || t("errors.imageInsertError")
          });
          return null;
        }
      };
      setImagePreviewCursor = async (imageFile) => {
        const cursorImageSizePx = 96;
        const imagePreview = await resizeImageFile(imageFile, {
          maxWidthOrHeight: cursorImageSizePx
        });
        let previewDataURL2 = await getDataURL(imagePreview);
        if (imageFile.type === MIME_TYPES.svg) {
          const img = await loadHTMLImageElement(previewDataURL2);
          let height = Math.min(img.height, cursorImageSizePx);
          let width = height * (img.width / img.height);
          if (width > cursorImageSizePx) {
            width = cursorImageSizePx;
            height = width * (img.height / img.width);
          }
          const canvas2 = document.createElement("canvas");
          canvas2.height = height;
          canvas2.width = width;
          const context = canvas2.getContext("2d");
          context.drawImage(img, 0, 0, width, height);
          previewDataURL2 = canvas2.toDataURL(MIME_TYPES.svg);
        }
        if (this.state.pendingImageElementId) {
          setCursor(this.interactiveCanvas, `url(${previewDataURL2}) 4 4, auto`);
        }
      };
      onImageAction = async ({
        insertOnCanvasDirectly
      }) => {
        try {
          const clientX = this.state.width / 2 + this.state.offsetLeft;
          const clientY = this.state.height / 2 + this.state.offsetTop;
          const { x, y } = viewportCoordsToSceneCoords(
            { clientX, clientY },
            this.state
          );
          const imageFile = await fileOpen({
            description: "Image",
            extensions: Object.keys(
              IMAGE_MIME_TYPES
            )
          });
          const imageElement = this.createImageElement({
            sceneX: x,
            sceneY: y,
            addToFrameUnderCursor: false
          });
          if (insertOnCanvasDirectly) {
            this.insertImageElement(imageElement, imageFile);
            this.initializeImageDimensions(imageElement);
            this.setState(
              {
                selectedElementIds: makeNextSelectedElementIds(
                  { [imageElement.id]: true },
                  this.state
                )
              },
              () => {
                this.actionManager.executeAction(actionFinalize);
              }
            );
          } else {
            this.setState(
              {
                pendingImageElementId: imageElement.id
              },
              () => {
                this.insertImageElement(
                  imageElement,
                  imageFile,
                  /* showCursorImagePreview */
                  true
                );
              }
            );
          }
        } catch (error) {
          if (error.name !== "AbortError") {
            console.error(error);
          } else {
            console.warn(error);
          }
          this.setState(
            {
              pendingImageElementId: null,
              editingElement: null,
              activeTool: updateActiveTool(this.state, { type: "selection" })
            },
            () => {
              this.actionManager.executeAction(actionFinalize);
            }
          );
        }
      };
      initializeImageDimensions = (imageElement, forceNaturalSize = false) => {
        const image = isInitializedImageElement(imageElement) && this.imageCache.get(imageElement.fileId)?.image;
        if (!image || image instanceof Promise) {
          if (imageElement.width < DRAGGING_THRESHOLD / this.state.zoom.value && imageElement.height < DRAGGING_THRESHOLD / this.state.zoom.value) {
            const placeholderSize = 100 / this.state.zoom.value;
            mutateElement(imageElement, {
              x: imageElement.x - placeholderSize / 2,
              y: imageElement.y - placeholderSize / 2,
              width: placeholderSize,
              height: placeholderSize
            });
          }
          return;
        }
        if (forceNaturalSize || // if user-created bounding box is below threshold, assume the
        // intention was to click instead of drag, and use the image's
        // intrinsic size
        imageElement.width < DRAGGING_THRESHOLD / this.state.zoom.value && imageElement.height < DRAGGING_THRESHOLD / this.state.zoom.value) {
          const minHeight = Math.max(this.state.height - 120, 160);
          const maxHeight = Math.min(
            minHeight,
            Math.floor(this.state.height * 0.5) / this.state.zoom.value
          );
          const height = Math.min(image.naturalHeight, maxHeight);
          const width = height * (image.naturalWidth / image.naturalHeight);
          const x = imageElement.x + imageElement.width / 2 - width / 2;
          const y = imageElement.y + imageElement.height / 2 - height / 2;
          mutateElement(imageElement, { x, y, width, height });
        }
      };
      /** updates image cache, refreshing updated elements and/or setting status
          to error for images that fail during <img> element creation */
      updateImageCache = async (elements, files = this.files) => {
        const { updatedFiles, erroredFiles } = await updateImageCache({
          imageCache: this.imageCache,
          fileIds: elements.map((element) => element.fileId),
          files
        });
        if (updatedFiles.size || erroredFiles.size) {
          for (const element of elements) {
            if (updatedFiles.has(element.fileId)) {
              ShapeCache.delete(element);
            }
          }
        }
        if (erroredFiles.size) {
          this.scene.replaceAllElements(
            this.scene.getElementsIncludingDeleted().map((element) => {
              if (isInitializedImageElement(element) && erroredFiles.has(element.fileId)) {
                return newElementWith(element, {
                  status: "error"
                });
              }
              return element;
            })
          );
        }
        return { updatedFiles, erroredFiles };
      };
      /** adds new images to imageCache and re-renders if needed */
      addNewImagesToImageCache = async (imageElements = getInitializedImageElements(
        this.scene.getNonDeletedElements()
      ), files = this.files) => {
        const uncachedImageElements = imageElements.filter(
          (element) => !element.isDeleted && !this.imageCache.has(element.fileId)
        );
        if (uncachedImageElements.length) {
          const { updatedFiles } = await this.updateImageCache(
            uncachedImageElements,
            files
          );
          if (updatedFiles.size) {
            this.scene.informMutation();
          }
        }
      };
      /** generally you should use `addNewImagesToImageCache()` directly if you need
       *  to render new images. This is just a failsafe  */
      scheduleImageRefresh = throttle2(() => {
        this.addNewImagesToImageCache();
      }, IMAGE_RENDER_TIMEOUT);
      updateBindingEnabledOnPointerMove = (event) => {
        const shouldEnableBinding = shouldEnableBindingForPointerEvent(event);
        if (this.state.isBindingEnabled !== shouldEnableBinding) {
          this.setState({ isBindingEnabled: shouldEnableBinding });
        }
      };
      maybeSuggestBindingAtCursor = (pointerCoords) => {
        const hoveredBindableElement = getHoveredElementForBinding(
          pointerCoords,
          this.scene.getNonDeletedElements(),
          this.scene.getNonDeletedElementsMap()
        );
        this.setState({
          suggestedBindings: hoveredBindableElement != null ? [hoveredBindableElement] : []
        });
      };
      maybeSuggestBindingsForLinearElementAtCoords = (linearElement, pointerCoords, oppositeBindingBoundElement) => {
        if (!pointerCoords.length) {
          return;
        }
        const suggestedBindings = pointerCoords.reduce(
          (acc, coords) => {
            const hoveredBindableElement = getHoveredElementForBinding(
              coords,
              this.scene.getNonDeletedElements(),
              this.scene.getNonDeletedElementsMap()
            );
            if (hoveredBindableElement != null && !isLinearElementSimpleAndAlreadyBound(
              linearElement,
              oppositeBindingBoundElement?.id,
              hoveredBindableElement
            )) {
              acc.push(hoveredBindableElement);
            }
            return acc;
          },
          []
        );
        this.setState({ suggestedBindings });
      };
      maybeSuggestBindingForAll(selectedElements) {
        if (selectedElements.length > 50) {
          return;
        }
        const suggestedBindings = getEligibleElementsForBinding(
          selectedElements,
          this.scene.getNonDeletedElements(),
          this.scene.getNonDeletedElementsMap()
        );
        this.setState({ suggestedBindings });
      }
      clearSelection(hitElement) {
        this.setState((prevState) => ({
          selectedElementIds: makeNextSelectedElementIds({}, prevState),
          activeEmbeddable: null,
          selectedGroupIds: {},
          // Continue editing the same group if the user selected a different
          // element from it
          editingGroupId: prevState.editingGroupId && hitElement != null && isElementInGroup(hitElement, prevState.editingGroupId) ? prevState.editingGroupId : null
        }));
        this.setState({
          selectedElementIds: makeNextSelectedElementIds({}, this.state),
          activeEmbeddable: null,
          previousSelectedElementIds: this.state.selectedElementIds
        });
      }
      handleInteractiveCanvasRef = (canvas2) => {
        if (canvas2 !== null) {
          this.interactiveCanvas = canvas2;
          this.interactiveCanvas.addEventListener("wheel" /* WHEEL */, this.handleWheel);
          this.interactiveCanvas.addEventListener(
            "touchstart" /* TOUCH_START */,
            this.onTouchStart
          );
          this.interactiveCanvas.addEventListener("touchend" /* TOUCH_END */, this.onTouchEnd);
        } else {
          this.interactiveCanvas?.removeEventListener(
            "wheel" /* WHEEL */,
            this.handleWheel
          );
          this.interactiveCanvas?.removeEventListener(
            "touchstart" /* TOUCH_START */,
            this.onTouchStart
          );
          this.interactiveCanvas?.removeEventListener(
            "touchend" /* TOUCH_END */,
            this.onTouchEnd
          );
        }
      };
      handleAppOnDrop = async (event) => {
        const { file: file2, fileHandle } = await getFileFromEvent(event);
        const { x: sceneX, y: sceneY } = viewportCoordsToSceneCoords(
          event,
          this.state
        );
        try {
          if (isSupportedImageFile(file2) && this.isToolSupported("image")) {
            if (file2?.type === MIME_TYPES.png || file2?.type === MIME_TYPES.svg) {
              try {
                const scene = await loadFromBlob(
                  file2,
                  this.state,
                  this.scene.getElementsIncludingDeleted(),
                  fileHandle
                );
                this.syncActionResult({
                  ...scene,
                  appState: {
                    ...scene.appState || this.state,
                    isLoading: false
                  },
                  replaceFiles: true,
                  commitToHistory: true
                });
                return;
              } catch (error) {
                if (error.name !== "EncodingError") {
                  throw error;
                }
              }
            }
            const imageElement = this.createImageElement({ sceneX, sceneY });
            this.insertImageElement(imageElement, file2);
            this.initializeImageDimensions(imageElement);
            this.setState({
              selectedElementIds: makeNextSelectedElementIds(
                { [imageElement.id]: true },
                this.state
              )
            });
            return;
          }
        } catch (error) {
          return this.setState({
            isLoading: false,
            errorMessage: error.message
          });
        }
        const libraryJSON = event.dataTransfer.getData(MIME_TYPES.excalidrawlib);
        if (libraryJSON && typeof libraryJSON === "string") {
          try {
            const libraryItems = parseLibraryJSON(libraryJSON);
            this.addElementsFromPasteOrLibrary({
              elements: distributeLibraryItemsOnSquareGrid(libraryItems),
              position: event,
              files: null
            });
          } catch (error) {
            this.setState({ errorMessage: error.message });
          }
          return;
        }
        if (file2) {
          await this.loadFileToCanvas(file2, fileHandle);
        }
        if (event.dataTransfer?.types?.includes("text/plain")) {
          const text = event.dataTransfer?.getData("text");
          if (text && embeddableURLValidator(text, this.props.validateEmbeddable) && (/^(http|https):\/\/[^\s/$.?#].[^\s]*$/.test(text) || getEmbedLink(text)?.type === "video")) {
            const embeddable = this.insertEmbeddableElement({
              sceneX,
              sceneY,
              link: normalizeLink(text)
            });
            if (embeddable) {
              this.setState({ selectedElementIds: { [embeddable.id]: true } });
            }
          }
        }
      };
      loadFileToCanvas = async (file2, fileHandle) => {
        file2 = await normalizeFile(file2);
        try {
          const ret = await loadSceneOrLibraryFromBlob(
            file2,
            this.state,
            this.scene.getElementsIncludingDeleted(),
            fileHandle
          );
          if (ret.type === MIME_TYPES.excalidraw) {
            this.setState({ isLoading: true });
            this.syncActionResult({
              ...ret.data,
              appState: {
                ...ret.data.appState || this.state,
                isLoading: false
              },
              replaceFiles: true,
              commitToHistory: true
            });
          } else if (ret.type === MIME_TYPES.excalidrawlib) {
            await this.library.updateLibrary({
              libraryItems: file2,
              merge: true,
              openLibraryMenu: true
            }).catch((error) => {
              console.error(error);
              this.setState({ errorMessage: t("errors.importLibraryError") });
            });
          }
        } catch (error) {
          if (error instanceof ImageSceneDataError && error.code === "IMAGE_NOT_CONTAINS_SCENE_DATA" && !this.isToolSupported("image")) {
            this.setState({
              isLoading: false,
              errorMessage: t("errors.imageToolNotSupported")
            });
            return;
          }
          this.setState({ isLoading: false, errorMessage: error.message });
        }
      };
      handleCanvasContextMenu = (event) => {
        event.preventDefault();
        if (("pointerType" in event.nativeEvent && event.nativeEvent.pointerType === "touch" || "pointerType" in event.nativeEvent && event.nativeEvent.pointerType === "pen" && // always allow if user uses a pen secondary button
        event.button !== POINTER_BUTTON.SECONDARY) && this.state.activeTool.type !== "selection") {
          return;
        }
        const { x, y } = viewportCoordsToSceneCoords(event, this.state);
        const element = this.getElementAtPosition(x, y, {
          preferSelected: true,
          includeLockedElements: true
        });
        const selectedElements = this.scene.getSelectedElements(this.state);
        const isHittingCommonBoundBox = this.isHittingCommonBoundingBoxOfSelectedElements(
          { x, y },
          selectedElements
        );
        const type = element || isHittingCommonBoundBox ? "element" : "canvas";
        const container = this.excalidrawContainerRef.current;
        const { top: offsetTop, left: offsetLeft } = container.getBoundingClientRect();
        const left = event.clientX - offsetLeft;
        const top = event.clientY - offsetTop;
        trackEvent("contextMenu", "openContextMenu", type);
        this.setState(
          {
            ...element && !this.state.selectedElementIds[element.id] ? {
              ...this.state,
              ...selectGroupsForSelectedElements(
                {
                  editingGroupId: this.state.editingGroupId,
                  selectedElementIds: { [element.id]: true }
                },
                this.scene.getNonDeletedElements(),
                this.state,
                this
              ),
              selectedLinearElement: isLinearElement(element) ? new LinearElementEditor(element) : null
            } : this.state,
            showHyperlinkPopup: false
          },
          () => {
            this.setState({
              contextMenu: { top, left, items: this.getContextMenuItems(type) }
            });
          }
        );
      };
      maybeDragNewGenericElement = (pointerDownState, event) => {
        const draggingElement = this.state.draggingElement;
        const pointerCoords = pointerDownState.lastCoords;
        if (!draggingElement) {
          return;
        }
        if (draggingElement.type === "selection" && this.state.activeTool.type !== "eraser") {
          dragNewElement(
            draggingElement,
            this.state.activeTool.type,
            pointerDownState.origin.x,
            pointerDownState.origin.y,
            pointerCoords.x,
            pointerCoords.y,
            distance(pointerDownState.origin.x, pointerCoords.x),
            distance(pointerDownState.origin.y, pointerCoords.y),
            shouldMaintainAspectRatio(event),
            shouldResizeFromCenter(event)
          );
        } else {
          let [gridX, gridY] = getGridPoint(
            pointerCoords.x,
            pointerCoords.y,
            event[KEYS.CTRL_OR_CMD] ? null : this.state.gridSize
          );
          const image = isInitializedImageElement(draggingElement) && this.imageCache.get(draggingElement.fileId)?.image;
          const aspectRatio = image && !(image instanceof Promise) ? image.width / image.height : null;
          this.maybeCacheReferenceSnapPoints(event, [draggingElement]);
          const { snapOffset, snapLines } = snapNewElement(
            draggingElement,
            this.state,
            event,
            {
              x: pointerDownState.originInGrid.x + (this.state.originSnapOffset?.x ?? 0),
              y: pointerDownState.originInGrid.y + (this.state.originSnapOffset?.y ?? 0)
            },
            {
              x: gridX - pointerDownState.originInGrid.x,
              y: gridY - pointerDownState.originInGrid.y
            },
            this.scene.getNonDeletedElementsMap()
          );
          gridX += snapOffset.x;
          gridY += snapOffset.y;
          this.setState({
            snapLines
          });
          dragNewElement(
            draggingElement,
            this.state.activeTool.type,
            pointerDownState.originInGrid.x,
            pointerDownState.originInGrid.y,
            gridX,
            gridY,
            distance(pointerDownState.originInGrid.x, gridX),
            distance(pointerDownState.originInGrid.y, gridY),
            isImageElement(draggingElement) ? !shouldMaintainAspectRatio(event) : shouldMaintainAspectRatio(event),
            shouldResizeFromCenter(event),
            aspectRatio,
            this.state.originSnapOffset
          );
          this.maybeSuggestBindingForAll([draggingElement]);
          if (this.state.activeTool.type === TOOL_TYPE.frame || this.state.activeTool.type === TOOL_TYPE.magicframe) {
            this.setState({
              elementsToHighlight: getElementsInResizingFrame(
                this.scene.getNonDeletedElements(),
                draggingElement,
                this.state,
                this.scene.getNonDeletedElementsMap()
              )
            });
          }
        }
      };
      maybeHandleResize = (pointerDownState, event) => {
        const selectedElements = this.scene.getSelectedElements(this.state);
        const selectedFrames = selectedElements.filter(
          (element) => isFrameLikeElement(element)
        );
        const transformHandleType = pointerDownState.resize.handleType;
        if (selectedFrames.length > 0 && transformHandleType === "rotation") {
          return false;
        }
        this.setState({
          // TODO: rename this state field to "isScaling" to distinguish
          // it from the generic "isResizing" which includes scaling and
          // rotating
          isResizing: transformHandleType && transformHandleType !== "rotation",
          isRotating: transformHandleType === "rotation",
          activeEmbeddable: null
        });
        const pointerCoords = pointerDownState.lastCoords;
        let [resizeX, resizeY] = getGridPoint(
          pointerCoords.x - pointerDownState.resize.offset.x,
          pointerCoords.y - pointerDownState.resize.offset.y,
          event[KEYS.CTRL_OR_CMD] ? null : this.state.gridSize
        );
        const frameElementsOffsetsMap = /* @__PURE__ */ new Map();
        selectedFrames.forEach((frame) => {
          const elementsInFrame = getFrameChildren(
            this.scene.getNonDeletedElements(),
            frame.id
          );
          elementsInFrame.forEach((element) => {
            frameElementsOffsetsMap.set(frame.id + element.id, {
              x: element.x - frame.x,
              y: element.y - frame.y
            });
          });
        });
        if (!this.state.selectedElementsAreBeingDragged) {
          const [gridX, gridY] = getGridPoint(
            pointerCoords.x,
            pointerCoords.y,
            event[KEYS.CTRL_OR_CMD] ? null : this.state.gridSize
          );
          const dragOffset = {
            x: gridX - pointerDownState.originInGrid.x,
            y: gridY - pointerDownState.originInGrid.y
          };
          const originalElements = [...pointerDownState.originalElements.values()];
          this.maybeCacheReferenceSnapPoints(event, selectedElements);
          const { snapOffset, snapLines } = snapResizingElements(
            selectedElements,
            getSelectedElements(originalElements, this.state),
            this.state,
            event,
            dragOffset,
            transformHandleType
          );
          resizeX += snapOffset.x;
          resizeY += snapOffset.y;
          this.setState({
            snapLines
          });
        }
        if (transformElements(
          pointerDownState.originalElements,
          transformHandleType,
          selectedElements,
          this.scene.getElementsMapIncludingDeleted(),
          shouldRotateWithDiscreteAngle(event),
          shouldResizeFromCenter(event),
          selectedElements.length === 1 && isImageElement(selectedElements[0]) ? !shouldMaintainAspectRatio(event) : shouldMaintainAspectRatio(event),
          resizeX,
          resizeY,
          pointerDownState.resize.center.x,
          pointerDownState.resize.center.y
        )) {
          this.maybeSuggestBindingForAll(selectedElements);
          const elementsToHighlight = /* @__PURE__ */ new Set();
          selectedFrames.forEach((frame) => {
            getElementsInResizingFrame(
              this.scene.getNonDeletedElements(),
              frame,
              this.state,
              this.scene.getNonDeletedElementsMap()
            ).forEach((element) => elementsToHighlight.add(element));
          });
          this.setState({
            elementsToHighlight: [...elementsToHighlight]
          });
          return true;
        }
        return false;
      };
      getContextMenuItems = (type) => {
        const options = [];
        options.push(actionCopyAsPng, actionCopyAsSvg);
        if (type === "canvas") {
          if (this.state.viewModeEnabled) {
            return [
              ...options,
              actionToggleGridMode,
              actionToggleZenMode,
              actionToggleViewMode,
              actionToggleStats
            ];
          }
          return [
            actionPaste,
            CONTEXT_MENU_SEPARATOR,
            actionCopyAsPng,
            actionCopyAsSvg,
            copyText,
            CONTEXT_MENU_SEPARATOR,
            actionSelectAll,
            actionUnlockAllElements,
            CONTEXT_MENU_SEPARATOR,
            actionToggleGridMode,
            actionToggleObjectsSnapMode,
            actionToggleZenMode,
            actionToggleViewMode,
            actionToggleStats
          ];
        }
        options.push(copyText);
        if (this.state.viewModeEnabled) {
          return [actionCopy, ...options];
        }
        return [
          actionCut,
          actionCopy,
          actionPaste,
          actionSelectAllElementsInFrame,
          actionRemoveAllElementsFromFrame,
          CONTEXT_MENU_SEPARATOR,
          ...options,
          CONTEXT_MENU_SEPARATOR,
          actionCopyStyles,
          actionPasteStyles,
          CONTEXT_MENU_SEPARATOR,
          actionGroup,
          actionUnbindText,
          actionBindText,
          actionWrapTextInContainer,
          actionUngroup,
          CONTEXT_MENU_SEPARATOR,
          actionAddToLibrary,
          CONTEXT_MENU_SEPARATOR,
          actionSendBackward,
          actionBringForward,
          actionSendToBack,
          actionBringToFront,
          CONTEXT_MENU_SEPARATOR,
          actionFlipHorizontal,
          actionFlipVertical,
          CONTEXT_MENU_SEPARATOR,
          actionToggleLinearEditor,
          actionLink,
          actionDuplicateSelection,
          actionToggleElementLock,
          CONTEXT_MENU_SEPARATOR,
          actionDeleteSelected
        ];
      };
      handleWheel = withBatchedUpdates(
        (event) => {
          event.preventDefault();
          if (isPanning) {
            return;
          }
          const { deltaX, deltaY } = event;
          if (event.metaKey || event.ctrlKey) {
            const sign2 = Math.sign(deltaY);
            const MAX_STEP = ZOOM_STEP * 100;
            const absDelta = Math.abs(deltaY);
            let delta = deltaY;
            if (absDelta > MAX_STEP) {
              delta = MAX_STEP * sign2;
            }
            let newZoom = this.state.zoom.value - delta / 100;
            newZoom += Math.log10(Math.max(1, this.state.zoom.value)) * -sign2 * // reduced amplification for small deltas (small movements on a trackpad)
            Math.min(1, absDelta / 20);
            this.translateCanvas((state) => ({
              ...getStateForZoom(
                {
                  viewportX: this.lastViewportPosition.x,
                  viewportY: this.lastViewportPosition.y,
                  nextZoom: getNormalizedZoom(newZoom)
                },
                state
              ),
              shouldCacheIgnoreZoom: true
            }));
            this.resetShouldCacheIgnoreZoomDebounced();
            return;
          }
          if (event.shiftKey) {
            this.translateCanvas(({ zoom, scrollX }) => ({
              // on Mac, shift+wheel tends to result in deltaX
              scrollX: scrollX - (deltaY || deltaX) / zoom.value
            }));
            return;
          }
          this.translateCanvas(({ zoom, scrollX, scrollY }) => ({
            scrollX: scrollX - deltaX / zoom.value,
            scrollY: scrollY - deltaY / zoom.value
          }));
        }
      );
      getTextWysiwygSnappedToCenterPosition(x, y, appState, container) {
        if (container) {
          let elementCenterX = container.x + container.width / 2;
          let elementCenterY = container.y + container.height / 2;
          const elementCenter = getContainerCenter(
            container,
            appState,
            this.scene.getNonDeletedElementsMap()
          );
          if (elementCenter) {
            elementCenterX = elementCenter.x;
            elementCenterY = elementCenter.y;
          }
          const distanceToCenter = Math.hypot(
            x - elementCenterX,
            y - elementCenterY
          );
          const isSnappedToCenter = distanceToCenter < TEXT_TO_CENTER_SNAP_THRESHOLD;
          if (isSnappedToCenter) {
            const { x: viewportX, y: viewportY } = sceneCoordsToViewportCoords(
              { sceneX: elementCenterX, sceneY: elementCenterY },
              appState
            );
            return { viewportX, viewportY, elementCenterX, elementCenterY };
          }
        }
      }
      savePointer = (x, y, button) => {
        if (!x || !y) {
          return;
        }
        const { x: sceneX, y: sceneY } = viewportCoordsToSceneCoords(
          { clientX: x, clientY: y },
          this.state
        );
        if (isNaN(sceneX) || isNaN(sceneY)) {
        }
        const pointer = {
          x: sceneX,
          y: sceneY,
          tool: this.state.activeTool.type === "laser" ? "laser" : "pointer"
        };
        this.props.onPointerUpdate?.({
          pointer,
          button,
          pointersMap: gesture.pointers
        });
      };
      resetShouldCacheIgnoreZoomDebounced = debounce(() => {
        if (!this.unmounted) {
          this.setState({ shouldCacheIgnoreZoom: false });
        }
      }, 300);
      updateDOMRect = (cb) => {
        if (this.excalidrawContainerRef?.current) {
          const excalidrawContainer = this.excalidrawContainerRef.current;
          const {
            width,
            height,
            left: offsetLeft,
            top: offsetTop
          } = excalidrawContainer.getBoundingClientRect();
          const {
            width: currentWidth,
            height: currentHeight,
            offsetTop: currentOffsetTop,
            offsetLeft: currentOffsetLeft
          } = this.state;
          if (width === currentWidth && height === currentHeight && offsetLeft === currentOffsetLeft && offsetTop === currentOffsetTop) {
            if (cb) {
              cb();
            }
            return;
          }
          this.setState(
            {
              width,
              height,
              offsetLeft,
              offsetTop
            },
            () => {
              cb && cb();
            }
          );
        }
      };
      refresh = () => {
        this.setState({ ...this.getCanvasOffsets() });
      };
      getCanvasOffsets() {
        if (this.excalidrawContainerRef?.current) {
          const excalidrawContainer = this.excalidrawContainerRef.current;
          const { left, top } = excalidrawContainer.getBoundingClientRect();
          return {
            offsetLeft: left,
            offsetTop: top
          };
        }
        return {
          offsetLeft: 0,
          offsetTop: 0
        };
      }
      async updateLanguage() {
        const currentLang2 = languages.find((lang) => lang.code === this.props.langCode) || defaultLang;
        await setLanguage(currentLang2);
        this.setAppState({});
      }
    };
    if (define_import_meta_env_default.MODE === ENV.TEST || define_import_meta_env_default.DEV) {
      window.h = window.h || {};
      Object.defineProperties(window.h, {
        elements: {
          configurable: true,
          get() {
            return this.app?.scene.getElementsIncludingDeleted();
          },
          set(elements) {
            return this.app?.scene.replaceAllElements(elements);
          }
        }
      });
    }
    App_default = App;
  }
});

// css/app.scss
var init_app = __esm({
  "css/app.scss"() {
  }
});

// css/styles.scss
var init_styles = __esm({
  "css/styles.scss"() {
  }
});

// ../../public/fonts/fonts.css
var init_fonts = __esm({
  "../../public/fonts/fonts.css"() {
  }
});

// polyfill.ts
var polyfill, polyfill_default;
var init_polyfill = __esm({
  "polyfill.ts"() {
    "use strict";
    init_define_import_meta_env();
    polyfill = () => {
      if (!Array.prototype.at) {
        Object.defineProperty(Array.prototype, "at", {
          value: function(n) {
            n = Math.trunc(n) || 0;
            if (n < 0) {
              n += this.length;
            }
            if (n < 0 || n >= this.length) {
              return void 0;
            }
            return this[n];
          },
          writable: true,
          enumerable: false,
          configurable: true
        });
      }
      if (!Element.prototype.replaceChildren) {
        Element.prototype.replaceChildren = function(...nodes) {
          this.innerHTML = "";
          this.append(...nodes);
        };
      }
    };
    polyfill_default = polyfill;
  }
});

// components/footer/FooterCenter.scss
var init_FooterCenter = __esm({
  "components/footer/FooterCenter.scss"() {
  }
});

// components/footer/FooterCenter.tsx
import clsx48 from "clsx";
import { jsx as jsx123 } from "react/jsx-runtime";
var FooterCenter, FooterCenter_default;
var init_FooterCenter2 = __esm({
  "components/footer/FooterCenter.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_tunnels();
    init_FooterCenter();
    init_ui_appState();
    FooterCenter = ({ children }) => {
      const { FooterCenterTunnel } = useTunnels();
      const appState = useUIAppState();
      return /* @__PURE__ */ jsx123(FooterCenterTunnel.In, { children: /* @__PURE__ */ jsx123(
        "div",
        {
          className: clsx48("footer-center zen-mode-transition", {
            "layer-ui__wrapper__footer-left--transition-bottom": appState.zenModeEnabled
          }),
          children
        }
      ) });
    };
    FooterCenter_default = FooterCenter;
    FooterCenter.displayName = "FooterCenter";
  }
});

// components/ExcalidrawLogo.scss
var init_ExcalidrawLogo = __esm({
  "components/ExcalidrawLogo.scss"() {
  }
});

// components/ExcalidrawLogo.tsx
import { jsx as jsx124, jsxs as jsxs70 } from "react/jsx-runtime";
var LogoIcon, LogoText, ExcalidrawLogo;
var init_ExcalidrawLogo2 = __esm({
  "components/ExcalidrawLogo.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_ExcalidrawLogo();
    LogoIcon = () => /* @__PURE__ */ jsx124(
      "svg",
      {
        viewBox: "0 0 40 40",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        className: "ExcalidrawLogo-icon",
        children: /* @__PURE__ */ jsx124(
          "path",
          {
            d: "M39.9 32.889a.326.326 0 0 0-.279-.056c-2.094-3.083-4.774-6-7.343-8.833l-.419-.472a.212.212 0 0 0-.056-.139.586.586 0 0 0-.167-.111l-.084-.083-.056-.056c-.084-.167-.28-.278-.475-.167-.782.39-1.507.973-2.206 1.528-.92.722-1.842 1.445-2.708 2.25a8.405 8.405 0 0 0-.977 1.028c-.14.194-.028.361.14.444-.615.611-1.23 1.223-1.843 1.861a.315.315 0 0 0-.084.223c0 .083.056.166.111.194l1.09.833v.028c1.535 1.528 4.244 3.611 7.12 5.861.418.334.865.667 1.284 1 .195.223.39.473.558.695.084.11.28.139.391.055.056.056.14.111.196.167a.398.398 0 0 0 .167.056.255.255 0 0 0 .224-.111.394.394 0 0 0 .055-.167c.029 0 .028.028.056.028a.318.318 0 0 0 .224-.084l5.082-5.528a.309.309 0 0 0 0-.444Zm-14.63-1.917a.485.485 0 0 0 .111.14c.586.5 1.2 1 1.843 1.555l-2.569-1.945-.251-.166c-.056-.028-.112-.084-.168-.111l-.195-.167.056-.056.055-.055.112-.111c.866-.861 2.346-2.306 3.1-3.028-.81.805-2.43 3.167-2.095 3.944Zm8.767 6.89-2.122-1.612a44.713 44.713 0 0 0-2.625-2.5c1.145.861 2.122 1.611 2.262 1.75 1.117.972 1.06.806 1.815 1.445l.921.666a1.06 1.06 0 0 1-.251.25Zm.558.416-.056-.028c.084-.055.168-.111.252-.194l-.196.222ZM1.089 5.75c.055.361.14.722.195 1.056.335 1.833.67 3.5 1.284 4.75l.252.944c.084.361.223.806.363.917 1.424 1.25 3.602 3.11 5.947 4.889a.295.295 0 0 0 .363 0s0 .027.028.027a.254.254 0 0 0 .196.084.318.318 0 0 0 .223-.084c2.988-3.305 5.221-6.027 6.813-8.305.112-.111.14-.278.14-.417.111-.111.195-.25.307-.333.111-.111.111-.306 0-.39l-.028-.027c0-.055-.028-.139-.084-.167-.698-.666-1.2-1.138-1.731-1.638-.922-.862-1.871-1.75-3.881-3.75l-.028-.028c-.028-.028-.056-.056-.112-.056-.558-.194-1.703-.389-3.127-.639C6.087 2.223 3.21 1.723.614.944c0 0-.168 0-.196.028l-.083.084c-.028.027-.056.055-.224.11h.056-.056c.028.167.028.278.084.473 0 .055.112.5.112.555l.782 3.556Zm15.496 3.278-.335-.334c.084.112.196.195.335.334Zm-3.546 4.666-.056.056c0-.028.028-.056.056-.056Zm-2.038-10c.168.167.866.834 1.033.973-.726-.334-2.54-1.167-3.379-1.445.838.167 1.983.334 2.346.472ZM1.424 2.306c.419.722.754 3.222 1.089 5.666-.196-.778-.335-1.555-.503-2.278-.251-1.277-.503-2.416-.838-3.416.056 0 .14 0 .252.028Zm-.168-.584c-.112 0-.223-.028-.307-.028 0-.027 0-.055-.028-.055.14 0 .223.028.335.083Zm-1.089.222c0-.027 0-.027 0 0ZM39.453 1.333c.028-.11-.558-.61-.363-.639.42-.027.42-.666 0-.666-.558.028-1.144.166-1.675.25-.977.194-1.982.389-2.96.61-2.205.473-4.383.973-6.561 1.557-.67.194-1.424.333-2.066.666-.224.111-.196.333-.084.472-.056.028-.084.028-.14.056-.195.028-.363.056-.558.083-.168.028-.252.167-.224.334 0 .027.028.083.028.11-1.173 1.556-2.485 3.195-3.909 4.945-1.396 1.611-2.876 3.306-4.356 5.056-4.719 5.5-10.052 11.75-15.943 17.25a.268.268 0 0 0 0 .389c.028.027.056.055.084.055-.084.084-.168.14-.252.222-.056.056-.084.111-.084.167a.605.605 0 0 0-.111.139c-.112.111-.112.305.028.389.111.11.307.11.39-.028.029-.028.029-.056.056-.056a.44.44 0 0 1 .615 0c.335.362.67.723.977 1.028l-.698-.583c-.112-.111-.307-.083-.39.028-.113.11-.085.305.027.389l7.427 6.194c.056.056.112.056.196.056s.14-.028.195-.084l.168-.166c.028.027.083.027.111.027.084 0 .14-.027.196-.083 10.052-10.055 18.15-17.639 27.42-24.417.083-.055.111-.166.111-.25.112 0 .196-.083.251-.194 1.704-5.194 2.039-9.806 2.15-12.083v-.028c0-.028.028-.056.028-.083.028-.056.028-.084.028-.084a1.626 1.626 0 0 0-.111-1.028ZM21.472 9.5c.446-.5.893-1.028 1.34-1.5-2.876 3.778-7.65 9.583-14.408 16.5 4.607-5.083 9.242-10.333 13.068-15ZM5.193 35.778h.084-.084Zm3.462 3.194c-.027-.028-.027-.028 0-.028v.028Zm4.16-3.583c.224-.25.448-.472.699-.722 0 0 0 .027.028.027-.252.223-.475.445-.726.695Zm1.146-1.111c.14-.14.279-.334.446-.5l.028-.028c1.648-1.694 3.351-3.389 5.082-5.111l.028-.028c.419-.333.921-.694 1.368-1.028a379.003 379.003 0 0 0-6.952 6.695ZM24.794 6.472c-.921 1.195-1.954 2.778-2.82 4.028-2.736 3.944-11.532 13.583-11.727 13.75a1976.983 1976.983 0 0 1-8.042 7.639l-.167.167c-.14-.167-.14-.417.028-.556C14.49 19.861 22.03 10.167 25.074 5.917c-.084.194-.14.36-.28.555Zm4.83 5.695c-1.116-.64-1.646-1.64-1.34-2.611l.084-.334c.028-.083.084-.194.14-.277.307-.5.754-.917 1.257-1.167.027 0 .055 0 .083-.028-.028-.056-.028-.139-.028-.222.028-.167.14-.278.335-.278.335 0 1.369.306 1.76.639.111.083.223.194.335.305.14.167.363.445.474.667.056.028.112.306.196.445.056.222.111.472.084.694-.028.028 0 .194-.028.194a2.668 2.668 0 0 1-.363 1.028c-.028.028-.028.056-.056.084l-.028.027c-.14.223-.335.417-.53.556-.643.444-1.369.583-2.095.389 0 0-.195-.084-.28-.111Zm8.154-.834a39.098 39.098 0 0 1-.893 3.167c0 .028-.028.083 0 .111-.056 0-.084.028-.14.056-2.206 1.61-4.356 3.305-6.506 5.028 1.843-1.64 3.686-3.306 5.613-4.945.558-.5.949-1.139 1.06-1.861l.28-1.667v-.055c.14-.334.67-.195.586.166Z",
            fill: "currentColor"
          }
        )
      }
    );
    LogoText = () => /* @__PURE__ */ jsxs70(
      "svg",
      {
        viewBox: "0 0 450 55",
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        className: "ExcalidrawLogo-text",
        children: [
          /* @__PURE__ */ jsx124(
            "path",
            {
              d: "M429.27 96.74c2.47-1.39 4.78-3.02 6.83-4.95 1.43-1.35 2.73-2.86 3.81-4.51-.66.9-1.4 1.77-2.23 2.59-2.91 2.84-5.72 5.09-8.42 6.87h.01ZM343.6 69.36c.33 3.13.58 6.27.79 9.4.09 1.37.18 2.75.25 4.12-.12-4.46-.27-8.93-.5-13.39-.11-2.08-.24-4.16-.4-6.24-.06 1.79-.11 3.85-.13 6.11h-.01ZM378.47 98.34c.01-.37.07-1.13.01-6.51-.11 1.9-.22 3.81-.31 5.71-.07 1.42-.22 2.91-.16 4.35.39.03.78.07 1.17.1-.92-.85-.76-2.01-.72-3.66l.01.01ZM344.09 86.12c-.09-2.41-.22-4.83-.39-7.24v12.21c.15-.05.32-.09.47-.14.05-1.61-.03-3.23-.09-4.83h.01ZM440.69 66.79c-.22-.34-.45-.67-.69-.99-3.71-4.87-9.91-7.14-15.65-8.55-1.05-.26-2.12-.49-3.18-.71 2.29.59 4.48 1.26 6.64 2.02 7.19 2.54 10.57 5.41 12.88 8.23ZM305.09 72.46l1.2 3.6c.84 2.53 1.67 5.06 2.46 7.61.24.78.5 1.57.73 2.36.22-.04.44-.08.67-.12a776.9 776.9 0 0 1-5.01-13.57c-.02.04-.03.09-.05.13v-.01ZM345.49 90.25v.31c1.48-.42 3.05-.83 4.66-1.2-1.56.25-3.12.52-4.66.89ZM371.02 90.22c0-.57-.04-1.14-.11-1.71-.06-.02-.12-.04-.19-.05-.21-.05-.43-.08-.65-.11.42.16.74.88.95 1.87ZM398.93 54.23c-.13 0-.27-.01-.4-.02l.03.4c.11-.15.23-.27.37-.38ZM401.57 62.28v-.15c-1.22-.24-2.86-.61-3.23-1.25-.09-.15-.18-.51-.27-.98-.09.37-.2.73-.33 1.09 1.24.56 2.52.98 3.83 1.29ZM421.73 88.68c-2.97 1.65-6.28 3.12-9.69 3.68v.18c4.72-.14 11.63-3.85 16.33-8.38-2.04 1.75-4.33 3.24-6.63 4.53l-.01-.01ZM411.28 80.92c-.05-1.2-.09-2.4-.15-3.6-.21 5.66-.46 11.38-.47 14.51.24-.02.48-.04.71-.07.15-3.61.05-7.23-.09-10.83v-.01Z",
              transform: "translate(-144.023 -51.76)"
            }
          ),
          /* @__PURE__ */ jsx124(
            "path",
            {
              d: "M425.38 67.41c-3.5-1.45-7.19-2.57-14.06-3.62.09 1.97.06 4.88-.03 8.12.03.04.06.09.06.15.19 1.36.28 2.73.37 4.1.25 3.77.39 7.55.41 11.33 0 1.38-.01 2.76-.07 4.13 1.4-.25 2.78-.65 4.12-1.15 4.07-1.5 7.94-3.78 11.28-6.54 2.33-1.92 5.13-4.49 5.88-7.58.63-3.53-2.45-6.68-7.97-8.96l.01.02ZM411.35 92.53v-.06l-.34.03c.11.01.22.03.34.03ZM314.26 64.06c-.23-.59-.47-1.17-.7-1.75.57 1.62 1.11 3.25 1.6 4.9l.15.54 2.35 6.05c.32.82.66 1.64.98 2.46-1.38-4.1-2.83-8.17-4.39-12.2h.01ZM156.82 103.07c-.18.13-.38.23-.58.33 1.32-.03 2.66-.2 3.93-.34.86-.09 1.72-.22 2.58-.33-2.12.1-4.12.17-5.94.34h.01ZM210.14 68.88s.03.04.05.07c.18-.31.39-.64.58-.96-.21.3-.42.6-.64.89h.01ZM201.65 82.8c-.5.77-1.02 1.56-1.49 2.37 1.11-1.55 2.21-3.1 3.2-4.59-.23.23-.49.51-.75.79-.32.47-.65.95-.96 1.43ZM194.03 98.66c-.33-.4-.65-.84-1.05-1.17-.24-.2-.07-.49.17-.56-.23-.26-.42-.5-.63-.75 1.51-2.55 3.93-5.87 6.4-9.28-.17-.08-.29-.28-.2-.49.04-.09.09-.17.13-.26-1.21 1.78-2.42 3.55-3.61 5.33-.87 1.31-1.74 2.64-2.54 4-.29.5-.63 1.04-.87 1.61.81.65 1.63 1.27 2.47 1.88-.09-.11-.18-.21-.27-.32v.01ZM307.79 82.93c-1-3.17-2.05-6.32-3.1-9.48-1.62 4.08-3.69 9.17-6.16 15.19 3.32-1.04 6.77-1.87 10.27-2.5-.32-1.08-.67-2.15-1.01-3.21ZM149.5 80.7c.05-1.71.04-3.43 0-5.14-.1 2.26-.16 4.51-.22 6.77-.02.73-.03 1.46-.04 2.19.14-1.27.2-2.55.24-3.82h.02ZM228.98 98.3c.39 1.25.91 3.03.94 3.91.06-.03.12-.07.17-.1.08-1.29-.55-2.65-1.11-3.81ZM307.72 53.36c.81.5 1.53 1.04 2.07 1.49-.38-.8-.78-1.58-1.21-2.35-.17.03-.34.06-.51.11-.43.12-.86.26-1.29.41.35-.01.53.1.94.34ZM283.69 96.14c3.91-7.25 6.89-13.35 8.88-18.15l1.1-2.66c-1.27 2.64-2.56 5.27-3.83 7.9-1.53 3.15-3.06 6.31-4.58 9.47-.87 1.81-1.76 3.62-2.54 5.47.04.02.07.04.11.07.05.05.1.09.15.14.05-.73.27-1.48.71-2.24ZM289.92 103.23s-.04.01-.05.03c0-.02.04-.03.05-.04.05-.05.11-.1.16-.15l.21-.21c-.55 0-1.5-.27-2.55-.72.4.26.8.51 1.22.74.24.13.48.26.73.37.05.02.1.03.14.05a.27.27 0 0 1 .08-.07h.01ZM269.23 68.49c-.39-.19-.82-.48-1.33-.87-3.06-1.56-6.31-2.78-9.36-2.35-3.5.49-5.7 1.11-7.74 2.44 5.71-2.6 12.82-2.07 18.44.79l-.01-.01ZM177.87 53.69l1.06.03c-.96-.22-2-.25-2.89-.3-4.95-.26-9.99.33-14.86 1.19-2.44.43-4.88.95-7.28 1.59 9.09-1.76 15.69-2.77 23.97-2.51ZM219.85 55.51c-.18.12-.36.27-.56.45-.45.53-.86 1.11-1.26 1.66-1.91 2.61-3.71 5.31-5.57 7.95l-.12.18 8.05-10.11c-.18-.05-.36-.1-.55-.13h.01ZM510.71 54.1c.12-.15.29-.3.53-.45.69-.4 3.72-.63 5.87-.74-.36-.02-.73-.04-1.09-.05-1.84-.03-3.67.09-5.49.35.05.3.12.59.18.88v.01ZM510.76 86.02c1.37-3.07 2.49-6.27 3.57-9.46.55-1.64 1.12-3.3 1.6-4.97-1.59 4.01-3.67 9.14-6.2 15.3.24-.08.5-.14.74-.22.1-.22.19-.44.29-.65ZM566.95 75.76c.11-.02.23.03.31.11-.05-.13-.09-.26-.14-.39-.05.09-.11.18-.17.28ZM511.33 86.41c3.08-.89 6.24-1.62 9.46-2.14-1.51-3.98-2.98-7.96-4.39-11.87-.05.15-.09.31-.14.46-1.02 3.32-2.15 6.61-3.39 9.85-.48 1.25-.98 2.49-1.53 3.7h-.01ZM578.24 74.45c.11-.44.23-.87.35-1.31-.31.7-.64 1.39-.97 2.08.09.21.19.4.28.61.12-.46.23-.92.35-1.38h-.01ZM520.62 53.11c-.09 0-.18-.01-.28-.02.38.34.29 1.08.93 2.53l6.65 17.15c2.2 5.68 4.69 11.36 7.41 16.87l1.06 2.17c-2.95-7.05-5.92-14.08-8.87-21.13-1.58-3.79-3.16-7.59-4.7-11.4-.78-1.92-1.73-3.89-2.25-5.91-.03-.1 0-.19.04-.26h.01ZM578.78 77.87c1.45-5.77 3.07-10.43 3.58-13.36.05-.34.16-.88.31-1.55-.67 1.79-1.37 3.56-2.08 5.33-.12.43-.23.86-.35 1.29-.65 2.43-1.29 4.86-1.9 7.3.14.33.29.65.43 1l.01-.01ZM545.3 94.66c.02-.44.03-.83.05-1.12.02-1.01.05-2.02.11-3.02.03-6.66-.46-14.33-1.46-22.8-.13-.42-.27-1.24-.56-2.89 0-.02 0-.04-.01-.06.62 6.61.95 13.25 1.32 19.87.17 3.08.33 6.16.52 9.23.02.25.03.52.04.78l-.01.01ZM580.77 102.81c.13.2.27.38.37.49.27-.11.53-.22.8-.32-.43.09-.82.05-1.17-.16v-.01ZM530.48 104.07h.33c-.36-.13-.71-.32-1.04-.56.14.24.3.47.45.7.06-.08.14-.13.26-.13v-.01ZM542.63 58.82c.06.23.11.47.15.71.14-.33.36-.62.7-.86-.28.05-.57.11-.85.15ZM583.81 57.87c.15-.7.29-1.41.42-2.11-.14.45-.28.9-.42 1.34-.46 1.44-.89 2.89-1.31 4.34.44-1.19.88-2.37 1.31-3.57ZM523.62 91.48c-4.66 1.17-9.05 2.89-14.02 5.27 4.65-1.84 9.48-3.29 14.28-4.63-.09-.22-.17-.41-.26-.64ZM460.64 78.3c-.04-2.9-.11-5.81-.28-8.71-.1-1.68-.17-3.43-.5-5.09-.07.02-.14.03-.2.05.3 6.54.45 12.17.51 17.12.17-.07.34-.14.51-.2 0-1.06-.01-2.11-.03-3.17h-.01ZM470.63 63.24c-3.38-.26-6.81.32-10.1 1.1.41 2.01.47 4.14.57 6.18.18 3.55.25 7.11.27 10.67 3.31-1.38 6.5-3.12 9.3-5.35 1.96-1.56 3.86-3.41 5.02-5.66.73-1.41 1.19-3.22.26-4.65-1.09-1.7-3.46-2.14-5.32-2.29ZM460.29 63.68c1-.24 2.01-.46 3.04-.65-1.15.16-2.37.38-3.71.69v.13c.07-.02.15-.04.22-.05.11-.13.3-.18.45-.11v-.01ZM457.24 100.96c.43-.03.86-.07 1.29-.11.14-.49.27-.99.38-1.49-.44.7-1 1.23-1.67 1.6ZM482.88 104.98c-.18.23-.36.38-.55.47.14.09.27.19.4.28a70.76 70.76 0 0 0 4.37-4.63c.76-.89 1.52-1.81 2.19-2.77-.3-.27-.61-.53-.92-.79-.07 1.94-4.62 6.32-5.49 7.45v-.01Z",
              transform: "translate(-144.023 -51.76)"
            }
          ),
          /* @__PURE__ */ jsx124(
            "path",
            {
              d: "M474.36 63.31c-.4-.16-.84-.27-1.29-.37 1.56.42 3.08 1.22 3.76 2.74.62 1.4.32 2.95-.28 4.32.7-1.22.94-2.34.74-3.47-.24-1.33-1.19-2.54-2.93-3.21v-.01ZM477.34 89.18c-1.2-.81-2.4-1.62-3.6-2.42-.14.1-.26.19-.4.29 1.4.67 2.73 1.39 4 2.13ZM465.88 93.85c.37.25.74.5 1.1.75.46.32.92.65 1.38.97-1.57-1.2-2.01-1.61-2.49-1.72h.01ZM574.92 90.06c-2.28-5.21-4.93-11.13-5.67-12.26-.1-.15-1.57-3.01-1.63-3.08 0 0-.01.02-.02.02.4 1.37 1.09 2.69 1.65 3.99 2.14 4.95 4.36 9.86 6.67 14.73.6 1.26 1.21 2.52 1.83 3.78-.75-2.01-1.64-4.45-2.83-7.18ZM448.73 65.29c.1.2.22.38.34.57.22-.02.43-.06.65-.08v-.08c-.14-.05-.25 0-.99-.41ZM460.16 94.81c-.02.31-.06.59-.1.89-.03 1.71-.33 3.43-.79 5.07.15-.02.3-.03.45-.05.01-.04.02-.08.03-.11.09-.34.15-.69.2-1.03.17-1.07.25-2.16.33-3.24.05-.69.08-1.39.12-2.08-.27.1-.27.26-.24.57v-.02Z",
              transform: "translate(-144.023 -51.76)"
            }
          ),
          /* @__PURE__ */ jsx124(
            "path",
            {
              d: "m328.67 98.12-3.22-6.58c-1.29-2.63-2.53-5.29-3.72-7.97-.25-.85-.52-1.69-.79-2.53-.81-2.57-1.67-5.12-2.55-7.67-1.92-5.53-3.9-11.08-6.32-16.41-.72-1.58-1.46-3.44-2.63-4.79-.03-.17-.16-.29-.34-.36a.282.282 0 0 0-.23-.04c-.06-.01-.12 0-.18.01-.74.06-1.5.38-2.19.61-2.22.77-4.4 1.64-6.63 2.38-.03-.08-.06-.16-.09-.25-.15-.42-.82-.24-.67.19.03.09.07.19.1.28l-.18.06c-.36.11-.28.6 0 .68.18 1.18.63 2.36.98 3.49.03.09.06.17.08.26-.08.23-.17.46-.24.64-.37.98-.79 1.94-1.21 2.9-1.27 2.89-2.62 5.75-3.98 8.6-3.18 6.67-6.44 13.31-9.64 19.97-1.08 2.25-2.2 4.5-3.15 6.81-.13.32.24.5.5.37 1.34 1.33 2.84 2.5 4.4 3.57.65.44 1.31.87 2.01 1.24.4.22.86.48 1.33.5.24.01.35-.19.33-.37.11-.1.21-.21.28-.28.41-.41.81-.84 1.2-1.26.85-.92 1.69-1.87 2.5-2.84 6.31-2.34 12.6-4.31 18.71-5.84 2.14 5.3 3.43 8.43 3.97 9.58.55 1.05 1.15 1.88 1.82 2.52 1.32.56 6.96-.03 9.23-1.96.87-1.28 1.19-2.67.93-4.15-.09-.5-.22-.95-.4-1.33l-.01-.03Zm-20.09-45.61c.43.77.83 1.56 1.21 2.35-.54-.45-1.27-.99-2.07-1.49-.42-.24-.6-.35-.94-.34.43-.15.85-.29 1.29-.41.17-.05.34-.08.51-.11Zm-25.86 45.66c.78-1.85 1.67-3.66 2.54-5.47 1.51-3.16 3.05-6.31 4.58-9.47 1.28-2.63 2.56-5.26 3.83-7.9l-1.1 2.66c-1.99 4.79-4.97 10.9-8.88 18.15-.43.76-.66 1.51-.71 2.24-.05-.05-.1-.09-.15-.14a.259.259 0 0 0-.11-.07Zm6.24 4.71c-.42-.23-.82-.48-1.22-.74 1.05.45 2 .72 2.55.72l-.21.21c-.05.05-.11.1-.16.15-.01.01-.04.03-.05.04 0-.02.03-.02.05-.03a.27.27 0 0 0-.08.07c-.05-.02-.1-.03-.14-.05-.25-.1-.49-.24-.73-.37h-.01Zm15.73-29.43c1.05 3.15 2.1 6.31 3.1 9.48.34 1.06.69 2.13 1.01 3.21-3.5.63-6.95 1.46-10.27 2.5 2.48-6.03 4.54-11.11 6.16-15.19Zm4.79 12.57c-.23-.79-.49-1.58-.73-2.36-.79-2.54-1.63-5.08-2.46-7.61l-1.2-3.6c.02-.04.04-.09.05-.13 1.6 4.45 3.28 9 5.01 13.57l-.67.12v.01Zm5.83-18.27-.15-.54c-.49-1.64-1.03-3.28-1.6-4.9.23.58.47 1.17.7 1.75 1.56 4.03 3.01 8.1 4.39 12.2-.33-.82-.67-1.64-.98-2.46l-2.35-6.05h-.01ZM390.43 79.37c-.13-10.43-.22-17.5-.24-19.97-.24-1.6.21-2.88-.65-3.65-.14-.13-.32-.23-.52-.32h.03c.45 0 .45-.69 0-.7-1.75-.03-3.5-.04-5.25-.14-1.38-.08-2.76-.21-4.15-.31-.07 0-.12.01-.17.04-.21-.07-.47.03-.45.31l.03.45c-.11.14-.19.3-.22.5-.21 1.26-.32 13.67-.36 23.59-.32 5.79-.67 11.57-.97 17.36-.09 1.73-.29 3.54-.21 5.3-.39.02-.38.64.04.69v.12c.05.44.74.45.7 0v-.06c1.1.09 2.2.21 3.3.3 1.14.19 2.44.2 3.29.17 1.73-.05 2.92-.05 3.8-.37.45-.05.9-.11 1.35-.17.44-.06.25-.73-.19-.67h-.01c.24-.32.45-.72.62-1.25.66-1.84.41-6.36.34-11.33l-.13-9.9.02.01Zm-12.26 18.17c.09-1.91.2-3.81.31-5.71.06 5.38 0 6.14-.01 6.51-.05 1.65-.21 2.81.72 3.66-.39-.04-.78-.07-1.17-.1-.06-1.44.09-2.93.16-4.35l-.01-.01ZM588.97 53.85c-2.06-.25-3.17-.51-3.76-.6a.3.3 0 0 1 .04-.08c.22-.39-.39-.75-.6-.35-.56 1.02-.9 2.19-1.26 3.29-.61 1.88-1.17 3.78-1.72 5.68-.63 2.19-1.24 4.39-1.83 6.59-.81 2.03-1.67 4.05-2.61 6.03-1.7-3.64-3.11-6.04-4.03-7.57-2.26-3.74-2.85-5.48-3.57-6.08l.31-.09c.43-.12.25-.8-.19-.67-1.06.3-2.12.6-3.17.95-.93.32-1.85.69-2.76 1.07-.13.05-.19.16-.22.27-.04.02-.08.05-.11.07-.04-.06-.07-.12-.11-.18a.354.354 0 0 0-.48-.12c-.16.09-.22.32-.13.48l.33.54c0 .09.02.18.06.28.51 1.16.78 1.38.72 1.47-2.42 3.44-5.41 7.86-6.2 9.1-1.27 1.97-2.01 3.14-2.45 3.84l-.91-6.56-.43-4.1c-.19-1.85-.37-3.23-.53-4.13-.19-1.1-.3-2.15-.45-3.16-.2-1.36-.29-2.06-.47-2.42h.04c.45.02.45-.68 0-.7-3.43-.16-6.81.94-10.17 1.48-.24-.22-.73-.04-.58.32.24.59.33 1.25.43 1.87.17 1.06.29 2.13.4 3.2.32 3.09.53 6.2.74 9.3.44 6.75.77 13.51 1.17 20.26.11 1.95.13 3.96.46 5.89.05.3.37.31.55.14.74 1.71 2.87 1.27 6.13 1.27 1.34 0 2.39.04 2.99-.11.02.32.48.53.63.18 3.61-8.26 7.41-16.46 12.05-24.2.03-.05.04-.1.05-.15.3.73.64 1.45.94 2.16.97 2.26 1.97 4.52 2.98 6.76 2.26 5.03 4.54 10.07 7.09 14.96.47.9.94 1.79 1.47 2.65.2.32.4.67.66.96-.18.25 0 .68.34.54.91-.38 1.82-.75 2.76-1.07 1.04-.35 2.11-.65 3.17-.95.39-.11.28-.66-.07-.68.62-.4.95-.96.87-1.91-.3-3.34.72-7.47.86-8.52l2.14-11.43c1.75-10.74 3.13-17.51 3.23-20.86.02-.49.08-2.84.13-3.24.17-1.25.48-1-4.96-1.65l.03-.02Zm-46.19 5.67c-.04-.24-.09-.48-.15-.71l.85-.15c-.34.24-.56.53-.7.86Zm1.95 25.12c-.36-6.63-.7-13.26-1.32-19.87 0 .02 0 .04.01.06.29 1.65.44 2.47.56 2.89 1 8.46 1.5 16.14 1.46 22.8-.06.99-.1 2-.11 3.02-.01.29-.03.68-.05 1.12-.01-.26-.03-.53-.04-.78-.19-3.08-.35-6.16-.52-9.23l.01-.01Zm36.4 18.66c-.11-.11-.24-.29-.37-.49.35.21.74.26 1.17.16-.27.11-.53.22-.8.32v.01Zm-.89-33.72c.12-.43.23-.86.35-1.29.71-1.77 1.41-3.55 2.08-5.33-.15.68-.26 1.22-.31 1.55-.5 2.94-2.13 7.59-3.58 13.36-.15-.35-.29-.66-.43-1 .61-2.44 1.25-4.87 1.9-7.3l-.01.01Zm3.56-12.48c.14-.44.28-.89.42-1.34-.13.7-.27 1.41-.42 2.11-.43 1.19-.86 2.38-1.31 3.57.42-1.45.85-2.9 1.31-4.34Zm-5.22 16.05c-.11.44-.23.87-.35 1.31-.12.46-.23.92-.35 1.38-.1-.22-.19-.4-.28-.61.34-.69.66-1.38.97-2.08h.01Zm-11.64 2.62c.06-.1.12-.19.17-.28.05.13.09.26.14.39a.398.398 0 0 0-.31-.11Zm2.3 2.98c-.56-1.3-1.25-2.63-1.65-3.99 0 0 .01-.02.02-.02.06.08 1.52 2.93 1.63 3.08.73 1.13 3.38 7.04 5.67 12.26 1.2 2.73 2.08 5.17 2.83 7.18-.62-1.25-1.23-2.51-1.83-3.78-2.31-4.87-4.53-9.78-6.67-14.73ZM275.92 87.03c-1.06-2.18-1.13-3.45-2.44-2.93-1.52.57-2.94 1.3-4.5 2.1-1.4.72-2.68 1.44-3.92 2.12.01-.25-.24-.5-.51-.34-4.8 2.93-12.41 4.7-17.28 1.31-1.98-1.77-3.32-4.15-3.97-5.78-.29-.95-.49-1.94-.63-2.93-.14-3.34 1.58-6.53 3.9-9.12.8-.79 1.68-1.51 2.66-2.12 3.7-2.3 8.22-3.07 12.51-2.51 2.71.35 5.32 1.24 7.71 2.55.39.22.75-.39.35-.6-.18-.1-.37-.18-.55-.27.56.27 1.03.33 1.51.19l-.48.39c-.15.11-.23.3-.13.48.09.15.33.24.48.13 1.3-.97 2.46-2.09 3.45-3.37.37-.29.64-.6.65-.97v-.02c.08-.33-.03-.7-.21-1.08-.31-.87-.98-2.01-2.19-3.26-2.43-2.52-3.79-3.45-5.68-4.26-1.14-.49-3.12-1.06-4.42-1.23-3.28-.42-10.64-1.21-18.18 4.11-7.74 5.46-11.94 12.3-12.23 20.61-.08 2.06.04 3.98.34 5.71.74 4.18 2.57 8 5.44 11.34 4.26 4.99 9.76 7.52 16.34 7.52 4.85 0 9.69-1.77 14.89-4.62.23-.12.45-.23.68-.35 2.19-1.1 4.37-2.23 6.46-3.5.49-.3 1.03-.61 1.5-.98 1.47-.87 1.11-1.12.49-2.95-.39-1.14-.76-2.7-2.06-5.36l.02-.01Zm-17.38-21.76c3.05-.42 6.31.79 9.36 2.35.51.39.94.68 1.33.87-5.61-2.86-12.72-3.39-18.44-.79 2.05-1.33 4.24-1.95 7.74-2.44l.01.01ZM443.67 72.67c-.4-2.2-1.15-4.33-2.37-6.22-1.49-2.32-3.58-4.19-5.91-5.64-6.17-3.81-13.75-5.11-20.83-6.01-3.23-.41-6.47-.69-9.72-.92l-1.39-.12c-.85-.07-1.52-.1-2.05-.1-1.08-.06-2.17-.12-3.25-.17-.08 0-.14.02-.19.05-.1.05-.18.14-.16.3.27 2.55-.01 5.12-.92 7.52-.15.38.4.56.62.28 1.32.59 2.68 1.05 4.08 1.37 0 2.78-.14 7.58-.33 12.91 0 0 0 .02-.01.03-.61 3.66-.79 7.42-1 11.12-.23 4.01-.43 8.03-.44 12.05 0 .64 0 1.28.03 1.93.02.31 0 .68.15.96.06.11.14.16.24.17-.2.17-.21.54.11.59 3.83.67 7.78.71 11.68.25 2.3-.19 4.87-.65 7.65-1.56 1.85-.54 3.67-1.18 5.43-1.91 7.2-3.02 14.31-8.07 17.35-15.53.76-1.86 1.17-3.8 1.31-5.75.3-1.93.28-3.82-.09-5.58l.01-.02Zm-19.32-15.42c5.74 1.41 11.94 3.68 15.65 8.55.25.32.47.65.69.99-2.3-2.82-5.68-5.69-12.88-8.23-2.16-.76-4.35-1.43-6.64-2.02 1.06.21 2.13.45 3.18.71Zm-25.82-3.04c.13 0 .27.01.4.02-.14.1-.26.23-.37.38 0-.13-.02-.26-.03-.4Zm34.82 22.17c-.75 3.09-3.55 5.66-5.88 7.58-3.35 2.76-7.21 5.03-11.28 6.54-1.33.49-2.71.9-4.12 1.15.06-1.38.08-2.76.07-4.13-.02-3.78-.16-7.56-.41-11.33-.09-1.37-.18-2.74-.37-4.1 0-.06-.03-.11-.06-.15.09-3.25.12-6.16.03-8.12 6.86 1.05 10.56 2.17 14.06 3.62 5.52 2.28 8.59 5.44 7.97 8.96l-.01-.02Zm-22 16.15c-.12 0-.23-.02-.34-.03l.34-.03v.06Zm-.69-.7c0-3.13.26-8.84.47-14.51.06 1.2.11 2.41.15 3.6.15 3.6.25 7.23.09 10.83-.24.03-.48.05-.71.07v.01Zm-12.33-30.94c.37.63 2.01 1.01 3.23 1.25v.15c-1.31-.31-2.59-.73-3.83-1.29.12-.36.23-.72.33-1.09.08.48.18.84.27.98Zm13.7 31.65v-.18c3.41-.56 6.71-2.02 9.69-3.68 2.31-1.28 4.59-2.78 6.63-4.53-4.69 4.53-11.61 8.24-16.33 8.38l.01.01Zm24.07-.75c-2.05 1.93-4.37 3.56-6.83 4.95 2.7-1.78 5.52-4.03 8.42-6.87.82-.82 1.56-1.69 2.23-2.59-1.08 1.65-2.38 3.16-3.81 4.51h-.01ZM187.16 92.14c-.79-2.47-2.1-7.12-3.1-6.87-.19-.01-2.09.77-4.08 1.54-3.06 1.18-5.91 2.13-10.09 2.82-2.74.42-5.87 1.01-10.61 1.06.04-3.34.05-6.01.05-7.99 7.97-.65 12.33-2.11 16.37-3.55 1.11-.39 2.69-1.01 2.63-1.8-.08-.35-.55-1.39-1.17-2.61-.47-1.16-.98-2.31-1.61-3.38-.42-.71-1.04-1.69-1.86-2.06-.11-.08-.22-.13-.29-.12-.02 0-.04 0-.07.01-.19-.04-.39-.05-.6-.01-.17.03-.24.15-.25.28-.04.02-.09.04-.14.05-4.33 1.48-8.85 2.33-13.24 3.61a499.1 499.1 0 0 0-.31-8.19c4.51-.99 8.88-1.38 13.11-1.82 3.68-.38 6.28.12 7.47.34.59.11.9.16 1.16.18h.1c-.1.37.44.66.62.28.02-.04.03-.08.05-.13.15.2.53.22.62-.1.17-.58.19-1.21.21-1.81v-.36c.03-.15.05-.3.07-.45.52-2.47.33-5.09-.64-7.44-.11-.27-.44-.28-.6-.14-.08-.21-.15-.42-.24-.62-.19-.41-.79-.05-.6.35.03.07.05.15.09.22-.98-.42-2.15-.54-3.17-.63-2.17-.19-4.37-.14-6.54 0-5.7.35-11.4 1.3-16.91 2.79-2.08.56-4.13 1.22-6.14 2-4.54 1.05-3.79 1.51-2.17 6.07.18.51.46 1.68.54 1.94.82 2.47 1.08 2.13 3.1 2.13s0 .05 0 .08h.52c-.48 2.66-.51 5.45-.62 8.13-.15 3.48-.22 6.96-.28 10.45 0 .41-.01.82-.02 1.23-.16.29-.33.57-.51.85-.05.38-.09.77-.14 1.18-.42 3.52-.59 6.48-.52 8.8v.34c.02.47.05.76.06.87.16 1.57-.26 3.47 1.35 3.79 1.61.32 3.5.55 4.85.55.11 0 .22-.02.33-.02 1.79.24 3.67.05 5.45-.12 2.85-.28 5.69-.7 8.51-1.19 3.03-.53 6.05-1.14 9.04-1.86 2.4-.58 4.82-1.19 7.13-2.06.51-.19 1.73-.57 2.46-1.14 1.81-.68 2.18-1 1.57-2.67-.23-.62-.48-1.49-.91-2.78l-.03-.02Zm-11.12-38.71c.89.05 1.93.08 2.89.3-.33 0-.68-.02-1.06-.03-8.28-.26-14.88.75-23.97 2.51 2.41-.64 4.85-1.16 7.28-1.59 4.87-.86 9.91-1.45 14.86-1.19Zm-26.53 22.13c.03 1.71.04 3.43 0 5.14-.04 1.27-.11 2.55-.24 3.82 0-.73.02-1.46.04-2.19.05-2.26.12-4.51.22-6.77h-.02Zm6.73 27.85c.2-.1.4-.21.58-.33 1.82-.17 3.82-.24 5.94-.34-.86.11-1.72.24-2.58.33-1.27.14-2.61.31-3.93.34h-.01ZM534.48 85.44c-3.52-8.38-7.07-16.75-10.5-25.17-.63-1.54-1.25-3.09-1.86-4.65-.31-.8-.65-1.6-.87-2.43-.04-.17-.17-.24-.31-.25.1-.2 0-.51-.29-.53-1.59-.08-3.18-.22-4.78-.25-1.96-.03-3.91.13-5.84.42-.31.05-.31.38-.13.56-.03.06-.05.14-.04.22.23 1.54.63 3.06 1.16 4.53.13.35.27.7.41 1.06l-2.68 6.18c-.11.03-.2.09-.25.22-.67 1.9-1.52 3.73-2.34 5.56a536.85 536.85 0 0 1-3.9 8.45c-2.64 5.64-5.34 11.25-7.91 16.93-.44.97-.88 1.94-1.29 2.93-.2.48-.47 1-.55 1.52v.05c-.02.12.02.26.16.34 1.19.73 2.41 1.41 3.66 2.05 1.2.62 2.45 1.25 3.76 1.61.43.12.62-.55.19-.67-1.13-.31-2.2-.83-3.24-1.36 1.09.36 2.1.69 2.75.93 2.82 1.01 2.38 1.1 4.3-3.75 2.1-1.09 4.34-1.96 6.53-2.79 4.35-1.64 8.8-3.03 13.27-4.29.82 2.01 1.77 3.97 2.72 5.92.35.83.62 1.45.79 1.82.22.42.45.8.69 1.15.17.33.33.67.5 1 .42.8.84 1.63 1.4 2.35.23.29.6 0 .55-.31 1.53-.02 3.06-.07 4.58-.27.92-.12 1.82-.32 2.71-.54 1.39-.27 3.85-1.11 3.74-1.42-.67-1.96-1.55-3.87-2.34-5.78-1.57-3.78-3.16-7.56-4.75-11.33v-.01Zm-11.65-26.16c1.54 3.81 3.12 7.6 4.7 11.4 2.94 7.05 5.91 14.09 8.87 21.13l-1.06-2.17c-2.71-5.51-5.2-11.19-7.41-16.87l-6.65-17.15c-.65-1.45-.55-2.19-.93-2.53.09 0 .18.01.28.02a.29.29 0 0 0-.04.26c.52 2.02 1.47 3.98 2.25 5.91h-.01Zm-6.58 13.58c.05-.15.09-.31.14-.46 1.41 3.92 2.88 7.9 4.39 11.87-3.22.52-6.38 1.25-9.46 2.14.55-1.22 1.05-2.46 1.53-3.7 1.24-3.24 2.37-6.53 3.39-9.85h.01Zm-.23-20c.36 0 .73.03 1.09.05-2.15.1-5.18.33-5.87.74-.24.15-.41.3-.53.45-.06-.29-.13-.58-.18-.88 1.82-.26 3.65-.39 5.49-.35v-.01Zm-.09 18.72c-.49 1.67-1.05 3.33-1.6 4.97-1.07 3.19-2.19 6.38-3.57 9.46-.09.21-.19.43-.29.65-.25.07-.5.14-.74.22 2.53-6.16 4.61-11.29 6.2-15.3Zm-6.34 25.16c4.97-2.38 9.37-4.1 14.02-5.27l.26.64c-4.8 1.35-9.63 2.8-14.28 4.63Zm20.17 6.76c.33.23.68.42 1.04.56h-.33c-.12 0-.21.06-.26.13-.15-.23-.31-.45-.45-.7v.01ZM226.57 91.75c-3.55-4.74-6.68-9.11-9.31-12.99 9.2-15.25 10.05-17.81 10.35-18.38.17-.34 1.09-2.27.64-2.53-1.13-.65-1.03-.65-2.97-1.71-1.19-.65-3.04-1.61-4.53-2.12-1.71-.59-1.24-.36-3 2.77-.06.1-.11.2-.17.3-.75 1.02-1.48 2.05-2.2 3.09-1.88 2.71-3.73 5.45-5.69 8.1-3.68-4.91-6.88-8.76-9.51-11.43-.15-.15-.3-.29-.46-.42-1.27-1.28-7.24 3.53-7.93 5.58-.09.09-.19.16-.28.25-.27.26.03.64.33.58.19.65.5 1.29.94 1.91 3.85 5.06 7.19 9.76 9.94 14-1.23 2.61-3.06 5-4.67 7.38l-2.28 3.33c-.5.66-.93 1.23-1.29 1.69-.67.93-2.09 2.61-2.3 3.87-.51.85-1.16 1.84-1.29 2.83-.06.44.61.63.67.19.01-.08.04-.15.06-.22 1.36 1.08 2.76 2.11 4.19 3.11 1.3.91 2.62 1.85 4.04 2.56.21.1.4 0 .48-.17.24.07.48.14.72.2.44.1.62-.57.19-.67-2.02-.48-3.77-1.57-5.23-3.02-.47-.46-.9-.96-1.32-1.46 1.74 1.35 4.2 2.89 5.89 4.14 1.39 1.03 2.85-2.27 4.22-4.2 1.86-2.64 3.96-5.86 5.52-8.29l10.39 14.51c.67.81 1.14 1.21 1.57 1.36-.05.24.12.51.41.4 1.53-.58 3.05-1.19 4.54-1.87 1.52-.69 3.06-1.45 4.36-2.5a.28.28 0 0 0 .12-.23c1.66-1.1.81-1.74-1.41-4.91-1.13-1.58-1.71-2.36-3.7-5.01l-.03-.02Zm2.41 6.54c.56 1.15 1.19 2.52 1.11 3.81-.06.04-.12.07-.17.1-.03-.88-.55-2.66-.94-3.91Zm-16.51-32.73c1.86-2.65 3.65-5.35 5.57-7.95.4-.55.81-1.13 1.26-1.66.19-.18.38-.33.56-.45.18.03.36.08.55.13l-8.05 10.11.12-.18h-.01ZM192.7 95.48c.79-1.37 1.66-2.69 2.54-4 1.19-1.79 2.4-3.56 3.61-5.33-.04.09-.09.17-.13.26-.1.22.03.41.2.49-2.47 3.42-4.89 6.73-6.4 9.28.21.24.4.48.63.75-.24.07-.4.36-.17.56.4.33.72.77 1.05 1.17.09.11.18.21.27.32-.84-.61-1.66-1.24-2.47-1.88.24-.57.58-1.11.87-1.61v-.01Zm7.46-10.32c.47-.81.98-1.59 1.49-2.37.31-.48.64-.95.96-1.43.26-.29.52-.56.75-.79-.99 1.48-2.09 3.03-3.2 4.59Zm10.03-16.22s-.03-.05-.05-.07c.22-.29.43-.59.64-.89-.2.32-.4.65-.58.96h-.01ZM371.54 87.96c-.01-.08-.01-.16-.03-.23-.06-.38-.58-.29-.66.03-.3-.05-.6-.08-.81-.11-1.14-.15-2.29-.19-3.44-.2 1.04-.09 2.09-.18 3.14-.23.45-.02.45-.72 0-.7-6.57.35-13.14 1.23-19.65 2.11-1.53.21-3.05.42-4.57.68-.01 0-.02.01-.04.01-.04-3.33-.13-6.66-.24-9.99-.19-5.7-.4-11.41-.88-17.1-.13-1.51-.23-3.07-.49-4.58 0-.25 0-.48-.02-.68-.06-1.19-.04-2.61-.68-2.78-.16-.07-.72-.16-1.5-.24.22-.17.16-.62-.2-.63-1.19-.04-2.39.09-3.57.23-1.2.14-2.41.32-3.59.6-.16-.1-.41-.06-.5.12-.06.02-.13.03-.19.05-.35.1-.29.55-.03.66-.26.6-.19 2.27-.21 3-.02.66-.66 33.73-.9 40.3-.03.65.06 1.12.04 1.45-.16 3.05.87 4.96 6.34 3.93 1.09-.08 2.75-.77 5.36-1.43 4.13-1.04 5.78-1.52 6.2-1.65 6.43-1.69 6.78-1.97 11.72-2.43.55-.05 4.8-.38 6.03-.3.64.04 1.19.07 1.65.1.09 0 .16-.03.24-.05.1.27.56.33.66-.02.39-1.32.61-2.71.78-4.08.2-1.61.29-3.24.15-4.86.24.03.52-.23.38-.53-.09-.2-.27-.33-.49-.43v-.02Zm-.63.56c.07.57.11 1.14.11 1.71-.21-.99-.53-1.71-.95-1.87.22.03.44.06.65.11.06.01.12.04.19.05Zm-25.41 1.73c1.54-.36 3.1-.64 4.66-.89-1.61.37-3.18.77-4.66 1.2v-.31Zm-.86-7.37c-.07-1.37-.16-2.75-.25-4.12-.21-3.13-.45-6.27-.79-9.4.02-2.25.08-4.31.13-6.11.16 2.08.29 4.16.4 6.24.23 4.46.38 8.93.5 13.39h.01Zm-.94-4c.16 2.41.29 4.83.39 7.24.06 1.6.14 3.22.09 4.83-.15.05-.32.09-.47.14V78.88h-.01ZM483.72 92.83c-3.05-2.28-6.22-4.4-9.38-6.51 8.86-6.49 13.49-12.95 13.73-19.23.04-.76 0-1.5-.13-2.2-.67-3.82-3.5-6.68-8.39-8.48.13.04.27.08.4.13 3.92 1.39 7.74 4.23 8.5 8.56.34 1.95-.05 3.96-.98 5.69-.21.4.39.75.6.35 1.86-3.46 1.46-7.55-.97-10.63-3.53-4.47-9.76-5.88-15.16-6.16-2.32-.12-4.64-.04-6.95.19-6 .32-12.71 1.68-17.63 3.21-.37.11-.67.23-.92.35-.2-.17-.62.02-.57.37v.03c-.64.68-.18 1.64.48 3.21.38.91.67 1.89 1.15 2.58.32.76.68 1.51 1.13 2.19.14.21.38.19.53.07.19-.02.38-.05.57-.08v1.57c-.06.06-.1.13-.11.23-.27 4.18-.34 8.38-.48 12.57l-.3 9.03c-.24 3.91-.44 6.77-.46 7.26-.05.88-.11 1.95.07 2.81-.01.22-.02.43-.04.65 0 .11-.02.23-.03.35 0 .05-.03.27-.01.16-.05.4.5.59.64.28.05.04.12.08.2.08 1.75.13 3.5.28 5.25.3 1.69.02 3.38-.12 5.06-.32.08.23.36.39.55.15.06-.08.11-.17.16-.26.18-.09.24-.32.18-.48.05-.2.1-.4.13-.6.16-.86.25-1.74.33-2.62.11-1.17.17-2.34.23-3.51.15-.01.32-.03.52-.04.36-.03 1.73-.15 2.06-.15.39 0 .7-.02.95-.04 1.76 1.11 3.45 2.35 5.14 3.55 2.83 2.01 5.64 4.04 8.47 6.04 1.42 1 2.85 2 4.29 2.97.1.06.19.07.27.04.08 0 .17-.02.25-.1 1.61-1.56 3.15-3.18 4.6-4.88.75-.88 1.49-1.78 2.15-2.73.01.01.03.02.04.03.34.3.83-.2.49-.49-2.16-1.9-4.34-3.76-6.64-5.48l.03-.01Zm-6.38-3.65a55.72 55.72 0 0 0-4-2.13c.14-.1.26-.19.4-.29 1.2.81 2.4 1.61 3.6 2.42Zm-20.1 11.78c.67-.37 1.23-.91 1.67-1.6-.11.5-.24 1-.38 1.49-.43.04-.86.08-1.29.11Zm2.38-37.24c1.34-.31 2.56-.52 3.71-.69-1.03.19-2.04.41-3.04.65-.14-.07-.34-.02-.45.11-.07.02-.15.04-.22.05v-.13.01Zm.04.84c.07-.02.14-.03.2-.05.34 1.66.41 3.41.5 5.09.17 2.9.24 5.81.28 8.71l.03 3.17c-.17.07-.34.14-.51.2-.06-4.96-.21-10.58-.51-17.12h.01Zm16.04 5.62c-1.16 2.25-3.06 4.1-5.02 5.66-2.8 2.23-5.99 3.97-9.3 5.35-.01-3.56-.09-7.12-.27-10.67-.1-2.04-.16-4.16-.57-6.18 3.3-.78 6.72-1.36 10.1-1.1 1.85.14 4.23.59 5.32 2.29.92 1.43.46 3.24-.26 4.65Zm.85-.18c.6-1.37.9-2.92.28-4.32-.67-1.52-2.2-2.32-3.76-2.74.46.1.89.21 1.29.37 1.74.67 2.69 1.88 2.93 3.21.2 1.13-.05 2.25-.74 3.47V70Zm-27.47-4.14c-.12-.19-.23-.38-.34-.57.74.42.85.36.99.41v.08c-.22.03-.43.06-.65.08Zm11.21 30.46c-.08 1.08-.16 2.17-.33 3.24-.05.35-.11.69-.2 1.03 0 .04-.02.07-.03.11-.15.02-.3.04-.45.05.45-1.64.76-3.36.79-5.07.03-.29.08-.57.1-.89-.03-.31-.03-.47.24-.57-.04.69-.07 1.39-.12 2.08v.02Zm5.6-2.47c.48.11.92.52 2.49 1.72-.46-.32-.92-.65-1.38-.97-.37-.25-.73-.5-1.1-.75h-.01Zm21.23 7.24a70.76 70.76 0 0 1-4.37 4.63c-.14-.09-.27-.19-.4-.28.19-.09.37-.24.55-.47.87-1.14 5.43-5.51 5.49-7.45.31.26.62.53.92.79-.67.97-1.42 1.88-2.19 2.77v.01Z",
              fill: "currentColor",
              transform: "translate(-144.023 -51.76)"
            }
          )
        ]
      }
    );
    ExcalidrawLogo = ({
      style,
      size = "small",
      withText
    }) => {
      return /* @__PURE__ */ jsxs70("div", { className: `ExcalidrawLogo is-${size}`, style, children: [
        /* @__PURE__ */ jsx124(LogoIcon, {}),
        withText && /* @__PURE__ */ jsx124(LogoText, {})
      ] });
    };
  }
});

// components/welcome-screen/WelcomeScreen.Center.tsx
import { Fragment as Fragment21, jsx as jsx125, jsxs as jsxs71 } from "react/jsx-runtime";
var WelcomeScreenMenuItemContent, WelcomeScreenMenuItem, WelcomeScreenMenuItemLink, Center, Logo, Heading, Menu, MenuItemHelp, MenuItemLoadScene, MenuItemLiveCollaborationTrigger;
var init_WelcomeScreen_Center = __esm({
  "components/welcome-screen/WelcomeScreen.Center.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_actions();
    init_shortcuts();
    init_i18n();
    init_App();
    init_tunnels();
    init_icons();
    init_ui_appState();
    init_ExcalidrawLogo2();
    WelcomeScreenMenuItemContent = ({
      icon,
      shortcut,
      children
    }) => {
      const device = useDevice();
      return /* @__PURE__ */ jsxs71(Fragment21, { children: [
        /* @__PURE__ */ jsx125("div", { className: "welcome-screen-menu-item__icon", children: icon }),
        /* @__PURE__ */ jsx125("div", { className: "welcome-screen-menu-item__text", children }),
        shortcut && !device.editor.isMobile && /* @__PURE__ */ jsx125("div", { className: "welcome-screen-menu-item__shortcut", children: shortcut })
      ] });
    };
    WelcomeScreenMenuItemContent.displayName = "WelcomeScreenMenuItemContent";
    WelcomeScreenMenuItem = ({
      onSelect,
      children,
      icon,
      shortcut,
      className = "",
      ...props
    }) => {
      return /* @__PURE__ */ jsx125(
        "button",
        {
          ...props,
          type: "button",
          className: `welcome-screen-menu-item ${className}`,
          onClick: onSelect,
          children: /* @__PURE__ */ jsx125(WelcomeScreenMenuItemContent, { icon, shortcut, children })
        }
      );
    };
    WelcomeScreenMenuItem.displayName = "WelcomeScreenMenuItem";
    WelcomeScreenMenuItemLink = ({
      children,
      href,
      icon,
      shortcut,
      className = "",
      ...props
    }) => {
      return /* @__PURE__ */ jsx125(
        "a",
        {
          ...props,
          className: `welcome-screen-menu-item ${className}`,
          href,
          target: "_blank",
          rel: "noreferrer",
          children: /* @__PURE__ */ jsx125(WelcomeScreenMenuItemContent, { icon, shortcut, children })
        }
      );
    };
    WelcomeScreenMenuItemLink.displayName = "WelcomeScreenMenuItemLink";
    Center = ({ children }) => {
      const { WelcomeScreenCenterTunnel } = useTunnels();
      return /* @__PURE__ */ jsx125(WelcomeScreenCenterTunnel.In, { children: /* @__PURE__ */ jsx125("div", { className: "welcome-screen-center", children: children || /* @__PURE__ */ jsxs71(Fragment21, { children: [
        /* @__PURE__ */ jsx125(Logo, {}),
        /* @__PURE__ */ jsx125(Heading, { children: t("welcomeScreen.defaults.center_heading") }),
        /* @__PURE__ */ jsxs71(Menu, { children: [
          /* @__PURE__ */ jsx125(MenuItemLoadScene, {}),
          /* @__PURE__ */ jsx125(MenuItemHelp, {})
        ] })
      ] }) }) });
    };
    Center.displayName = "Center";
    Logo = ({ children }) => {
      return /* @__PURE__ */ jsx125("div", { className: "welcome-screen-center__logo virgil welcome-screen-decor", children: children || /* @__PURE__ */ jsx125(ExcalidrawLogo, { withText: true }) });
    };
    Logo.displayName = "Logo";
    Heading = ({ children }) => {
      return /* @__PURE__ */ jsx125("div", { className: "welcome-screen-center__heading welcome-screen-decor virgil", children });
    };
    Heading.displayName = "Heading";
    Menu = ({ children }) => {
      return /* @__PURE__ */ jsx125("div", { className: "welcome-screen-menu", children });
    };
    Menu.displayName = "Menu";
    MenuItemHelp = () => {
      const actionManager = useExcalidrawActionManager();
      return /* @__PURE__ */ jsx125(
        WelcomeScreenMenuItem,
        {
          onSelect: () => actionManager.executeAction(actionShortcuts),
          shortcut: "?",
          icon: HelpIcon,
          children: t("helpDialog.title")
        }
      );
    };
    MenuItemHelp.displayName = "MenuItemHelp";
    MenuItemLoadScene = () => {
      const appState = useUIAppState();
      const actionManager = useExcalidrawActionManager();
      if (appState.viewModeEnabled) {
        return null;
      }
      return /* @__PURE__ */ jsx125(
        WelcomeScreenMenuItem,
        {
          onSelect: () => actionManager.executeAction(actionLoadScene),
          shortcut: getShortcutFromShortcutName("loadScene"),
          icon: LoadIcon,
          children: t("buttons.load")
        }
      );
    };
    MenuItemLoadScene.displayName = "MenuItemLoadScene";
    MenuItemLiveCollaborationTrigger = ({
      onSelect
    }) => {
      const { t: t2 } = useI18n();
      return /* @__PURE__ */ jsx125(WelcomeScreenMenuItem, { shortcut: null, onSelect, icon: usersIcon, children: t2("labels.liveCollaboration") });
    };
    MenuItemLiveCollaborationTrigger.displayName = "MenuItemLiveCollaborationTrigger";
    Center.Logo = Logo;
    Center.Heading = Heading;
    Center.Menu = Menu;
    Center.MenuItem = WelcomeScreenMenuItem;
    Center.MenuItemLink = WelcomeScreenMenuItemLink;
    Center.MenuItemHelp = MenuItemHelp;
    Center.MenuItemLoadScene = MenuItemLoadScene;
    Center.MenuItemLiveCollaborationTrigger = MenuItemLiveCollaborationTrigger;
  }
});

// components/welcome-screen/WelcomeScreen.Hints.tsx
import { jsx as jsx126, jsxs as jsxs72 } from "react/jsx-runtime";
var MenuHint, ToolbarHint, HelpHint;
var init_WelcomeScreen_Hints = __esm({
  "components/welcome-screen/WelcomeScreen.Hints.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_i18n();
    init_tunnels();
    init_icons();
    MenuHint = ({ children }) => {
      const { WelcomeScreenMenuHintTunnel } = useTunnels();
      return /* @__PURE__ */ jsx126(WelcomeScreenMenuHintTunnel.In, { children: /* @__PURE__ */ jsxs72("div", { className: "virgil welcome-screen-decor welcome-screen-decor-hint welcome-screen-decor-hint--menu", children: [
        WelcomeScreenMenuArrow,
        /* @__PURE__ */ jsx126("div", { className: "welcome-screen-decor-hint__label", children: children || t("welcomeScreen.defaults.menuHint") })
      ] }) });
    };
    MenuHint.displayName = "MenuHint";
    ToolbarHint = ({ children }) => {
      const { WelcomeScreenToolbarHintTunnel } = useTunnels();
      return /* @__PURE__ */ jsx126(WelcomeScreenToolbarHintTunnel.In, { children: /* @__PURE__ */ jsxs72("div", { className: "virgil welcome-screen-decor welcome-screen-decor-hint welcome-screen-decor-hint--toolbar", children: [
        /* @__PURE__ */ jsx126("div", { className: "welcome-screen-decor-hint__label", children: children || t("welcomeScreen.defaults.toolbarHint") }),
        WelcomeScreenTopToolbarArrow
      ] }) });
    };
    ToolbarHint.displayName = "ToolbarHint";
    HelpHint = ({ children }) => {
      const { WelcomeScreenHelpHintTunnel } = useTunnels();
      return /* @__PURE__ */ jsx126(WelcomeScreenHelpHintTunnel.In, { children: /* @__PURE__ */ jsxs72("div", { className: "virgil welcome-screen-decor welcome-screen-decor-hint welcome-screen-decor-hint--help", children: [
        /* @__PURE__ */ jsx126("div", { children: children || t("welcomeScreen.defaults.helpHint") }),
        WelcomeScreenHelpArrow
      ] }) });
    };
    HelpHint.displayName = "HelpHint";
  }
});

// components/welcome-screen/WelcomeScreen.scss
var init_WelcomeScreen = __esm({
  "components/welcome-screen/WelcomeScreen.scss"() {
  }
});

// components/welcome-screen/WelcomeScreen.tsx
import { Fragment as Fragment22, jsx as jsx127, jsxs as jsxs73 } from "react/jsx-runtime";
var WelcomeScreen, WelcomeScreen_default;
var init_WelcomeScreen2 = __esm({
  "components/welcome-screen/WelcomeScreen.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_WelcomeScreen_Center();
    init_WelcomeScreen_Hints();
    init_WelcomeScreen();
    WelcomeScreen = (props) => {
      return /* @__PURE__ */ jsx127(Fragment22, { children: props.children || /* @__PURE__ */ jsxs73(Fragment22, { children: [
        /* @__PURE__ */ jsx127(Center, {}),
        /* @__PURE__ */ jsx127(MenuHint, {}),
        /* @__PURE__ */ jsx127(ToolbarHint, {}),
        /* @__PURE__ */ jsx127(HelpHint, {})
      ] }) });
    };
    WelcomeScreen.displayName = "WelcomeScreen";
    WelcomeScreen.Center = Center;
    WelcomeScreen.Hints = { MenuHint, ToolbarHint, HelpHint };
    WelcomeScreen_default = WelcomeScreen;
  }
});

// components/live-collaboration/LiveCollaborationTrigger.scss
var init_LiveCollaborationTrigger = __esm({
  "components/live-collaboration/LiveCollaborationTrigger.scss"() {
  }
});

// components/live-collaboration/LiveCollaborationTrigger.tsx
import clsx49 from "clsx";
import { jsx as jsx128, jsxs as jsxs74 } from "react/jsx-runtime";
var LiveCollaborationTrigger2, LiveCollaborationTrigger_default;
var init_LiveCollaborationTrigger2 = __esm({
  "components/live-collaboration/LiveCollaborationTrigger.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_i18n();
    init_icons();
    init_Button2();
    init_LiveCollaborationTrigger();
    init_ui_appState();
    LiveCollaborationTrigger2 = ({
      isCollaborating,
      onSelect,
      ...rest
    }) => {
      const appState = useUIAppState();
      const showIconOnly = appState.width < 830;
      return /* @__PURE__ */ jsxs74(
        Button,
        {
          ...rest,
          className: clsx49("collab-button", { active: isCollaborating }),
          type: "button",
          onSelect,
          style: { position: "relative", width: showIconOnly ? void 0 : "auto" },
          title: t("labels.liveCollaboration"),
          children: [
            showIconOnly ? share : t("labels.share"),
            appState.collaborators.size > 0 && /* @__PURE__ */ jsx128("div", { className: "CollabButton-collaborators", children: appState.collaborators.size })
          ]
        }
      );
    };
    LiveCollaborationTrigger_default = LiveCollaborationTrigger2;
    LiveCollaborationTrigger2.displayName = "LiveCollaborationTrigger";
  }
});

// components/TTDDialog/TTDDialogTrigger.tsx
import { jsx as jsx129, jsxs as jsxs75 } from "react/jsx-runtime";
var TTDDialogTrigger;
var init_TTDDialogTrigger = __esm({
  "components/TTDDialog/TTDDialogTrigger.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_tunnels();
    init_DropdownMenu2();
    init_App();
    init_icons();
    init_i18n();
    init_analytics();
    TTDDialogTrigger = ({
      children,
      icon
    }) => {
      const { TTDDialogTriggerTunnel } = useTunnels();
      const setAppState = useExcalidrawSetAppState();
      return /* @__PURE__ */ jsx129(TTDDialogTriggerTunnel.In, { children: /* @__PURE__ */ jsxs75(
        DropdownMenu_default.Item,
        {
          onSelect: () => {
            trackEvent("ai", "dialog open", "ttd");
            setAppState({ openDialog: { name: "ttd", tab: "text-to-diagram" } });
          },
          icon: icon ?? brainIcon,
          children: [
            children ?? t("labels.textToDiagram"),
            /* @__PURE__ */ jsx129(DropdownMenu_default.Item.Badge, { children: "AI" })
          ]
        }
      ) });
    };
    TTDDialogTrigger.displayName = "TTDDialogTrigger";
  }
});

// index.tsx
import React39, { useEffect as useEffect31 } from "react";
import { Provider as Provider2 } from "jotai";
import { jsx as jsx130 } from "react/jsx-runtime";
var ExcalidrawBase, areEqual4, Excalidraw;
var init_excalidraw = __esm({
  "index.tsx"() {
    init_define_import_meta_env();
    init_InitializeApp();
    init_App();
    init_utils();
    init_app();
    init_styles();
    init_fonts();
    init_polyfill();
    init_i18n();
    init_constants();
    init_jotai();
    init_FooterCenter2();
    init_MainMenu();
    init_WelcomeScreen2();
    init_LiveCollaborationTrigger2();
    init_element();
    init_i18n();
    init_restore();
    init_export2();
    init_typeChecks();
    init_constants();
    init_mutateElement();
    init_library();
    init_utils();
    init_Sidebar2();
    init_Button2();
    init_App();
    init_DefaultSidebar();
    init_TTDDialog2();
    init_TTDDialogTrigger();
    init_url();
    init_actionCanvas();
    init_transform();
    init_bounds();
    init_export2();
    polyfill_default();
    ExcalidrawBase = (props) => {
      const {
        onChange,
        initialData,
        excalidrawAPI,
        isCollaborating = false,
        onPointerUpdate,
        renderTopRightUI,
        langCode = defaultLang.code,
        viewModeEnabled,
        zenModeEnabled,
        gridModeEnabled,
        libraryReturnUrl,
        theme,
        name,
        renderCustomStats,
        onPaste,
        detectScroll = true,
        handleKeyboardGlobally = false,
        onLibraryChange,
        autoFocus = false,
        generateIdForFile,
        onLinkOpen,
        onPointerDown,
        onPointerUp,
        onScrollChange,
        children,
        validateEmbeddable,
        renderEmbeddable,
        aiEnabled
      } = props;
      const canvasActions = props.UIOptions?.canvasActions;
      const UIOptions = {
        ...props.UIOptions,
        canvasActions: {
          ...DEFAULT_UI_OPTIONS.canvasActions,
          ...canvasActions
        },
        tools: {
          image: props.UIOptions?.tools?.image ?? true
        }
      };
      if (canvasActions?.export) {
        UIOptions.canvasActions.export.saveFileToDisk = canvasActions.export?.saveFileToDisk ?? DEFAULT_UI_OPTIONS.canvasActions.export.saveFileToDisk;
      }
      if (UIOptions.canvasActions.toggleTheme === null && typeof theme === "undefined") {
        UIOptions.canvasActions.toggleTheme = true;
      }
      useEffect31(() => {
        const importPolyfill = async () => {
          await import("canvas-roundrect-polyfill");
        };
        importPolyfill();
        const handleTouchMove = (event) => {
          if (typeof event.scale === "number" && event.scale !== 1) {
            event.preventDefault();
          }
        };
        document.addEventListener("touchmove", handleTouchMove, {
          passive: false
        });
        return () => {
          document.removeEventListener("touchmove", handleTouchMove);
        };
      }, []);
      return /* @__PURE__ */ jsx130(Provider2, { unstable_createStore: () => jotaiStore, scope: jotaiScope, children: /* @__PURE__ */ jsx130(InitializeApp, { langCode, theme, children: /* @__PURE__ */ jsx130(
        App_default,
        {
          onChange,
          initialData,
          excalidrawAPI,
          isCollaborating,
          onPointerUpdate,
          renderTopRightUI,
          langCode,
          viewModeEnabled,
          zenModeEnabled,
          gridModeEnabled,
          libraryReturnUrl,
          theme,
          name,
          renderCustomStats,
          UIOptions,
          onPaste,
          detectScroll,
          handleKeyboardGlobally,
          onLibraryChange,
          autoFocus,
          generateIdForFile,
          onLinkOpen,
          onPointerDown,
          onPointerUp,
          onScrollChange,
          validateEmbeddable,
          renderEmbeddable,
          aiEnabled: aiEnabled !== false,
          children
        }
      ) }) });
    };
    areEqual4 = (prevProps, nextProps) => {
      if (prevProps.children !== nextProps.children) {
        return false;
      }
      const {
        initialData: prevInitialData,
        UIOptions: prevUIOptions = {},
        ...prev
      } = prevProps;
      const {
        initialData: nextInitialData,
        UIOptions: nextUIOptions = {},
        ...next
      } = nextProps;
      const prevUIOptionsKeys = Object.keys(prevUIOptions);
      const nextUIOptionsKeys = Object.keys(nextUIOptions);
      if (prevUIOptionsKeys.length !== nextUIOptionsKeys.length) {
        return false;
      }
      const isUIOptionsSame = prevUIOptionsKeys.every((key) => {
        if (key === "canvasActions") {
          const canvasOptionKeys = Object.keys(
            prevUIOptions.canvasActions
          );
          return canvasOptionKeys.every((key2) => {
            if (key2 === "export" && prevUIOptions?.canvasActions?.export && nextUIOptions?.canvasActions?.export) {
              return prevUIOptions.canvasActions.export.saveFileToDisk === nextUIOptions.canvasActions.export.saveFileToDisk;
            }
            return prevUIOptions?.canvasActions?.[key2] === nextUIOptions?.canvasActions?.[key2];
          });
        }
        return prevUIOptions[key] === nextUIOptions[key];
      });
      return isUIOptionsSame && isShallowEqual(prev, next);
    };
    Excalidraw = React39.memo(ExcalidrawBase, areEqual4);
    Excalidraw.displayName = "Excalidraw";
  }
});
init_excalidraw();
export {
  Button,
  DefaultSidebar,
  Excalidraw,
  FONT_FAMILY,
  FooterCenter_default as Footer,
  LiveCollaborationTrigger_default as LiveCollaborationTrigger,
  MIME_TYPES,
  MainMenu_default as MainMenu,
  ROUNDNESS,
  Sidebar,
  THEME,
  TTDDialog,
  TTDDialogTrigger,
  WelcomeScreen_default as WelcomeScreen,
  bumpVersion,
  convertToExcalidrawElements,
  defaultLang,
  elementPartiallyOverlapsWithOrContainsBBox,
  elementsOverlappingBBox,
  exportToBlob,
  exportToCanvas2 as exportToCanvas,
  exportToClipboard,
  exportToSvg2 as exportToSvg,
  getCommonBounds,
  getFreeDrawSvgPath,
  getNonDeletedElements3 as getNonDeletedElements,
  getSceneVersion,
  getVisibleSceneBounds,
  isElementInsideBBox,
  isInvisiblySmallElement,
  isLinearElement,
  languages,
  loadFromBlob,
  loadLibraryFromBlob,
  loadSceneOrLibraryFromBlob,
  mergeLibraryItems,
  mutateElement,
  newElementWith,
  normalizeLink,
  parseLibraryTokensFromUrl,
  restore,
  restoreAppState,
  restoreElements,
  restoreLibraryItems,
  sceneCoordsToViewportCoords,
  serializeAsJSON,
  serializeLibraryAsJSON,
  useDevice,
  useHandleLibrary,
  useI18n,
  viewportCoordsToSceneCoords,
  zoomToFitBounds
};
//# sourceMappingURL=index.js.map
