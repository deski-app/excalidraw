import {
  define_import_meta_env_default,
  init_define_import_meta_env
} from "./chunk-YRUDZAGT.js";
import {
  en_default
} from "./chunk-ZS2BUC62.js";
import {
  percentages_default
} from "./chunk-YZTYRBEQ.js";
import {
  __commonJS,
  __export,
  __glob,
  __toESM
} from "./chunk-F3UQABQJ.js";

// ../../node_modules/crc-32/crc32.js
var require_crc32 = __commonJS({
  "../../node_modules/crc-32/crc32.js"(exports) {
    init_define_import_meta_env();
    var CRC32;
    (function(factory) {
      if (typeof DO_NOT_EXPORT_CRC === "undefined") {
        if ("object" === typeof exports) {
          factory(exports);
        } else if ("function" === typeof define && define.amd) {
          define(function() {
            var module2 = {};
            factory(module2);
            return module2;
          });
        } else {
          factory(CRC32 = {});
        }
      } else {
        factory(CRC32 = {});
      }
    })(function(CRC322) {
      CRC322.version = "0.3.0";
      function signed_crc_table() {
        var c3 = 0, table2 = new Array(256);
        for (var n4 = 0; n4 != 256; ++n4) {
          c3 = n4;
          c3 = c3 & 1 ? -306674912 ^ c3 >>> 1 : c3 >>> 1;
          c3 = c3 & 1 ? -306674912 ^ c3 >>> 1 : c3 >>> 1;
          c3 = c3 & 1 ? -306674912 ^ c3 >>> 1 : c3 >>> 1;
          c3 = c3 & 1 ? -306674912 ^ c3 >>> 1 : c3 >>> 1;
          c3 = c3 & 1 ? -306674912 ^ c3 >>> 1 : c3 >>> 1;
          c3 = c3 & 1 ? -306674912 ^ c3 >>> 1 : c3 >>> 1;
          c3 = c3 & 1 ? -306674912 ^ c3 >>> 1 : c3 >>> 1;
          c3 = c3 & 1 ? -306674912 ^ c3 >>> 1 : c3 >>> 1;
          table2[n4] = c3;
        }
        return typeof Int32Array !== "undefined" ? new Int32Array(table2) : table2;
      }
      var table = signed_crc_table();
      var use_buffer = typeof Buffer !== "undefined";
      function crc32_bstr(bstr) {
        if (bstr.length > 32768) {
          if (use_buffer)
            return crc32_buf_8(new Buffer(bstr));
        }
        var crc = -1, L4 = bstr.length - 1;
        for (var i4 = 0; i4 < L4; ) {
          crc = table[(crc ^ bstr.charCodeAt(i4++)) & 255] ^ crc >>> 8;
          crc = table[(crc ^ bstr.charCodeAt(i4++)) & 255] ^ crc >>> 8;
        }
        if (i4 === L4)
          crc = crc >>> 8 ^ table[(crc ^ bstr.charCodeAt(i4)) & 255];
        return crc ^ -1;
      }
      function crc32_buf(buf) {
        if (buf.length > 1e4)
          return crc32_buf_8(buf);
        for (var crc = -1, i4 = 0, L4 = buf.length - 3; i4 < L4; ) {
          crc = crc >>> 8 ^ table[(crc ^ buf[i4++]) & 255];
          crc = crc >>> 8 ^ table[(crc ^ buf[i4++]) & 255];
          crc = crc >>> 8 ^ table[(crc ^ buf[i4++]) & 255];
          crc = crc >>> 8 ^ table[(crc ^ buf[i4++]) & 255];
        }
        while (i4 < L4 + 3)
          crc = crc >>> 8 ^ table[(crc ^ buf[i4++]) & 255];
        return crc ^ -1;
      }
      function crc32_buf_8(buf) {
        for (var crc = -1, i4 = 0, L4 = buf.length - 7; i4 < L4; ) {
          crc = crc >>> 8 ^ table[(crc ^ buf[i4++]) & 255];
          crc = crc >>> 8 ^ table[(crc ^ buf[i4++]) & 255];
          crc = crc >>> 8 ^ table[(crc ^ buf[i4++]) & 255];
          crc = crc >>> 8 ^ table[(crc ^ buf[i4++]) & 255];
          crc = crc >>> 8 ^ table[(crc ^ buf[i4++]) & 255];
          crc = crc >>> 8 ^ table[(crc ^ buf[i4++]) & 255];
          crc = crc >>> 8 ^ table[(crc ^ buf[i4++]) & 255];
          crc = crc >>> 8 ^ table[(crc ^ buf[i4++]) & 255];
        }
        while (i4 < L4 + 7)
          crc = crc >>> 8 ^ table[(crc ^ buf[i4++]) & 255];
        return crc ^ -1;
      }
      function crc32_str(str) {
        for (var crc = -1, i4 = 0, L4 = str.length, c3, d3; i4 < L4; ) {
          c3 = str.charCodeAt(i4++);
          if (c3 < 128) {
            crc = crc >>> 8 ^ table[(crc ^ c3) & 255];
          } else if (c3 < 2048) {
            crc = crc >>> 8 ^ table[(crc ^ (192 | c3 >> 6 & 31)) & 255];
            crc = crc >>> 8 ^ table[(crc ^ (128 | c3 & 63)) & 255];
          } else if (c3 >= 55296 && c3 < 57344) {
            c3 = (c3 & 1023) + 64;
            d3 = str.charCodeAt(i4++) & 1023;
            crc = crc >>> 8 ^ table[(crc ^ (240 | c3 >> 8 & 7)) & 255];
            crc = crc >>> 8 ^ table[(crc ^ (128 | c3 >> 2 & 63)) & 255];
            crc = crc >>> 8 ^ table[(crc ^ (128 | d3 >> 6 & 15 | c3 & 3)) & 255];
            crc = crc >>> 8 ^ table[(crc ^ (128 | d3 & 63)) & 255];
          } else {
            crc = crc >>> 8 ^ table[(crc ^ (224 | c3 >> 12 & 15)) & 255];
            crc = crc >>> 8 ^ table[(crc ^ (128 | c3 >> 6 & 63)) & 255];
            crc = crc >>> 8 ^ table[(crc ^ (128 | c3 & 63)) & 255];
          }
        }
        return crc ^ -1;
      }
      CRC322.table = table;
      CRC322.bstr = crc32_bstr;
      CRC322.buf = crc32_buf;
      CRC322.str = crc32_str;
    });
  }
});

// ../../node_modules/png-chunks-extract/index.js
var require_png_chunks_extract = __commonJS({
  "../../node_modules/png-chunks-extract/index.js"(exports, module) {
    init_define_import_meta_env();
    var crc32 = require_crc32();
    module.exports = extractChunks;
    var uint8 = new Uint8Array(4);
    var int32 = new Int32Array(uint8.buffer);
    var uint32 = new Uint32Array(uint8.buffer);
    function extractChunks(data) {
      if (data[0] !== 137)
        throw new Error("Invalid .png file header");
      if (data[1] !== 80)
        throw new Error("Invalid .png file header");
      if (data[2] !== 78)
        throw new Error("Invalid .png file header");
      if (data[3] !== 71)
        throw new Error("Invalid .png file header");
      if (data[4] !== 13)
        throw new Error("Invalid .png file header: possibly caused by DOS-Unix line ending conversion?");
      if (data[5] !== 10)
        throw new Error("Invalid .png file header: possibly caused by DOS-Unix line ending conversion?");
      if (data[6] !== 26)
        throw new Error("Invalid .png file header");
      if (data[7] !== 10)
        throw new Error("Invalid .png file header: possibly caused by DOS-Unix line ending conversion?");
      var ended = false;
      var chunks = [];
      var idx = 8;
      while (idx < data.length) {
        uint8[3] = data[idx++];
        uint8[2] = data[idx++];
        uint8[1] = data[idx++];
        uint8[0] = data[idx++];
        var length = uint32[0] + 4;
        var chunk2 = new Uint8Array(length);
        chunk2[0] = data[idx++];
        chunk2[1] = data[idx++];
        chunk2[2] = data[idx++];
        chunk2[3] = data[idx++];
        var name = String.fromCharCode(chunk2[0]) + String.fromCharCode(chunk2[1]) + String.fromCharCode(chunk2[2]) + String.fromCharCode(chunk2[3]);
        if (!chunks.length && name !== "IHDR") {
          throw new Error("IHDR header missing");
        }
        if (name === "IEND") {
          ended = true;
          chunks.push({
            name,
            data: new Uint8Array(0)
          });
          break;
        }
        for (var i4 = 4; i4 < length; i4++) {
          chunk2[i4] = data[idx++];
        }
        uint8[3] = data[idx++];
        uint8[2] = data[idx++];
        uint8[1] = data[idx++];
        uint8[0] = data[idx++];
        var crcActual = int32[0];
        var crcExpect = crc32.buf(chunk2);
        if (crcExpect !== crcActual) {
          throw new Error(
            "CRC values for " + name + " header do not match, PNG file is likely corrupted"
          );
        }
        var chunkData = new Uint8Array(chunk2.buffer.slice(4));
        chunks.push({
          name,
          data: chunkData
        });
      }
      if (!ended) {
        throw new Error(".png file ended prematurely: no IEND header was found");
      }
      return chunks;
    }
  }
});

// ../../node_modules/png-chunk-text/encode.js
var require_encode = __commonJS({
  "../../node_modules/png-chunk-text/encode.js"(exports, module) {
    init_define_import_meta_env();
    module.exports = encode2;
    function encode2(keyword, content) {
      keyword = String(keyword);
      content = String(content);
      if (!/^[\x00-\xFF]+$/.test(keyword) || !/^[\x00-\xFF]+$/.test(content)) {
        throw new Error("Only Latin-1 characters are permitted in PNG tEXt chunks. You might want to consider base64 encoding and/or zEXt compression");
      }
      if (keyword.length >= 80) {
        throw new Error('Keyword "' + keyword + '" is longer than the 79-character limit imposed by the PNG specification');
      }
      var totalSize = keyword.length + content.length + 1;
      var output = new Uint8Array(totalSize);
      var idx = 0;
      var code;
      for (var i4 = 0; i4 < keyword.length; i4++) {
        if (!(code = keyword.charCodeAt(i4))) {
          throw new Error("0x00 character is not permitted in tEXt keywords");
        }
        output[idx++] = code;
      }
      output[idx++] = 0;
      for (var j = 0; j < content.length; j++) {
        if (!(code = content.charCodeAt(j))) {
          throw new Error("0x00 character is not permitted in tEXt content");
        }
        output[idx++] = code;
      }
      return {
        name: "tEXt",
        data: output
      };
    }
  }
});

// ../../node_modules/png-chunk-text/decode.js
var require_decode = __commonJS({
  "../../node_modules/png-chunk-text/decode.js"(exports, module) {
    init_define_import_meta_env();
    module.exports = decode2;
    function decode2(data) {
      if (data.data && data.name) {
        data = data.data;
      }
      var naming = true;
      var text = "";
      var name = "";
      for (var i4 = 0; i4 < data.length; i4++) {
        var code = data[i4];
        if (naming) {
          if (code) {
            name += String.fromCharCode(code);
          } else {
            naming = false;
          }
        } else {
          if (code) {
            text += String.fromCharCode(code);
          } else {
            throw new Error("Invalid NULL character found. 0x00 character is not permitted in tEXt content");
          }
        }
      }
      return {
        keyword: name,
        text
      };
    }
  }
});

// ../../node_modules/png-chunk-text/index.js
var require_png_chunk_text = __commonJS({
  "../../node_modules/png-chunk-text/index.js"(exports) {
    init_define_import_meta_env();
    exports.encode = require_encode();
    exports.decode = require_decode();
  }
});

// ../../node_modules/sliced/index.js
var require_sliced = __commonJS({
  "../../node_modules/sliced/index.js"(exports, module) {
    init_define_import_meta_env();
    module.exports = function(args, slice, sliceEnd) {
      var ret = [];
      var len = args.length;
      if (0 === len)
        return ret;
      var start2 = slice < 0 ? Math.max(0, slice + len) : slice || 0;
      if (sliceEnd !== void 0) {
        len = sliceEnd < 0 ? sliceEnd + len : sliceEnd;
      }
      while (len-- > start2) {
        ret[len - start2] = args[len];
      }
      return ret;
    };
  }
});

// ../../node_modules/png-chunks-encode/index.js
var require_png_chunks_encode = __commonJS({
  "../../node_modules/png-chunks-encode/index.js"(exports, module) {
    init_define_import_meta_env();
    var sliced = require_sliced();
    var crc32 = require_crc32();
    module.exports = encodeChunks;
    var uint8 = new Uint8Array(4);
    var int32 = new Int32Array(uint8.buffer);
    var uint32 = new Uint32Array(uint8.buffer);
    function encodeChunks(chunks) {
      var totalSize = 8;
      var idx = totalSize;
      var i4;
      for (i4 = 0; i4 < chunks.length; i4++) {
        totalSize += chunks[i4].data.length;
        totalSize += 12;
      }
      var output = new Uint8Array(totalSize);
      output[0] = 137;
      output[1] = 80;
      output[2] = 78;
      output[3] = 71;
      output[4] = 13;
      output[5] = 10;
      output[6] = 26;
      output[7] = 10;
      for (i4 = 0; i4 < chunks.length; i4++) {
        var chunk2 = chunks[i4];
        var name = chunk2.name;
        var data = chunk2.data;
        var size = data.length;
        var nameChars = [
          name.charCodeAt(0),
          name.charCodeAt(1),
          name.charCodeAt(2),
          name.charCodeAt(3)
        ];
        uint32[0] = size;
        output[idx++] = uint8[3];
        output[idx++] = uint8[2];
        output[idx++] = uint8[1];
        output[idx++] = uint8[0];
        output[idx++] = nameChars[0];
        output[idx++] = nameChars[1];
        output[idx++] = nameChars[2];
        output[idx++] = nameChars[3];
        for (var j = 0; j < size; ) {
          output[idx++] = data[j++];
        }
        var crcCheck = nameChars.concat(sliced(data));
        var crc = crc32.buf(crcCheck);
        int32[0] = crc;
        output[idx++] = uint8[3];
        output[idx++] = uint8[2];
        output[idx++] = uint8[1];
        output[idx++] = uint8[0];
      }
      return output;
    }
  }
});

// ../../node_modules/pako/lib/utils/common.js
var require_common = __commonJS({
  "../../node_modules/pako/lib/utils/common.js"(exports) {
    "use strict";
    init_define_import_meta_env();
    var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
    function _has(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
    exports.assign = function(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        var source = sources.shift();
        if (!source) {
          continue;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be non-object");
        }
        for (var p3 in source) {
          if (_has(source, p3)) {
            obj[p3] = source[p3];
          }
        }
      }
      return obj;
    };
    exports.shrinkBuf = function(buf, size) {
      if (buf.length === size) {
        return buf;
      }
      if (buf.subarray) {
        return buf.subarray(0, size);
      }
      buf.length = size;
      return buf;
    };
    var fnTyped = {
      arraySet: function(dest, src, src_offs, len, dest_offs) {
        if (src.subarray && dest.subarray) {
          dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
          return;
        }
        for (var i4 = 0; i4 < len; i4++) {
          dest[dest_offs + i4] = src[src_offs + i4];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        var i4, l4, len, pos, chunk2, result;
        len = 0;
        for (i4 = 0, l4 = chunks.length; i4 < l4; i4++) {
          len += chunks[i4].length;
        }
        result = new Uint8Array(len);
        pos = 0;
        for (i4 = 0, l4 = chunks.length; i4 < l4; i4++) {
          chunk2 = chunks[i4];
          result.set(chunk2, pos);
          pos += chunk2.length;
        }
        return result;
      }
    };
    var fnUntyped = {
      arraySet: function(dest, src, src_offs, len, dest_offs) {
        for (var i4 = 0; i4 < len; i4++) {
          dest[dest_offs + i4] = src[src_offs + i4];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        return [].concat.apply([], chunks);
      }
    };
    exports.setTyped = function(on) {
      if (on) {
        exports.Buf8 = Uint8Array;
        exports.Buf16 = Uint16Array;
        exports.Buf32 = Int32Array;
        exports.assign(exports, fnTyped);
      } else {
        exports.Buf8 = Array;
        exports.Buf16 = Array;
        exports.Buf32 = Array;
        exports.assign(exports, fnUntyped);
      }
    };
    exports.setTyped(TYPED_OK);
  }
});

// ../../node_modules/pako/lib/zlib/trees.js
var require_trees = __commonJS({
  "../../node_modules/pako/lib/zlib/trees.js"(exports) {
    "use strict";
    init_define_import_meta_env();
    var utils = require_common();
    var Z_FIXED = 4;
    var Z_BINARY = 0;
    var Z_TEXT = 1;
    var Z_UNKNOWN = 2;
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    var STORED_BLOCK = 0;
    var STATIC_TREES = 1;
    var DYN_TREES = 2;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var Buf_size = 16;
    var MAX_BL_BITS = 7;
    var END_BLOCK = 256;
    var REP_3_6 = 16;
    var REPZ_3_10 = 17;
    var REPZ_11_138 = 18;
    var extra_lbits = (
      /* extra bits for each length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
    );
    var extra_dbits = (
      /* extra bits for each distance code */
      [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
    );
    var extra_blbits = (
      /* extra bits for each bit length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
    );
    var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    var DIST_CODE_LEN = 512;
    var static_ltree = new Array((L_CODES + 2) * 2);
    zero(static_ltree);
    var static_dtree = new Array(D_CODES * 2);
    zero(static_dtree);
    var _dist_code = new Array(DIST_CODE_LEN);
    zero(_dist_code);
    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
    zero(_length_code);
    var base_length = new Array(LENGTH_CODES);
    zero(base_length);
    var base_dist = new Array(D_CODES);
    zero(base_dist);
    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
      this.static_tree = static_tree;
      this.extra_bits = extra_bits;
      this.extra_base = extra_base;
      this.elems = elems;
      this.max_length = max_length;
      this.has_stree = static_tree && static_tree.length;
    }
    var static_l_desc;
    var static_d_desc;
    var static_bl_desc;
    function TreeDesc(dyn_tree, stat_desc) {
      this.dyn_tree = dyn_tree;
      this.max_code = 0;
      this.stat_desc = stat_desc;
    }
    function d_code(dist) {
      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    }
    function put_short(s4, w3) {
      s4.pending_buf[s4.pending++] = w3 & 255;
      s4.pending_buf[s4.pending++] = w3 >>> 8 & 255;
    }
    function send_bits(s4, value, length) {
      if (s4.bi_valid > Buf_size - length) {
        s4.bi_buf |= value << s4.bi_valid & 65535;
        put_short(s4, s4.bi_buf);
        s4.bi_buf = value >> Buf_size - s4.bi_valid;
        s4.bi_valid += length - Buf_size;
      } else {
        s4.bi_buf |= value << s4.bi_valid & 65535;
        s4.bi_valid += length;
      }
    }
    function send_code(s4, c3, tree) {
      send_bits(
        s4,
        tree[c3 * 2],
        tree[c3 * 2 + 1]
        /*.Len*/
      );
    }
    function bi_reverse(code, len) {
      var res = 0;
      do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    }
    function bi_flush(s4) {
      if (s4.bi_valid === 16) {
        put_short(s4, s4.bi_buf);
        s4.bi_buf = 0;
        s4.bi_valid = 0;
      } else if (s4.bi_valid >= 8) {
        s4.pending_buf[s4.pending++] = s4.bi_buf & 255;
        s4.bi_buf >>= 8;
        s4.bi_valid -= 8;
      }
    }
    function gen_bitlen(s4, desc) {
      var tree = desc.dyn_tree;
      var max_code = desc.max_code;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var extra = desc.stat_desc.extra_bits;
      var base = desc.stat_desc.extra_base;
      var max_length = desc.stat_desc.max_length;
      var h3;
      var n4, m3;
      var bits;
      var xbits;
      var f3;
      var overflow = 0;
      for (bits = 0; bits <= MAX_BITS; bits++) {
        s4.bl_count[bits] = 0;
      }
      tree[s4.heap[s4.heap_max] * 2 + 1] = 0;
      for (h3 = s4.heap_max + 1; h3 < HEAP_SIZE; h3++) {
        n4 = s4.heap[h3];
        bits = tree[tree[n4 * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree[n4 * 2 + 1] = bits;
        if (n4 > max_code) {
          continue;
        }
        s4.bl_count[bits]++;
        xbits = 0;
        if (n4 >= base) {
          xbits = extra[n4 - base];
        }
        f3 = tree[n4 * 2];
        s4.opt_len += f3 * (bits + xbits);
        if (has_stree) {
          s4.static_len += f3 * (stree[n4 * 2 + 1] + xbits);
        }
      }
      if (overflow === 0) {
        return;
      }
      do {
        bits = max_length - 1;
        while (s4.bl_count[bits] === 0) {
          bits--;
        }
        s4.bl_count[bits]--;
        s4.bl_count[bits + 1] += 2;
        s4.bl_count[max_length]--;
        overflow -= 2;
      } while (overflow > 0);
      for (bits = max_length; bits !== 0; bits--) {
        n4 = s4.bl_count[bits];
        while (n4 !== 0) {
          m3 = s4.heap[--h3];
          if (m3 > max_code) {
            continue;
          }
          if (tree[m3 * 2 + 1] !== bits) {
            s4.opt_len += (bits - tree[m3 * 2 + 1]) * tree[m3 * 2];
            tree[m3 * 2 + 1] = bits;
          }
          n4--;
        }
      }
    }
    function gen_codes(tree, max_code, bl_count) {
      var next_code = new Array(MAX_BITS + 1);
      var code = 0;
      var bits;
      var n4;
      for (bits = 1; bits <= MAX_BITS; bits++) {
        next_code[bits] = code = code + bl_count[bits - 1] << 1;
      }
      for (n4 = 0; n4 <= max_code; n4++) {
        var len = tree[n4 * 2 + 1];
        if (len === 0) {
          continue;
        }
        tree[n4 * 2] = bi_reverse(next_code[len]++, len);
      }
    }
    function tr_static_init() {
      var n4;
      var bits;
      var length;
      var code;
      var dist;
      var bl_count = new Array(MAX_BITS + 1);
      length = 0;
      for (code = 0; code < LENGTH_CODES - 1; code++) {
        base_length[code] = length;
        for (n4 = 0; n4 < 1 << extra_lbits[code]; n4++) {
          _length_code[length++] = code;
        }
      }
      _length_code[length - 1] = code;
      dist = 0;
      for (code = 0; code < 16; code++) {
        base_dist[code] = dist;
        for (n4 = 0; n4 < 1 << extra_dbits[code]; n4++) {
          _dist_code[dist++] = code;
        }
      }
      dist >>= 7;
      for (; code < D_CODES; code++) {
        base_dist[code] = dist << 7;
        for (n4 = 0; n4 < 1 << extra_dbits[code] - 7; n4++) {
          _dist_code[256 + dist++] = code;
        }
      }
      for (bits = 0; bits <= MAX_BITS; bits++) {
        bl_count[bits] = 0;
      }
      n4 = 0;
      while (n4 <= 143) {
        static_ltree[n4 * 2 + 1] = 8;
        n4++;
        bl_count[8]++;
      }
      while (n4 <= 255) {
        static_ltree[n4 * 2 + 1] = 9;
        n4++;
        bl_count[9]++;
      }
      while (n4 <= 279) {
        static_ltree[n4 * 2 + 1] = 7;
        n4++;
        bl_count[7]++;
      }
      while (n4 <= 287) {
        static_ltree[n4 * 2 + 1] = 8;
        n4++;
        bl_count[8]++;
      }
      gen_codes(static_ltree, L_CODES + 1, bl_count);
      for (n4 = 0; n4 < D_CODES; n4++) {
        static_dtree[n4 * 2 + 1] = 5;
        static_dtree[n4 * 2] = bi_reverse(n4, 5);
      }
      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
    }
    function init_block(s4) {
      var n4;
      for (n4 = 0; n4 < L_CODES; n4++) {
        s4.dyn_ltree[n4 * 2] = 0;
      }
      for (n4 = 0; n4 < D_CODES; n4++) {
        s4.dyn_dtree[n4 * 2] = 0;
      }
      for (n4 = 0; n4 < BL_CODES; n4++) {
        s4.bl_tree[n4 * 2] = 0;
      }
      s4.dyn_ltree[END_BLOCK * 2] = 1;
      s4.opt_len = s4.static_len = 0;
      s4.last_lit = s4.matches = 0;
    }
    function bi_windup(s4) {
      if (s4.bi_valid > 8) {
        put_short(s4, s4.bi_buf);
      } else if (s4.bi_valid > 0) {
        s4.pending_buf[s4.pending++] = s4.bi_buf;
      }
      s4.bi_buf = 0;
      s4.bi_valid = 0;
    }
    function copy_block(s4, buf, len, header) {
      bi_windup(s4);
      if (header) {
        put_short(s4, len);
        put_short(s4, ~len);
      }
      utils.arraySet(s4.pending_buf, s4.window, buf, len, s4.pending);
      s4.pending += len;
    }
    function smaller(tree, n4, m3, depth) {
      var _n2 = n4 * 2;
      var _m2 = m3 * 2;
      return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n4] <= depth[m3];
    }
    function pqdownheap(s4, tree, k2) {
      var v3 = s4.heap[k2];
      var j = k2 << 1;
      while (j <= s4.heap_len) {
        if (j < s4.heap_len && smaller(tree, s4.heap[j + 1], s4.heap[j], s4.depth)) {
          j++;
        }
        if (smaller(tree, v3, s4.heap[j], s4.depth)) {
          break;
        }
        s4.heap[k2] = s4.heap[j];
        k2 = j;
        j <<= 1;
      }
      s4.heap[k2] = v3;
    }
    function compress_block(s4, ltree, dtree) {
      var dist;
      var lc;
      var lx = 0;
      var code;
      var extra;
      if (s4.last_lit !== 0) {
        do {
          dist = s4.pending_buf[s4.d_buf + lx * 2] << 8 | s4.pending_buf[s4.d_buf + lx * 2 + 1];
          lc = s4.pending_buf[s4.l_buf + lx];
          lx++;
          if (dist === 0) {
            send_code(s4, lc, ltree);
          } else {
            code = _length_code[lc];
            send_code(s4, code + LITERALS + 1, ltree);
            extra = extra_lbits[code];
            if (extra !== 0) {
              lc -= base_length[code];
              send_bits(s4, lc, extra);
            }
            dist--;
            code = d_code(dist);
            send_code(s4, code, dtree);
            extra = extra_dbits[code];
            if (extra !== 0) {
              dist -= base_dist[code];
              send_bits(s4, dist, extra);
            }
          }
        } while (lx < s4.last_lit);
      }
      send_code(s4, END_BLOCK, ltree);
    }
    function build_tree(s4, desc) {
      var tree = desc.dyn_tree;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var elems = desc.stat_desc.elems;
      var n4, m3;
      var max_code = -1;
      var node;
      s4.heap_len = 0;
      s4.heap_max = HEAP_SIZE;
      for (n4 = 0; n4 < elems; n4++) {
        if (tree[n4 * 2] !== 0) {
          s4.heap[++s4.heap_len] = max_code = n4;
          s4.depth[n4] = 0;
        } else {
          tree[n4 * 2 + 1] = 0;
        }
      }
      while (s4.heap_len < 2) {
        node = s4.heap[++s4.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node * 2] = 1;
        s4.depth[node] = 0;
        s4.opt_len--;
        if (has_stree) {
          s4.static_len -= stree[node * 2 + 1];
        }
      }
      desc.max_code = max_code;
      for (n4 = s4.heap_len >> 1; n4 >= 1; n4--) {
        pqdownheap(s4, tree, n4);
      }
      node = elems;
      do {
        n4 = s4.heap[
          1
          /*SMALLEST*/
        ];
        s4.heap[
          1
          /*SMALLEST*/
        ] = s4.heap[s4.heap_len--];
        pqdownheap(
          s4,
          tree,
          1
          /*SMALLEST*/
        );
        m3 = s4.heap[
          1
          /*SMALLEST*/
        ];
        s4.heap[--s4.heap_max] = n4;
        s4.heap[--s4.heap_max] = m3;
        tree[node * 2] = tree[n4 * 2] + tree[m3 * 2];
        s4.depth[node] = (s4.depth[n4] >= s4.depth[m3] ? s4.depth[n4] : s4.depth[m3]) + 1;
        tree[n4 * 2 + 1] = tree[m3 * 2 + 1] = node;
        s4.heap[
          1
          /*SMALLEST*/
        ] = node++;
        pqdownheap(
          s4,
          tree,
          1
          /*SMALLEST*/
        );
      } while (s4.heap_len >= 2);
      s4.heap[--s4.heap_max] = s4.heap[
        1
        /*SMALLEST*/
      ];
      gen_bitlen(s4, desc);
      gen_codes(tree, max_code, s4.bl_count);
    }
    function scan_tree(s4, tree, max_code) {
      var n4;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1] = 65535;
      for (n4 = 0; n4 <= max_code; n4++) {
        curlen = nextlen;
        nextlen = tree[(n4 + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          s4.bl_tree[curlen * 2] += count;
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            s4.bl_tree[curlen * 2]++;
          }
          s4.bl_tree[REP_3_6 * 2]++;
        } else if (count <= 10) {
          s4.bl_tree[REPZ_3_10 * 2]++;
        } else {
          s4.bl_tree[REPZ_11_138 * 2]++;
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function send_tree(s4, tree, max_code) {
      var n4;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n4 = 0; n4 <= max_code; n4++) {
        curlen = nextlen;
        nextlen = tree[(n4 + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          do {
            send_code(s4, curlen, s4.bl_tree);
          } while (--count !== 0);
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code(s4, curlen, s4.bl_tree);
            count--;
          }
          send_code(s4, REP_3_6, s4.bl_tree);
          send_bits(s4, count - 3, 2);
        } else if (count <= 10) {
          send_code(s4, REPZ_3_10, s4.bl_tree);
          send_bits(s4, count - 3, 3);
        } else {
          send_code(s4, REPZ_11_138, s4.bl_tree);
          send_bits(s4, count - 11, 7);
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function build_bl_tree(s4) {
      var max_blindex;
      scan_tree(s4, s4.dyn_ltree, s4.l_desc.max_code);
      scan_tree(s4, s4.dyn_dtree, s4.d_desc.max_code);
      build_tree(s4, s4.bl_desc);
      for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
        if (s4.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
          break;
        }
      }
      s4.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      return max_blindex;
    }
    function send_all_trees(s4, lcodes, dcodes, blcodes) {
      var rank;
      send_bits(s4, lcodes - 257, 5);
      send_bits(s4, dcodes - 1, 5);
      send_bits(s4, blcodes - 4, 4);
      for (rank = 0; rank < blcodes; rank++) {
        send_bits(s4, s4.bl_tree[bl_order[rank] * 2 + 1], 3);
      }
      send_tree(s4, s4.dyn_ltree, lcodes - 1);
      send_tree(s4, s4.dyn_dtree, dcodes - 1);
    }
    function detect_data_type(s4) {
      var black_mask = 4093624447;
      var n4;
      for (n4 = 0; n4 <= 31; n4++, black_mask >>>= 1) {
        if (black_mask & 1 && s4.dyn_ltree[n4 * 2] !== 0) {
          return Z_BINARY;
        }
      }
      if (s4.dyn_ltree[9 * 2] !== 0 || s4.dyn_ltree[10 * 2] !== 0 || s4.dyn_ltree[13 * 2] !== 0) {
        return Z_TEXT;
      }
      for (n4 = 32; n4 < LITERALS; n4++) {
        if (s4.dyn_ltree[n4 * 2] !== 0) {
          return Z_TEXT;
        }
      }
      return Z_BINARY;
    }
    var static_init_done = false;
    function _tr_init(s4) {
      if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
      }
      s4.l_desc = new TreeDesc(s4.dyn_ltree, static_l_desc);
      s4.d_desc = new TreeDesc(s4.dyn_dtree, static_d_desc);
      s4.bl_desc = new TreeDesc(s4.bl_tree, static_bl_desc);
      s4.bi_buf = 0;
      s4.bi_valid = 0;
      init_block(s4);
    }
    function _tr_stored_block(s4, buf, stored_len, last) {
      send_bits(s4, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
      copy_block(s4, buf, stored_len, true);
    }
    function _tr_align(s4) {
      send_bits(s4, STATIC_TREES << 1, 3);
      send_code(s4, END_BLOCK, static_ltree);
      bi_flush(s4);
    }
    function _tr_flush_block(s4, buf, stored_len, last) {
      var opt_lenb, static_lenb;
      var max_blindex = 0;
      if (s4.level > 0) {
        if (s4.strm.data_type === Z_UNKNOWN) {
          s4.strm.data_type = detect_data_type(s4);
        }
        build_tree(s4, s4.l_desc);
        build_tree(s4, s4.d_desc);
        max_blindex = build_bl_tree(s4);
        opt_lenb = s4.opt_len + 3 + 7 >>> 3;
        static_lenb = s4.static_len + 3 + 7 >>> 3;
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        opt_lenb = static_lenb = stored_len + 5;
      }
      if (stored_len + 4 <= opt_lenb && buf !== -1) {
        _tr_stored_block(s4, buf, stored_len, last);
      } else if (s4.strategy === Z_FIXED || static_lenb === opt_lenb) {
        send_bits(s4, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
        compress_block(s4, static_ltree, static_dtree);
      } else {
        send_bits(s4, (DYN_TREES << 1) + (last ? 1 : 0), 3);
        send_all_trees(s4, s4.l_desc.max_code + 1, s4.d_desc.max_code + 1, max_blindex + 1);
        compress_block(s4, s4.dyn_ltree, s4.dyn_dtree);
      }
      init_block(s4);
      if (last) {
        bi_windup(s4);
      }
    }
    function _tr_tally(s4, dist, lc) {
      s4.pending_buf[s4.d_buf + s4.last_lit * 2] = dist >>> 8 & 255;
      s4.pending_buf[s4.d_buf + s4.last_lit * 2 + 1] = dist & 255;
      s4.pending_buf[s4.l_buf + s4.last_lit] = lc & 255;
      s4.last_lit++;
      if (dist === 0) {
        s4.dyn_ltree[lc * 2]++;
      } else {
        s4.matches++;
        dist--;
        s4.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
        s4.dyn_dtree[d_code(dist) * 2]++;
      }
      return s4.last_lit === s4.lit_bufsize - 1;
    }
    exports._tr_init = _tr_init;
    exports._tr_stored_block = _tr_stored_block;
    exports._tr_flush_block = _tr_flush_block;
    exports._tr_tally = _tr_tally;
    exports._tr_align = _tr_align;
  }
});

// ../../node_modules/pako/lib/zlib/adler32.js
var require_adler32 = __commonJS({
  "../../node_modules/pako/lib/zlib/adler32.js"(exports, module) {
    "use strict";
    init_define_import_meta_env();
    function adler32(adler, buf, len, pos) {
      var s1 = adler & 65535 | 0, s22 = adler >>> 16 & 65535 | 0, n4 = 0;
      while (len !== 0) {
        n4 = len > 2e3 ? 2e3 : len;
        len -= n4;
        do {
          s1 = s1 + buf[pos++] | 0;
          s22 = s22 + s1 | 0;
        } while (--n4);
        s1 %= 65521;
        s22 %= 65521;
      }
      return s1 | s22 << 16 | 0;
    }
    module.exports = adler32;
  }
});

// ../../node_modules/pako/lib/zlib/crc32.js
var require_crc322 = __commonJS({
  "../../node_modules/pako/lib/zlib/crc32.js"(exports, module) {
    "use strict";
    init_define_import_meta_env();
    function makeTable() {
      var c3, table = [];
      for (var n4 = 0; n4 < 256; n4++) {
        c3 = n4;
        for (var k2 = 0; k2 < 8; k2++) {
          c3 = c3 & 1 ? 3988292384 ^ c3 >>> 1 : c3 >>> 1;
        }
        table[n4] = c3;
      }
      return table;
    }
    var crcTable = makeTable();
    function crc32(crc, buf, len, pos) {
      var t4 = crcTable, end = pos + len;
      crc ^= -1;
      for (var i4 = pos; i4 < end; i4++) {
        crc = crc >>> 8 ^ t4[(crc ^ buf[i4]) & 255];
      }
      return crc ^ -1;
    }
    module.exports = crc32;
  }
});

// ../../node_modules/pako/lib/zlib/messages.js
var require_messages = __commonJS({
  "../../node_modules/pako/lib/zlib/messages.js"(exports, module) {
    "use strict";
    init_define_import_meta_env();
    module.exports = {
      2: "need dictionary",
      /* Z_NEED_DICT       2  */
      1: "stream end",
      /* Z_STREAM_END      1  */
      0: "",
      /* Z_OK              0  */
      "-1": "file error",
      /* Z_ERRNO         (-1) */
      "-2": "stream error",
      /* Z_STREAM_ERROR  (-2) */
      "-3": "data error",
      /* Z_DATA_ERROR    (-3) */
      "-4": "insufficient memory",
      /* Z_MEM_ERROR     (-4) */
      "-5": "buffer error",
      /* Z_BUF_ERROR     (-5) */
      "-6": "incompatible version"
      /* Z_VERSION_ERROR (-6) */
    };
  }
});

// ../../node_modules/pako/lib/zlib/deflate.js
var require_deflate = __commonJS({
  "../../node_modules/pako/lib/zlib/deflate.js"(exports) {
    "use strict";
    init_define_import_meta_env();
    var utils = require_common();
    var trees = require_trees();
    var adler32 = require_adler32();
    var crc32 = require_crc322();
    var msg = require_messages();
    var Z_NO_FLUSH = 0;
    var Z_PARTIAL_FLUSH = 1;
    var Z_FULL_FLUSH = 3;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_BUF_ERROR = -5;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_FILTERED = 1;
    var Z_HUFFMAN_ONLY = 2;
    var Z_RLE = 3;
    var Z_FIXED = 4;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_UNKNOWN = 2;
    var Z_DEFLATED = 8;
    var MAX_MEM_LEVEL = 9;
    var MAX_WBITS = 15;
    var DEF_MEM_LEVEL = 8;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
    var PRESET_DICT = 32;
    var INIT_STATE = 42;
    var EXTRA_STATE = 69;
    var NAME_STATE = 73;
    var COMMENT_STATE = 91;
    var HCRC_STATE = 103;
    var BUSY_STATE = 113;
    var FINISH_STATE = 666;
    var BS_NEED_MORE = 1;
    var BS_BLOCK_DONE = 2;
    var BS_FINISH_STARTED = 3;
    var BS_FINISH_DONE = 4;
    var OS_CODE = 3;
    function err(strm, errorCode) {
      strm.msg = msg[errorCode];
      return errorCode;
    }
    function rank(f3) {
      return (f3 << 1) - (f3 > 4 ? 9 : 0);
    }
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    function flush_pending(strm) {
      var s4 = strm.state;
      var len = s4.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === 0) {
        return;
      }
      utils.arraySet(strm.output, s4.pending_buf, s4.pending_out, len, strm.next_out);
      strm.next_out += len;
      s4.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s4.pending -= len;
      if (s4.pending === 0) {
        s4.pending_out = 0;
      }
    }
    function flush_block_only(s4, last) {
      trees._tr_flush_block(s4, s4.block_start >= 0 ? s4.block_start : -1, s4.strstart - s4.block_start, last);
      s4.block_start = s4.strstart;
      flush_pending(s4.strm);
    }
    function put_byte(s4, b4) {
      s4.pending_buf[s4.pending++] = b4;
    }
    function putShortMSB(s4, b4) {
      s4.pending_buf[s4.pending++] = b4 >>> 8 & 255;
      s4.pending_buf[s4.pending++] = b4 & 255;
    }
    function read_buf(strm, buf, start2, size) {
      var len = strm.avail_in;
      if (len > size) {
        len = size;
      }
      if (len === 0) {
        return 0;
      }
      strm.avail_in -= len;
      utils.arraySet(buf, strm.input, strm.next_in, len, start2);
      if (strm.state.wrap === 1) {
        strm.adler = adler32(strm.adler, buf, len, start2);
      } else if (strm.state.wrap === 2) {
        strm.adler = crc32(strm.adler, buf, len, start2);
      }
      strm.next_in += len;
      strm.total_in += len;
      return len;
    }
    function longest_match(s4, cur_match) {
      var chain_length = s4.max_chain_length;
      var scan = s4.strstart;
      var match;
      var len;
      var best_len = s4.prev_length;
      var nice_match = s4.nice_match;
      var limit = s4.strstart > s4.w_size - MIN_LOOKAHEAD ? s4.strstart - (s4.w_size - MIN_LOOKAHEAD) : 0;
      var _win = s4.window;
      var wmask = s4.w_mask;
      var prev = s4.prev;
      var strend = s4.strstart + MAX_MATCH;
      var scan_end1 = _win[scan + best_len - 1];
      var scan_end = _win[scan + best_len];
      if (s4.prev_length >= s4.good_match) {
        chain_length >>= 2;
      }
      if (nice_match > s4.lookahead) {
        nice_match = s4.lookahead;
      }
      do {
        match = cur_match;
        if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
          continue;
        }
        scan += 2;
        match++;
        do {
        } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
        len = MAX_MATCH - (strend - scan);
        scan = strend - MAX_MATCH;
        if (len > best_len) {
          s4.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end1 = _win[scan + best_len - 1];
          scan_end = _win[scan + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
      if (best_len <= s4.lookahead) {
        return best_len;
      }
      return s4.lookahead;
    }
    function fill_window(s4) {
      var _w_size = s4.w_size;
      var p3, n4, m3, more, str;
      do {
        more = s4.window_size - s4.lookahead - s4.strstart;
        if (s4.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
          utils.arraySet(s4.window, s4.window, _w_size, _w_size, 0);
          s4.match_start -= _w_size;
          s4.strstart -= _w_size;
          s4.block_start -= _w_size;
          n4 = s4.hash_size;
          p3 = n4;
          do {
            m3 = s4.head[--p3];
            s4.head[p3] = m3 >= _w_size ? m3 - _w_size : 0;
          } while (--n4);
          n4 = _w_size;
          p3 = n4;
          do {
            m3 = s4.prev[--p3];
            s4.prev[p3] = m3 >= _w_size ? m3 - _w_size : 0;
          } while (--n4);
          more += _w_size;
        }
        if (s4.strm.avail_in === 0) {
          break;
        }
        n4 = read_buf(s4.strm, s4.window, s4.strstart + s4.lookahead, more);
        s4.lookahead += n4;
        if (s4.lookahead + s4.insert >= MIN_MATCH) {
          str = s4.strstart - s4.insert;
          s4.ins_h = s4.window[str];
          s4.ins_h = (s4.ins_h << s4.hash_shift ^ s4.window[str + 1]) & s4.hash_mask;
          while (s4.insert) {
            s4.ins_h = (s4.ins_h << s4.hash_shift ^ s4.window[str + MIN_MATCH - 1]) & s4.hash_mask;
            s4.prev[str & s4.w_mask] = s4.head[s4.ins_h];
            s4.head[s4.ins_h] = str;
            str++;
            s4.insert--;
            if (s4.lookahead + s4.insert < MIN_MATCH) {
              break;
            }
          }
        }
      } while (s4.lookahead < MIN_LOOKAHEAD && s4.strm.avail_in !== 0);
    }
    function deflate_stored(s4, flush) {
      var max_block_size = 65535;
      if (max_block_size > s4.pending_buf_size - 5) {
        max_block_size = s4.pending_buf_size - 5;
      }
      for (; ; ) {
        if (s4.lookahead <= 1) {
          fill_window(s4);
          if (s4.lookahead === 0 && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s4.lookahead === 0) {
            break;
          }
        }
        s4.strstart += s4.lookahead;
        s4.lookahead = 0;
        var max_start = s4.block_start + max_block_size;
        if (s4.strstart === 0 || s4.strstart >= max_start) {
          s4.lookahead = s4.strstart - max_start;
          s4.strstart = max_start;
          flush_block_only(s4, false);
          if (s4.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        if (s4.strstart - s4.block_start >= s4.w_size - MIN_LOOKAHEAD) {
          flush_block_only(s4, false);
          if (s4.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s4.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s4, true);
        if (s4.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s4.strstart > s4.block_start) {
        flush_block_only(s4, false);
        if (s4.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_NEED_MORE;
    }
    function deflate_fast(s4, flush) {
      var hash_head;
      var bflush;
      for (; ; ) {
        if (s4.lookahead < MIN_LOOKAHEAD) {
          fill_window(s4);
          if (s4.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s4.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s4.lookahead >= MIN_MATCH) {
          s4.ins_h = (s4.ins_h << s4.hash_shift ^ s4.window[s4.strstart + MIN_MATCH - 1]) & s4.hash_mask;
          hash_head = s4.prev[s4.strstart & s4.w_mask] = s4.head[s4.ins_h];
          s4.head[s4.ins_h] = s4.strstart;
        }
        if (hash_head !== 0 && s4.strstart - hash_head <= s4.w_size - MIN_LOOKAHEAD) {
          s4.match_length = longest_match(s4, hash_head);
        }
        if (s4.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s4, s4.strstart - s4.match_start, s4.match_length - MIN_MATCH);
          s4.lookahead -= s4.match_length;
          if (s4.match_length <= s4.max_lazy_match && s4.lookahead >= MIN_MATCH) {
            s4.match_length--;
            do {
              s4.strstart++;
              s4.ins_h = (s4.ins_h << s4.hash_shift ^ s4.window[s4.strstart + MIN_MATCH - 1]) & s4.hash_mask;
              hash_head = s4.prev[s4.strstart & s4.w_mask] = s4.head[s4.ins_h];
              s4.head[s4.ins_h] = s4.strstart;
            } while (--s4.match_length !== 0);
            s4.strstart++;
          } else {
            s4.strstart += s4.match_length;
            s4.match_length = 0;
            s4.ins_h = s4.window[s4.strstart];
            s4.ins_h = (s4.ins_h << s4.hash_shift ^ s4.window[s4.strstart + 1]) & s4.hash_mask;
          }
        } else {
          bflush = trees._tr_tally(s4, 0, s4.window[s4.strstart]);
          s4.lookahead--;
          s4.strstart++;
        }
        if (bflush) {
          flush_block_only(s4, false);
          if (s4.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s4.insert = s4.strstart < MIN_MATCH - 1 ? s4.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s4, true);
        if (s4.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s4.last_lit) {
        flush_block_only(s4, false);
        if (s4.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_slow(s4, flush) {
      var hash_head;
      var bflush;
      var max_insert;
      for (; ; ) {
        if (s4.lookahead < MIN_LOOKAHEAD) {
          fill_window(s4);
          if (s4.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s4.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s4.lookahead >= MIN_MATCH) {
          s4.ins_h = (s4.ins_h << s4.hash_shift ^ s4.window[s4.strstart + MIN_MATCH - 1]) & s4.hash_mask;
          hash_head = s4.prev[s4.strstart & s4.w_mask] = s4.head[s4.ins_h];
          s4.head[s4.ins_h] = s4.strstart;
        }
        s4.prev_length = s4.match_length;
        s4.prev_match = s4.match_start;
        s4.match_length = MIN_MATCH - 1;
        if (hash_head !== 0 && s4.prev_length < s4.max_lazy_match && s4.strstart - hash_head <= s4.w_size - MIN_LOOKAHEAD) {
          s4.match_length = longest_match(s4, hash_head);
          if (s4.match_length <= 5 && (s4.strategy === Z_FILTERED || s4.match_length === MIN_MATCH && s4.strstart - s4.match_start > 4096)) {
            s4.match_length = MIN_MATCH - 1;
          }
        }
        if (s4.prev_length >= MIN_MATCH && s4.match_length <= s4.prev_length) {
          max_insert = s4.strstart + s4.lookahead - MIN_MATCH;
          bflush = trees._tr_tally(s4, s4.strstart - 1 - s4.prev_match, s4.prev_length - MIN_MATCH);
          s4.lookahead -= s4.prev_length - 1;
          s4.prev_length -= 2;
          do {
            if (++s4.strstart <= max_insert) {
              s4.ins_h = (s4.ins_h << s4.hash_shift ^ s4.window[s4.strstart + MIN_MATCH - 1]) & s4.hash_mask;
              hash_head = s4.prev[s4.strstart & s4.w_mask] = s4.head[s4.ins_h];
              s4.head[s4.ins_h] = s4.strstart;
            }
          } while (--s4.prev_length !== 0);
          s4.match_available = 0;
          s4.match_length = MIN_MATCH - 1;
          s4.strstart++;
          if (bflush) {
            flush_block_only(s4, false);
            if (s4.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        } else if (s4.match_available) {
          bflush = trees._tr_tally(s4, 0, s4.window[s4.strstart - 1]);
          if (bflush) {
            flush_block_only(s4, false);
          }
          s4.strstart++;
          s4.lookahead--;
          if (s4.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        } else {
          s4.match_available = 1;
          s4.strstart++;
          s4.lookahead--;
        }
      }
      if (s4.match_available) {
        bflush = trees._tr_tally(s4, 0, s4.window[s4.strstart - 1]);
        s4.match_available = 0;
      }
      s4.insert = s4.strstart < MIN_MATCH - 1 ? s4.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s4, true);
        if (s4.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s4.last_lit) {
        flush_block_only(s4, false);
        if (s4.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_rle(s4, flush) {
      var bflush;
      var prev;
      var scan, strend;
      var _win = s4.window;
      for (; ; ) {
        if (s4.lookahead <= MAX_MATCH) {
          fill_window(s4);
          if (s4.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s4.lookahead === 0) {
            break;
          }
        }
        s4.match_length = 0;
        if (s4.lookahead >= MIN_MATCH && s4.strstart > 0) {
          scan = s4.strstart - 1;
          prev = _win[scan];
          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
            strend = s4.strstart + MAX_MATCH;
            do {
            } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
            s4.match_length = MAX_MATCH - (strend - scan);
            if (s4.match_length > s4.lookahead) {
              s4.match_length = s4.lookahead;
            }
          }
        }
        if (s4.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s4, 1, s4.match_length - MIN_MATCH);
          s4.lookahead -= s4.match_length;
          s4.strstart += s4.match_length;
          s4.match_length = 0;
        } else {
          bflush = trees._tr_tally(s4, 0, s4.window[s4.strstart]);
          s4.lookahead--;
          s4.strstart++;
        }
        if (bflush) {
          flush_block_only(s4, false);
          if (s4.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s4.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s4, true);
        if (s4.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s4.last_lit) {
        flush_block_only(s4, false);
        if (s4.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_huff(s4, flush) {
      var bflush;
      for (; ; ) {
        if (s4.lookahead === 0) {
          fill_window(s4);
          if (s4.lookahead === 0) {
            if (flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            break;
          }
        }
        s4.match_length = 0;
        bflush = trees._tr_tally(s4, 0, s4.window[s4.strstart]);
        s4.lookahead--;
        s4.strstart++;
        if (bflush) {
          flush_block_only(s4, false);
          if (s4.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s4.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s4, true);
        if (s4.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s4.last_lit) {
        flush_block_only(s4, false);
        if (s4.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function Config(good_length, max_lazy, nice_length, max_chain, func) {
      this.good_length = good_length;
      this.max_lazy = max_lazy;
      this.nice_length = nice_length;
      this.max_chain = max_chain;
      this.func = func;
    }
    var configuration_table;
    configuration_table = [
      /*      good lazy nice chain */
      new Config(0, 0, 0, 0, deflate_stored),
      /* 0 store only */
      new Config(4, 4, 8, 4, deflate_fast),
      /* 1 max speed, no lazy matches */
      new Config(4, 5, 16, 8, deflate_fast),
      /* 2 */
      new Config(4, 6, 32, 32, deflate_fast),
      /* 3 */
      new Config(4, 4, 16, 16, deflate_slow),
      /* 4 lazy matches */
      new Config(8, 16, 32, 32, deflate_slow),
      /* 5 */
      new Config(8, 16, 128, 128, deflate_slow),
      /* 6 */
      new Config(8, 32, 128, 256, deflate_slow),
      /* 7 */
      new Config(32, 128, 258, 1024, deflate_slow),
      /* 8 */
      new Config(32, 258, 258, 4096, deflate_slow)
      /* 9 max compression */
    ];
    function lm_init(s4) {
      s4.window_size = 2 * s4.w_size;
      zero(s4.head);
      s4.max_lazy_match = configuration_table[s4.level].max_lazy;
      s4.good_match = configuration_table[s4.level].good_length;
      s4.nice_match = configuration_table[s4.level].nice_length;
      s4.max_chain_length = configuration_table[s4.level].max_chain;
      s4.strstart = 0;
      s4.block_start = 0;
      s4.lookahead = 0;
      s4.insert = 0;
      s4.match_length = s4.prev_length = MIN_MATCH - 1;
      s4.match_available = 0;
      s4.ins_h = 0;
    }
    function DeflateState() {
      this.strm = null;
      this.status = 0;
      this.pending_buf = null;
      this.pending_buf_size = 0;
      this.pending_out = 0;
      this.pending = 0;
      this.wrap = 0;
      this.gzhead = null;
      this.gzindex = 0;
      this.method = Z_DEFLATED;
      this.last_flush = -1;
      this.w_size = 0;
      this.w_bits = 0;
      this.w_mask = 0;
      this.window = null;
      this.window_size = 0;
      this.prev = null;
      this.head = null;
      this.ins_h = 0;
      this.hash_size = 0;
      this.hash_bits = 0;
      this.hash_mask = 0;
      this.hash_shift = 0;
      this.block_start = 0;
      this.match_length = 0;
      this.prev_match = 0;
      this.match_available = 0;
      this.strstart = 0;
      this.match_start = 0;
      this.lookahead = 0;
      this.prev_length = 0;
      this.max_chain_length = 0;
      this.max_lazy_match = 0;
      this.level = 0;
      this.strategy = 0;
      this.good_match = 0;
      this.nice_match = 0;
      this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
      this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
      this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
      zero(this.dyn_ltree);
      zero(this.dyn_dtree);
      zero(this.bl_tree);
      this.l_desc = null;
      this.d_desc = null;
      this.bl_desc = null;
      this.bl_count = new utils.Buf16(MAX_BITS + 1);
      this.heap = new utils.Buf16(2 * L_CODES + 1);
      zero(this.heap);
      this.heap_len = 0;
      this.heap_max = 0;
      this.depth = new utils.Buf16(2 * L_CODES + 1);
      zero(this.depth);
      this.l_buf = 0;
      this.lit_bufsize = 0;
      this.last_lit = 0;
      this.d_buf = 0;
      this.opt_len = 0;
      this.static_len = 0;
      this.matches = 0;
      this.insert = 0;
      this.bi_buf = 0;
      this.bi_valid = 0;
    }
    function deflateResetKeep(strm) {
      var s4;
      if (!strm || !strm.state) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN;
      s4 = strm.state;
      s4.pending = 0;
      s4.pending_out = 0;
      if (s4.wrap < 0) {
        s4.wrap = -s4.wrap;
      }
      s4.status = s4.wrap ? INIT_STATE : BUSY_STATE;
      strm.adler = s4.wrap === 2 ? 0 : 1;
      s4.last_flush = Z_NO_FLUSH;
      trees._tr_init(s4);
      return Z_OK;
    }
    function deflateReset(strm) {
      var ret = deflateResetKeep(strm);
      if (ret === Z_OK) {
        lm_init(strm.state);
      }
      return ret;
    }
    function deflateSetHeader(strm, head) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      if (strm.state.wrap !== 2) {
        return Z_STREAM_ERROR;
      }
      strm.state.gzhead = head;
      return Z_OK;
    }
    function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      var wrap = 1;
      if (level === Z_DEFAULT_COMPRESSION) {
        level = 6;
      }
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else if (windowBits > 15) {
        wrap = 2;
        windowBits -= 16;
      }
      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
        return err(strm, Z_STREAM_ERROR);
      }
      if (windowBits === 8) {
        windowBits = 9;
      }
      var s4 = new DeflateState();
      strm.state = s4;
      s4.strm = strm;
      s4.wrap = wrap;
      s4.gzhead = null;
      s4.w_bits = windowBits;
      s4.w_size = 1 << s4.w_bits;
      s4.w_mask = s4.w_size - 1;
      s4.hash_bits = memLevel + 7;
      s4.hash_size = 1 << s4.hash_bits;
      s4.hash_mask = s4.hash_size - 1;
      s4.hash_shift = ~~((s4.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
      s4.window = new utils.Buf8(s4.w_size * 2);
      s4.head = new utils.Buf16(s4.hash_size);
      s4.prev = new utils.Buf16(s4.w_size);
      s4.lit_bufsize = 1 << memLevel + 6;
      s4.pending_buf_size = s4.lit_bufsize * 4;
      s4.pending_buf = new utils.Buf8(s4.pending_buf_size);
      s4.d_buf = 1 * s4.lit_bufsize;
      s4.l_buf = (1 + 2) * s4.lit_bufsize;
      s4.level = level;
      s4.strategy = strategy;
      s4.method = method;
      return deflateReset(strm);
    }
    function deflateInit(strm, level) {
      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
    }
    function deflate2(strm, flush) {
      var old_flush, s4;
      var beg, val;
      if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
      }
      s4 = strm.state;
      if (!strm.output || !strm.input && strm.avail_in !== 0 || s4.status === FINISH_STATE && flush !== Z_FINISH) {
        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
      }
      s4.strm = strm;
      old_flush = s4.last_flush;
      s4.last_flush = flush;
      if (s4.status === INIT_STATE) {
        if (s4.wrap === 2) {
          strm.adler = 0;
          put_byte(s4, 31);
          put_byte(s4, 139);
          put_byte(s4, 8);
          if (!s4.gzhead) {
            put_byte(s4, 0);
            put_byte(s4, 0);
            put_byte(s4, 0);
            put_byte(s4, 0);
            put_byte(s4, 0);
            put_byte(s4, s4.level === 9 ? 2 : s4.strategy >= Z_HUFFMAN_ONLY || s4.level < 2 ? 4 : 0);
            put_byte(s4, OS_CODE);
            s4.status = BUSY_STATE;
          } else {
            put_byte(
              s4,
              (s4.gzhead.text ? 1 : 0) + (s4.gzhead.hcrc ? 2 : 0) + (!s4.gzhead.extra ? 0 : 4) + (!s4.gzhead.name ? 0 : 8) + (!s4.gzhead.comment ? 0 : 16)
            );
            put_byte(s4, s4.gzhead.time & 255);
            put_byte(s4, s4.gzhead.time >> 8 & 255);
            put_byte(s4, s4.gzhead.time >> 16 & 255);
            put_byte(s4, s4.gzhead.time >> 24 & 255);
            put_byte(s4, s4.level === 9 ? 2 : s4.strategy >= Z_HUFFMAN_ONLY || s4.level < 2 ? 4 : 0);
            put_byte(s4, s4.gzhead.os & 255);
            if (s4.gzhead.extra && s4.gzhead.extra.length) {
              put_byte(s4, s4.gzhead.extra.length & 255);
              put_byte(s4, s4.gzhead.extra.length >> 8 & 255);
            }
            if (s4.gzhead.hcrc) {
              strm.adler = crc32(strm.adler, s4.pending_buf, s4.pending, 0);
            }
            s4.gzindex = 0;
            s4.status = EXTRA_STATE;
          }
        } else {
          var header = Z_DEFLATED + (s4.w_bits - 8 << 4) << 8;
          var level_flags = -1;
          if (s4.strategy >= Z_HUFFMAN_ONLY || s4.level < 2) {
            level_flags = 0;
          } else if (s4.level < 6) {
            level_flags = 1;
          } else if (s4.level === 6) {
            level_flags = 2;
          } else {
            level_flags = 3;
          }
          header |= level_flags << 6;
          if (s4.strstart !== 0) {
            header |= PRESET_DICT;
          }
          header += 31 - header % 31;
          s4.status = BUSY_STATE;
          putShortMSB(s4, header);
          if (s4.strstart !== 0) {
            putShortMSB(s4, strm.adler >>> 16);
            putShortMSB(s4, strm.adler & 65535);
          }
          strm.adler = 1;
        }
      }
      if (s4.status === EXTRA_STATE) {
        if (s4.gzhead.extra) {
          beg = s4.pending;
          while (s4.gzindex < (s4.gzhead.extra.length & 65535)) {
            if (s4.pending === s4.pending_buf_size) {
              if (s4.gzhead.hcrc && s4.pending > beg) {
                strm.adler = crc32(strm.adler, s4.pending_buf, s4.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s4.pending;
              if (s4.pending === s4.pending_buf_size) {
                break;
              }
            }
            put_byte(s4, s4.gzhead.extra[s4.gzindex] & 255);
            s4.gzindex++;
          }
          if (s4.gzhead.hcrc && s4.pending > beg) {
            strm.adler = crc32(strm.adler, s4.pending_buf, s4.pending - beg, beg);
          }
          if (s4.gzindex === s4.gzhead.extra.length) {
            s4.gzindex = 0;
            s4.status = NAME_STATE;
          }
        } else {
          s4.status = NAME_STATE;
        }
      }
      if (s4.status === NAME_STATE) {
        if (s4.gzhead.name) {
          beg = s4.pending;
          do {
            if (s4.pending === s4.pending_buf_size) {
              if (s4.gzhead.hcrc && s4.pending > beg) {
                strm.adler = crc32(strm.adler, s4.pending_buf, s4.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s4.pending;
              if (s4.pending === s4.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s4.gzindex < s4.gzhead.name.length) {
              val = s4.gzhead.name.charCodeAt(s4.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s4, val);
          } while (val !== 0);
          if (s4.gzhead.hcrc && s4.pending > beg) {
            strm.adler = crc32(strm.adler, s4.pending_buf, s4.pending - beg, beg);
          }
          if (val === 0) {
            s4.gzindex = 0;
            s4.status = COMMENT_STATE;
          }
        } else {
          s4.status = COMMENT_STATE;
        }
      }
      if (s4.status === COMMENT_STATE) {
        if (s4.gzhead.comment) {
          beg = s4.pending;
          do {
            if (s4.pending === s4.pending_buf_size) {
              if (s4.gzhead.hcrc && s4.pending > beg) {
                strm.adler = crc32(strm.adler, s4.pending_buf, s4.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s4.pending;
              if (s4.pending === s4.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s4.gzindex < s4.gzhead.comment.length) {
              val = s4.gzhead.comment.charCodeAt(s4.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s4, val);
          } while (val !== 0);
          if (s4.gzhead.hcrc && s4.pending > beg) {
            strm.adler = crc32(strm.adler, s4.pending_buf, s4.pending - beg, beg);
          }
          if (val === 0) {
            s4.status = HCRC_STATE;
          }
        } else {
          s4.status = HCRC_STATE;
        }
      }
      if (s4.status === HCRC_STATE) {
        if (s4.gzhead.hcrc) {
          if (s4.pending + 2 > s4.pending_buf_size) {
            flush_pending(strm);
          }
          if (s4.pending + 2 <= s4.pending_buf_size) {
            put_byte(s4, strm.adler & 255);
            put_byte(s4, strm.adler >> 8 & 255);
            strm.adler = 0;
            s4.status = BUSY_STATE;
          }
        } else {
          s4.status = BUSY_STATE;
        }
      }
      if (s4.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s4.last_flush = -1;
          return Z_OK;
        }
      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
        return err(strm, Z_BUF_ERROR);
      }
      if (s4.status === FINISH_STATE && strm.avail_in !== 0) {
        return err(strm, Z_BUF_ERROR);
      }
      if (strm.avail_in !== 0 || s4.lookahead !== 0 || flush !== Z_NO_FLUSH && s4.status !== FINISH_STATE) {
        var bstate = s4.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s4, flush) : s4.strategy === Z_RLE ? deflate_rle(s4, flush) : configuration_table[s4.level].func(s4, flush);
        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
          s4.status = FINISH_STATE;
        }
        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
          if (strm.avail_out === 0) {
            s4.last_flush = -1;
          }
          return Z_OK;
        }
        if (bstate === BS_BLOCK_DONE) {
          if (flush === Z_PARTIAL_FLUSH) {
            trees._tr_align(s4);
          } else if (flush !== Z_BLOCK) {
            trees._tr_stored_block(s4, 0, 0, false);
            if (flush === Z_FULL_FLUSH) {
              zero(s4.head);
              if (s4.lookahead === 0) {
                s4.strstart = 0;
                s4.block_start = 0;
                s4.insert = 0;
              }
            }
          }
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s4.last_flush = -1;
            return Z_OK;
          }
        }
      }
      if (flush !== Z_FINISH) {
        return Z_OK;
      }
      if (s4.wrap <= 0) {
        return Z_STREAM_END;
      }
      if (s4.wrap === 2) {
        put_byte(s4, strm.adler & 255);
        put_byte(s4, strm.adler >> 8 & 255);
        put_byte(s4, strm.adler >> 16 & 255);
        put_byte(s4, strm.adler >> 24 & 255);
        put_byte(s4, strm.total_in & 255);
        put_byte(s4, strm.total_in >> 8 & 255);
        put_byte(s4, strm.total_in >> 16 & 255);
        put_byte(s4, strm.total_in >> 24 & 255);
      } else {
        putShortMSB(s4, strm.adler >>> 16);
        putShortMSB(s4, strm.adler & 65535);
      }
      flush_pending(strm);
      if (s4.wrap > 0) {
        s4.wrap = -s4.wrap;
      }
      return s4.pending !== 0 ? Z_OK : Z_STREAM_END;
    }
    function deflateEnd(strm) {
      var status;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      status = strm.state.status;
      if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.state = null;
      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
    }
    function deflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var s4;
      var str, n4;
      var wrap;
      var avail;
      var next;
      var input;
      var tmpDict;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      s4 = strm.state;
      wrap = s4.wrap;
      if (wrap === 2 || wrap === 1 && s4.status !== INIT_STATE || s4.lookahead) {
        return Z_STREAM_ERROR;
      }
      if (wrap === 1) {
        strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
      }
      s4.wrap = 0;
      if (dictLength >= s4.w_size) {
        if (wrap === 0) {
          zero(s4.head);
          s4.strstart = 0;
          s4.block_start = 0;
          s4.insert = 0;
        }
        tmpDict = new utils.Buf8(s4.w_size);
        utils.arraySet(tmpDict, dictionary, dictLength - s4.w_size, s4.w_size, 0);
        dictionary = tmpDict;
        dictLength = s4.w_size;
      }
      avail = strm.avail_in;
      next = strm.next_in;
      input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = 0;
      strm.input = dictionary;
      fill_window(s4);
      while (s4.lookahead >= MIN_MATCH) {
        str = s4.strstart;
        n4 = s4.lookahead - (MIN_MATCH - 1);
        do {
          s4.ins_h = (s4.ins_h << s4.hash_shift ^ s4.window[str + MIN_MATCH - 1]) & s4.hash_mask;
          s4.prev[str & s4.w_mask] = s4.head[s4.ins_h];
          s4.head[s4.ins_h] = str;
          str++;
        } while (--n4);
        s4.strstart = str;
        s4.lookahead = MIN_MATCH - 1;
        fill_window(s4);
      }
      s4.strstart += s4.lookahead;
      s4.block_start = s4.strstart;
      s4.insert = s4.lookahead;
      s4.lookahead = 0;
      s4.match_length = s4.prev_length = MIN_MATCH - 1;
      s4.match_available = 0;
      strm.next_in = next;
      strm.input = input;
      strm.avail_in = avail;
      s4.wrap = wrap;
      return Z_OK;
    }
    exports.deflateInit = deflateInit;
    exports.deflateInit2 = deflateInit2;
    exports.deflateReset = deflateReset;
    exports.deflateResetKeep = deflateResetKeep;
    exports.deflateSetHeader = deflateSetHeader;
    exports.deflate = deflate2;
    exports.deflateEnd = deflateEnd;
    exports.deflateSetDictionary = deflateSetDictionary;
    exports.deflateInfo = "pako deflate (from Nodeca project)";
  }
});

// ../../node_modules/pako/lib/utils/strings.js
var require_strings = __commonJS({
  "../../node_modules/pako/lib/utils/strings.js"(exports) {
    "use strict";
    init_define_import_meta_env();
    var utils = require_common();
    var STR_APPLY_OK = true;
    var STR_APPLY_UIA_OK = true;
    try {
      String.fromCharCode.apply(null, [0]);
    } catch (__) {
      STR_APPLY_OK = false;
    }
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      STR_APPLY_UIA_OK = false;
    }
    var _utf8len = new utils.Buf8(256);
    for (q = 0; q < 256; q++) {
      _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
    }
    var q;
    _utf8len[254] = _utf8len[254] = 1;
    exports.string2buf = function(str) {
      var buf, c3, c22, m_pos, i4, str_len = str.length, buf_len = 0;
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c3 = str.charCodeAt(m_pos);
        if ((c3 & 64512) === 55296 && m_pos + 1 < str_len) {
          c22 = str.charCodeAt(m_pos + 1);
          if ((c22 & 64512) === 56320) {
            c3 = 65536 + (c3 - 55296 << 10) + (c22 - 56320);
            m_pos++;
          }
        }
        buf_len += c3 < 128 ? 1 : c3 < 2048 ? 2 : c3 < 65536 ? 3 : 4;
      }
      buf = new utils.Buf8(buf_len);
      for (i4 = 0, m_pos = 0; i4 < buf_len; m_pos++) {
        c3 = str.charCodeAt(m_pos);
        if ((c3 & 64512) === 55296 && m_pos + 1 < str_len) {
          c22 = str.charCodeAt(m_pos + 1);
          if ((c22 & 64512) === 56320) {
            c3 = 65536 + (c3 - 55296 << 10) + (c22 - 56320);
            m_pos++;
          }
        }
        if (c3 < 128) {
          buf[i4++] = c3;
        } else if (c3 < 2048) {
          buf[i4++] = 192 | c3 >>> 6;
          buf[i4++] = 128 | c3 & 63;
        } else if (c3 < 65536) {
          buf[i4++] = 224 | c3 >>> 12;
          buf[i4++] = 128 | c3 >>> 6 & 63;
          buf[i4++] = 128 | c3 & 63;
        } else {
          buf[i4++] = 240 | c3 >>> 18;
          buf[i4++] = 128 | c3 >>> 12 & 63;
          buf[i4++] = 128 | c3 >>> 6 & 63;
          buf[i4++] = 128 | c3 & 63;
        }
      }
      return buf;
    };
    function buf2binstring(buf, len) {
      if (len < 65534) {
        if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
          return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
        }
      }
      var result = "";
      for (var i4 = 0; i4 < len; i4++) {
        result += String.fromCharCode(buf[i4]);
      }
      return result;
    }
    exports.buf2binstring = function(buf) {
      return buf2binstring(buf, buf.length);
    };
    exports.binstring2buf = function(str) {
      var buf = new utils.Buf8(str.length);
      for (var i4 = 0, len = buf.length; i4 < len; i4++) {
        buf[i4] = str.charCodeAt(i4);
      }
      return buf;
    };
    exports.buf2string = function(buf, max) {
      var i4, out, c3, c_len;
      var len = max || buf.length;
      var utf16buf = new Array(len * 2);
      for (out = 0, i4 = 0; i4 < len; ) {
        c3 = buf[i4++];
        if (c3 < 128) {
          utf16buf[out++] = c3;
          continue;
        }
        c_len = _utf8len[c3];
        if (c_len > 4) {
          utf16buf[out++] = 65533;
          i4 += c_len - 1;
          continue;
        }
        c3 &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
        while (c_len > 1 && i4 < len) {
          c3 = c3 << 6 | buf[i4++] & 63;
          c_len--;
        }
        if (c_len > 1) {
          utf16buf[out++] = 65533;
          continue;
        }
        if (c3 < 65536) {
          utf16buf[out++] = c3;
        } else {
          c3 -= 65536;
          utf16buf[out++] = 55296 | c3 >> 10 & 1023;
          utf16buf[out++] = 56320 | c3 & 1023;
        }
      }
      return buf2binstring(utf16buf, out);
    };
    exports.utf8border = function(buf, max) {
      var pos;
      max = max || buf.length;
      if (max > buf.length) {
        max = buf.length;
      }
      pos = max - 1;
      while (pos >= 0 && (buf[pos] & 192) === 128) {
        pos--;
      }
      if (pos < 0) {
        return max;
      }
      if (pos === 0) {
        return max;
      }
      return pos + _utf8len[buf[pos]] > max ? pos : max;
    };
  }
});

// ../../node_modules/pako/lib/zlib/zstream.js
var require_zstream = __commonJS({
  "../../node_modules/pako/lib/zlib/zstream.js"(exports, module) {
    "use strict";
    init_define_import_meta_env();
    function ZStream() {
      this.input = null;
      this.next_in = 0;
      this.avail_in = 0;
      this.total_in = 0;
      this.output = null;
      this.next_out = 0;
      this.avail_out = 0;
      this.total_out = 0;
      this.msg = "";
      this.state = null;
      this.data_type = 2;
      this.adler = 0;
    }
    module.exports = ZStream;
  }
});

// ../../node_modules/pako/lib/deflate.js
var require_deflate2 = __commonJS({
  "../../node_modules/pako/lib/deflate.js"(exports) {
    "use strict";
    init_define_import_meta_env();
    var zlib_deflate = require_deflate();
    var utils = require_common();
    var strings = require_strings();
    var msg = require_messages();
    var ZStream = require_zstream();
    var toString = Object.prototype.toString;
    var Z_NO_FLUSH = 0;
    var Z_FINISH = 4;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_SYNC_FLUSH = 2;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_DEFLATED = 8;
    function Deflate(options) {
      if (!(this instanceof Deflate))
        return new Deflate(options);
      this.options = utils.assign({
        level: Z_DEFAULT_COMPRESSION,
        method: Z_DEFLATED,
        chunkSize: 16384,
        windowBits: 15,
        memLevel: 8,
        strategy: Z_DEFAULT_STRATEGY,
        to: ""
      }, options || {});
      var opt = this.options;
      if (opt.raw && opt.windowBits > 0) {
        opt.windowBits = -opt.windowBits;
      } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
        opt.windowBits += 16;
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      var status = zlib_deflate.deflateInit2(
        this.strm,
        opt.level,
        opt.method,
        opt.windowBits,
        opt.memLevel,
        opt.strategy
      );
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      if (opt.header) {
        zlib_deflate.deflateSetHeader(this.strm, opt.header);
      }
      if (opt.dictionary) {
        var dict;
        if (typeof opt.dictionary === "string") {
          dict = strings.string2buf(opt.dictionary);
        } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
          dict = new Uint8Array(opt.dictionary);
        } else {
          dict = opt.dictionary;
        }
        status = zlib_deflate.deflateSetDictionary(this.strm, dict);
        if (status !== Z_OK) {
          throw new Error(msg[status]);
        }
        this._dict_set = true;
      }
    }
    Deflate.prototype.push = function(data, mode) {
      var strm = this.strm;
      var chunkSize = this.options.chunkSize;
      var status, _mode;
      if (this.ended) {
        return false;
      }
      _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.string2buf(data);
      } else if (toString.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      do {
        if (strm.avail_out === 0) {
          strm.output = new utils.Buf8(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = zlib_deflate.deflate(strm, _mode);
        if (status !== Z_STREAM_END && status !== Z_OK) {
          this.onEnd(status);
          this.ended = true;
          return false;
        }
        if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
          if (this.options.to === "string") {
            this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
          } else {
            this.onData(utils.shrinkBuf(strm.output, strm.next_out));
          }
        }
      } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
      if (_mode === Z_FINISH) {
        status = zlib_deflate.deflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === Z_OK;
      }
      if (_mode === Z_SYNC_FLUSH) {
        this.onEnd(Z_OK);
        strm.avail_out = 0;
        return true;
      }
      return true;
    };
    Deflate.prototype.onData = function(chunk2) {
      this.chunks.push(chunk2);
    };
    Deflate.prototype.onEnd = function(status) {
      if (status === Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function deflate2(input, options) {
      var deflator = new Deflate(options);
      deflator.push(input, true);
      if (deflator.err) {
        throw deflator.msg || msg[deflator.err];
      }
      return deflator.result;
    }
    function deflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return deflate2(input, options);
    }
    function gzip(input, options) {
      options = options || {};
      options.gzip = true;
      return deflate2(input, options);
    }
    exports.Deflate = Deflate;
    exports.deflate = deflate2;
    exports.deflateRaw = deflateRaw;
    exports.gzip = gzip;
  }
});

// ../../node_modules/pako/lib/zlib/inffast.js
var require_inffast = __commonJS({
  "../../node_modules/pako/lib/zlib/inffast.js"(exports, module) {
    "use strict";
    init_define_import_meta_env();
    var BAD = 30;
    var TYPE = 12;
    module.exports = function inflate_fast(strm, start2) {
      var state;
      var _in;
      var last;
      var _out;
      var beg;
      var end;
      var dmax;
      var wsize;
      var whave;
      var wnext;
      var s_window;
      var hold;
      var bits;
      var lcode;
      var dcode;
      var lmask;
      var dmask;
      var here;
      var op;
      var len;
      var dist;
      var from3;
      var from_source;
      var input, output;
      state = strm.state;
      _in = strm.next_in;
      input = strm.input;
      last = _in + (strm.avail_in - 5);
      _out = strm.next_out;
      output = strm.output;
      beg = _out - (start2 - strm.avail_out);
      end = _out + (strm.avail_out - 257);
      dmax = state.dmax;
      wsize = state.wsize;
      whave = state.whave;
      wnext = state.wnext;
      s_window = state.window;
      hold = state.hold;
      bits = state.bits;
      lcode = state.lencode;
      dcode = state.distcode;
      lmask = (1 << state.lenbits) - 1;
      dmask = (1 << state.distbits) - 1;
      top:
        do {
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }
          here = lcode[hold & lmask];
          dolen:
            for (; ; ) {
              op = here >>> 24;
              hold >>>= op;
              bits -= op;
              op = here >>> 16 & 255;
              if (op === 0) {
                output[_out++] = here & 65535;
              } else if (op & 16) {
                len = here & 65535;
                op &= 15;
                if (op) {
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                  len += hold & (1 << op) - 1;
                  hold >>>= op;
                  bits -= op;
                }
                if (bits < 15) {
                  hold += input[_in++] << bits;
                  bits += 8;
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                here = dcode[hold & dmask];
                dodist:
                  for (; ; ) {
                    op = here >>> 24;
                    hold >>>= op;
                    bits -= op;
                    op = here >>> 16 & 255;
                    if (op & 16) {
                      dist = here & 65535;
                      op &= 15;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                        }
                      }
                      dist += hold & (1 << op) - 1;
                      if (dist > dmax) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD;
                        break top;
                      }
                      hold >>>= op;
                      bits -= op;
                      op = _out - beg;
                      if (dist > op) {
                        op = dist - op;
                        if (op > whave) {
                          if (state.sane) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD;
                            break top;
                          }
                        }
                        from3 = 0;
                        from_source = s_window;
                        if (wnext === 0) {
                          from3 += wsize - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from3++];
                            } while (--op);
                            from3 = _out - dist;
                            from_source = output;
                          }
                        } else if (wnext < op) {
                          from3 += wsize + wnext - op;
                          op -= wnext;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from3++];
                            } while (--op);
                            from3 = 0;
                            if (wnext < len) {
                              op = wnext;
                              len -= op;
                              do {
                                output[_out++] = s_window[from3++];
                              } while (--op);
                              from3 = _out - dist;
                              from_source = output;
                            }
                          }
                        } else {
                          from3 += wnext - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from3++];
                            } while (--op);
                            from3 = _out - dist;
                            from_source = output;
                          }
                        }
                        while (len > 2) {
                          output[_out++] = from_source[from3++];
                          output[_out++] = from_source[from3++];
                          output[_out++] = from_source[from3++];
                          len -= 3;
                        }
                        if (len) {
                          output[_out++] = from_source[from3++];
                          if (len > 1) {
                            output[_out++] = from_source[from3++];
                          }
                        }
                      } else {
                        from3 = _out - dist;
                        do {
                          output[_out++] = output[from3++];
                          output[_out++] = output[from3++];
                          output[_out++] = output[from3++];
                          len -= 3;
                        } while (len > 2);
                        if (len) {
                          output[_out++] = output[from3++];
                          if (len > 1) {
                            output[_out++] = output[from3++];
                          }
                        }
                      }
                    } else if ((op & 64) === 0) {
                      here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                      continue dodist;
                    } else {
                      strm.msg = "invalid distance code";
                      state.mode = BAD;
                      break top;
                    }
                    break;
                  }
              } else if ((op & 64) === 0) {
                here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                continue dolen;
              } else if (op & 32) {
                state.mode = TYPE;
                break top;
              } else {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break top;
              }
              break;
            }
        } while (_in < last && _out < end);
      len = bits >> 3;
      _in -= len;
      bits -= len << 3;
      hold &= (1 << bits) - 1;
      strm.next_in = _in;
      strm.next_out = _out;
      strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
      strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
      state.hold = hold;
      state.bits = bits;
      return;
    };
  }
});

// ../../node_modules/pako/lib/zlib/inftrees.js
var require_inftrees = __commonJS({
  "../../node_modules/pako/lib/zlib/inftrees.js"(exports, module) {
    "use strict";
    init_define_import_meta_env();
    var utils = require_common();
    var MAXBITS = 15;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var CODES2 = 0;
    var LENS = 1;
    var DISTS = 2;
    var lbase = [
      /* Length codes 257..285 base */
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      13,
      15,
      17,
      19,
      23,
      27,
      31,
      35,
      43,
      51,
      59,
      67,
      83,
      99,
      115,
      131,
      163,
      195,
      227,
      258,
      0,
      0
    ];
    var lext = [
      /* Length codes 257..285 extra */
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      16,
      72,
      78
    ];
    var dbase = [
      /* Distance codes 0..29 base */
      1,
      2,
      3,
      4,
      5,
      7,
      9,
      13,
      17,
      25,
      33,
      49,
      65,
      97,
      129,
      193,
      257,
      385,
      513,
      769,
      1025,
      1537,
      2049,
      3073,
      4097,
      6145,
      8193,
      12289,
      16385,
      24577,
      0,
      0
    ];
    var dext = [
      /* Distance codes 0..29 extra */
      16,
      16,
      16,
      16,
      17,
      17,
      18,
      18,
      19,
      19,
      20,
      20,
      21,
      21,
      22,
      22,
      23,
      23,
      24,
      24,
      25,
      25,
      26,
      26,
      27,
      27,
      28,
      28,
      29,
      29,
      64,
      64
    ];
    module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
      var bits = opts.bits;
      var len = 0;
      var sym = 0;
      var min = 0, max = 0;
      var root = 0;
      var curr = 0;
      var drop = 0;
      var left = 0;
      var used = 0;
      var huff = 0;
      var incr;
      var fill;
      var low;
      var mask;
      var next;
      var base = null;
      var base_index = 0;
      var end;
      var count = new utils.Buf16(MAXBITS + 1);
      var offs = new utils.Buf16(MAXBITS + 1);
      var extra = null;
      var extra_index = 0;
      var here_bits, here_op, here_val;
      for (len = 0; len <= MAXBITS; len++) {
        count[len] = 0;
      }
      for (sym = 0; sym < codes; sym++) {
        count[lens[lens_index + sym]]++;
      }
      root = bits;
      for (max = MAXBITS; max >= 1; max--) {
        if (count[max] !== 0) {
          break;
        }
      }
      if (root > max) {
        root = max;
      }
      if (max === 0) {
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        opts.bits = 1;
        return 0;
      }
      for (min = 1; min < max; min++) {
        if (count[min] !== 0) {
          break;
        }
      }
      if (root < min) {
        root = min;
      }
      left = 1;
      for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
        left -= count[len];
        if (left < 0) {
          return -1;
        }
      }
      if (left > 0 && (type === CODES2 || max !== 1)) {
        return -1;
      }
      offs[1] = 0;
      for (len = 1; len < MAXBITS; len++) {
        offs[len + 1] = offs[len] + count[len];
      }
      for (sym = 0; sym < codes; sym++) {
        if (lens[lens_index + sym] !== 0) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }
      if (type === CODES2) {
        base = extra = work;
        end = 19;
      } else if (type === LENS) {
        base = lbase;
        base_index -= 257;
        extra = lext;
        extra_index -= 257;
        end = 256;
      } else {
        base = dbase;
        extra = dext;
        end = -1;
      }
      huff = 0;
      sym = 0;
      len = min;
      next = table_index;
      curr = root;
      drop = 0;
      low = -1;
      used = 1 << root;
      mask = used - 1;
      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
        return 1;
      }
      for (; ; ) {
        here_bits = len - drop;
        if (work[sym] < end) {
          here_op = 0;
          here_val = work[sym];
        } else if (work[sym] > end) {
          here_op = extra[extra_index + work[sym]];
          here_val = base[base_index + work[sym]];
        } else {
          here_op = 32 + 64;
          here_val = 0;
        }
        incr = 1 << len - drop;
        fill = 1 << curr;
        min = fill;
        do {
          fill -= incr;
          table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
        } while (fill !== 0);
        incr = 1 << len - 1;
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }
        sym++;
        if (--count[len] === 0) {
          if (len === max) {
            break;
          }
          len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask) !== low) {
          if (drop === 0) {
            drop = root;
          }
          next += min;
          curr = len - drop;
          left = 1 << curr;
          while (curr + drop < max) {
            left -= count[curr + drop];
            if (left <= 0) {
              break;
            }
            curr++;
            left <<= 1;
          }
          used += 1 << curr;
          if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
            return 1;
          }
          low = huff & mask;
          table[low] = root << 24 | curr << 16 | next - table_index | 0;
        }
      }
      if (huff !== 0) {
        table[next + huff] = len - drop << 24 | 64 << 16 | 0;
      }
      opts.bits = root;
      return 0;
    };
  }
});

// ../../node_modules/pako/lib/zlib/inflate.js
var require_inflate = __commonJS({
  "../../node_modules/pako/lib/zlib/inflate.js"(exports) {
    "use strict";
    init_define_import_meta_env();
    var utils = require_common();
    var adler32 = require_adler32();
    var crc32 = require_crc322();
    var inflate_fast = require_inffast();
    var inflate_table = require_inftrees();
    var CODES2 = 0;
    var LENS = 1;
    var DISTS = 2;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_TREES = 6;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_NEED_DICT = 2;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_MEM_ERROR = -4;
    var Z_BUF_ERROR = -5;
    var Z_DEFLATED = 8;
    var HEAD = 1;
    var FLAGS = 2;
    var TIME = 3;
    var OS = 4;
    var EXLEN = 5;
    var EXTRA = 6;
    var NAME = 7;
    var COMMENT = 8;
    var HCRC = 9;
    var DICTID = 10;
    var DICT = 11;
    var TYPE = 12;
    var TYPEDO = 13;
    var STORED = 14;
    var COPY_ = 15;
    var COPY = 16;
    var TABLE = 17;
    var LENLENS = 18;
    var CODELENS = 19;
    var LEN_ = 20;
    var LEN = 21;
    var LENEXT = 22;
    var DIST = 23;
    var DISTEXT = 24;
    var MATCH = 25;
    var LIT = 26;
    var CHECK = 27;
    var LENGTH = 28;
    var DONE = 29;
    var BAD = 30;
    var MEM = 31;
    var SYNC = 32;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var MAX_WBITS = 15;
    var DEF_WBITS = MAX_WBITS;
    function zswap32(q) {
      return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
    }
    function InflateState() {
      this.mode = 0;
      this.last = false;
      this.wrap = 0;
      this.havedict = false;
      this.flags = 0;
      this.dmax = 0;
      this.check = 0;
      this.total = 0;
      this.head = null;
      this.wbits = 0;
      this.wsize = 0;
      this.whave = 0;
      this.wnext = 0;
      this.window = null;
      this.hold = 0;
      this.bits = 0;
      this.length = 0;
      this.offset = 0;
      this.extra = 0;
      this.lencode = null;
      this.distcode = null;
      this.lenbits = 0;
      this.distbits = 0;
      this.ncode = 0;
      this.nlen = 0;
      this.ndist = 0;
      this.have = 0;
      this.next = null;
      this.lens = new utils.Buf16(320);
      this.work = new utils.Buf16(288);
      this.lendyn = null;
      this.distdyn = null;
      this.sane = 0;
      this.back = 0;
      this.was = 0;
    }
    function inflateResetKeep(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      strm.total_in = strm.total_out = state.total = 0;
      strm.msg = "";
      if (state.wrap) {
        strm.adler = state.wrap & 1;
      }
      state.mode = HEAD;
      state.last = 0;
      state.havedict = 0;
      state.dmax = 32768;
      state.head = null;
      state.hold = 0;
      state.bits = 0;
      state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
      state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
      state.sane = 1;
      state.back = -1;
      return Z_OK;
    }
    function inflateReset(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      state.wsize = 0;
      state.whave = 0;
      state.wnext = 0;
      return inflateResetKeep(strm);
    }
    function inflateReset2(strm, windowBits) {
      var wrap;
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else {
        wrap = (windowBits >> 4) + 1;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR;
      }
      if (state.window !== null && state.wbits !== windowBits) {
        state.window = null;
      }
      state.wrap = wrap;
      state.wbits = windowBits;
      return inflateReset(strm);
    }
    function inflateInit2(strm, windowBits) {
      var ret;
      var state;
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      state = new InflateState();
      strm.state = state;
      state.window = null;
      ret = inflateReset2(strm, windowBits);
      if (ret !== Z_OK) {
        strm.state = null;
      }
      return ret;
    }
    function inflateInit(strm) {
      return inflateInit2(strm, DEF_WBITS);
    }
    var virgin = true;
    var lenfix;
    var distfix;
    function fixedtables(state) {
      if (virgin) {
        var sym;
        lenfix = new utils.Buf32(512);
        distfix = new utils.Buf32(32);
        sym = 0;
        while (sym < 144) {
          state.lens[sym++] = 8;
        }
        while (sym < 256) {
          state.lens[sym++] = 9;
        }
        while (sym < 280) {
          state.lens[sym++] = 7;
        }
        while (sym < 288) {
          state.lens[sym++] = 8;
        }
        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
        sym = 0;
        while (sym < 32) {
          state.lens[sym++] = 5;
        }
        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
        virgin = false;
      }
      state.lencode = lenfix;
      state.lenbits = 9;
      state.distcode = distfix;
      state.distbits = 5;
    }
    function updatewindow(strm, src, end, copy) {
      var dist;
      var state = strm.state;
      if (state.window === null) {
        state.wsize = 1 << state.wbits;
        state.wnext = 0;
        state.whave = 0;
        state.window = new utils.Buf8(state.wsize);
      }
      if (copy >= state.wsize) {
        utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
        state.wnext = 0;
        state.whave = state.wsize;
      } else {
        dist = state.wsize - state.wnext;
        if (dist > copy) {
          dist = copy;
        }
        utils.arraySet(state.window, src, end - copy, dist, state.wnext);
        copy -= dist;
        if (copy) {
          utils.arraySet(state.window, src, end - copy, copy, 0);
          state.wnext = copy;
          state.whave = state.wsize;
        } else {
          state.wnext += dist;
          if (state.wnext === state.wsize) {
            state.wnext = 0;
          }
          if (state.whave < state.wsize) {
            state.whave += dist;
          }
        }
      }
      return 0;
    }
    function inflate2(strm, flush) {
      var state;
      var input, output;
      var next;
      var put;
      var have, left;
      var hold;
      var bits;
      var _in, _out;
      var copy;
      var from3;
      var from_source;
      var here = 0;
      var here_bits, here_op, here_val;
      var last_bits, last_op, last_val;
      var len;
      var ret;
      var hbuf = new utils.Buf8(4);
      var opts;
      var n4;
      var order = (
        /* permutation of code lengths */
        [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
      );
      if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.mode === TYPE) {
        state.mode = TYPEDO;
      }
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state.hold;
      bits = state.bits;
      _in = have;
      _out = left;
      ret = Z_OK;
      inf_leave:
        for (; ; ) {
          switch (state.mode) {
            case HEAD:
              if (state.wrap === 0) {
                state.mode = TYPEDO;
                break;
              }
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.wrap & 2 && hold === 35615) {
                state.check = 0;
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
                hold = 0;
                bits = 0;
                state.mode = FLAGS;
                break;
              }
              state.flags = 0;
              if (state.head) {
                state.head.done = false;
              }
              if (!(state.wrap & 1) || /* check if zlib header allowed */
              (((hold & 255) << 8) + (hold >> 8)) % 31) {
                strm.msg = "incorrect header check";
                state.mode = BAD;
                break;
              }
              if ((hold & 15) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              hold >>>= 4;
              bits -= 4;
              len = (hold & 15) + 8;
              if (state.wbits === 0) {
                state.wbits = len;
              } else if (len > state.wbits) {
                strm.msg = "invalid window size";
                state.mode = BAD;
                break;
              }
              state.dmax = 1 << len;
              strm.adler = state.check = 1;
              state.mode = hold & 512 ? DICTID : TYPE;
              hold = 0;
              bits = 0;
              break;
            case FLAGS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.flags = hold;
              if ((state.flags & 255) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              if (state.flags & 57344) {
                strm.msg = "unknown header flags set";
                state.mode = BAD;
                break;
              }
              if (state.head) {
                state.head.text = hold >> 8 & 1;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = TIME;
            case TIME:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.time = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                hbuf[2] = hold >>> 16 & 255;
                hbuf[3] = hold >>> 24 & 255;
                state.check = crc32(state.check, hbuf, 4, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = OS;
            case OS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.xflags = hold & 255;
                state.head.os = hold >> 8;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = EXLEN;
            case EXLEN:
              if (state.flags & 1024) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length = hold;
                if (state.head) {
                  state.head.extra_len = hold;
                }
                if (state.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
              } else if (state.head) {
                state.head.extra = null;
              }
              state.mode = EXTRA;
            case EXTRA:
              if (state.flags & 1024) {
                copy = state.length;
                if (copy > have) {
                  copy = have;
                }
                if (copy) {
                  if (state.head) {
                    len = state.head.extra_len - state.length;
                    if (!state.head.extra) {
                      state.head.extra = new Array(state.head.extra_len);
                    }
                    utils.arraySet(
                      state.head.extra,
                      input,
                      next,
                      // extra field is limited to 65536 bytes
                      // - no need for additional size check
                      copy,
                      /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                      len
                    );
                  }
                  if (state.flags & 512) {
                    state.check = crc32(state.check, input, copy, next);
                  }
                  have -= copy;
                  next += copy;
                  state.length -= copy;
                }
                if (state.length) {
                  break inf_leave;
                }
              }
              state.length = 0;
              state.mode = NAME;
            case NAME:
              if (state.flags & 2048) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.name += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.name = null;
              }
              state.length = 0;
              state.mode = COMMENT;
            case COMMENT:
              if (state.flags & 4096) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.comment += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.comment = null;
              }
              state.mode = HCRC;
            case HCRC:
              if (state.flags & 512) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.check & 65535)) {
                  strm.msg = "header crc mismatch";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              if (state.head) {
                state.head.hcrc = state.flags >> 9 & 1;
                state.head.done = true;
              }
              strm.adler = state.check = 0;
              state.mode = TYPE;
              break;
            case DICTID:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              strm.adler = state.check = zswap32(hold);
              hold = 0;
              bits = 0;
              state.mode = DICT;
            case DICT:
              if (state.havedict === 0) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                return Z_NEED_DICT;
              }
              strm.adler = state.check = 1;
              state.mode = TYPE;
            case TYPE:
              if (flush === Z_BLOCK || flush === Z_TREES) {
                break inf_leave;
              }
            case TYPEDO:
              if (state.last) {
                hold >>>= bits & 7;
                bits -= bits & 7;
                state.mode = CHECK;
                break;
              }
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.last = hold & 1;
              hold >>>= 1;
              bits -= 1;
              switch (hold & 3) {
                case 0:
                  state.mode = STORED;
                  break;
                case 1:
                  fixedtables(state);
                  state.mode = LEN_;
                  if (flush === Z_TREES) {
                    hold >>>= 2;
                    bits -= 2;
                    break inf_leave;
                  }
                  break;
                case 2:
                  state.mode = TABLE;
                  break;
                case 3:
                  strm.msg = "invalid block type";
                  state.mode = BAD;
              }
              hold >>>= 2;
              bits -= 2;
              break;
            case STORED:
              hold >>>= bits & 7;
              bits -= bits & 7;
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                strm.msg = "invalid stored block lengths";
                state.mode = BAD;
                break;
              }
              state.length = hold & 65535;
              hold = 0;
              bits = 0;
              state.mode = COPY_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case COPY_:
              state.mode = COPY;
            case COPY:
              copy = state.length;
              if (copy) {
                if (copy > have) {
                  copy = have;
                }
                if (copy > left) {
                  copy = left;
                }
                if (copy === 0) {
                  break inf_leave;
                }
                utils.arraySet(output, input, next, copy, put);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
                state.length -= copy;
                break;
              }
              state.mode = TYPE;
              break;
            case TABLE:
              while (bits < 14) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.nlen = (hold & 31) + 257;
              hold >>>= 5;
              bits -= 5;
              state.ndist = (hold & 31) + 1;
              hold >>>= 5;
              bits -= 5;
              state.ncode = (hold & 15) + 4;
              hold >>>= 4;
              bits -= 4;
              if (state.nlen > 286 || state.ndist > 30) {
                strm.msg = "too many length or distance symbols";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = LENLENS;
            case LENLENS:
              while (state.have < state.ncode) {
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.lens[order[state.have++]] = hold & 7;
                hold >>>= 3;
                bits -= 3;
              }
              while (state.have < 19) {
                state.lens[order[state.have++]] = 0;
              }
              state.lencode = state.lendyn;
              state.lenbits = 7;
              opts = { bits: state.lenbits };
              ret = inflate_table(CODES2, state.lens, 0, 19, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid code lengths set";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = CODELENS;
            case CODELENS:
              while (state.have < state.nlen + state.ndist) {
                for (; ; ) {
                  here = state.lencode[hold & (1 << state.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (here_val < 16) {
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.lens[state.have++] = here_val;
                } else {
                  if (here_val === 16) {
                    n4 = here_bits + 2;
                    while (bits < n4) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    if (state.have === 0) {
                      strm.msg = "invalid bit length repeat";
                      state.mode = BAD;
                      break;
                    }
                    len = state.lens[state.have - 1];
                    copy = 3 + (hold & 3);
                    hold >>>= 2;
                    bits -= 2;
                  } else if (here_val === 17) {
                    n4 = here_bits + 3;
                    while (bits < n4) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 3 + (hold & 7);
                    hold >>>= 3;
                    bits -= 3;
                  } else {
                    n4 = here_bits + 7;
                    while (bits < n4) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 11 + (hold & 127);
                    hold >>>= 7;
                    bits -= 7;
                  }
                  if (state.have + copy > state.nlen + state.ndist) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  while (copy--) {
                    state.lens[state.have++] = len;
                  }
                }
              }
              if (state.mode === BAD) {
                break;
              }
              if (state.lens[256] === 0) {
                strm.msg = "invalid code -- missing end-of-block";
                state.mode = BAD;
                break;
              }
              state.lenbits = 9;
              opts = { bits: state.lenbits };
              ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid literal/lengths set";
                state.mode = BAD;
                break;
              }
              state.distbits = 6;
              state.distcode = state.distdyn;
              opts = { bits: state.distbits };
              ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
              state.distbits = opts.bits;
              if (ret) {
                strm.msg = "invalid distances set";
                state.mode = BAD;
                break;
              }
              state.mode = LEN_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case LEN_:
              state.mode = LEN;
            case LEN:
              if (have >= 6 && left >= 258) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                inflate_fast(strm, _out);
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state.hold;
                bits = state.bits;
                if (state.mode === TYPE) {
                  state.back = -1;
                }
                break;
              }
              state.back = 0;
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_op && (here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              state.length = here_val;
              if (here_op === 0) {
                state.mode = LIT;
                break;
              }
              if (here_op & 32) {
                state.back = -1;
                state.mode = TYPE;
                break;
              }
              if (here_op & 64) {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break;
              }
              state.extra = here_op & 15;
              state.mode = LENEXT;
            case LENEXT:
              if (state.extra) {
                n4 = state.extra;
                while (bits < n4) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              state.was = state.length;
              state.mode = DIST;
            case DIST:
              for (; ; ) {
                here = state.distcode[hold & (1 << state.distbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              if (here_op & 64) {
                strm.msg = "invalid distance code";
                state.mode = BAD;
                break;
              }
              state.offset = here_val;
              state.extra = here_op & 15;
              state.mode = DISTEXT;
            case DISTEXT:
              if (state.extra) {
                n4 = state.extra;
                while (bits < n4) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.offset += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              if (state.offset > state.dmax) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
              state.mode = MATCH;
            case MATCH:
              if (left === 0) {
                break inf_leave;
              }
              copy = _out - left;
              if (state.offset > copy) {
                copy = state.offset - copy;
                if (copy > state.whave) {
                  if (state.sane) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break;
                  }
                }
                if (copy > state.wnext) {
                  copy -= state.wnext;
                  from3 = state.wsize - copy;
                } else {
                  from3 = state.wnext - copy;
                }
                if (copy > state.length) {
                  copy = state.length;
                }
                from_source = state.window;
              } else {
                from_source = output;
                from3 = put - state.offset;
                copy = state.length;
              }
              if (copy > left) {
                copy = left;
              }
              left -= copy;
              state.length -= copy;
              do {
                output[put++] = from_source[from3++];
              } while (--copy);
              if (state.length === 0) {
                state.mode = LEN;
              }
              break;
            case LIT:
              if (left === 0) {
                break inf_leave;
              }
              output[put++] = state.length;
              left--;
              state.mode = LEN;
              break;
            case CHECK:
              if (state.wrap) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold |= input[next++] << bits;
                  bits += 8;
                }
                _out -= left;
                strm.total_out += _out;
                state.total += _out;
                if (_out) {
                  strm.adler = state.check = /*UPDATE(state.check, put - _out, _out);*/
                  state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                }
                _out = left;
                if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                  strm.msg = "incorrect data check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = LENGTH;
            case LENGTH:
              if (state.wrap && state.flags) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.total & 4294967295)) {
                  strm.msg = "incorrect length check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = DONE;
            case DONE:
              ret = Z_STREAM_END;
              break inf_leave;
            case BAD:
              ret = Z_DATA_ERROR;
              break inf_leave;
            case MEM:
              return Z_MEM_ERROR;
            case SYNC:
            default:
              return Z_STREAM_ERROR;
          }
        }
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next;
      strm.avail_in = have;
      state.hold = hold;
      state.bits = bits;
      if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
          state.mode = MEM;
          return Z_MEM_ERROR;
        }
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state.total += _out;
      if (state.wrap && _out) {
        strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
        state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
      }
      strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
      if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
        ret = Z_BUF_ERROR;
      }
      return ret;
    }
    function inflateEnd(strm) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      var state = strm.state;
      if (state.window) {
        state.window = null;
      }
      strm.state = null;
      return Z_OK;
    }
    function inflateGetHeader(strm, head) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if ((state.wrap & 2) === 0) {
        return Z_STREAM_ERROR;
      }
      state.head = head;
      head.done = false;
      return Z_OK;
    }
    function inflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var state;
      var dictid;
      var ret;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.wrap !== 0 && state.mode !== DICT) {
        return Z_STREAM_ERROR;
      }
      if (state.mode === DICT) {
        dictid = 1;
        dictid = adler32(dictid, dictionary, dictLength, 0);
        if (dictid !== state.check) {
          return Z_DATA_ERROR;
        }
      }
      ret = updatewindow(strm, dictionary, dictLength, dictLength);
      if (ret) {
        state.mode = MEM;
        return Z_MEM_ERROR;
      }
      state.havedict = 1;
      return Z_OK;
    }
    exports.inflateReset = inflateReset;
    exports.inflateReset2 = inflateReset2;
    exports.inflateResetKeep = inflateResetKeep;
    exports.inflateInit = inflateInit;
    exports.inflateInit2 = inflateInit2;
    exports.inflate = inflate2;
    exports.inflateEnd = inflateEnd;
    exports.inflateGetHeader = inflateGetHeader;
    exports.inflateSetDictionary = inflateSetDictionary;
    exports.inflateInfo = "pako inflate (from Nodeca project)";
  }
});

// ../../node_modules/pako/lib/zlib/constants.js
var require_constants = __commonJS({
  "../../node_modules/pako/lib/zlib/constants.js"(exports, module) {
    "use strict";
    init_define_import_meta_env();
    module.exports = {
      /* Allowed flush values; see deflate() and inflate() below for details */
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      /* Return codes for the compression/decompression functions. Negative values
      * are errors, positive values are used for special but normal events.
      */
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      //Z_MEM_ERROR:     -4,
      Z_BUF_ERROR: -5,
      //Z_VERSION_ERROR: -6,
      /* compression levels */
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      /* Possible values of the data_type field (though see inflate()) */
      Z_BINARY: 0,
      Z_TEXT: 1,
      //Z_ASCII:                1, // = Z_TEXT (deprecated)
      Z_UNKNOWN: 2,
      /* The deflate compression method */
      Z_DEFLATED: 8
      //Z_NULL:                 null // Use -1 or null inline, depending on var type
    };
  }
});

// ../../node_modules/pako/lib/zlib/gzheader.js
var require_gzheader = __commonJS({
  "../../node_modules/pako/lib/zlib/gzheader.js"(exports, module) {
    "use strict";
    init_define_import_meta_env();
    function GZheader() {
      this.text = 0;
      this.time = 0;
      this.xflags = 0;
      this.os = 0;
      this.extra = null;
      this.extra_len = 0;
      this.name = "";
      this.comment = "";
      this.hcrc = 0;
      this.done = false;
    }
    module.exports = GZheader;
  }
});

// ../../node_modules/pako/lib/inflate.js
var require_inflate2 = __commonJS({
  "../../node_modules/pako/lib/inflate.js"(exports) {
    "use strict";
    init_define_import_meta_env();
    var zlib_inflate = require_inflate();
    var utils = require_common();
    var strings = require_strings();
    var c3 = require_constants();
    var msg = require_messages();
    var ZStream = require_zstream();
    var GZheader = require_gzheader();
    var toString = Object.prototype.toString;
    function Inflate(options) {
      if (!(this instanceof Inflate))
        return new Inflate(options);
      this.options = utils.assign({
        chunkSize: 16384,
        windowBits: 0,
        to: ""
      }, options || {});
      var opt = this.options;
      if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
        opt.windowBits = -opt.windowBits;
        if (opt.windowBits === 0) {
          opt.windowBits = -15;
        }
      }
      if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
        opt.windowBits += 32;
      }
      if (opt.windowBits > 15 && opt.windowBits < 48) {
        if ((opt.windowBits & 15) === 0) {
          opt.windowBits |= 15;
        }
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      var status = zlib_inflate.inflateInit2(
        this.strm,
        opt.windowBits
      );
      if (status !== c3.Z_OK) {
        throw new Error(msg[status]);
      }
      this.header = new GZheader();
      zlib_inflate.inflateGetHeader(this.strm, this.header);
      if (opt.dictionary) {
        if (typeof opt.dictionary === "string") {
          opt.dictionary = strings.string2buf(opt.dictionary);
        } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
          opt.dictionary = new Uint8Array(opt.dictionary);
        }
        if (opt.raw) {
          status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
          if (status !== c3.Z_OK) {
            throw new Error(msg[status]);
          }
        }
      }
    }
    Inflate.prototype.push = function(data, mode) {
      var strm = this.strm;
      var chunkSize = this.options.chunkSize;
      var dictionary = this.options.dictionary;
      var status, _mode;
      var next_out_utf8, tail, utf8str;
      var allowBufError = false;
      if (this.ended) {
        return false;
      }
      _mode = mode === ~~mode ? mode : mode === true ? c3.Z_FINISH : c3.Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.binstring2buf(data);
      } else if (toString.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      do {
        if (strm.avail_out === 0) {
          strm.output = new utils.Buf8(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = zlib_inflate.inflate(strm, c3.Z_NO_FLUSH);
        if (status === c3.Z_NEED_DICT && dictionary) {
          status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
        }
        if (status === c3.Z_BUF_ERROR && allowBufError === true) {
          status = c3.Z_OK;
          allowBufError = false;
        }
        if (status !== c3.Z_STREAM_END && status !== c3.Z_OK) {
          this.onEnd(status);
          this.ended = true;
          return false;
        }
        if (strm.next_out) {
          if (strm.avail_out === 0 || status === c3.Z_STREAM_END || strm.avail_in === 0 && (_mode === c3.Z_FINISH || _mode === c3.Z_SYNC_FLUSH)) {
            if (this.options.to === "string") {
              next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
              tail = strm.next_out - next_out_utf8;
              utf8str = strings.buf2string(strm.output, next_out_utf8);
              strm.next_out = tail;
              strm.avail_out = chunkSize - tail;
              if (tail) {
                utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
              }
              this.onData(utf8str);
            } else {
              this.onData(utils.shrinkBuf(strm.output, strm.next_out));
            }
          }
        }
        if (strm.avail_in === 0 && strm.avail_out === 0) {
          allowBufError = true;
        }
      } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c3.Z_STREAM_END);
      if (status === c3.Z_STREAM_END) {
        _mode = c3.Z_FINISH;
      }
      if (_mode === c3.Z_FINISH) {
        status = zlib_inflate.inflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === c3.Z_OK;
      }
      if (_mode === c3.Z_SYNC_FLUSH) {
        this.onEnd(c3.Z_OK);
        strm.avail_out = 0;
        return true;
      }
      return true;
    };
    Inflate.prototype.onData = function(chunk2) {
      this.chunks.push(chunk2);
    };
    Inflate.prototype.onEnd = function(status) {
      if (status === c3.Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function inflate2(input, options) {
      var inflator = new Inflate(options);
      inflator.push(input, true);
      if (inflator.err) {
        throw inflator.msg || msg[inflator.err];
      }
      return inflator.result;
    }
    function inflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return inflate2(input, options);
    }
    exports.Inflate = Inflate;
    exports.inflate = inflate2;
    exports.inflateRaw = inflateRaw;
    exports.ungzip = inflate2;
  }
});

// ../../node_modules/pako/index.js
var require_pako = __commonJS({
  "../../node_modules/pako/index.js"(exports, module) {
    "use strict";
    init_define_import_meta_env();
    var assign = require_common().assign;
    var deflate2 = require_deflate2();
    var inflate2 = require_inflate2();
    var constants = require_constants();
    var pako = {};
    assign(pako, deflate2, inflate2, constants);
    module.exports = pako;
  }
});

// ../../node_modules/@braintree/sanitize-url/dist/index.js
var require_dist = __commonJS({
  "../../node_modules/@braintree/sanitize-url/dist/index.js"(exports) {
    "use strict";
    init_define_import_meta_env();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sanitizeUrl = void 0;
    var invalidProtocolRegex = /^([^\w]*)(javascript|data|vbscript)/im;
    var htmlEntitiesRegex = /&#(\w+)(^\w|;)?/g;
    var htmlCtrlEntityRegex = /&(newline|tab);/gi;
    var ctrlCharactersRegex = /[\u0000-\u001F\u007F-\u009F\u2000-\u200D\uFEFF]/gim;
    var urlSchemeRegex = /^.+(:|&colon;)/gim;
    var relativeFirstCharacters = [".", "/"];
    function isRelativeUrlWithoutProtocol(url) {
      return relativeFirstCharacters.indexOf(url[0]) > -1;
    }
    function decodeHtmlCharacters(str) {
      return str.replace(htmlEntitiesRegex, function(match, dec) {
        return String.fromCharCode(dec);
      });
    }
    function sanitizeUrl2(url) {
      var sanitizedUrl = decodeHtmlCharacters(url || "").replace(htmlCtrlEntityRegex, "").replace(ctrlCharactersRegex, "").trim();
      if (!sanitizedUrl) {
        return "about:blank";
      }
      if (isRelativeUrlWithoutProtocol(sanitizedUrl)) {
        return sanitizedUrl;
      }
      var urlSchemeParseResults = sanitizedUrl.match(urlSchemeRegex);
      if (!urlSchemeParseResults) {
        return sanitizedUrl;
      }
      var urlScheme = urlSchemeParseResults[0];
      if (invalidProtocolRegex.test(urlScheme)) {
        return "about:blank";
      }
      return sanitizedUrl;
    }
    exports.sanitizeUrl = sanitizeUrl2;
  }
});

// external-global-plugin:react
var require_react = __commonJS({
  "external-global-plugin:react"(exports, module) {
    init_define_import_meta_env();
    module.exports = React;
  }
});

// external-global-plugin:react-dom
var require_react_dom = __commonJS({
  "external-global-plugin:react-dom"(exports, module) {
    init_define_import_meta_env();
    module.exports = ReactDOM;
  }
});

// ../../node_modules/react/cjs/react-jsx-runtime.development.js
var require_react_jsx_runtime_development = __commonJS({
  "../../node_modules/react/cjs/react-jsx-runtime.development.js"(exports) {
    "use strict";
    init_define_import_meta_env();
    if (true) {
      (function() {
        "use strict";
        var React49 = require_react();
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        var ReactSharedInternals = React49.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function error(format) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var REACT_MODULE_REFERENCE;
        {
          REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
        }
        function isValidElementType(type) {
          if (typeof type === "string" || typeof type === "function") {
            return true;
          }
          if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
            return true;
          }
          if (typeof type === "object" && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
            // types supported by any Flight configuration anywhere since
            // we don't know which Flight build this will end up being used
            // with.
            type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
              return true;
            }
          }
          return false;
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var displayName = outerType.displayName;
          if (displayName) {
            return displayName;
          }
          var functionName = innerType.displayName || innerType.name || "";
          return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
        }
        function getContextName(type) {
          return type.displayName || "Context";
        }
        function getComponentNameFromType(type) {
          if (type == null) {
            return null;
          }
          {
            if (typeof type.tag === "number") {
              error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type === "function") {
            return type.displayName || type.name || null;
          }
          if (typeof type === "string") {
            return type;
          }
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type;
                return getContextName(context) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                var outerName = type.displayName || null;
                if (outerName !== null) {
                  return outerName;
                }
                return getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return getComponentNameFromType(init(payload));
                } catch (x3) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var assign = Object.assign;
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: assign({}, props, {
                  value: prevLog
                }),
                info: assign({}, props, {
                  value: prevInfo
                }),
                warn: assign({}, props, {
                  value: prevWarn
                }),
                error: assign({}, props, {
                  value: prevError
                }),
                group: assign({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: assign({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: assign({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
          {
            if (prefix === void 0) {
              try {
                throw Error();
              } catch (x3) {
                var match = x3.stack.trim().match(/\n( *(at )?)/);
                prefix = match && match[1] || "";
              }
            }
            return "\n" + prefix + name;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x3) {
                  control = x3;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x3) {
                  control = x3;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x3) {
                control = x3;
              }
              fn();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s4 = sampleLines.length - 1;
              var c3 = controlLines.length - 1;
              while (s4 >= 1 && c3 >= 0 && sampleLines[s4] !== controlLines[c3]) {
                c3--;
              }
              for (; s4 >= 1 && c3 >= 0; s4--, c3--) {
                if (sampleLines[s4] !== controlLines[c3]) {
                  if (s4 !== 1 || c3 !== 1) {
                    do {
                      s4--;
                      c3--;
                      if (c3 < 0 || sampleLines[s4] !== controlLines[c3]) {
                        var _frame = "\n" + sampleLines[s4].replace(" at new ", " at ");
                        if (fn.displayName && _frame.includes("<anonymous>")) {
                          _frame = _frame.replace("<anonymous>", fn.displayName);
                        }
                        {
                          if (typeof fn === "function") {
                            componentFrameCache.set(fn, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s4 >= 1 && c3 >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name = fn ? fn.displayName || fn.name : "";
          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
          {
            if (typeof fn === "function") {
              componentFrameCache.set(fn, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn, false);
          }
        }
        function shouldConstruct(Component) {
          var prototype = Component.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
          if (type == null) {
            return "";
          }
          if (typeof type === "function") {
            {
              return describeNativeComponentFrame(type, shouldConstruct(type));
            }
          }
          if (typeof type === "string") {
            return describeBuiltInComponentFrame(type);
          }
          switch (type) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                } catch (x3) {
                }
              }
            }
          }
          return "";
        }
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location2, componentName, element) {
          {
            var has = Function.call.bind(hasOwnProperty);
            for (var typeSpecName in typeSpecs) {
              if (has(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location2 + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location2, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location2, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error("Failed %s type: %s", location2, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        var isArrayImpl = Array.isArray;
        function isArray(a4) {
          return isArrayImpl(a4);
        }
        function typeName(value) {
          {
            var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
            var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            return type;
          }
        }
        function willCoercionThrow(value) {
          {
            try {
              testStringCoercion(value);
              return false;
            } catch (e3) {
              return true;
            }
          }
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkKeyStringCoercion(value) {
          {
            if (willCoercionThrow(value)) {
              error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
        var RESERVED_PROPS = {
          key: true,
          ref: true,
          __self: true,
          __source: true
        };
        var specialPropKeyWarningShown;
        var specialPropRefWarningShown;
        var didWarnAboutStringRefs;
        {
          didWarnAboutStringRefs = {};
        }
        function hasValidRef(config) {
          {
            if (hasOwnProperty.call(config, "ref")) {
              var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.ref !== void 0;
        }
        function hasValidKey(config) {
          {
            if (hasOwnProperty.call(config, "key")) {
              var getter = Object.getOwnPropertyDescriptor(config, "key").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.key !== void 0;
        }
        function warnIfStringRefCannotBeAutoConverted(config, self2) {
          {
            if (typeof config.ref === "string" && ReactCurrentOwner.current && self2 && ReactCurrentOwner.current.stateNode !== self2) {
              var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
              if (!didWarnAboutStringRefs[componentName]) {
                error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);
                didWarnAboutStringRefs[componentName] = true;
              }
            }
          }
        }
        function defineKeyPropWarningGetter(props, displayName) {
          {
            var warnAboutAccessingKey = function() {
              if (!specialPropKeyWarningShown) {
                specialPropKeyWarningShown = true;
                error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            };
            warnAboutAccessingKey.isReactWarning = true;
            Object.defineProperty(props, "key", {
              get: warnAboutAccessingKey,
              configurable: true
            });
          }
        }
        function defineRefPropWarningGetter(props, displayName) {
          {
            var warnAboutAccessingRef = function() {
              if (!specialPropRefWarningShown) {
                specialPropRefWarningShown = true;
                error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            };
            warnAboutAccessingRef.isReactWarning = true;
            Object.defineProperty(props, "ref", {
              get: warnAboutAccessingRef,
              configurable: true
            });
          }
        }
        var ReactElement = function(type, key, ref, self2, source, owner, props) {
          var element = {
            // This tag allows us to uniquely identify this as a React Element
            $$typeof: REACT_ELEMENT_TYPE,
            // Built-in properties that belong on the element
            type,
            key,
            ref,
            props,
            // Record the component responsible for creating this element.
            _owner: owner
          };
          {
            element._store = {};
            Object.defineProperty(element._store, "validated", {
              configurable: false,
              enumerable: false,
              writable: true,
              value: false
            });
            Object.defineProperty(element, "_self", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: self2
            });
            Object.defineProperty(element, "_source", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: source
            });
            if (Object.freeze) {
              Object.freeze(element.props);
              Object.freeze(element);
            }
          }
          return element;
        };
        function jsxDEV(type, config, maybeKey, source, self2) {
          {
            var propName;
            var props = {};
            var key = null;
            var ref = null;
            if (maybeKey !== void 0) {
              {
                checkKeyStringCoercion(maybeKey);
              }
              key = "" + maybeKey;
            }
            if (hasValidKey(config)) {
              {
                checkKeyStringCoercion(config.key);
              }
              key = "" + config.key;
            }
            if (hasValidRef(config)) {
              ref = config.ref;
              warnIfStringRefCannotBeAutoConverted(config, self2);
            }
            for (propName in config) {
              if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                props[propName] = config[propName];
              }
            }
            if (type && type.defaultProps) {
              var defaultProps = type.defaultProps;
              for (propName in defaultProps) {
                if (props[propName] === void 0) {
                  props[propName] = defaultProps[propName];
                }
              }
            }
            if (key || ref) {
              var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
              if (key) {
                defineKeyPropWarningGetter(props, displayName);
              }
              if (ref) {
                defineRefPropWarningGetter(props, displayName);
              }
            }
            return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
          }
        }
        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement$1(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame$1.setExtraStackFrame(null);
            }
          }
        }
        var propTypesMisspellWarningShown;
        {
          propTypesMisspellWarningShown = false;
        }
        function isValidElement(object) {
          {
            return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
          }
        }
        function getDeclarationErrorAddendum() {
          {
            if (ReactCurrentOwner$1.current) {
              var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);
              if (name) {
                return "\n\nCheck the render method of `" + name + "`.";
              }
            }
            return "";
          }
        }
        function getSourceInfoErrorAddendum(source) {
          {
            if (source !== void 0) {
              var fileName = source.fileName.replace(/^.*[\\\/]/, "");
              var lineNumber = source.lineNumber;
              return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
            }
            return "";
          }
        }
        var ownerHasKeyUseWarning = {};
        function getCurrentComponentErrorInfo(parentType) {
          {
            var info = getDeclarationErrorAddendum();
            if (!info) {
              var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
              if (parentName) {
                info = "\n\nCheck the top-level render call using <" + parentName + ">.";
              }
            }
            return info;
          }
        }
        function validateExplicitKey(element, parentType) {
          {
            if (!element._store || element._store.validated || element.key != null) {
              return;
            }
            element._store.validated = true;
            var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
            if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
              return;
            }
            ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
            var childOwner = "";
            if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
              childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
            }
            setCurrentlyValidatingElement$1(element);
            error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
            setCurrentlyValidatingElement$1(null);
          }
        }
        function validateChildKeys(node, parentType) {
          {
            if (typeof node !== "object") {
              return;
            }
            if (isArray(node)) {
              for (var i4 = 0; i4 < node.length; i4++) {
                var child = node[i4];
                if (isValidElement(child)) {
                  validateExplicitKey(child, parentType);
                }
              }
            } else if (isValidElement(node)) {
              if (node._store) {
                node._store.validated = true;
              }
            } else if (node) {
              var iteratorFn = getIteratorFn(node);
              if (typeof iteratorFn === "function") {
                if (iteratorFn !== node.entries) {
                  var iterator = iteratorFn.call(node);
                  var step;
                  while (!(step = iterator.next()).done) {
                    if (isValidElement(step.value)) {
                      validateExplicitKey(step.value, parentType);
                    }
                  }
                }
              }
            }
          }
        }
        function validatePropTypes(element) {
          {
            var type = element.type;
            if (type === null || type === void 0 || typeof type === "string") {
              return;
            }
            var propTypes;
            if (typeof type === "function") {
              propTypes = type.propTypes;
            } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
            // Inner props are checked in the reconciler.
            type.$$typeof === REACT_MEMO_TYPE)) {
              propTypes = type.propTypes;
            } else {
              return;
            }
            if (propTypes) {
              var name = getComponentNameFromType(type);
              checkPropTypes(propTypes, element.props, "prop", name, element);
            } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
              propTypesMisspellWarningShown = true;
              var _name = getComponentNameFromType(type);
              error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
            }
            if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
              error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
            }
          }
        }
        function validateFragmentProps(fragment) {
          {
            var keys = Object.keys(fragment.props);
            for (var i4 = 0; i4 < keys.length; i4++) {
              var key = keys[i4];
              if (key !== "children" && key !== "key") {
                setCurrentlyValidatingElement$1(fragment);
                error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                setCurrentlyValidatingElement$1(null);
                break;
              }
            }
            if (fragment.ref !== null) {
              setCurrentlyValidatingElement$1(fragment);
              error("Invalid attribute `ref` supplied to `React.Fragment`.");
              setCurrentlyValidatingElement$1(null);
            }
          }
        }
        function jsxWithValidation(type, props, key, isStaticChildren, source, self2) {
          {
            var validType = isValidElementType(type);
            if (!validType) {
              var info = "";
              if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
              }
              var sourceInfo = getSourceInfoErrorAddendum(source);
              if (sourceInfo) {
                info += sourceInfo;
              } else {
                info += getDeclarationErrorAddendum();
              }
              var typeString;
              if (type === null) {
                typeString = "null";
              } else if (isArray(type)) {
                typeString = "array";
              } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
                typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
                info = " Did you accidentally export a JSX literal instead of a component?";
              } else {
                typeString = typeof type;
              }
              error("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
            }
            var element = jsxDEV(type, props, key, source, self2);
            if (element == null) {
              return element;
            }
            if (validType) {
              var children = props.children;
              if (children !== void 0) {
                if (isStaticChildren) {
                  if (isArray(children)) {
                    for (var i4 = 0; i4 < children.length; i4++) {
                      validateChildKeys(children[i4], type);
                    }
                    if (Object.freeze) {
                      Object.freeze(children);
                    }
                  } else {
                    error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
                  }
                } else {
                  validateChildKeys(children, type);
                }
              }
            }
            if (type === REACT_FRAGMENT_TYPE) {
              validateFragmentProps(element);
            } else {
              validatePropTypes(element);
            }
            return element;
          }
        }
        function jsxWithValidationStatic(type, props, key) {
          {
            return jsxWithValidation(type, props, key, true);
          }
        }
        function jsxWithValidationDynamic(type, props, key) {
          {
            return jsxWithValidation(type, props, key, false);
          }
        }
        var jsx131 = jsxWithValidationDynamic;
        var jsxs76 = jsxWithValidationStatic;
        exports.Fragment = REACT_FRAGMENT_TYPE;
        exports.jsx = jsx131;
        exports.jsxs = jsxs76;
      })();
    }
  }
});

// ../../node_modules/react/jsx-runtime.js
var require_jsx_runtime = __commonJS({
  "../../node_modules/react/jsx-runtime.js"(exports, module) {
    "use strict";
    init_define_import_meta_env();
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_jsx_runtime_development();
    }
  }
});

// ../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js
var require_use_sync_external_store_shim_development = __commonJS({
  "../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js"(exports) {
    "use strict";
    init_define_import_meta_env();
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var React49 = require_react();
        var ReactSharedInternals = React49.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function error(format) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        function is(x3, y3) {
          return x3 === y3 && (x3 !== 0 || 1 / x3 === 1 / y3) || x3 !== x3 && y3 !== y3;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is;
        var useState35 = React49.useState, useEffect36 = React49.useEffect, useLayoutEffect10 = React49.useLayoutEffect, useDebugValue3 = React49.useDebugValue;
        var didWarnOld18Alpha = false;
        var didWarnUncachedGetSnapshot = false;
        function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          {
            if (!didWarnOld18Alpha) {
              if (React49.startTransition !== void 0) {
                didWarnOld18Alpha = true;
                error("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.");
              }
            }
          }
          var value = getSnapshot();
          {
            if (!didWarnUncachedGetSnapshot) {
              var cachedValue = getSnapshot();
              if (!objectIs(value, cachedValue)) {
                error("The result of getSnapshot should be cached to avoid an infinite loop");
                didWarnUncachedGetSnapshot = true;
              }
            }
          }
          var _useState = useState35({
            inst: {
              value,
              getSnapshot
            }
          }), inst = _useState[0].inst, forceUpdate = _useState[1];
          useLayoutEffect10(function() {
            inst.value = value;
            inst.getSnapshot = getSnapshot;
            if (checkIfSnapshotChanged(inst)) {
              forceUpdate({
                inst
              });
            }
          }, [subscribe, value, getSnapshot]);
          useEffect36(function() {
            if (checkIfSnapshotChanged(inst)) {
              forceUpdate({
                inst
              });
            }
            var handleStoreChange = function() {
              if (checkIfSnapshotChanged(inst)) {
                forceUpdate({
                  inst
                });
              }
            };
            return subscribe(handleStoreChange);
          }, [subscribe]);
          useDebugValue3(value);
          return value;
        }
        function checkIfSnapshotChanged(inst) {
          var latestGetSnapshot = inst.getSnapshot;
          var prevValue = inst.value;
          try {
            var nextValue = latestGetSnapshot();
            return !objectIs(prevValue, nextValue);
          } catch (error2) {
            return true;
          }
        }
        function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {
          return getSnapshot();
        }
        var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
        var isServerEnvironment = !canUseDOM;
        var shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore;
        var useSyncExternalStore$2 = React49.useSyncExternalStore !== void 0 ? React49.useSyncExternalStore : shim;
        exports.useSyncExternalStore = useSyncExternalStore$2;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// ../../node_modules/use-sync-external-store/shim/index.js
var require_shim = __commonJS({
  "../../node_modules/use-sync-external-store/shim/index.js"(exports, module) {
    "use strict";
    init_define_import_meta_env();
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_use_sync_external_store_shim_development();
    }
  }
});

// ../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js
var require_with_selector_development = __commonJS({
  "../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js"(exports) {
    "use strict";
    init_define_import_meta_env();
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var React49 = require_react();
        var shim = require_shim();
        function is(x3, y3) {
          return x3 === y3 && (x3 !== 0 || 1 / x3 === 1 / y3) || x3 !== x3 && y3 !== y3;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is;
        var useSyncExternalStore = shim.useSyncExternalStore;
        var useRef34 = React49.useRef, useEffect36 = React49.useEffect, useMemo5 = React49.useMemo, useDebugValue3 = React49.useDebugValue;
        function useSyncExternalStoreWithSelector2(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
          var instRef = useRef34(null);
          var inst;
          if (instRef.current === null) {
            inst = {
              hasValue: false,
              value: null
            };
            instRef.current = inst;
          } else {
            inst = instRef.current;
          }
          var _useMemo = useMemo5(function() {
            var hasMemo = false;
            var memoizedSnapshot;
            var memoizedSelection;
            var memoizedSelector = function(nextSnapshot) {
              if (!hasMemo) {
                hasMemo = true;
                memoizedSnapshot = nextSnapshot;
                var _nextSelection = selector(nextSnapshot);
                if (isEqual !== void 0) {
                  if (inst.hasValue) {
                    var currentSelection = inst.value;
                    if (isEqual(currentSelection, _nextSelection)) {
                      memoizedSelection = currentSelection;
                      return currentSelection;
                    }
                  }
                }
                memoizedSelection = _nextSelection;
                return _nextSelection;
              }
              var prevSnapshot = memoizedSnapshot;
              var prevSelection = memoizedSelection;
              if (objectIs(prevSnapshot, nextSnapshot)) {
                return prevSelection;
              }
              var nextSelection = selector(nextSnapshot);
              if (isEqual !== void 0 && isEqual(prevSelection, nextSelection)) {
                return prevSelection;
              }
              memoizedSnapshot = nextSnapshot;
              memoizedSelection = nextSelection;
              return nextSelection;
            };
            var maybeGetServerSnapshot = getServerSnapshot === void 0 ? null : getServerSnapshot;
            var getSnapshotWithSelector = function() {
              return memoizedSelector(getSnapshot());
            };
            var getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? void 0 : function() {
              return memoizedSelector(maybeGetServerSnapshot());
            };
            return [getSnapshotWithSelector, getServerSnapshotWithSelector];
          }, [getSnapshot, getServerSnapshot, selector, isEqual]), getSelection = _useMemo[0], getServerSelection = _useMemo[1];
          var value = useSyncExternalStore(subscribe, getSelection, getServerSelection);
          useEffect36(function() {
            inst.hasValue = true;
            inst.value = value;
          }, [value]);
          useDebugValue3(value);
          return value;
        }
        exports.useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector2;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// ../../node_modules/use-sync-external-store/shim/with-selector.js
var require_with_selector = __commonJS({
  "../../node_modules/use-sync-external-store/shim/with-selector.js"(exports, module) {
    "use strict";
    init_define_import_meta_env();
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_with_selector_development();
    }
  }
});

// ../../node_modules/lodash.throttle/index.js
var require_lodash = __commonJS({
  "../../node_modules/lodash.throttle/index.js"(exports, module) {
    init_define_import_meta_env();
    var FUNC_ERROR_TEXT = "Expected a function";
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var nativeMax = Math.max;
    var nativeMin = Math.min;
    var now = function() {
      return root.Date.now();
    };
    function debounce2(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time) : result;
      }
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;
        return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
      }
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
      function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result : trailingEdge(now());
      }
      function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    function throttle3(func, wait, options) {
      var leading = true, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject(options)) {
        leading = "leading" in options ? !!options.leading : leading;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      return debounce2(func, wait, {
        "leading": leading,
        "maxWait": wait,
        "trailing": trailing
      });
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module.exports = throttle3;
  }
});

// data/image.ts
init_define_import_meta_env();
var import_png_chunks_extract = __toESM(require_png_chunks_extract(), 1);
var import_png_chunk_text = __toESM(require_png_chunk_text(), 1);
var import_png_chunks_encode = __toESM(require_png_chunks_encode(), 1);

// data/encode.ts
init_define_import_meta_env();
var import_pako = __toESM(require_pako(), 1);

// data/encryption.ts
init_define_import_meta_env();

// constants.ts
init_define_import_meta_env();

// css/variables.module.scss
var variables_module_default = {};

// colors.ts
init_define_import_meta_env();

// ../../node_modules/open-color/open-color.json
var open_color_default = {
  white: "#ffffff",
  black: "#000000",
  gray: [
    "#f8f9fa",
    "#f1f3f5",
    "#e9ecef",
    "#dee2e6",
    "#ced4da",
    "#adb5bd",
    "#868e96",
    "#495057",
    "#343a40",
    "#212529"
  ],
  red: [
    "#fff5f5",
    "#ffe3e3",
    "#ffc9c9",
    "#ffa8a8",
    "#ff8787",
    "#ff6b6b",
    "#fa5252",
    "#f03e3e",
    "#e03131",
    "#c92a2a"
  ],
  pink: [
    "#fff0f6",
    "#ffdeeb",
    "#fcc2d7",
    "#faa2c1",
    "#f783ac",
    "#f06595",
    "#e64980",
    "#d6336c",
    "#c2255c",
    "#a61e4d"
  ],
  grape: [
    "#f8f0fc",
    "#f3d9fa",
    "#eebefa",
    "#e599f7",
    "#da77f2",
    "#cc5de8",
    "#be4bdb",
    "#ae3ec9",
    "#9c36b5",
    "#862e9c"
  ],
  violet: [
    "#f3f0ff",
    "#e5dbff",
    "#d0bfff",
    "#b197fc",
    "#9775fa",
    "#845ef7",
    "#7950f2",
    "#7048e8",
    "#6741d9",
    "#5f3dc4"
  ],
  indigo: [
    "#edf2ff",
    "#dbe4ff",
    "#bac8ff",
    "#91a7ff",
    "#748ffc",
    "#5c7cfa",
    "#4c6ef5",
    "#4263eb",
    "#3b5bdb",
    "#364fc7"
  ],
  blue: [
    "#e7f5ff",
    "#d0ebff",
    "#a5d8ff",
    "#74c0fc",
    "#4dabf7",
    "#339af0",
    "#228be6",
    "#1c7ed6",
    "#1971c2",
    "#1864ab"
  ],
  cyan: [
    "#e3fafc",
    "#c5f6fa",
    "#99e9f2",
    "#66d9e8",
    "#3bc9db",
    "#22b8cf",
    "#15aabf",
    "#1098ad",
    "#0c8599",
    "#0b7285"
  ],
  teal: [
    "#e6fcf5",
    "#c3fae8",
    "#96f2d7",
    "#63e6be",
    "#38d9a9",
    "#20c997",
    "#12b886",
    "#0ca678",
    "#099268",
    "#087f5b"
  ],
  green: [
    "#ebfbee",
    "#d3f9d8",
    "#b2f2bb",
    "#8ce99a",
    "#69db7c",
    "#51cf66",
    "#40c057",
    "#37b24d",
    "#2f9e44",
    "#2b8a3e"
  ],
  lime: [
    "#f4fce3",
    "#e9fac8",
    "#d8f5a2",
    "#c0eb75",
    "#a9e34b",
    "#94d82d",
    "#82c91e",
    "#74b816",
    "#66a80f",
    "#5c940d"
  ],
  yellow: [
    "#fff9db",
    "#fff3bf",
    "#ffec99",
    "#ffe066",
    "#ffd43b",
    "#fcc419",
    "#fab005",
    "#f59f00",
    "#f08c00",
    "#e67700"
  ],
  orange: [
    "#fff4e6",
    "#ffe8cc",
    "#ffd8a8",
    "#ffc078",
    "#ffa94d",
    "#ff922b",
    "#fd7e14",
    "#f76707",
    "#e8590c",
    "#d9480f"
  ]
};

// colors.ts
var pick = (source, keys) => {
  return keys.reduce((acc, key) => {
    if (key in source) {
      acc[key] = source[key];
    }
    return acc;
  }, {});
};
var MAX_CUSTOM_COLORS_USED_IN_CANVAS = 5;
var COLORS_PER_ROW = 5;
var DEFAULT_CHART_COLOR_INDEX = 4;
var DEFAULT_ELEMENT_STROKE_COLOR_INDEX = 4;
var DEFAULT_ELEMENT_BACKGROUND_COLOR_INDEX = 1;
var ELEMENTS_PALETTE_SHADE_INDEXES = [0, 2, 4, 6, 8];
var getSpecificColorShades = (color, indexArr) => {
  return indexArr.map((index2) => open_color_default[color][index2]);
};
var COLOR_PALETTE = {
  transparent: "transparent",
  black: "#1e1e1e",
  white: "#ffffff",
  // open-colors
  gray: getSpecificColorShades("gray", ELEMENTS_PALETTE_SHADE_INDEXES),
  red: getSpecificColorShades("red", ELEMENTS_PALETTE_SHADE_INDEXES),
  pink: getSpecificColorShades("pink", ELEMENTS_PALETTE_SHADE_INDEXES),
  grape: getSpecificColorShades("grape", ELEMENTS_PALETTE_SHADE_INDEXES),
  violet: getSpecificColorShades("violet", ELEMENTS_PALETTE_SHADE_INDEXES),
  blue: getSpecificColorShades("blue", ELEMENTS_PALETTE_SHADE_INDEXES),
  cyan: getSpecificColorShades("cyan", ELEMENTS_PALETTE_SHADE_INDEXES),
  teal: getSpecificColorShades("teal", ELEMENTS_PALETTE_SHADE_INDEXES),
  green: getSpecificColorShades("green", ELEMENTS_PALETTE_SHADE_INDEXES),
  yellow: getSpecificColorShades("yellow", ELEMENTS_PALETTE_SHADE_INDEXES),
  orange: getSpecificColorShades("orange", ELEMENTS_PALETTE_SHADE_INDEXES),
  // radix bronze shades 3,5,7,9,11
  bronze: ["#f8f1ee", "#eaddd7", "#d2bab0", "#a18072", "#846358"]
};
var COMMON_ELEMENT_SHADES = pick(COLOR_PALETTE, [
  "cyan",
  "blue",
  "violet",
  "grape",
  "pink",
  "green",
  "teal",
  "yellow",
  "orange",
  "red"
]);
var DEFAULT_ELEMENT_STROKE_PICKS = [
  COLOR_PALETTE.black,
  COLOR_PALETTE.red[DEFAULT_ELEMENT_STROKE_COLOR_INDEX],
  COLOR_PALETTE.green[DEFAULT_ELEMENT_STROKE_COLOR_INDEX],
  COLOR_PALETTE.blue[DEFAULT_ELEMENT_STROKE_COLOR_INDEX],
  COLOR_PALETTE.yellow[DEFAULT_ELEMENT_STROKE_COLOR_INDEX]
];
var DEFAULT_ELEMENT_BACKGROUND_PICKS = [
  COLOR_PALETTE.transparent,
  COLOR_PALETTE.red[DEFAULT_ELEMENT_BACKGROUND_COLOR_INDEX],
  COLOR_PALETTE.green[DEFAULT_ELEMENT_BACKGROUND_COLOR_INDEX],
  COLOR_PALETTE.blue[DEFAULT_ELEMENT_BACKGROUND_COLOR_INDEX],
  COLOR_PALETTE.yellow[DEFAULT_ELEMENT_BACKGROUND_COLOR_INDEX]
];
var DEFAULT_CANVAS_BACKGROUND_PICKS = [
  COLOR_PALETTE.white,
  // radix slate2
  "#f8f9fa",
  // radix blue2
  "#f5faff",
  // radix yellow2
  "#fffce8",
  // radix bronze2
  "#fdf8f6"
];
var DEFAULT_ELEMENT_STROKE_COLOR_PALETTE = {
  // 1st row
  transparent: COLOR_PALETTE.transparent,
  white: COLOR_PALETTE.white,
  gray: COLOR_PALETTE.gray,
  black: COLOR_PALETTE.black,
  bronze: COLOR_PALETTE.bronze,
  // rest
  ...COMMON_ELEMENT_SHADES
};
var DEFAULT_ELEMENT_BACKGROUND_COLOR_PALETTE = {
  transparent: COLOR_PALETTE.transparent,
  white: COLOR_PALETTE.white,
  gray: COLOR_PALETTE.gray,
  black: COLOR_PALETTE.black,
  bronze: COLOR_PALETTE.bronze,
  ...COMMON_ELEMENT_SHADES
};
var getAllColorsSpecificShade = (index2) => [
  // 2nd row
  COLOR_PALETTE.cyan[index2],
  COLOR_PALETTE.blue[index2],
  COLOR_PALETTE.violet[index2],
  COLOR_PALETTE.grape[index2],
  COLOR_PALETTE.pink[index2],
  // 3rd row
  COLOR_PALETTE.green[index2],
  COLOR_PALETTE.teal[index2],
  COLOR_PALETTE.yellow[index2],
  COLOR_PALETTE.orange[index2],
  COLOR_PALETTE.red[index2]
];
var rgbToHex = (r3, g3, b4) => `#${((1 << 24) + (r3 << 16) + (g3 << 8) + b4).toString(16).slice(1)}`;

// constants.ts
var isDarwin = /Mac|iPod|iPhone|iPad/.test(navigator.platform);
var isWindows = /^Win/.test(navigator.platform);
var isAndroid = /\b(android)\b/i.test(navigator.userAgent);
var isFirefox = "netscape" in window && navigator.userAgent.indexOf("rv:") > 1 && navigator.userAgent.indexOf("Gecko") > 1;
var isChrome = navigator.userAgent.indexOf("Chrome") !== -1;
var isSafari = !isChrome && navigator.userAgent.indexOf("Safari") !== -1;
var isIOS = /iPad|iPhone/.test(navigator.platform) || // iPadOS 13+
navigator.userAgent.includes("Mac") && "ontouchend" in document;
var isBrave = () => navigator.brave?.isBrave?.name === "isBrave";
var APP_NAME = "Excalidraw";
var DRAGGING_THRESHOLD = 10;
var LINE_CONFIRM_THRESHOLD = 8;
var ELEMENT_SHIFT_TRANSLATE_AMOUNT = 5;
var ELEMENT_TRANSLATE_AMOUNT = 1;
var TEXT_TO_CENTER_SNAP_THRESHOLD = 30;
var SHIFT_LOCKING_ANGLE = Math.PI / 12;
var CURSOR_TYPE = {
  TEXT: "text",
  CROSSHAIR: "crosshair",
  GRABBING: "grabbing",
  GRAB: "grab",
  POINTER: "pointer",
  MOVE: "move",
  AUTO: ""
};
var POINTER_BUTTON = {
  MAIN: 0,
  WHEEL: 1,
  SECONDARY: 2,
  TOUCH: -1,
  ERASER: 5
};
var POINTER_EVENTS = {
  enabled: "all",
  disabled: "none",
  // asserted as any so it can be freely assigned to React Element
  // "pointerEnvets" CSS prop
  inheritFromUI: "var(--ui-pointerEvents)"
};
var YOUTUBE_STATES = {
  UNSTARTED: -1,
  ENDED: 0,
  PLAYING: 1,
  PAUSED: 2,
  BUFFERING: 3,
  CUED: 5
};
var ENV = {
  TEST: "test",
  DEVELOPMENT: "development"
};
var CLASSES = {
  SHAPE_ACTIONS_MENU: "App-menu__left"
};
var FONT_FAMILY = {
  Virgil: 1,
  Helvetica: 2,
  Cascadia: 3,
  Assistant: 4
};
var THEME = {
  LIGHT: "light",
  DARK: "dark"
};
var FRAME_STYLE = {
  strokeColor: "#bbb",
  strokeWidth: 2,
  strokeStyle: "solid",
  fillStyle: "solid",
  roughness: 0,
  roundness: null,
  backgroundColor: "transparent",
  radius: 8,
  nameOffsetY: 3,
  nameColorLightTheme: "#999999",
  nameColorDarkTheme: "#7a7a7a",
  nameFontSize: 14,
  nameLineHeight: 1.25
};
var WINDOWS_EMOJI_FALLBACK_FONT = "Segoe UI Emoji";
var MIN_FONT_SIZE = 1;
var DEFAULT_FONT_SIZE = 20;
var DEFAULT_FONT_FAMILY = FONT_FAMILY.Virgil;
var DEFAULT_TEXT_ALIGN = "left";
var DEFAULT_VERTICAL_ALIGN = "top";
var DEFAULT_TRANSFORM_HANDLE_SPACING = 2;
var GRID_SIZE = 20;
var IMAGE_MIME_TYPES = {
  svg: "image/svg+xml",
  png: "image/png",
  jpg: "image/jpeg",
  gif: "image/gif",
  webp: "image/webp",
  bmp: "image/bmp",
  ico: "image/x-icon",
  avif: "image/avif",
  jfif: "image/jfif"
};
var ALLOWED_PASTE_MIME_TYPES = ["text/plain", "text/html"];
var MIME_TYPES = {
  json: "application/json",
  // excalidraw data
  excalidraw: "application/vnd.excalidraw+json",
  excalidrawlib: "application/vnd.excalidrawlib+json",
  // image-encoded excalidraw data
  "excalidraw.svg": "image/svg+xml",
  "excalidraw.png": "image/png",
  // binary
  binary: "application/octet-stream",
  // image
  ...IMAGE_MIME_TYPES
};
var EXPORT_IMAGE_TYPES = {
  png: "png",
  svg: "svg",
  clipboard: "clipboard"
};
var EXPORT_DATA_TYPES = {
  excalidraw: "excalidraw",
  excalidrawClipboard: "excalidraw/clipboard",
  excalidrawLibrary: "excalidrawlib",
  excalidrawClipboardWithAPI: "excalidraw-api/clipboard"
};
var EXPORT_SOURCE = window.EXCALIDRAW_EXPORT_SOURCE || window.location.origin;
var IMAGE_RENDER_TIMEOUT = 500;
var TAP_TWICE_TIMEOUT = 300;
var TOUCH_CTX_MENU_TIMEOUT = 500;
var SCROLL_TIMEOUT = 100;
var ZOOM_STEP = 0.1;
var MIN_ZOOM = 0.1;
var HYPERLINK_TOOLTIP_DELAY = 300;
var THEME_FILTER = variables_module_default.themeFilter;
var URL_QUERY_KEYS = {
  addLibrary: "addLibrary"
};
var URL_HASH_KEYS = {
  addLibrary: "addLibrary"
};
var DEFAULT_UI_OPTIONS = {
  canvasActions: {
    changeViewBackgroundColor: true,
    clearCanvas: true,
    export: { saveFileToDisk: true },
    loadScene: true,
    saveToActiveFile: true,
    toggleTheme: null,
    saveAsImage: true
  },
  tools: {
    image: true
  }
};
var MQ_MAX_WIDTH_PORTRAIT = 730;
var MQ_MAX_WIDTH_LANDSCAPE = 1e3;
var MQ_MAX_HEIGHT_LANDSCAPE = 500;
var MQ_RIGHT_SIDEBAR_MIN_WIDTH = 1229;
var LIBRARY_SIDEBAR_WIDTH = parseInt(variables_module_default.rightSidebarWidth);
var MAX_DECIMALS_FOR_SVG_EXPORT = 2;
var EXPORT_SCALES = [1, 2, 3];
var DEFAULT_EXPORT_PADDING = 10;
var DEFAULT_MAX_IMAGE_WIDTH_OR_HEIGHT = 1440;
var MAX_ALLOWED_FILE_BYTES = 2 * 1024 * 1024;
var SVG_NS = "http://www.w3.org/2000/svg";
var VERSIONS = {
  excalidraw: 2,
  excalidrawLibrary: 2
};
var BOUND_TEXT_PADDING = 5;
var ARROW_LABEL_WIDTH_FRACTION = 0.7;
var ARROW_LABEL_FONT_SIZE_TO_MIN_WIDTH_RATIO = 11;
var VERTICAL_ALIGN = {
  TOP: "top",
  MIDDLE: "middle",
  BOTTOM: "bottom"
};
var TEXT_ALIGN = {
  LEFT: "left",
  CENTER: "center",
  RIGHT: "right"
};
var ELEMENT_READY_TO_ERASE_OPACITY = 20;
var DEFAULT_PROPORTIONAL_RADIUS = 0.25;
var DEFAULT_ADAPTIVE_RADIUS = 32;
var ROUNDNESS = {
  // Used for legacy rounding (rectangles), which currently works the same
  // as PROPORTIONAL_RADIUS, but we need to differentiate for UI purposes and
  // forwards-compat.
  LEGACY: 1,
  // Used for linear elements & diamonds
  PROPORTIONAL_RADIUS: 2,
  // Current default algorithm for rectangles, using fixed pixel radius.
  // It's working similarly to a regular border-radius, but attemps to make
  // radius visually similar across differnt element sizes, especially
  // very large and very small elements.
  //
  // NOTE right now we don't allow configuration and use a constant radius
  // (see DEFAULT_ADAPTIVE_RADIUS constant)
  ADAPTIVE_RADIUS: 3
};
var PRECEDING_ELEMENT_KEY = "__precedingElement__";
var ROUGHNESS = {
  architect: 0,
  artist: 1,
  cartoonist: 2
};
var STROKE_WIDTH = {
  thin: 1,
  bold: 2,
  extraBold: 4
};
var DEFAULT_ELEMENT_PROPS = {
  strokeColor: COLOR_PALETTE.black,
  backgroundColor: COLOR_PALETTE.transparent,
  fillStyle: "solid",
  strokeWidth: 2,
  strokeStyle: "solid",
  roughness: ROUGHNESS.artist,
  opacity: 100,
  locked: false
};
var LIBRARY_SIDEBAR_TAB = "library";
var DEFAULT_SIDEBAR = {
  name: "default",
  defaultTab: LIBRARY_SIDEBAR_TAB
};
var LIBRARY_DISABLED_TYPES = /* @__PURE__ */ new Set([
  "iframe",
  "embeddable",
  "image"
]);
var TOOL_TYPE = {
  selection: "selection",
  rectangle: "rectangle",
  diamond: "diamond",
  ellipse: "ellipse",
  arrow: "arrow",
  line: "line",
  freedraw: "freedraw",
  text: "text",
  image: "image",
  eraser: "eraser",
  hand: "hand",
  frame: "frame",
  magicframe: "magicframe",
  embeddable: "embeddable",
  laser: "laser"
};
var EDITOR_LS_KEYS = {
  OAI_API_KEY: "excalidraw-oai-api-key",
  // legacy naming (non)scheme
  MERMAID_TO_EXCALIDRAW: "mermaid-to-excalidraw",
  PUBLISH_LIBRARY: "publish-library-data"
};
var DEFAULT_FILENAME = "Untitled";

// data/blob.ts
init_define_import_meta_env();

// node_modules/nanoid/index.browser.js
init_define_import_meta_env();

// node_modules/nanoid/url-alphabet/index.js
init_define_import_meta_env();

// node_modules/nanoid/index.browser.js
var nanoid = (size = 21) => crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {
  byte &= 63;
  if (byte < 36) {
    id += byte.toString(36);
  } else if (byte < 62) {
    id += (byte - 26).toString(36).toUpperCase();
  } else if (byte > 62) {
    id += "-";
  } else {
    id += "_";
  }
  return id;
}, "");

// appState.ts
init_define_import_meta_env();
var defaultExportScale = EXPORT_SCALES.includes(devicePixelRatio) ? devicePixelRatio : 1;
var getDefaultAppState = () => {
  return {
    showWelcomeScreen: false,
    theme: THEME.LIGHT,
    collaborators: /* @__PURE__ */ new Map(),
    currentChartType: "bar",
    currentItemBackgroundColor: DEFAULT_ELEMENT_PROPS.backgroundColor,
    currentItemEndArrowhead: "arrow",
    currentItemFillStyle: DEFAULT_ELEMENT_PROPS.fillStyle,
    currentItemFontFamily: DEFAULT_FONT_FAMILY,
    currentItemFontSize: DEFAULT_FONT_SIZE,
    currentItemOpacity: DEFAULT_ELEMENT_PROPS.opacity,
    currentItemRoughness: DEFAULT_ELEMENT_PROPS.roughness,
    currentItemStartArrowhead: null,
    currentItemStrokeColor: DEFAULT_ELEMENT_PROPS.strokeColor,
    currentItemRoundness: "round",
    currentItemStrokeStyle: DEFAULT_ELEMENT_PROPS.strokeStyle,
    currentItemStrokeWidth: DEFAULT_ELEMENT_PROPS.strokeWidth,
    currentItemTextAlign: DEFAULT_TEXT_ALIGN,
    cursorButton: "up",
    activeEmbeddable: null,
    draggingElement: null,
    editingElement: null,
    editingGroupId: null,
    editingLinearElement: null,
    activeTool: {
      type: "selection",
      customType: null,
      locked: DEFAULT_ELEMENT_PROPS.locked,
      lastActiveTool: null
    },
    penMode: false,
    penDetected: false,
    errorMessage: null,
    exportBackground: true,
    exportScale: defaultExportScale,
    exportEmbedScene: false,
    exportWithDarkMode: false,
    fileHandle: null,
    gridSize: null,
    isBindingEnabled: true,
    defaultSidebarDockedPreference: false,
    isLoading: false,
    isResizing: false,
    isRotating: false,
    lastPointerDownWith: "mouse",
    multiElement: null,
    name: null,
    contextMenu: null,
    openMenu: null,
    openPopup: null,
    openSidebar: null,
    openDialog: null,
    pasteDialog: { shown: false, data: null },
    previousSelectedElementIds: {},
    resizingElement: null,
    scrolledOutside: false,
    scrollX: 0,
    scrollY: 0,
    selectedElementIds: {},
    selectedGroupIds: {},
    selectedElementsAreBeingDragged: false,
    selectionElement: null,
    shouldCacheIgnoreZoom: false,
    showStats: false,
    startBoundElement: null,
    suggestedBindings: [],
    frameRendering: { enabled: true, clip: true, name: true, outline: true },
    frameToHighlight: null,
    editingFrame: null,
    elementsToHighlight: null,
    toast: null,
    viewBackgroundColor: COLOR_PALETTE.white,
    zenModeEnabled: false,
    zoom: {
      value: 1
    },
    viewModeEnabled: false,
    pendingImageElementId: null,
    showHyperlinkPopup: false,
    selectedLinearElement: null,
    snapLines: [],
    originSnapOffset: {
      x: 0,
      y: 0
    },
    objectsSnapModeEnabled: false,
    userToFollow: null,
    followedBy: /* @__PURE__ */ new Set()
  };
};
var APP_STATE_STORAGE_CONF = /* @__PURE__ */ ((config) => config)({
  showWelcomeScreen: { browser: true, export: false, server: false },
  theme: { browser: true, export: false, server: false },
  collaborators: { browser: false, export: false, server: false },
  currentChartType: { browser: true, export: false, server: false },
  currentItemBackgroundColor: { browser: true, export: false, server: false },
  currentItemEndArrowhead: { browser: true, export: false, server: false },
  currentItemFillStyle: { browser: true, export: false, server: false },
  currentItemFontFamily: { browser: true, export: false, server: false },
  currentItemFontSize: { browser: true, export: false, server: false },
  currentItemRoundness: {
    browser: true,
    export: false,
    server: false
  },
  currentItemOpacity: { browser: true, export: false, server: false },
  currentItemRoughness: { browser: true, export: false, server: false },
  currentItemStartArrowhead: { browser: true, export: false, server: false },
  currentItemStrokeColor: { browser: true, export: false, server: false },
  currentItemStrokeStyle: { browser: true, export: false, server: false },
  currentItemStrokeWidth: { browser: true, export: false, server: false },
  currentItemTextAlign: { browser: true, export: false, server: false },
  cursorButton: { browser: true, export: false, server: false },
  activeEmbeddable: { browser: false, export: false, server: false },
  draggingElement: { browser: false, export: false, server: false },
  editingElement: { browser: false, export: false, server: false },
  editingGroupId: { browser: true, export: false, server: false },
  editingLinearElement: { browser: false, export: false, server: false },
  activeTool: { browser: true, export: false, server: false },
  penMode: { browser: true, export: false, server: false },
  penDetected: { browser: true, export: false, server: false },
  errorMessage: { browser: false, export: false, server: false },
  exportBackground: { browser: true, export: false, server: false },
  exportEmbedScene: { browser: true, export: false, server: false },
  exportScale: { browser: true, export: false, server: false },
  exportWithDarkMode: { browser: true, export: false, server: false },
  fileHandle: { browser: false, export: false, server: false },
  gridSize: { browser: true, export: true, server: true },
  height: { browser: false, export: false, server: false },
  isBindingEnabled: { browser: false, export: false, server: false },
  defaultSidebarDockedPreference: {
    browser: true,
    export: false,
    server: false
  },
  isLoading: { browser: false, export: false, server: false },
  isResizing: { browser: false, export: false, server: false },
  isRotating: { browser: false, export: false, server: false },
  lastPointerDownWith: { browser: true, export: false, server: false },
  multiElement: { browser: false, export: false, server: false },
  name: { browser: true, export: false, server: false },
  offsetLeft: { browser: false, export: false, server: false },
  offsetTop: { browser: false, export: false, server: false },
  contextMenu: { browser: false, export: false, server: false },
  openMenu: { browser: true, export: false, server: false },
  openPopup: { browser: false, export: false, server: false },
  openSidebar: { browser: true, export: false, server: false },
  openDialog: { browser: false, export: false, server: false },
  pasteDialog: { browser: false, export: false, server: false },
  previousSelectedElementIds: { browser: true, export: false, server: false },
  resizingElement: { browser: false, export: false, server: false },
  scrolledOutside: { browser: true, export: false, server: false },
  scrollX: { browser: true, export: false, server: false },
  scrollY: { browser: true, export: false, server: false },
  selectedElementIds: { browser: true, export: false, server: false },
  selectedGroupIds: { browser: true, export: false, server: false },
  selectedElementsAreBeingDragged: {
    browser: false,
    export: false,
    server: false
  },
  selectionElement: { browser: false, export: false, server: false },
  shouldCacheIgnoreZoom: { browser: true, export: false, server: false },
  showStats: { browser: true, export: false, server: false },
  startBoundElement: { browser: false, export: false, server: false },
  suggestedBindings: { browser: false, export: false, server: false },
  frameRendering: { browser: false, export: false, server: false },
  frameToHighlight: { browser: false, export: false, server: false },
  editingFrame: { browser: false, export: false, server: false },
  elementsToHighlight: { browser: false, export: false, server: false },
  toast: { browser: false, export: false, server: false },
  viewBackgroundColor: { browser: true, export: true, server: true },
  width: { browser: false, export: false, server: false },
  zenModeEnabled: { browser: true, export: false, server: false },
  zoom: { browser: true, export: false, server: false },
  viewModeEnabled: { browser: false, export: false, server: false },
  pendingImageElementId: { browser: false, export: false, server: false },
  showHyperlinkPopup: { browser: false, export: false, server: false },
  selectedLinearElement: { browser: true, export: false, server: false },
  snapLines: { browser: false, export: false, server: false },
  originSnapOffset: { browser: false, export: false, server: false },
  objectsSnapModeEnabled: { browser: true, export: false, server: false },
  userToFollow: { browser: false, export: false, server: false },
  followedBy: { browser: false, export: false, server: false }
});
var _clearAppStateForStorage = (appState, exportType) => {
  const stateForExport = {};
  for (const key of Object.keys(appState)) {
    const propConfig = APP_STATE_STORAGE_CONF[key];
    if (propConfig?.[exportType]) {
      const nextValue = appState[key];
      stateForExport[key] = nextValue;
    }
  }
  return stateForExport;
};
var cleanAppStateForExport = (appState) => {
  return _clearAppStateForStorage(appState, "export");
};
var clearAppStateForDatabase = (appState) => {
  return _clearAppStateForStorage(appState, "server");
};
var isEraserActive = ({
  activeTool
}) => activeTool.type === "eraser";
var isHandToolActive = ({
  activeTool
}) => {
  return activeTool.type === "hand";
};

// element/index.ts
init_define_import_meta_env();

// element/sizeHelpers.ts
init_define_import_meta_env();

// element/mutateElement.ts
init_define_import_meta_env();

// scene/Scene.ts
init_define_import_meta_env();

// element/typeChecks.ts
init_define_import_meta_env();

// utils.ts
init_define_import_meta_env();
var mockDateTime = null;
var getDateTime = () => {
  if (mockDateTime) {
    return mockDateTime;
  }
  const date = /* @__PURE__ */ new Date();
  const year = date.getFullYear();
  const month = `${date.getMonth() + 1}`.padStart(2, "0");
  const day = `${date.getDate()}`.padStart(2, "0");
  const hr = `${date.getHours()}`.padStart(2, "0");
  const min = `${date.getMinutes()}`.padStart(2, "0");
  return `${year}-${month}-${day}-${hr}${min}`;
};
var capitalizeString = (str) => str.charAt(0).toUpperCase() + str.slice(1);
var isToolIcon = (target) => target instanceof HTMLElement && target.className.includes("ToolIcon");
var isInputLike = (target) => target instanceof HTMLElement && target.dataset.type === "wysiwyg" || target instanceof HTMLBRElement || // newline in wysiwyg
target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement || target instanceof HTMLSelectElement;
var isInteractive = (target) => {
  return isInputLike(target) || target instanceof Element && !!target.closest("label, button");
};
var isWritableElement = (target) => target instanceof HTMLElement && target.dataset.type === "wysiwyg" || target instanceof HTMLBRElement || // newline in wysiwyg
target instanceof HTMLTextAreaElement || target instanceof HTMLInputElement && (target.type === "text" || target.type === "number" || target.type === "password");
var getFontFamilyString = ({
  fontFamily
}) => {
  for (const [fontFamilyString, id] of Object.entries(FONT_FAMILY)) {
    if (id === fontFamily) {
      return `${fontFamilyString}, ${WINDOWS_EMOJI_FALLBACK_FONT}`;
    }
  }
  return WINDOWS_EMOJI_FALLBACK_FONT;
};
var getFontString = ({
  fontSize,
  fontFamily
}) => {
  return `${fontSize}px ${getFontFamilyString({ fontFamily })}`;
};
var debounce = (fn, timeout) => {
  let handle = 0;
  let lastArgs = null;
  const ret = (...args) => {
    lastArgs = args;
    clearTimeout(handle);
    handle = window.setTimeout(() => {
      lastArgs = null;
      fn(...args);
    }, timeout);
  };
  ret.flush = () => {
    clearTimeout(handle);
    if (lastArgs) {
      const _lastArgs = lastArgs;
      lastArgs = null;
      fn(..._lastArgs);
    }
  };
  ret.cancel = () => {
    lastArgs = null;
    clearTimeout(handle);
  };
  return ret;
};
var throttleRAF = (fn, opts) => {
  let timerId = null;
  let lastArgs = null;
  let lastArgsTrailing = null;
  const scheduleFunc = (args) => {
    timerId = window.requestAnimationFrame(() => {
      timerId = null;
      fn(...args);
      lastArgs = null;
      if (lastArgsTrailing) {
        lastArgs = lastArgsTrailing;
        lastArgsTrailing = null;
        scheduleFunc(lastArgs);
      }
    });
  };
  const ret = (...args) => {
    if (define_import_meta_env_default.MODE === "test") {
      fn(...args);
      return;
    }
    lastArgs = args;
    if (timerId === null) {
      scheduleFunc(lastArgs);
    } else if (opts?.trailing) {
      lastArgsTrailing = args;
    }
  };
  ret.flush = () => {
    if (timerId !== null) {
      cancelAnimationFrame(timerId);
      timerId = null;
    }
    if (lastArgs) {
      fn(...lastArgsTrailing || lastArgs);
      lastArgs = lastArgsTrailing = null;
    }
  };
  ret.cancel = () => {
    lastArgs = lastArgsTrailing = null;
    if (timerId !== null) {
      cancelAnimationFrame(timerId);
      timerId = null;
    }
  };
  return ret;
};
var easeOut = (k2) => {
  return 1 - Math.pow(1 - k2, 4);
};
var easeOutInterpolate = (from3, to, progress) => {
  return (to - from3) * easeOut(progress) + from3;
};
var easeToValuesRAF = ({
  fromValues,
  toValues,
  onStep,
  duration = 250,
  interpolateValue,
  onStart,
  onEnd,
  onCancel
}) => {
  let canceled = false;
  let frameId = 0;
  let startTime;
  function step(timestamp) {
    if (canceled) {
      return;
    }
    if (startTime === void 0) {
      startTime = timestamp;
      onStart?.();
    }
    const elapsed = Math.min(timestamp - startTime, duration);
    const factor = easeOut(elapsed / duration);
    const newValues = {};
    Object.keys(fromValues).forEach((key) => {
      const _key = key;
      const result = (toValues[_key] - fromValues[_key]) * factor + fromValues[_key];
      newValues[_key] = result;
    });
    onStep(newValues);
    if (elapsed < duration) {
      const progress = elapsed / duration;
      const newValues2 = {};
      Object.keys(fromValues).forEach((key) => {
        const _key = key;
        const startValue = fromValues[_key];
        const endValue = toValues[_key];
        let result;
        result = interpolateValue ? interpolateValue(startValue, endValue, progress, _key) : easeOutInterpolate(startValue, endValue, progress);
        if (result == null) {
          result = easeOutInterpolate(startValue, endValue, progress);
        }
        newValues2[_key] = result;
      });
      onStep(newValues2);
      frameId = window.requestAnimationFrame(step);
    } else {
      onStep(toValues);
      onEnd?.();
    }
  }
  frameId = window.requestAnimationFrame(step);
  return () => {
    onCancel?.();
    canceled = true;
    window.cancelAnimationFrame(frameId);
  };
};
var chunk = (array, size) => {
  if (!array.length || size < 1) {
    return [];
  }
  let index2 = 0;
  let resIndex = 0;
  const result = Array(Math.ceil(array.length / size));
  while (index2 < array.length) {
    result[resIndex++] = array.slice(index2, index2 += size);
  }
  return result;
};
var distance = (x3, y3) => Math.abs(x3 - y3);
var updateActiveTool = (appState, data) => {
  if (data.type === "custom") {
    return {
      ...appState.activeTool,
      type: "custom",
      customType: data.customType,
      locked: data.locked ?? appState.activeTool.locked
    };
  }
  return {
    ...appState.activeTool,
    lastActiveTool: data.lastActiveToolBeforeEraser === void 0 ? appState.activeTool.lastActiveTool : data.lastActiveToolBeforeEraser,
    type: data.type,
    customType: null,
    locked: data.locked ?? appState.activeTool.locked
  };
};
var getShortcutKey = (shortcut) => {
  shortcut = shortcut.replace(/\bAlt\b/i, "Alt").replace(/\bShift\b/i, "Shift").replace(/\b(Enter|Return)\b/i, "Enter");
  if (isDarwin) {
    return shortcut.replace(/\bCtrlOrCmd\b/gi, "Cmd").replace(/\bAlt\b/i, "Option");
  }
  return shortcut.replace(/\bCtrlOrCmd\b/gi, "Ctrl");
};
var viewportCoordsToSceneCoords = ({ clientX, clientY }, {
  zoom,
  offsetLeft,
  offsetTop,
  scrollX,
  scrollY
}) => {
  const x3 = (clientX - offsetLeft) / zoom.value - scrollX;
  const y3 = (clientY - offsetTop) / zoom.value - scrollY;
  return { x: x3, y: y3 };
};
var sceneCoordsToViewportCoords = ({ sceneX, sceneY }, {
  zoom,
  offsetLeft,
  offsetTop,
  scrollX,
  scrollY
}) => {
  const x3 = (sceneX + scrollX) * zoom.value + offsetLeft;
  const y3 = (sceneY + scrollY) * zoom.value + offsetTop;
  return { x: x3, y: y3 };
};
var getGlobalCSSVariable = (name) => getComputedStyle(document.documentElement).getPropertyValue(`--${name}`);
var RS_LTR_CHARS = "A-Za-z\xC0-\xD6\xD8-\xF6\xF8-\u02B8\u0300-\u0590\u0800-\u1FFF\u2C00-\uFB1C\uFDFE-\uFE6F\uFEFD-\uFFFF";
var RS_RTL_CHARS = "\u0591-\u07FF\uFB1D-\uFDFD\uFE70-\uFEFC";
var RE_RTL_CHECK = new RegExp(`^[^${RS_LTR_CHARS}]*[${RS_RTL_CHARS}]`);
var isRTL = (text) => RE_RTL_CHECK.test(text);
var tupleToCoors = (xyTuple) => {
  const [x3, y3] = xyTuple;
  return { x: x3, y: y3 };
};
var muteFSAbortError = (error) => {
  if (error?.name === "AbortError") {
    console.warn(error);
    return;
  }
  throw error;
};
var findIndex = (array, cb, fromIndex = 0) => {
  if (fromIndex < 0) {
    fromIndex = array.length + fromIndex;
  }
  fromIndex = Math.min(array.length, Math.max(fromIndex, 0));
  let index2 = fromIndex - 1;
  while (++index2 < array.length) {
    if (cb(array[index2], index2, array)) {
      return index2;
    }
  }
  return -1;
};
var findLastIndex = (array, cb, fromIndex = array.length - 1) => {
  if (fromIndex < 0) {
    fromIndex = array.length + fromIndex;
  }
  fromIndex = Math.min(array.length - 1, Math.max(fromIndex, 0));
  let index2 = fromIndex + 1;
  while (--index2 > -1) {
    if (cb(array[index2], index2, array)) {
      return index2;
    }
  }
  return -1;
};
var isTransparent = (color) => {
  const isRGBTransparent = color.length === 5 && color.substr(4, 1) === "0";
  const isRRGGBBTransparent = color.length === 9 && color.substr(7, 2) === "00";
  return isRGBTransparent || isRRGGBBTransparent || color === COLOR_PALETTE.transparent;
};
var getNearestScrollableContainer = (element) => {
  let parent = element.parentElement;
  while (parent) {
    if (parent === document.body) {
      return document;
    }
    const { overflowY } = window.getComputedStyle(parent);
    const hasScrollableContent = parent.scrollHeight > parent.clientHeight;
    if (hasScrollableContent && (overflowY === "auto" || overflowY === "scroll" || overflowY === "overlay")) {
      return parent;
    }
    parent = parent.parentElement;
  }
  return document;
};
var focusNearestParent = (element) => {
  let parent = element.parentElement;
  while (parent) {
    if (parent.tabIndex > -1) {
      parent.focus();
      return;
    }
    parent = parent.parentElement;
  }
};
var bytesToHexString = (bytes) => {
  return Array.from(bytes).map((byte) => `0${byte.toString(16)}`.slice(-2)).join("");
};
var getUpdatedTimestamp = () => isTestEnv() ? 1 : Date.now();
var arrayToMap = (items) => {
  if (items instanceof Map) {
    return items;
  }
  return items.reduce((acc, element) => {
    acc.set(typeof element === "string" ? element : element.id, element);
    return acc;
  }, /* @__PURE__ */ new Map());
};
var arrayToMapWithIndex = (elements) => elements.reduce((acc, element, idx) => {
  acc.set(element.id, [element, idx]);
  return acc;
}, /* @__PURE__ */ new Map());
var isTestEnv = () => define_import_meta_env_default.MODE === "test";
var wrapEvent = (name, nativeEvent) => {
  return new CustomEvent(name, {
    detail: {
      nativeEvent
    },
    cancelable: true
  });
};
var updateObject = (obj, updates) => {
  let didChange = false;
  for (const key in updates) {
    const value = updates[key];
    if (typeof value !== "undefined") {
      if (obj[key] === value && // if object, always update because its attrs could have changed
      (typeof value !== "object" || value === null)) {
        continue;
      }
      didChange = true;
    }
  }
  if (!didChange) {
    return obj;
  }
  return {
    ...obj,
    ...updates
  };
};
var getFrame = () => {
  try {
    return window.self === window.top ? "top" : "iframe";
  } catch (error) {
    return "iframe";
  }
};
var isPromiseLike = (value) => {
  return !!value && typeof value === "object" && "then" in value && "catch" in value && "finally" in value;
};
var queryFocusableElements = (container) => {
  const focusableElements = container?.querySelectorAll(
    "button, a, input, select, textarea, div[tabindex], label[tabindex]"
  );
  return focusableElements ? Array.from(focusableElements).filter(
    (element) => element.tabIndex > -1 && !element.disabled
  ) : [];
};
var _defaultIsShallowComparatorFallback = (a4, b4) => {
  if (Array.isArray(a4) && Array.isArray(b4) && a4.length === 0 && b4.length === 0) {
    return true;
  }
  return a4 === b4;
};
var isShallowEqual = (objA, objB, comparators, debug = false) => {
  const aKeys = Object.keys(objA);
  const bKeys = Object.keys(objB);
  if (aKeys.length !== bKeys.length) {
    return false;
  }
  if (comparators && Array.isArray(comparators)) {
    for (const key of comparators) {
      const ret = objA[key] === objB[key] || _defaultIsShallowComparatorFallback(objA[key], objB[key]);
      if (!ret) {
        if (debug) {
          console.warn(
            `%cisShallowEqual: ${key} not equal ->`,
            "color: #8B4000",
            objA[key],
            objB[key]
          );
        }
        return false;
      }
    }
    return true;
  }
  return aKeys.every((key) => {
    const comparator = comparators?.[key];
    const ret = comparator ? comparator(objA[key], objB[key]) : objA[key] === objB[key] || _defaultIsShallowComparatorFallback(objA[key], objB[key]);
    if (!ret && debug) {
      console.warn(
        `%cisShallowEqual: ${key} not equal ->`,
        "color: #8B4000",
        objA[key],
        objB[key]
      );
    }
    return ret;
  });
};
var composeEventHandlers = (originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) => {
  return function handleEvent(event) {
    originalEventHandler?.(event);
    if (!checkForDefaultPrevented || !event?.defaultPrevented) {
      return ourEventHandler?.(event);
    }
  };
};
var assertNever = (value, message, softAssert) => {
  if (!message) {
    return value;
  }
  if (softAssert) {
    console.error(message);
    return value;
  }
  throw new Error(message);
};
var memoize = (func) => {
  let lastArgs;
  let lastResult;
  const ret = function(opts) {
    const currentArgs = Object.entries(opts);
    if (lastArgs) {
      let argsAreEqual = true;
      for (const [key, value] of currentArgs) {
        if (lastArgs.get(key) !== value) {
          argsAreEqual = false;
          break;
        }
      }
      if (argsAreEqual) {
        return lastResult;
      }
    }
    const result = func(opts);
    lastArgs = new Map(currentArgs);
    lastResult = result;
    return result;
  };
  ret.clear = () => {
    lastArgs = void 0;
    lastResult = void 0;
  };
  return ret;
};
var isMemberOf = (collection, value) => {
  return collection instanceof Set || collection instanceof Map ? collection.has(value) : "includes" in collection ? collection.includes(value) : collection.hasOwnProperty(value);
};
var cloneJSON = (obj) => JSON.parse(JSON.stringify(obj));
var isFiniteNumber = (value) => {
  return typeof value === "number" && Number.isFinite(value);
};
var updateStable = (prevValue, nextValue) => {
  if (isShallowEqual(prevValue, nextValue)) {
    return prevValue;
  }
  return nextValue;
};
function addEventListener(target, type, listener, options) {
  if (!target) {
    return () => {
    };
  }
  target?.addEventListener?.(type, listener, options);
  return () => {
    target?.removeEventListener?.(type, listener, options);
  };
}
var average = (a4, b4) => (a4 + b4) / 2;
function getSvgPathFromStroke(points, closed = true) {
  const len = points.length;
  if (len < 4) {
    return ``;
  }
  let a4 = points[0];
  let b4 = points[1];
  const c3 = points[2];
  let result = `M${a4[0].toFixed(2)},${a4[1].toFixed(2)} Q${b4[0].toFixed(
    2
  )},${b4[1].toFixed(2)} ${average(b4[0], c3[0]).toFixed(2)},${average(
    b4[1],
    c3[1]
  ).toFixed(2)} T`;
  for (let i4 = 2, max = len - 1; i4 < max; i4++) {
    a4 = points[i4];
    b4 = points[i4 + 1];
    result += `${average(a4[0], b4[0]).toFixed(2)},${average(a4[1], b4[1]).toFixed(
      2
    )} `;
  }
  if (closed) {
    result += "Z";
  }
  return result;
}
var normalizeEOL = (str) => {
  return str.replace(/\r?\n|\r/g, "\n");
};
var toBrandedType = (value) => {
  return value;
};

// element/typeChecks.ts
var isInitializedImageElement = (element) => {
  return !!element && element.type === "image" && !!element.fileId;
};
var isImageElement = (element) => {
  return !!element && element.type === "image";
};
var isEmbeddableElement = (element) => {
  return !!element && element.type === "embeddable";
};
var isIframeElement = (element) => {
  return !!element && element.type === "iframe";
};
var isIframeLikeElement = (element) => {
  return !!element && (element.type === "iframe" || element.type === "embeddable");
};
var isTextElement = (element) => {
  return element != null && element.type === "text";
};
var isFrameElement = (element) => {
  return element != null && element.type === "frame";
};
var isMagicFrameElement = (element) => {
  return element != null && element.type === "magicframe";
};
var isFrameLikeElement = (element) => {
  return element != null && (element.type === "frame" || element.type === "magicframe");
};
var isFreeDrawElement = (element) => {
  return element != null && isFreeDrawElementType(element.type);
};
var isFreeDrawElementType = (elementType) => {
  return elementType === "freedraw";
};
var isLinearElement = (element) => {
  return element != null && isLinearElementType(element.type);
};
var isArrowElement = (element) => {
  return element != null && element.type === "arrow";
};
var isLinearElementType = (elementType) => {
  return elementType === "arrow" || elementType === "line";
};
var isBindingElement = (element, includeLocked = true) => {
  return element != null && (!element.locked || includeLocked === true) && isBindingElementType(element.type);
};
var isBindingElementType = (elementType) => {
  return elementType === "arrow";
};
var isBindableElement = (element, includeLocked = true) => {
  return element != null && (!element.locked || includeLocked === true) && (element.type === "rectangle" || element.type === "diamond" || element.type === "ellipse" || element.type === "image" || element.type === "iframe" || element.type === "embeddable" || element.type === "frame" || element.type === "magicframe" || element.type === "text" && !element.containerId);
};
var isTextBindableContainer = (element, includeLocked = true) => {
  return element != null && (!element.locked || includeLocked === true) && (element.type === "rectangle" || element.type === "diamond" || element.type === "ellipse" || isArrowElement(element));
};
var isExcalidrawElement = (element) => {
  const type = element?.type;
  if (!type) {
    return false;
  }
  switch (type) {
    case "text":
    case "diamond":
    case "rectangle":
    case "iframe":
    case "embeddable":
    case "ellipse":
    case "arrow":
    case "freedraw":
    case "line":
    case "frame":
    case "magicframe":
    case "image":
    case "selection": {
      return true;
    }
    default: {
      assertNever(type, null);
      return false;
    }
  }
};
var hasBoundTextElement = (element) => {
  return isTextBindableContainer(element) && !!element.boundElements?.some(({ type }) => type === "text");
};
var isBoundToContainer = (element) => {
  return element !== null && "containerId" in element && element.containerId !== null && isTextElement(element);
};
var isUsingAdaptiveRadius = (type) => type === "rectangle" || type === "embeddable" || type === "iframe" || type === "image";
var isUsingProportionalRadius = (type) => type === "line" || type === "arrow" || type === "diamond";
var canApplyRoundnessTypeToElement = (roundnessType, element) => {
  if ((roundnessType === ROUNDNESS.ADAPTIVE_RADIUS || // if legacy roundness, it can be applied to elements that currently
  // use adaptive radius
  roundnessType === ROUNDNESS.LEGACY) && isUsingAdaptiveRadius(element.type)) {
    return true;
  }
  if (roundnessType === ROUNDNESS.PROPORTIONAL_RADIUS && isUsingProportionalRadius(element.type)) {
    return true;
  }
  return false;
};
var getDefaultRoundnessTypeForElement = (element) => {
  if (isUsingProportionalRadius(element.type)) {
    return {
      type: ROUNDNESS.PROPORTIONAL_RADIUS
    };
  }
  if (isUsingAdaptiveRadius(element.type)) {
    return {
      type: ROUNDNESS.ADAPTIVE_RADIUS
    };
  }
  return null;
};

// scene/selection.ts
init_define_import_meta_env();

// frame.ts
init_define_import_meta_env();

// math.ts
init_define_import_meta_env();

// element/bounds.ts
init_define_import_meta_env();

// ../../node_modules/roughjs/bin/rough.js
init_define_import_meta_env();

// ../../node_modules/roughjs/bin/canvas.js
init_define_import_meta_env();

// ../../node_modules/roughjs/bin/generator.js
init_define_import_meta_env();

// ../../node_modules/roughjs/bin/renderer.js
init_define_import_meta_env();

// ../../node_modules/roughjs/bin/fillers/filler.js
init_define_import_meta_env();

// ../../node_modules/roughjs/bin/fillers/hachure-filler.js
init_define_import_meta_env();

// ../../node_modules/roughjs/bin/fillers/scan-line-hachure.js
init_define_import_meta_env();

// ../../node_modules/hachure-fill/bin/hachure.js
init_define_import_meta_env();
function rotatePoints(points, center, degrees) {
  if (points && points.length) {
    const [cx, cy] = center;
    const angle = Math.PI / 180 * degrees;
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    for (const p3 of points) {
      const [x3, y3] = p3;
      p3[0] = (x3 - cx) * cos - (y3 - cy) * sin + cx;
      p3[1] = (x3 - cx) * sin + (y3 - cy) * cos + cy;
    }
  }
}
function rotateLines(lines, center, degrees) {
  const points = [];
  lines.forEach((line2) => points.push(...line2));
  rotatePoints(points, center, degrees);
}
function areSamePoints(p1, p22) {
  return p1[0] === p22[0] && p1[1] === p22[1];
}
function hachureLines(polygons, hachureGap, hachureAngle, hachureStepOffset = 1) {
  const angle = hachureAngle;
  const gap = Math.max(hachureGap, 0.1);
  const polygonList = polygons[0] && polygons[0][0] && typeof polygons[0][0] === "number" ? [polygons] : polygons;
  const rotationCenter = [0, 0];
  if (angle) {
    for (const polygon2 of polygonList) {
      rotatePoints(polygon2, rotationCenter, angle);
    }
  }
  const lines = straightHachureLines(polygonList, gap, hachureStepOffset);
  if (angle) {
    for (const polygon2 of polygonList) {
      rotatePoints(polygon2, rotationCenter, -angle);
    }
    rotateLines(lines, rotationCenter, -angle);
  }
  return lines;
}
function straightHachureLines(polygons, gap, hachureStepOffset) {
  const vertexArray = [];
  for (const polygon2 of polygons) {
    const vertices = [...polygon2];
    if (!areSamePoints(vertices[0], vertices[vertices.length - 1])) {
      vertices.push([vertices[0][0], vertices[0][1]]);
    }
    if (vertices.length > 2) {
      vertexArray.push(vertices);
    }
  }
  const lines = [];
  gap = Math.max(gap, 0.1);
  const edges = [];
  for (const vertices of vertexArray) {
    for (let i4 = 0; i4 < vertices.length - 1; i4++) {
      const p1 = vertices[i4];
      const p22 = vertices[i4 + 1];
      if (p1[1] !== p22[1]) {
        const ymin = Math.min(p1[1], p22[1]);
        edges.push({
          ymin,
          ymax: Math.max(p1[1], p22[1]),
          x: ymin === p1[1] ? p1[0] : p22[0],
          islope: (p22[0] - p1[0]) / (p22[1] - p1[1])
        });
      }
    }
  }
  edges.sort((e1, e22) => {
    if (e1.ymin < e22.ymin) {
      return -1;
    }
    if (e1.ymin > e22.ymin) {
      return 1;
    }
    if (e1.x < e22.x) {
      return -1;
    }
    if (e1.x > e22.x) {
      return 1;
    }
    if (e1.ymax === e22.ymax) {
      return 0;
    }
    return (e1.ymax - e22.ymax) / Math.abs(e1.ymax - e22.ymax);
  });
  if (!edges.length) {
    return lines;
  }
  let activeEdges = [];
  let y3 = edges[0].ymin;
  let iteration = 0;
  while (activeEdges.length || edges.length) {
    if (edges.length) {
      let ix = -1;
      for (let i4 = 0; i4 < edges.length; i4++) {
        if (edges[i4].ymin > y3) {
          break;
        }
        ix = i4;
      }
      const removed = edges.splice(0, ix + 1);
      removed.forEach((edge) => {
        activeEdges.push({ s: y3, edge });
      });
    }
    activeEdges = activeEdges.filter((ae2) => {
      if (ae2.edge.ymax <= y3) {
        return false;
      }
      return true;
    });
    activeEdges.sort((ae1, ae2) => {
      if (ae1.edge.x === ae2.edge.x) {
        return 0;
      }
      return (ae1.edge.x - ae2.edge.x) / Math.abs(ae1.edge.x - ae2.edge.x);
    });
    if (hachureStepOffset !== 1 || iteration % gap === 0) {
      if (activeEdges.length > 1) {
        for (let i4 = 0; i4 < activeEdges.length; i4 = i4 + 2) {
          const nexti = i4 + 1;
          if (nexti >= activeEdges.length) {
            break;
          }
          const ce2 = activeEdges[i4].edge;
          const ne = activeEdges[nexti].edge;
          lines.push([
            [Math.round(ce2.x), y3],
            [Math.round(ne.x), y3]
          ]);
        }
      }
    }
    y3 += hachureStepOffset;
    activeEdges.forEach((ae2) => {
      ae2.edge.x = ae2.edge.x + hachureStepOffset * ae2.edge.islope;
    });
    iteration++;
  }
  return lines;
}

// ../../node_modules/roughjs/bin/fillers/scan-line-hachure.js
function polygonHachureLines(polygonList, o4) {
  var _a;
  const angle = o4.hachureAngle + 90;
  let gap = o4.hachureGap;
  if (gap < 0) {
    gap = o4.strokeWidth * 4;
  }
  gap = Math.max(gap, 0.1);
  let skipOffset = 1;
  if (o4.roughness >= 1) {
    if ((((_a = o4.randomizer) === null || _a === void 0 ? void 0 : _a.next()) || Math.random()) > 0.7) {
      skipOffset = gap;
    }
  }
  return hachureLines(polygonList, gap, angle, skipOffset || 1);
}

// ../../node_modules/roughjs/bin/fillers/hachure-filler.js
var HachureFiller = class {
  constructor(helper2) {
    this.helper = helper2;
  }
  fillPolygons(polygonList, o4) {
    return this._fillPolygons(polygonList, o4);
  }
  _fillPolygons(polygonList, o4) {
    const lines = polygonHachureLines(polygonList, o4);
    const ops = this.renderLines(lines, o4);
    return { type: "fillSketch", ops };
  }
  renderLines(lines, o4) {
    const ops = [];
    for (const line2 of lines) {
      ops.push(...this.helper.doubleLineOps(line2[0][0], line2[0][1], line2[1][0], line2[1][1], o4));
    }
    return ops;
  }
};

// ../../node_modules/roughjs/bin/fillers/zigzag-filler.js
init_define_import_meta_env();

// ../../node_modules/roughjs/bin/geometry.js
init_define_import_meta_env();
function lineLength(line2) {
  const p1 = line2[0];
  const p22 = line2[1];
  return Math.sqrt(Math.pow(p1[0] - p22[0], 2) + Math.pow(p1[1] - p22[1], 2));
}

// ../../node_modules/roughjs/bin/fillers/zigzag-filler.js
var ZigZagFiller = class extends HachureFiller {
  fillPolygons(polygonList, o4) {
    let gap = o4.hachureGap;
    if (gap < 0) {
      gap = o4.strokeWidth * 4;
    }
    gap = Math.max(gap, 0.1);
    const o22 = Object.assign({}, o4, { hachureGap: gap });
    const lines = polygonHachureLines(polygonList, o22);
    const zigZagAngle = Math.PI / 180 * o4.hachureAngle;
    const zigzagLines = [];
    const dgx = gap * 0.5 * Math.cos(zigZagAngle);
    const dgy = gap * 0.5 * Math.sin(zigZagAngle);
    for (const [p1, p22] of lines) {
      if (lineLength([p1, p22])) {
        zigzagLines.push([
          [p1[0] - dgx, p1[1] + dgy],
          [...p22]
        ], [
          [p1[0] + dgx, p1[1] - dgy],
          [...p22]
        ]);
      }
    }
    const ops = this.renderLines(zigzagLines, o4);
    return { type: "fillSketch", ops };
  }
};

// ../../node_modules/roughjs/bin/fillers/hatch-filler.js
init_define_import_meta_env();
var HatchFiller = class extends HachureFiller {
  fillPolygons(polygonList, o4) {
    const set = this._fillPolygons(polygonList, o4);
    const o22 = Object.assign({}, o4, { hachureAngle: o4.hachureAngle + 90 });
    const set2 = this._fillPolygons(polygonList, o22);
    set.ops = set.ops.concat(set2.ops);
    return set;
  }
};

// ../../node_modules/roughjs/bin/fillers/dot-filler.js
init_define_import_meta_env();
var DotFiller = class {
  constructor(helper2) {
    this.helper = helper2;
  }
  fillPolygons(polygonList, o4) {
    o4 = Object.assign({}, o4, { hachureAngle: 0 });
    const lines = polygonHachureLines(polygonList, o4);
    return this.dotsOnLines(lines, o4);
  }
  dotsOnLines(lines, o4) {
    const ops = [];
    let gap = o4.hachureGap;
    if (gap < 0) {
      gap = o4.strokeWidth * 4;
    }
    gap = Math.max(gap, 0.1);
    let fweight = o4.fillWeight;
    if (fweight < 0) {
      fweight = o4.strokeWidth / 2;
    }
    const ro = gap / 4;
    for (const line2 of lines) {
      const length = lineLength(line2);
      const dl = length / gap;
      const count = Math.ceil(dl) - 1;
      const offset2 = length - count * gap;
      const x3 = (line2[0][0] + line2[1][0]) / 2 - gap / 4;
      const minY = Math.min(line2[0][1], line2[1][1]);
      for (let i4 = 0; i4 < count; i4++) {
        const y3 = minY + offset2 + i4 * gap;
        const cx = x3 - ro + Math.random() * 2 * ro;
        const cy = y3 - ro + Math.random() * 2 * ro;
        const el = this.helper.ellipse(cx, cy, fweight, fweight, o4);
        ops.push(...el.ops);
      }
    }
    return { type: "fillSketch", ops };
  }
};

// ../../node_modules/roughjs/bin/fillers/dashed-filler.js
init_define_import_meta_env();
var DashedFiller = class {
  constructor(helper2) {
    this.helper = helper2;
  }
  fillPolygons(polygonList, o4) {
    const lines = polygonHachureLines(polygonList, o4);
    return { type: "fillSketch", ops: this.dashedLine(lines, o4) };
  }
  dashedLine(lines, o4) {
    const offset2 = o4.dashOffset < 0 ? o4.hachureGap < 0 ? o4.strokeWidth * 4 : o4.hachureGap : o4.dashOffset;
    const gap = o4.dashGap < 0 ? o4.hachureGap < 0 ? o4.strokeWidth * 4 : o4.hachureGap : o4.dashGap;
    const ops = [];
    lines.forEach((line2) => {
      const length = lineLength(line2);
      const count = Math.floor(length / (offset2 + gap));
      const startOffset = (length + gap - count * (offset2 + gap)) / 2;
      let p1 = line2[0];
      let p22 = line2[1];
      if (p1[0] > p22[0]) {
        p1 = line2[1];
        p22 = line2[0];
      }
      const alpha = Math.atan((p22[1] - p1[1]) / (p22[0] - p1[0]));
      for (let i4 = 0; i4 < count; i4++) {
        const lstart = i4 * (offset2 + gap);
        const lend = lstart + offset2;
        const start2 = [p1[0] + lstart * Math.cos(alpha) + startOffset * Math.cos(alpha), p1[1] + lstart * Math.sin(alpha) + startOffset * Math.sin(alpha)];
        const end = [p1[0] + lend * Math.cos(alpha) + startOffset * Math.cos(alpha), p1[1] + lend * Math.sin(alpha) + startOffset * Math.sin(alpha)];
        ops.push(...this.helper.doubleLineOps(start2[0], start2[1], end[0], end[1], o4));
      }
    });
    return ops;
  }
};

// ../../node_modules/roughjs/bin/fillers/zigzag-line-filler.js
init_define_import_meta_env();
var ZigZagLineFiller = class {
  constructor(helper2) {
    this.helper = helper2;
  }
  fillPolygons(polygonList, o4) {
    const gap = o4.hachureGap < 0 ? o4.strokeWidth * 4 : o4.hachureGap;
    const zo = o4.zigzagOffset < 0 ? gap : o4.zigzagOffset;
    o4 = Object.assign({}, o4, { hachureGap: gap + zo });
    const lines = polygonHachureLines(polygonList, o4);
    return { type: "fillSketch", ops: this.zigzagLines(lines, zo, o4) };
  }
  zigzagLines(lines, zo, o4) {
    const ops = [];
    lines.forEach((line2) => {
      const length = lineLength(line2);
      const count = Math.round(length / (2 * zo));
      let p1 = line2[0];
      let p22 = line2[1];
      if (p1[0] > p22[0]) {
        p1 = line2[1];
        p22 = line2[0];
      }
      const alpha = Math.atan((p22[1] - p1[1]) / (p22[0] - p1[0]));
      for (let i4 = 0; i4 < count; i4++) {
        const lstart = i4 * 2 * zo;
        const lend = (i4 + 1) * 2 * zo;
        const dz = Math.sqrt(2 * Math.pow(zo, 2));
        const start2 = [p1[0] + lstart * Math.cos(alpha), p1[1] + lstart * Math.sin(alpha)];
        const end = [p1[0] + lend * Math.cos(alpha), p1[1] + lend * Math.sin(alpha)];
        const middle = [start2[0] + dz * Math.cos(alpha + Math.PI / 4), start2[1] + dz * Math.sin(alpha + Math.PI / 4)];
        ops.push(...this.helper.doubleLineOps(start2[0], start2[1], middle[0], middle[1], o4), ...this.helper.doubleLineOps(middle[0], middle[1], end[0], end[1], o4));
      }
    });
    return ops;
  }
};

// ../../node_modules/roughjs/bin/fillers/filler.js
var fillers = {};
function getFiller(o4, helper2) {
  let fillerName = o4.fillStyle || "hachure";
  if (!fillers[fillerName]) {
    switch (fillerName) {
      case "zigzag":
        if (!fillers[fillerName]) {
          fillers[fillerName] = new ZigZagFiller(helper2);
        }
        break;
      case "cross-hatch":
        if (!fillers[fillerName]) {
          fillers[fillerName] = new HatchFiller(helper2);
        }
        break;
      case "dots":
        if (!fillers[fillerName]) {
          fillers[fillerName] = new DotFiller(helper2);
        }
        break;
      case "dashed":
        if (!fillers[fillerName]) {
          fillers[fillerName] = new DashedFiller(helper2);
        }
        break;
      case "zigzag-line":
        if (!fillers[fillerName]) {
          fillers[fillerName] = new ZigZagLineFiller(helper2);
        }
        break;
      case "hachure":
      default:
        fillerName = "hachure";
        if (!fillers[fillerName]) {
          fillers[fillerName] = new HachureFiller(helper2);
        }
        break;
    }
  }
  return fillers[fillerName];
}

// ../../node_modules/roughjs/bin/math.js
init_define_import_meta_env();
function randomSeed() {
  return Math.floor(Math.random() * 2 ** 31);
}
var Random = class {
  constructor(seed) {
    this.seed = seed;
  }
  next() {
    if (this.seed) {
      return (2 ** 31 - 1 & (this.seed = Math.imul(48271, this.seed))) / 2 ** 31;
    } else {
      return Math.random();
    }
  }
};

// ../../node_modules/path-data-parser/lib/index.js
init_define_import_meta_env();

// ../../node_modules/path-data-parser/lib/parser.js
init_define_import_meta_env();
var COMMAND = 0;
var NUMBER = 1;
var EOD = 2;
var PARAMS = { A: 7, a: 7, C: 6, c: 6, H: 1, h: 1, L: 2, l: 2, M: 2, m: 2, Q: 4, q: 4, S: 4, s: 4, T: 2, t: 2, V: 1, v: 1, Z: 0, z: 0 };
function tokenize(d3) {
  const tokens = new Array();
  while (d3 !== "") {
    if (d3.match(/^([ \t\r\n,]+)/)) {
      d3 = d3.substr(RegExp.$1.length);
    } else if (d3.match(/^([aAcChHlLmMqQsStTvVzZ])/)) {
      tokens[tokens.length] = { type: COMMAND, text: RegExp.$1 };
      d3 = d3.substr(RegExp.$1.length);
    } else if (d3.match(/^(([-+]?[0-9]+(\.[0-9]*)?|[-+]?\.[0-9]+)([eE][-+]?[0-9]+)?)/)) {
      tokens[tokens.length] = { type: NUMBER, text: `${parseFloat(RegExp.$1)}` };
      d3 = d3.substr(RegExp.$1.length);
    } else {
      return [];
    }
  }
  tokens[tokens.length] = { type: EOD, text: "" };
  return tokens;
}
function isType(token, type) {
  return token.type === type;
}
function parsePath(d3) {
  const segments = [];
  const tokens = tokenize(d3);
  let mode = "BOD";
  let index2 = 0;
  let token = tokens[index2];
  while (!isType(token, EOD)) {
    let paramsCount = 0;
    const params = [];
    if (mode === "BOD") {
      if (token.text === "M" || token.text === "m") {
        index2++;
        paramsCount = PARAMS[token.text];
        mode = token.text;
      } else {
        return parsePath("M0,0" + d3);
      }
    } else if (isType(token, NUMBER)) {
      paramsCount = PARAMS[mode];
    } else {
      index2++;
      paramsCount = PARAMS[token.text];
      mode = token.text;
    }
    if (index2 + paramsCount < tokens.length) {
      for (let i4 = index2; i4 < index2 + paramsCount; i4++) {
        const numbeToken = tokens[i4];
        if (isType(numbeToken, NUMBER)) {
          params[params.length] = +numbeToken.text;
        } else {
          throw new Error("Param not a number: " + mode + "," + numbeToken.text);
        }
      }
      if (typeof PARAMS[mode] === "number") {
        const segment = { key: mode, data: params };
        segments.push(segment);
        index2 += paramsCount;
        token = tokens[index2];
        if (mode === "M")
          mode = "L";
        if (mode === "m")
          mode = "l";
      } else {
        throw new Error("Bad segment: " + mode);
      }
    } else {
      throw new Error("Path data ended short");
    }
  }
  return segments;
}

// ../../node_modules/path-data-parser/lib/absolutize.js
init_define_import_meta_env();
function absolutize(segments) {
  let cx = 0, cy = 0;
  let subx = 0, suby = 0;
  const out = [];
  for (const { key, data } of segments) {
    switch (key) {
      case "M":
        out.push({ key: "M", data: [...data] });
        [cx, cy] = data;
        [subx, suby] = data;
        break;
      case "m":
        cx += data[0];
        cy += data[1];
        out.push({ key: "M", data: [cx, cy] });
        subx = cx;
        suby = cy;
        break;
      case "L":
        out.push({ key: "L", data: [...data] });
        [cx, cy] = data;
        break;
      case "l":
        cx += data[0];
        cy += data[1];
        out.push({ key: "L", data: [cx, cy] });
        break;
      case "C":
        out.push({ key: "C", data: [...data] });
        cx = data[4];
        cy = data[5];
        break;
      case "c": {
        const newdata = data.map((d3, i4) => i4 % 2 ? d3 + cy : d3 + cx);
        out.push({ key: "C", data: newdata });
        cx = newdata[4];
        cy = newdata[5];
        break;
      }
      case "Q":
        out.push({ key: "Q", data: [...data] });
        cx = data[2];
        cy = data[3];
        break;
      case "q": {
        const newdata = data.map((d3, i4) => i4 % 2 ? d3 + cy : d3 + cx);
        out.push({ key: "Q", data: newdata });
        cx = newdata[2];
        cy = newdata[3];
        break;
      }
      case "A":
        out.push({ key: "A", data: [...data] });
        cx = data[5];
        cy = data[6];
        break;
      case "a":
        cx += data[5];
        cy += data[6];
        out.push({ key: "A", data: [data[0], data[1], data[2], data[3], data[4], cx, cy] });
        break;
      case "H":
        out.push({ key: "H", data: [...data] });
        cx = data[0];
        break;
      case "h":
        cx += data[0];
        out.push({ key: "H", data: [cx] });
        break;
      case "V":
        out.push({ key: "V", data: [...data] });
        cy = data[0];
        break;
      case "v":
        cy += data[0];
        out.push({ key: "V", data: [cy] });
        break;
      case "S":
        out.push({ key: "S", data: [...data] });
        cx = data[2];
        cy = data[3];
        break;
      case "s": {
        const newdata = data.map((d3, i4) => i4 % 2 ? d3 + cy : d3 + cx);
        out.push({ key: "S", data: newdata });
        cx = newdata[2];
        cy = newdata[3];
        break;
      }
      case "T":
        out.push({ key: "T", data: [...data] });
        cx = data[0];
        cy = data[1];
        break;
      case "t":
        cx += data[0];
        cy += data[1];
        out.push({ key: "T", data: [cx, cy] });
        break;
      case "Z":
      case "z":
        out.push({ key: "Z", data: [] });
        cx = subx;
        cy = suby;
        break;
    }
  }
  return out;
}

// ../../node_modules/path-data-parser/lib/normalize.js
init_define_import_meta_env();
function normalize(segments) {
  const out = [];
  let lastType = "";
  let cx = 0, cy = 0;
  let subx = 0, suby = 0;
  let lcx = 0, lcy = 0;
  for (const { key, data } of segments) {
    switch (key) {
      case "M":
        out.push({ key: "M", data: [...data] });
        [cx, cy] = data;
        [subx, suby] = data;
        break;
      case "C":
        out.push({ key: "C", data: [...data] });
        cx = data[4];
        cy = data[5];
        lcx = data[2];
        lcy = data[3];
        break;
      case "L":
        out.push({ key: "L", data: [...data] });
        [cx, cy] = data;
        break;
      case "H":
        cx = data[0];
        out.push({ key: "L", data: [cx, cy] });
        break;
      case "V":
        cy = data[0];
        out.push({ key: "L", data: [cx, cy] });
        break;
      case "S": {
        let cx1 = 0, cy1 = 0;
        if (lastType === "C" || lastType === "S") {
          cx1 = cx + (cx - lcx);
          cy1 = cy + (cy - lcy);
        } else {
          cx1 = cx;
          cy1 = cy;
        }
        out.push({ key: "C", data: [cx1, cy1, ...data] });
        lcx = data[0];
        lcy = data[1];
        cx = data[2];
        cy = data[3];
        break;
      }
      case "T": {
        const [x3, y3] = data;
        let x1 = 0, y1 = 0;
        if (lastType === "Q" || lastType === "T") {
          x1 = cx + (cx - lcx);
          y1 = cy + (cy - lcy);
        } else {
          x1 = cx;
          y1 = cy;
        }
        const cx1 = cx + 2 * (x1 - cx) / 3;
        const cy1 = cy + 2 * (y1 - cy) / 3;
        const cx2 = x3 + 2 * (x1 - x3) / 3;
        const cy2 = y3 + 2 * (y1 - y3) / 3;
        out.push({ key: "C", data: [cx1, cy1, cx2, cy2, x3, y3] });
        lcx = x1;
        lcy = y1;
        cx = x3;
        cy = y3;
        break;
      }
      case "Q": {
        const [x1, y1, x3, y3] = data;
        const cx1 = cx + 2 * (x1 - cx) / 3;
        const cy1 = cy + 2 * (y1 - cy) / 3;
        const cx2 = x3 + 2 * (x1 - x3) / 3;
        const cy2 = y3 + 2 * (y1 - y3) / 3;
        out.push({ key: "C", data: [cx1, cy1, cx2, cy2, x3, y3] });
        lcx = x1;
        lcy = y1;
        cx = x3;
        cy = y3;
        break;
      }
      case "A": {
        const r1 = Math.abs(data[0]);
        const r22 = Math.abs(data[1]);
        const angle = data[2];
        const largeArcFlag = data[3];
        const sweepFlag = data[4];
        const x3 = data[5];
        const y3 = data[6];
        if (r1 === 0 || r22 === 0) {
          out.push({ key: "C", data: [cx, cy, x3, y3, x3, y3] });
          cx = x3;
          cy = y3;
        } else {
          if (cx !== x3 || cy !== y3) {
            const curves = arcToCubicCurves(cx, cy, x3, y3, r1, r22, angle, largeArcFlag, sweepFlag);
            curves.forEach(function(curve2) {
              out.push({ key: "C", data: curve2 });
            });
            cx = x3;
            cy = y3;
          }
        }
        break;
      }
      case "Z":
        out.push({ key: "Z", data: [] });
        cx = subx;
        cy = suby;
        break;
    }
    lastType = key;
  }
  return out;
}
function degToRad(degrees) {
  return Math.PI * degrees / 180;
}
function rotate(x3, y3, angleRad) {
  const X = x3 * Math.cos(angleRad) - y3 * Math.sin(angleRad);
  const Y = x3 * Math.sin(angleRad) + y3 * Math.cos(angleRad);
  return [X, Y];
}
function arcToCubicCurves(x1, y1, x22, y22, r1, r22, angle, largeArcFlag, sweepFlag, recursive) {
  const angleRad = degToRad(angle);
  let params = [];
  let f1 = 0, f22 = 0, cx = 0, cy = 0;
  if (recursive) {
    [f1, f22, cx, cy] = recursive;
  } else {
    [x1, y1] = rotate(x1, y1, -angleRad);
    [x22, y22] = rotate(x22, y22, -angleRad);
    const x3 = (x1 - x22) / 2;
    const y3 = (y1 - y22) / 2;
    let h3 = x3 * x3 / (r1 * r1) + y3 * y3 / (r22 * r22);
    if (h3 > 1) {
      h3 = Math.sqrt(h3);
      r1 = h3 * r1;
      r22 = h3 * r22;
    }
    const sign2 = largeArcFlag === sweepFlag ? -1 : 1;
    const r1Pow = r1 * r1;
    const r2Pow = r22 * r22;
    const left = r1Pow * r2Pow - r1Pow * y3 * y3 - r2Pow * x3 * x3;
    const right = r1Pow * y3 * y3 + r2Pow * x3 * x3;
    const k2 = sign2 * Math.sqrt(Math.abs(left / right));
    cx = k2 * r1 * y3 / r22 + (x1 + x22) / 2;
    cy = k2 * -r22 * x3 / r1 + (y1 + y22) / 2;
    f1 = Math.asin(parseFloat(((y1 - cy) / r22).toFixed(9)));
    f22 = Math.asin(parseFloat(((y22 - cy) / r22).toFixed(9)));
    if (x1 < cx) {
      f1 = Math.PI - f1;
    }
    if (x22 < cx) {
      f22 = Math.PI - f22;
    }
    if (f1 < 0) {
      f1 = Math.PI * 2 + f1;
    }
    if (f22 < 0) {
      f22 = Math.PI * 2 + f22;
    }
    if (sweepFlag && f1 > f22) {
      f1 = f1 - Math.PI * 2;
    }
    if (!sweepFlag && f22 > f1) {
      f22 = f22 - Math.PI * 2;
    }
  }
  let df = f22 - f1;
  if (Math.abs(df) > Math.PI * 120 / 180) {
    const f2old = f22;
    const x2old = x22;
    const y2old = y22;
    if (sweepFlag && f22 > f1) {
      f22 = f1 + Math.PI * 120 / 180 * 1;
    } else {
      f22 = f1 + Math.PI * 120 / 180 * -1;
    }
    x22 = cx + r1 * Math.cos(f22);
    y22 = cy + r22 * Math.sin(f22);
    params = arcToCubicCurves(x22, y22, x2old, y2old, r1, r22, angle, 0, sweepFlag, [f22, f2old, cx, cy]);
  }
  df = f22 - f1;
  const c1 = Math.cos(f1);
  const s1 = Math.sin(f1);
  const c22 = Math.cos(f22);
  const s22 = Math.sin(f22);
  const t4 = Math.tan(df / 4);
  const hx = 4 / 3 * r1 * t4;
  const hy = 4 / 3 * r22 * t4;
  const m1 = [x1, y1];
  const m22 = [x1 + hx * s1, y1 - hy * c1];
  const m3 = [x22 + hx * s22, y22 - hy * c22];
  const m4 = [x22, y22];
  m22[0] = 2 * m1[0] - m22[0];
  m22[1] = 2 * m1[1] - m22[1];
  if (recursive) {
    return [m22, m3, m4].concat(params);
  } else {
    params = [m22, m3, m4].concat(params);
    const curves = [];
    for (let i4 = 0; i4 < params.length; i4 += 3) {
      const r12 = rotate(params[i4][0], params[i4][1], angleRad);
      const r23 = rotate(params[i4 + 1][0], params[i4 + 1][1], angleRad);
      const r3 = rotate(params[i4 + 2][0], params[i4 + 2][1], angleRad);
      curves.push([r12[0], r12[1], r23[0], r23[1], r3[0], r3[1]]);
    }
    return curves;
  }
}

// ../../node_modules/roughjs/bin/renderer.js
var helper = {
  randOffset,
  randOffsetWithRange,
  ellipse,
  doubleLineOps: doubleLineFillOps
};
function line(x1, y1, x22, y22, o4) {
  return { type: "path", ops: _doubleLine(x1, y1, x22, y22, o4) };
}
function linearPath(points, close, o4) {
  const len = (points || []).length;
  if (len > 2) {
    const ops = [];
    for (let i4 = 0; i4 < len - 1; i4++) {
      ops.push(..._doubleLine(points[i4][0], points[i4][1], points[i4 + 1][0], points[i4 + 1][1], o4));
    }
    if (close) {
      ops.push(..._doubleLine(points[len - 1][0], points[len - 1][1], points[0][0], points[0][1], o4));
    }
    return { type: "path", ops };
  } else if (len === 2) {
    return line(points[0][0], points[0][1], points[1][0], points[1][1], o4);
  }
  return { type: "path", ops: [] };
}
function polygon(points, o4) {
  return linearPath(points, true, o4);
}
function rectangle(x3, y3, width, height, o4) {
  const points = [
    [x3, y3],
    [x3 + width, y3],
    [x3 + width, y3 + height],
    [x3, y3 + height]
  ];
  return polygon(points, o4);
}
function curve(points, o4) {
  let o1 = _curveWithOffset(points, 1 * (1 + o4.roughness * 0.2), o4);
  if (!o4.disableMultiStroke) {
    const o22 = _curveWithOffset(points, 1.5 * (1 + o4.roughness * 0.22), cloneOptionsAlterSeed(o4));
    o1 = o1.concat(o22);
  }
  return { type: "path", ops: o1 };
}
function ellipse(x3, y3, width, height, o4) {
  const params = generateEllipseParams(width, height, o4);
  return ellipseWithParams(x3, y3, o4, params).opset;
}
function generateEllipseParams(width, height, o4) {
  const psq = Math.sqrt(Math.PI * 2 * Math.sqrt((Math.pow(width / 2, 2) + Math.pow(height / 2, 2)) / 2));
  const stepCount = Math.ceil(Math.max(o4.curveStepCount, o4.curveStepCount / Math.sqrt(200) * psq));
  const increment = Math.PI * 2 / stepCount;
  let rx = Math.abs(width / 2);
  let ry = Math.abs(height / 2);
  const curveFitRandomness = 1 - o4.curveFitting;
  rx += _offsetOpt(rx * curveFitRandomness, o4);
  ry += _offsetOpt(ry * curveFitRandomness, o4);
  return { increment, rx, ry };
}
function ellipseWithParams(x3, y3, o4, ellipseParams) {
  const [ap1, cp1] = _computeEllipsePoints(ellipseParams.increment, x3, y3, ellipseParams.rx, ellipseParams.ry, 1, ellipseParams.increment * _offset(0.1, _offset(0.4, 1, o4), o4), o4);
  let o1 = _curve(ap1, null, o4);
  if (!o4.disableMultiStroke && o4.roughness !== 0) {
    const [ap2] = _computeEllipsePoints(ellipseParams.increment, x3, y3, ellipseParams.rx, ellipseParams.ry, 1.5, 0, o4);
    const o22 = _curve(ap2, null, o4);
    o1 = o1.concat(o22);
  }
  return {
    estimatedPoints: cp1,
    opset: { type: "path", ops: o1 }
  };
}
function arc(x3, y3, width, height, start2, stop2, closed, roughClosure, o4) {
  const cx = x3;
  const cy = y3;
  let rx = Math.abs(width / 2);
  let ry = Math.abs(height / 2);
  rx += _offsetOpt(rx * 0.01, o4);
  ry += _offsetOpt(ry * 0.01, o4);
  let strt = start2;
  let stp = stop2;
  while (strt < 0) {
    strt += Math.PI * 2;
    stp += Math.PI * 2;
  }
  if (stp - strt > Math.PI * 2) {
    strt = 0;
    stp = Math.PI * 2;
  }
  const ellipseInc = Math.PI * 2 / o4.curveStepCount;
  const arcInc = Math.min(ellipseInc / 2, (stp - strt) / 2);
  const ops = _arc(arcInc, cx, cy, rx, ry, strt, stp, 1, o4);
  if (!o4.disableMultiStroke) {
    const o22 = _arc(arcInc, cx, cy, rx, ry, strt, stp, 1.5, o4);
    ops.push(...o22);
  }
  if (closed) {
    if (roughClosure) {
      ops.push(..._doubleLine(cx, cy, cx + rx * Math.cos(strt), cy + ry * Math.sin(strt), o4), ..._doubleLine(cx, cy, cx + rx * Math.cos(stp), cy + ry * Math.sin(stp), o4));
    } else {
      ops.push({ op: "lineTo", data: [cx, cy] }, { op: "lineTo", data: [cx + rx * Math.cos(strt), cy + ry * Math.sin(strt)] });
    }
  }
  return { type: "path", ops };
}
function svgPath(path, o4) {
  const segments = normalize(absolutize(parsePath(path)));
  const ops = [];
  let first = [0, 0];
  let current = [0, 0];
  for (const { key, data } of segments) {
    switch (key) {
      case "M": {
        current = [data[0], data[1]];
        first = [data[0], data[1]];
        break;
      }
      case "L":
        ops.push(..._doubleLine(current[0], current[1], data[0], data[1], o4));
        current = [data[0], data[1]];
        break;
      case "C": {
        const [x1, y1, x22, y22, x3, y3] = data;
        ops.push(..._bezierTo(x1, y1, x22, y22, x3, y3, current, o4));
        current = [x3, y3];
        break;
      }
      case "Z":
        ops.push(..._doubleLine(current[0], current[1], first[0], first[1], o4));
        current = [first[0], first[1]];
        break;
    }
  }
  return { type: "path", ops };
}
function solidFillPolygon(polygonList, o4) {
  const ops = [];
  for (const points of polygonList) {
    if (points.length) {
      const offset2 = o4.maxRandomnessOffset || 0;
      const len = points.length;
      if (len > 2) {
        ops.push({ op: "move", data: [points[0][0] + _offsetOpt(offset2, o4), points[0][1] + _offsetOpt(offset2, o4)] });
        for (let i4 = 1; i4 < len; i4++) {
          ops.push({ op: "lineTo", data: [points[i4][0] + _offsetOpt(offset2, o4), points[i4][1] + _offsetOpt(offset2, o4)] });
        }
      }
    }
  }
  return { type: "fillPath", ops };
}
function patternFillPolygons(polygonList, o4) {
  return getFiller(o4, helper).fillPolygons(polygonList, o4);
}
function patternFillArc(x3, y3, width, height, start2, stop2, o4) {
  const cx = x3;
  const cy = y3;
  let rx = Math.abs(width / 2);
  let ry = Math.abs(height / 2);
  rx += _offsetOpt(rx * 0.01, o4);
  ry += _offsetOpt(ry * 0.01, o4);
  let strt = start2;
  let stp = stop2;
  while (strt < 0) {
    strt += Math.PI * 2;
    stp += Math.PI * 2;
  }
  if (stp - strt > Math.PI * 2) {
    strt = 0;
    stp = Math.PI * 2;
  }
  const increment = (stp - strt) / o4.curveStepCount;
  const points = [];
  for (let angle = strt; angle <= stp; angle = angle + increment) {
    points.push([cx + rx * Math.cos(angle), cy + ry * Math.sin(angle)]);
  }
  points.push([cx + rx * Math.cos(stp), cy + ry * Math.sin(stp)]);
  points.push([cx, cy]);
  return patternFillPolygons([points], o4);
}
function randOffset(x3, o4) {
  return _offsetOpt(x3, o4);
}
function randOffsetWithRange(min, max, o4) {
  return _offset(min, max, o4);
}
function doubleLineFillOps(x1, y1, x22, y22, o4) {
  return _doubleLine(x1, y1, x22, y22, o4, true);
}
function cloneOptionsAlterSeed(ops) {
  const result = Object.assign({}, ops);
  result.randomizer = void 0;
  if (ops.seed) {
    result.seed = ops.seed + 1;
  }
  return result;
}
function random(ops) {
  if (!ops.randomizer) {
    ops.randomizer = new Random(ops.seed || 0);
  }
  return ops.randomizer.next();
}
function _offset(min, max, ops, roughnessGain = 1) {
  return ops.roughness * roughnessGain * (random(ops) * (max - min) + min);
}
function _offsetOpt(x3, ops, roughnessGain = 1) {
  return _offset(-x3, x3, ops, roughnessGain);
}
function _doubleLine(x1, y1, x22, y22, o4, filling = false) {
  const singleStroke = filling ? o4.disableMultiStrokeFill : o4.disableMultiStroke;
  const o1 = _line(x1, y1, x22, y22, o4, true, false);
  if (singleStroke) {
    return o1;
  }
  const o22 = _line(x1, y1, x22, y22, o4, true, true);
  return o1.concat(o22);
}
function _line(x1, y1, x22, y22, o4, move, overlay) {
  const lengthSq = Math.pow(x1 - x22, 2) + Math.pow(y1 - y22, 2);
  const length = Math.sqrt(lengthSq);
  let roughnessGain = 1;
  if (length < 200) {
    roughnessGain = 1;
  } else if (length > 500) {
    roughnessGain = 0.4;
  } else {
    roughnessGain = -16668e-7 * length + 1.233334;
  }
  let offset2 = o4.maxRandomnessOffset || 0;
  if (offset2 * offset2 * 100 > lengthSq) {
    offset2 = length / 10;
  }
  const halfOffset = offset2 / 2;
  const divergePoint = 0.2 + random(o4) * 0.2;
  let midDispX = o4.bowing * o4.maxRandomnessOffset * (y22 - y1) / 200;
  let midDispY = o4.bowing * o4.maxRandomnessOffset * (x1 - x22) / 200;
  midDispX = _offsetOpt(midDispX, o4, roughnessGain);
  midDispY = _offsetOpt(midDispY, o4, roughnessGain);
  const ops = [];
  const randomHalf = () => _offsetOpt(halfOffset, o4, roughnessGain);
  const randomFull = () => _offsetOpt(offset2, o4, roughnessGain);
  const preserveVertices = o4.preserveVertices;
  if (move) {
    if (overlay) {
      ops.push({
        op: "move",
        data: [
          x1 + (preserveVertices ? 0 : randomHalf()),
          y1 + (preserveVertices ? 0 : randomHalf())
        ]
      });
    } else {
      ops.push({
        op: "move",
        data: [
          x1 + (preserveVertices ? 0 : _offsetOpt(offset2, o4, roughnessGain)),
          y1 + (preserveVertices ? 0 : _offsetOpt(offset2, o4, roughnessGain))
        ]
      });
    }
  }
  if (overlay) {
    ops.push({
      op: "bcurveTo",
      data: [
        midDispX + x1 + (x22 - x1) * divergePoint + randomHalf(),
        midDispY + y1 + (y22 - y1) * divergePoint + randomHalf(),
        midDispX + x1 + 2 * (x22 - x1) * divergePoint + randomHalf(),
        midDispY + y1 + 2 * (y22 - y1) * divergePoint + randomHalf(),
        x22 + (preserveVertices ? 0 : randomHalf()),
        y22 + (preserveVertices ? 0 : randomHalf())
      ]
    });
  } else {
    ops.push({
      op: "bcurveTo",
      data: [
        midDispX + x1 + (x22 - x1) * divergePoint + randomFull(),
        midDispY + y1 + (y22 - y1) * divergePoint + randomFull(),
        midDispX + x1 + 2 * (x22 - x1) * divergePoint + randomFull(),
        midDispY + y1 + 2 * (y22 - y1) * divergePoint + randomFull(),
        x22 + (preserveVertices ? 0 : randomFull()),
        y22 + (preserveVertices ? 0 : randomFull())
      ]
    });
  }
  return ops;
}
function _curveWithOffset(points, offset2, o4) {
  const ps = [];
  ps.push([
    points[0][0] + _offsetOpt(offset2, o4),
    points[0][1] + _offsetOpt(offset2, o4)
  ]);
  ps.push([
    points[0][0] + _offsetOpt(offset2, o4),
    points[0][1] + _offsetOpt(offset2, o4)
  ]);
  for (let i4 = 1; i4 < points.length; i4++) {
    ps.push([
      points[i4][0] + _offsetOpt(offset2, o4),
      points[i4][1] + _offsetOpt(offset2, o4)
    ]);
    if (i4 === points.length - 1) {
      ps.push([
        points[i4][0] + _offsetOpt(offset2, o4),
        points[i4][1] + _offsetOpt(offset2, o4)
      ]);
    }
  }
  return _curve(ps, null, o4);
}
function _curve(points, closePoint, o4) {
  const len = points.length;
  const ops = [];
  if (len > 3) {
    const b4 = [];
    const s4 = 1 - o4.curveTightness;
    ops.push({ op: "move", data: [points[1][0], points[1][1]] });
    for (let i4 = 1; i4 + 2 < len; i4++) {
      const cachedVertArray = points[i4];
      b4[0] = [cachedVertArray[0], cachedVertArray[1]];
      b4[1] = [cachedVertArray[0] + (s4 * points[i4 + 1][0] - s4 * points[i4 - 1][0]) / 6, cachedVertArray[1] + (s4 * points[i4 + 1][1] - s4 * points[i4 - 1][1]) / 6];
      b4[2] = [points[i4 + 1][0] + (s4 * points[i4][0] - s4 * points[i4 + 2][0]) / 6, points[i4 + 1][1] + (s4 * points[i4][1] - s4 * points[i4 + 2][1]) / 6];
      b4[3] = [points[i4 + 1][0], points[i4 + 1][1]];
      ops.push({ op: "bcurveTo", data: [b4[1][0], b4[1][1], b4[2][0], b4[2][1], b4[3][0], b4[3][1]] });
    }
    if (closePoint && closePoint.length === 2) {
      const ro = o4.maxRandomnessOffset;
      ops.push({ op: "lineTo", data: [closePoint[0] + _offsetOpt(ro, o4), closePoint[1] + _offsetOpt(ro, o4)] });
    }
  } else if (len === 3) {
    ops.push({ op: "move", data: [points[1][0], points[1][1]] });
    ops.push({
      op: "bcurveTo",
      data: [
        points[1][0],
        points[1][1],
        points[2][0],
        points[2][1],
        points[2][0],
        points[2][1]
      ]
    });
  } else if (len === 2) {
    ops.push(..._doubleLine(points[0][0], points[0][1], points[1][0], points[1][1], o4));
  }
  return ops;
}
function _computeEllipsePoints(increment, cx, cy, rx, ry, offset2, overlap, o4) {
  const coreOnly = o4.roughness === 0;
  const corePoints = [];
  const allPoints = [];
  if (coreOnly) {
    increment = increment / 4;
    allPoints.push([
      cx + rx * Math.cos(-increment),
      cy + ry * Math.sin(-increment)
    ]);
    for (let angle = 0; angle <= Math.PI * 2; angle = angle + increment) {
      const p3 = [
        cx + rx * Math.cos(angle),
        cy + ry * Math.sin(angle)
      ];
      corePoints.push(p3);
      allPoints.push(p3);
    }
    allPoints.push([
      cx + rx * Math.cos(0),
      cy + ry * Math.sin(0)
    ]);
    allPoints.push([
      cx + rx * Math.cos(increment),
      cy + ry * Math.sin(increment)
    ]);
  } else {
    const radOffset = _offsetOpt(0.5, o4) - Math.PI / 2;
    allPoints.push([
      _offsetOpt(offset2, o4) + cx + 0.9 * rx * Math.cos(radOffset - increment),
      _offsetOpt(offset2, o4) + cy + 0.9 * ry * Math.sin(radOffset - increment)
    ]);
    const endAngle = Math.PI * 2 + radOffset - 0.01;
    for (let angle = radOffset; angle < endAngle; angle = angle + increment) {
      const p3 = [
        _offsetOpt(offset2, o4) + cx + rx * Math.cos(angle),
        _offsetOpt(offset2, o4) + cy + ry * Math.sin(angle)
      ];
      corePoints.push(p3);
      allPoints.push(p3);
    }
    allPoints.push([
      _offsetOpt(offset2, o4) + cx + rx * Math.cos(radOffset + Math.PI * 2 + overlap * 0.5),
      _offsetOpt(offset2, o4) + cy + ry * Math.sin(radOffset + Math.PI * 2 + overlap * 0.5)
    ]);
    allPoints.push([
      _offsetOpt(offset2, o4) + cx + 0.98 * rx * Math.cos(radOffset + overlap),
      _offsetOpt(offset2, o4) + cy + 0.98 * ry * Math.sin(radOffset + overlap)
    ]);
    allPoints.push([
      _offsetOpt(offset2, o4) + cx + 0.9 * rx * Math.cos(radOffset + overlap * 0.5),
      _offsetOpt(offset2, o4) + cy + 0.9 * ry * Math.sin(radOffset + overlap * 0.5)
    ]);
  }
  return [allPoints, corePoints];
}
function _arc(increment, cx, cy, rx, ry, strt, stp, offset2, o4) {
  const radOffset = strt + _offsetOpt(0.1, o4);
  const points = [];
  points.push([
    _offsetOpt(offset2, o4) + cx + 0.9 * rx * Math.cos(radOffset - increment),
    _offsetOpt(offset2, o4) + cy + 0.9 * ry * Math.sin(radOffset - increment)
  ]);
  for (let angle = radOffset; angle <= stp; angle = angle + increment) {
    points.push([
      _offsetOpt(offset2, o4) + cx + rx * Math.cos(angle),
      _offsetOpt(offset2, o4) + cy + ry * Math.sin(angle)
    ]);
  }
  points.push([
    cx + rx * Math.cos(stp),
    cy + ry * Math.sin(stp)
  ]);
  points.push([
    cx + rx * Math.cos(stp),
    cy + ry * Math.sin(stp)
  ]);
  return _curve(points, null, o4);
}
function _bezierTo(x1, y1, x22, y22, x3, y3, current, o4) {
  const ops = [];
  const ros = [o4.maxRandomnessOffset || 1, (o4.maxRandomnessOffset || 1) + 0.3];
  let f3 = [0, 0];
  const iterations = o4.disableMultiStroke ? 1 : 2;
  const preserveVertices = o4.preserveVertices;
  for (let i4 = 0; i4 < iterations; i4++) {
    if (i4 === 0) {
      ops.push({ op: "move", data: [current[0], current[1]] });
    } else {
      ops.push({ op: "move", data: [current[0] + (preserveVertices ? 0 : _offsetOpt(ros[0], o4)), current[1] + (preserveVertices ? 0 : _offsetOpt(ros[0], o4))] });
    }
    f3 = preserveVertices ? [x3, y3] : [x3 + _offsetOpt(ros[i4], o4), y3 + _offsetOpt(ros[i4], o4)];
    ops.push({
      op: "bcurveTo",
      data: [
        x1 + _offsetOpt(ros[i4], o4),
        y1 + _offsetOpt(ros[i4], o4),
        x22 + _offsetOpt(ros[i4], o4),
        y22 + _offsetOpt(ros[i4], o4),
        f3[0],
        f3[1]
      ]
    });
  }
  return ops;
}

// ../../node_modules/points-on-curve/lib/curve-to-bezier.js
init_define_import_meta_env();
function clone(p3) {
  return [...p3];
}
function curveToBezier(pointsIn, curveTightness = 0) {
  const len = pointsIn.length;
  if (len < 3) {
    throw new Error("A curve must have at least three points.");
  }
  const out = [];
  if (len === 3) {
    out.push(clone(pointsIn[0]), clone(pointsIn[1]), clone(pointsIn[2]), clone(pointsIn[2]));
  } else {
    const points = [];
    points.push(pointsIn[0], pointsIn[0]);
    for (let i4 = 1; i4 < pointsIn.length; i4++) {
      points.push(pointsIn[i4]);
      if (i4 === pointsIn.length - 1) {
        points.push(pointsIn[i4]);
      }
    }
    const b4 = [];
    const s4 = 1 - curveTightness;
    out.push(clone(points[0]));
    for (let i4 = 1; i4 + 2 < points.length; i4++) {
      const cachedVertArray = points[i4];
      b4[0] = [cachedVertArray[0], cachedVertArray[1]];
      b4[1] = [cachedVertArray[0] + (s4 * points[i4 + 1][0] - s4 * points[i4 - 1][0]) / 6, cachedVertArray[1] + (s4 * points[i4 + 1][1] - s4 * points[i4 - 1][1]) / 6];
      b4[2] = [points[i4 + 1][0] + (s4 * points[i4][0] - s4 * points[i4 + 2][0]) / 6, points[i4 + 1][1] + (s4 * points[i4][1] - s4 * points[i4 + 2][1]) / 6];
      b4[3] = [points[i4 + 1][0], points[i4 + 1][1]];
      out.push(b4[1], b4[2], b4[3]);
    }
  }
  return out;
}

// ../../node_modules/points-on-curve/lib/index.js
init_define_import_meta_env();
function distance2(p1, p22) {
  return Math.sqrt(distanceSq(p1, p22));
}
function distanceSq(p1, p22) {
  return Math.pow(p1[0] - p22[0], 2) + Math.pow(p1[1] - p22[1], 2);
}
function distanceToSegmentSq(p3, v3, w3) {
  const l22 = distanceSq(v3, w3);
  if (l22 === 0) {
    return distanceSq(p3, v3);
  }
  let t4 = ((p3[0] - v3[0]) * (w3[0] - v3[0]) + (p3[1] - v3[1]) * (w3[1] - v3[1])) / l22;
  t4 = Math.max(0, Math.min(1, t4));
  return distanceSq(p3, lerp(v3, w3, t4));
}
function lerp(a4, b4, t4) {
  return [
    a4[0] + (b4[0] - a4[0]) * t4,
    a4[1] + (b4[1] - a4[1]) * t4
  ];
}
function flatness(points, offset2) {
  const p1 = points[offset2 + 0];
  const p22 = points[offset2 + 1];
  const p3 = points[offset2 + 2];
  const p4 = points[offset2 + 3];
  let ux = 3 * p22[0] - 2 * p1[0] - p4[0];
  ux *= ux;
  let uy = 3 * p22[1] - 2 * p1[1] - p4[1];
  uy *= uy;
  let vx = 3 * p3[0] - 2 * p4[0] - p1[0];
  vx *= vx;
  let vy = 3 * p3[1] - 2 * p4[1] - p1[1];
  vy *= vy;
  if (ux < vx) {
    ux = vx;
  }
  if (uy < vy) {
    uy = vy;
  }
  return ux + uy;
}
function getPointsOnBezierCurveWithSplitting(points, offset2, tolerance, newPoints) {
  const outPoints = newPoints || [];
  if (flatness(points, offset2) < tolerance) {
    const p0 = points[offset2 + 0];
    if (outPoints.length) {
      const d3 = distance2(outPoints[outPoints.length - 1], p0);
      if (d3 > 1) {
        outPoints.push(p0);
      }
    } else {
      outPoints.push(p0);
    }
    outPoints.push(points[offset2 + 3]);
  } else {
    const t4 = 0.5;
    const p1 = points[offset2 + 0];
    const p22 = points[offset2 + 1];
    const p3 = points[offset2 + 2];
    const p4 = points[offset2 + 3];
    const q1 = lerp(p1, p22, t4);
    const q2 = lerp(p22, p3, t4);
    const q3 = lerp(p3, p4, t4);
    const r1 = lerp(q1, q2, t4);
    const r22 = lerp(q2, q3, t4);
    const red = lerp(r1, r22, t4);
    getPointsOnBezierCurveWithSplitting([p1, q1, r1, red], 0, tolerance, outPoints);
    getPointsOnBezierCurveWithSplitting([red, r22, q3, p4], 0, tolerance, outPoints);
  }
  return outPoints;
}
function simplify(points, distance5) {
  return simplifyPoints(points, 0, points.length, distance5);
}
function simplifyPoints(points, start2, end, epsilon, newPoints) {
  const outPoints = newPoints || [];
  const s4 = points[start2];
  const e3 = points[end - 1];
  let maxDistSq = 0;
  let maxNdx = 1;
  for (let i4 = start2 + 1; i4 < end - 1; ++i4) {
    const distSq = distanceToSegmentSq(points[i4], s4, e3);
    if (distSq > maxDistSq) {
      maxDistSq = distSq;
      maxNdx = i4;
    }
  }
  if (Math.sqrt(maxDistSq) > epsilon) {
    simplifyPoints(points, start2, maxNdx + 1, epsilon, outPoints);
    simplifyPoints(points, maxNdx, end, epsilon, outPoints);
  } else {
    if (!outPoints.length) {
      outPoints.push(s4);
    }
    outPoints.push(e3);
  }
  return outPoints;
}
function pointsOnBezierCurves(points, tolerance = 0.15, distance5) {
  const newPoints = [];
  const numSegments = (points.length - 1) / 3;
  for (let i4 = 0; i4 < numSegments; i4++) {
    const offset2 = i4 * 3;
    getPointsOnBezierCurveWithSplitting(points, offset2, tolerance, newPoints);
  }
  if (distance5 && distance5 > 0) {
    return simplifyPoints(newPoints, 0, newPoints.length, distance5);
  }
  return newPoints;
}

// ../../node_modules/points-on-path/lib/index.js
init_define_import_meta_env();
function pointsOnPath(path, tolerance, distance5) {
  const segments = parsePath(path);
  const normalized2 = normalize(absolutize(segments));
  const sets = [];
  let currentPoints = [];
  let start2 = [0, 0];
  let pendingCurve = [];
  const appendPendingCurve = () => {
    if (pendingCurve.length >= 4) {
      currentPoints.push(...pointsOnBezierCurves(pendingCurve, tolerance));
    }
    pendingCurve = [];
  };
  const appendPendingPoints = () => {
    appendPendingCurve();
    if (currentPoints.length) {
      sets.push(currentPoints);
      currentPoints = [];
    }
  };
  for (const { key, data } of normalized2) {
    switch (key) {
      case "M":
        appendPendingPoints();
        start2 = [data[0], data[1]];
        currentPoints.push(start2);
        break;
      case "L":
        appendPendingCurve();
        currentPoints.push([data[0], data[1]]);
        break;
      case "C":
        if (!pendingCurve.length) {
          const lastPoint = currentPoints.length ? currentPoints[currentPoints.length - 1] : start2;
          pendingCurve.push([lastPoint[0], lastPoint[1]]);
        }
        pendingCurve.push([data[0], data[1]]);
        pendingCurve.push([data[2], data[3]]);
        pendingCurve.push([data[4], data[5]]);
        break;
      case "Z":
        appendPendingCurve();
        currentPoints.push([start2[0], start2[1]]);
        break;
    }
  }
  appendPendingPoints();
  if (!distance5) {
    return sets;
  }
  const out = [];
  for (const set of sets) {
    const simplifiedSet = simplify(set, distance5);
    if (simplifiedSet.length) {
      out.push(simplifiedSet);
    }
  }
  return out;
}

// ../../node_modules/roughjs/bin/generator.js
var NOS = "none";
var RoughGenerator = class {
  constructor(config) {
    this.defaultOptions = {
      maxRandomnessOffset: 2,
      roughness: 1,
      bowing: 1,
      stroke: "#000",
      strokeWidth: 1,
      curveTightness: 0,
      curveFitting: 0.95,
      curveStepCount: 9,
      fillStyle: "hachure",
      fillWeight: -1,
      hachureAngle: -41,
      hachureGap: -1,
      dashOffset: -1,
      dashGap: -1,
      zigzagOffset: -1,
      seed: 0,
      disableMultiStroke: false,
      disableMultiStrokeFill: false,
      preserveVertices: false,
      fillShapeRoughnessGain: 0.8
    };
    this.config = config || {};
    if (this.config.options) {
      this.defaultOptions = this._o(this.config.options);
    }
  }
  static newSeed() {
    return randomSeed();
  }
  _o(options) {
    return options ? Object.assign({}, this.defaultOptions, options) : this.defaultOptions;
  }
  _d(shape, sets, options) {
    return { shape, sets: sets || [], options: options || this.defaultOptions };
  }
  line(x1, y1, x22, y22, options) {
    const o4 = this._o(options);
    return this._d("line", [line(x1, y1, x22, y22, o4)], o4);
  }
  rectangle(x3, y3, width, height, options) {
    const o4 = this._o(options);
    const paths = [];
    const outline = rectangle(x3, y3, width, height, o4);
    if (o4.fill) {
      const points = [[x3, y3], [x3 + width, y3], [x3 + width, y3 + height], [x3, y3 + height]];
      if (o4.fillStyle === "solid") {
        paths.push(solidFillPolygon([points], o4));
      } else {
        paths.push(patternFillPolygons([points], o4));
      }
    }
    if (o4.stroke !== NOS) {
      paths.push(outline);
    }
    return this._d("rectangle", paths, o4);
  }
  ellipse(x3, y3, width, height, options) {
    const o4 = this._o(options);
    const paths = [];
    const ellipseParams = generateEllipseParams(width, height, o4);
    const ellipseResponse = ellipseWithParams(x3, y3, o4, ellipseParams);
    if (o4.fill) {
      if (o4.fillStyle === "solid") {
        const shape = ellipseWithParams(x3, y3, o4, ellipseParams).opset;
        shape.type = "fillPath";
        paths.push(shape);
      } else {
        paths.push(patternFillPolygons([ellipseResponse.estimatedPoints], o4));
      }
    }
    if (o4.stroke !== NOS) {
      paths.push(ellipseResponse.opset);
    }
    return this._d("ellipse", paths, o4);
  }
  circle(x3, y3, diameter, options) {
    const ret = this.ellipse(x3, y3, diameter, diameter, options);
    ret.shape = "circle";
    return ret;
  }
  linearPath(points, options) {
    const o4 = this._o(options);
    return this._d("linearPath", [linearPath(points, false, o4)], o4);
  }
  arc(x3, y3, width, height, start2, stop2, closed = false, options) {
    const o4 = this._o(options);
    const paths = [];
    const outline = arc(x3, y3, width, height, start2, stop2, closed, true, o4);
    if (closed && o4.fill) {
      if (o4.fillStyle === "solid") {
        const fillOptions = Object.assign({}, o4);
        fillOptions.disableMultiStroke = true;
        const shape = arc(x3, y3, width, height, start2, stop2, true, false, fillOptions);
        shape.type = "fillPath";
        paths.push(shape);
      } else {
        paths.push(patternFillArc(x3, y3, width, height, start2, stop2, o4));
      }
    }
    if (o4.stroke !== NOS) {
      paths.push(outline);
    }
    return this._d("arc", paths, o4);
  }
  curve(points, options) {
    const o4 = this._o(options);
    const paths = [];
    const outline = curve(points, o4);
    if (o4.fill && o4.fill !== NOS && points.length >= 3) {
      if (o4.fillStyle === "solid") {
        const fillShape = curve(points, Object.assign(Object.assign({}, o4), { disableMultiStroke: true, roughness: o4.roughness ? o4.roughness + o4.fillShapeRoughnessGain : 0 }));
        paths.push({
          type: "fillPath",
          ops: this._mergedShape(fillShape.ops)
        });
      } else {
        const bcurve = curveToBezier(points);
        const polyPoints = pointsOnBezierCurves(bcurve, 10, (1 + o4.roughness) / 2);
        paths.push(patternFillPolygons([polyPoints], o4));
      }
    }
    if (o4.stroke !== NOS) {
      paths.push(outline);
    }
    return this._d("curve", paths, o4);
  }
  polygon(points, options) {
    const o4 = this._o(options);
    const paths = [];
    const outline = linearPath(points, true, o4);
    if (o4.fill) {
      if (o4.fillStyle === "solid") {
        paths.push(solidFillPolygon([points], o4));
      } else {
        paths.push(patternFillPolygons([points], o4));
      }
    }
    if (o4.stroke !== NOS) {
      paths.push(outline);
    }
    return this._d("polygon", paths, o4);
  }
  path(d3, options) {
    const o4 = this._o(options);
    const paths = [];
    if (!d3) {
      return this._d("path", paths, o4);
    }
    d3 = (d3 || "").replace(/\n/g, " ").replace(/(-\s)/g, "-").replace("/(ss)/g", " ");
    const hasFill = o4.fill && o4.fill !== "transparent" && o4.fill !== NOS;
    const hasStroke = o4.stroke !== NOS;
    const simplified = !!(o4.simplification && o4.simplification < 1);
    const distance5 = simplified ? 4 - 4 * (o4.simplification || 1) : (1 + o4.roughness) / 2;
    const sets = pointsOnPath(d3, 1, distance5);
    const shape = svgPath(d3, o4);
    if (hasFill) {
      if (o4.fillStyle === "solid") {
        if (sets.length === 1) {
          const fillShape = svgPath(d3, Object.assign(Object.assign({}, o4), { disableMultiStroke: true, roughness: o4.roughness ? o4.roughness + o4.fillShapeRoughnessGain : 0 }));
          paths.push({
            type: "fillPath",
            ops: this._mergedShape(fillShape.ops)
          });
        } else {
          paths.push(solidFillPolygon(sets, o4));
        }
      } else {
        paths.push(patternFillPolygons(sets, o4));
      }
    }
    if (hasStroke) {
      if (simplified) {
        sets.forEach((set) => {
          paths.push(linearPath(set, false, o4));
        });
      } else {
        paths.push(shape);
      }
    }
    return this._d("path", paths, o4);
  }
  opsToPath(drawing, fixedDecimals) {
    let path = "";
    for (const item of drawing.ops) {
      const data = typeof fixedDecimals === "number" && fixedDecimals >= 0 ? item.data.map((d3) => +d3.toFixed(fixedDecimals)) : item.data;
      switch (item.op) {
        case "move":
          path += `M${data[0]} ${data[1]} `;
          break;
        case "bcurveTo":
          path += `C${data[0]} ${data[1]}, ${data[2]} ${data[3]}, ${data[4]} ${data[5]} `;
          break;
        case "lineTo":
          path += `L${data[0]} ${data[1]} `;
          break;
      }
    }
    return path.trim();
  }
  toPaths(drawable) {
    const sets = drawable.sets || [];
    const o4 = drawable.options || this.defaultOptions;
    const paths = [];
    for (const drawing of sets) {
      let path = null;
      switch (drawing.type) {
        case "path":
          path = {
            d: this.opsToPath(drawing),
            stroke: o4.stroke,
            strokeWidth: o4.strokeWidth,
            fill: NOS
          };
          break;
        case "fillPath":
          path = {
            d: this.opsToPath(drawing),
            stroke: NOS,
            strokeWidth: 0,
            fill: o4.fill || NOS
          };
          break;
        case "fillSketch":
          path = this.fillSketch(drawing, o4);
          break;
      }
      if (path) {
        paths.push(path);
      }
    }
    return paths;
  }
  fillSketch(drawing, o4) {
    let fweight = o4.fillWeight;
    if (fweight < 0) {
      fweight = o4.strokeWidth / 2;
    }
    return {
      d: this.opsToPath(drawing),
      stroke: o4.fill || NOS,
      strokeWidth: fweight,
      fill: NOS
    };
  }
  _mergedShape(input) {
    return input.filter((d3, i4) => {
      if (i4 === 0) {
        return true;
      }
      if (d3.op === "move") {
        return false;
      }
      return true;
    });
  }
};

// ../../node_modules/roughjs/bin/canvas.js
var RoughCanvas = class {
  constructor(canvas2, config) {
    this.canvas = canvas2;
    this.ctx = this.canvas.getContext("2d");
    this.gen = new RoughGenerator(config);
  }
  draw(drawable) {
    const sets = drawable.sets || [];
    const o4 = drawable.options || this.getDefaultOptions();
    const ctx = this.ctx;
    const precision = drawable.options.fixedDecimalPlaceDigits;
    for (const drawing of sets) {
      switch (drawing.type) {
        case "path":
          ctx.save();
          ctx.strokeStyle = o4.stroke === "none" ? "transparent" : o4.stroke;
          ctx.lineWidth = o4.strokeWidth;
          if (o4.strokeLineDash) {
            ctx.setLineDash(o4.strokeLineDash);
          }
          if (o4.strokeLineDashOffset) {
            ctx.lineDashOffset = o4.strokeLineDashOffset;
          }
          this._drawToContext(ctx, drawing, precision);
          ctx.restore();
          break;
        case "fillPath": {
          ctx.save();
          ctx.fillStyle = o4.fill || "";
          const fillRule = drawable.shape === "curve" || drawable.shape === "polygon" || drawable.shape === "path" ? "evenodd" : "nonzero";
          this._drawToContext(ctx, drawing, precision, fillRule);
          ctx.restore();
          break;
        }
        case "fillSketch":
          this.fillSketch(ctx, drawing, o4);
          break;
      }
    }
  }
  fillSketch(ctx, drawing, o4) {
    let fweight = o4.fillWeight;
    if (fweight < 0) {
      fweight = o4.strokeWidth / 2;
    }
    ctx.save();
    if (o4.fillLineDash) {
      ctx.setLineDash(o4.fillLineDash);
    }
    if (o4.fillLineDashOffset) {
      ctx.lineDashOffset = o4.fillLineDashOffset;
    }
    ctx.strokeStyle = o4.fill || "";
    ctx.lineWidth = fweight;
    this._drawToContext(ctx, drawing, o4.fixedDecimalPlaceDigits);
    ctx.restore();
  }
  _drawToContext(ctx, drawing, fixedDecimals, rule = "nonzero") {
    ctx.beginPath();
    for (const item of drawing.ops) {
      const data = typeof fixedDecimals === "number" && fixedDecimals >= 0 ? item.data.map((d3) => +d3.toFixed(fixedDecimals)) : item.data;
      switch (item.op) {
        case "move":
          ctx.moveTo(data[0], data[1]);
          break;
        case "bcurveTo":
          ctx.bezierCurveTo(data[0], data[1], data[2], data[3], data[4], data[5]);
          break;
        case "lineTo":
          ctx.lineTo(data[0], data[1]);
          break;
      }
    }
    if (drawing.type === "fillPath") {
      ctx.fill(rule);
    } else {
      ctx.stroke();
    }
  }
  get generator() {
    return this.gen;
  }
  getDefaultOptions() {
    return this.gen.defaultOptions;
  }
  line(x1, y1, x22, y22, options) {
    const d3 = this.gen.line(x1, y1, x22, y22, options);
    this.draw(d3);
    return d3;
  }
  rectangle(x3, y3, width, height, options) {
    const d3 = this.gen.rectangle(x3, y3, width, height, options);
    this.draw(d3);
    return d3;
  }
  ellipse(x3, y3, width, height, options) {
    const d3 = this.gen.ellipse(x3, y3, width, height, options);
    this.draw(d3);
    return d3;
  }
  circle(x3, y3, diameter, options) {
    const d3 = this.gen.circle(x3, y3, diameter, options);
    this.draw(d3);
    return d3;
  }
  linearPath(points, options) {
    const d3 = this.gen.linearPath(points, options);
    this.draw(d3);
    return d3;
  }
  polygon(points, options) {
    const d3 = this.gen.polygon(points, options);
    this.draw(d3);
    return d3;
  }
  arc(x3, y3, width, height, start2, stop2, closed = false, options) {
    const d3 = this.gen.arc(x3, y3, width, height, start2, stop2, closed, options);
    this.draw(d3);
    return d3;
  }
  curve(points, options) {
    const d3 = this.gen.curve(points, options);
    this.draw(d3);
    return d3;
  }
  path(d3, options) {
    const drawing = this.gen.path(d3, options);
    this.draw(drawing);
    return drawing;
  }
};

// ../../node_modules/roughjs/bin/svg.js
init_define_import_meta_env();

// ../../node_modules/roughjs/bin/core.js
init_define_import_meta_env();
var SVGNS = "http://www.w3.org/2000/svg";

// ../../node_modules/roughjs/bin/svg.js
var RoughSVG = class {
  constructor(svg, config) {
    this.svg = svg;
    this.gen = new RoughGenerator(config);
  }
  draw(drawable) {
    const sets = drawable.sets || [];
    const o4 = drawable.options || this.getDefaultOptions();
    const doc = this.svg.ownerDocument || window.document;
    const g3 = doc.createElementNS(SVGNS, "g");
    const precision = drawable.options.fixedDecimalPlaceDigits;
    for (const drawing of sets) {
      let path = null;
      switch (drawing.type) {
        case "path": {
          path = doc.createElementNS(SVGNS, "path");
          path.setAttribute("d", this.opsToPath(drawing, precision));
          path.setAttribute("stroke", o4.stroke);
          path.setAttribute("stroke-width", o4.strokeWidth + "");
          path.setAttribute("fill", "none");
          if (o4.strokeLineDash) {
            path.setAttribute("stroke-dasharray", o4.strokeLineDash.join(" ").trim());
          }
          if (o4.strokeLineDashOffset) {
            path.setAttribute("stroke-dashoffset", `${o4.strokeLineDashOffset}`);
          }
          break;
        }
        case "fillPath": {
          path = doc.createElementNS(SVGNS, "path");
          path.setAttribute("d", this.opsToPath(drawing, precision));
          path.setAttribute("stroke", "none");
          path.setAttribute("stroke-width", "0");
          path.setAttribute("fill", o4.fill || "");
          if (drawable.shape === "curve" || drawable.shape === "polygon") {
            path.setAttribute("fill-rule", "evenodd");
          }
          break;
        }
        case "fillSketch": {
          path = this.fillSketch(doc, drawing, o4);
          break;
        }
      }
      if (path) {
        g3.appendChild(path);
      }
    }
    return g3;
  }
  fillSketch(doc, drawing, o4) {
    let fweight = o4.fillWeight;
    if (fweight < 0) {
      fweight = o4.strokeWidth / 2;
    }
    const path = doc.createElementNS(SVGNS, "path");
    path.setAttribute("d", this.opsToPath(drawing, o4.fixedDecimalPlaceDigits));
    path.setAttribute("stroke", o4.fill || "");
    path.setAttribute("stroke-width", fweight + "");
    path.setAttribute("fill", "none");
    if (o4.fillLineDash) {
      path.setAttribute("stroke-dasharray", o4.fillLineDash.join(" ").trim());
    }
    if (o4.fillLineDashOffset) {
      path.setAttribute("stroke-dashoffset", `${o4.fillLineDashOffset}`);
    }
    return path;
  }
  get generator() {
    return this.gen;
  }
  getDefaultOptions() {
    return this.gen.defaultOptions;
  }
  opsToPath(drawing, fixedDecimalPlaceDigits) {
    return this.gen.opsToPath(drawing, fixedDecimalPlaceDigits);
  }
  line(x1, y1, x22, y22, options) {
    const d3 = this.gen.line(x1, y1, x22, y22, options);
    return this.draw(d3);
  }
  rectangle(x3, y3, width, height, options) {
    const d3 = this.gen.rectangle(x3, y3, width, height, options);
    return this.draw(d3);
  }
  ellipse(x3, y3, width, height, options) {
    const d3 = this.gen.ellipse(x3, y3, width, height, options);
    return this.draw(d3);
  }
  circle(x3, y3, diameter, options) {
    const d3 = this.gen.circle(x3, y3, diameter, options);
    return this.draw(d3);
  }
  linearPath(points, options) {
    const d3 = this.gen.linearPath(points, options);
    return this.draw(d3);
  }
  polygon(points, options) {
    const d3 = this.gen.polygon(points, options);
    return this.draw(d3);
  }
  arc(x3, y3, width, height, start2, stop2, closed = false, options) {
    const d3 = this.gen.arc(x3, y3, width, height, start2, stop2, closed, options);
    return this.draw(d3);
  }
  curve(points, options) {
    const d3 = this.gen.curve(points, options);
    return this.draw(d3);
  }
  path(d3, options) {
    const drawing = this.gen.path(d3, options);
    return this.draw(drawing);
  }
};

// ../../node_modules/roughjs/bin/rough.js
var rough_default = {
  canvas(canvas2, config) {
    return new RoughCanvas(canvas2, config);
  },
  svg(svg, config) {
    return new RoughSVG(svg, config);
  },
  generator(config) {
    return new RoughGenerator(config);
  },
  newSeed() {
    return RoughGenerator.newSeed();
  }
};

// scene/Shape.ts
init_define_import_meta_env();

// renderer/renderElement.ts
init_define_import_meta_env();

// ../../node_modules/perfect-freehand/dist/esm/index.js
init_define_import_meta_env();
function $(e3, t4, u3, x3 = (h3) => h3) {
  return e3 * x3(0.5 - t4 * (0.5 - u3));
}
function se(e3) {
  return [-e3[0], -e3[1]];
}
function l(e3, t4) {
  return [e3[0] + t4[0], e3[1] + t4[1]];
}
function a(e3, t4) {
  return [e3[0] - t4[0], e3[1] - t4[1]];
}
function b(e3, t4) {
  return [e3[0] * t4, e3[1] * t4];
}
function he(e3, t4) {
  return [e3[0] / t4, e3[1] / t4];
}
function R(e3) {
  return [e3[1], -e3[0]];
}
function B(e3, t4) {
  return e3[0] * t4[0] + e3[1] * t4[1];
}
function ue(e3, t4) {
  return e3[0] === t4[0] && e3[1] === t4[1];
}
function ge(e3) {
  return Math.hypot(e3[0], e3[1]);
}
function de(e3) {
  return e3[0] * e3[0] + e3[1] * e3[1];
}
function A(e3, t4) {
  return de(a(e3, t4));
}
function G(e3) {
  return he(e3, ge(e3));
}
function ie(e3, t4) {
  return Math.hypot(e3[1] - t4[1], e3[0] - t4[0]);
}
function L(e3, t4, u3) {
  let x3 = Math.sin(u3), h3 = Math.cos(u3), y3 = e3[0] - t4[0], n4 = e3[1] - t4[1], f3 = y3 * h3 - n4 * x3, d3 = y3 * x3 + n4 * h3;
  return [f3 + t4[0], d3 + t4[1]];
}
function K(e3, t4, u3) {
  return l(e3, b(a(t4, e3), u3));
}
function ee(e3, t4, u3) {
  return l(e3, b(t4, u3));
}
var { min: C, PI: xe } = Math;
var pe = 0.275;
var V = xe + 1e-4;
function ce(e3, t4 = {}) {
  let { size: u3 = 16, smoothing: x3 = 0.5, thinning: h3 = 0.5, simulatePressure: y3 = true, easing: n4 = (r3) => r3, start: f3 = {}, end: d3 = {}, last: D3 = false } = t4, { cap: S2 = true, easing: j = (r3) => r3 * (2 - r3) } = f3, { cap: q = true, easing: c3 = (r3) => --r3 * r3 * r3 + 1 } = d3;
  if (e3.length === 0 || u3 <= 0)
    return [];
  let p3 = e3[e3.length - 1].runningLength, g3 = f3.taper === false ? 0 : f3.taper === true ? Math.max(u3, p3) : f3.taper, T3 = d3.taper === false ? 0 : d3.taper === true ? Math.max(u3, p3) : d3.taper, te = Math.pow(u3 * x3, 2), _ = [], M = [], H2 = e3.slice(0, 10).reduce((r3, i4) => {
    let o4 = i4.pressure;
    if (y3) {
      let s4 = C(1, i4.distance / u3), W2 = C(1, 1 - s4);
      o4 = C(1, r3 + (W2 - r3) * (s4 * pe));
    }
    return (r3 + o4) / 2;
  }, e3[0].pressure), m3 = $(u3, h3, e3[e3.length - 1].pressure, n4), U, X = e3[0].vector, z2 = e3[0].point, F = z2, O2 = z2, E4 = F, J = false;
  for (let r3 = 0; r3 < e3.length; r3++) {
    let { pressure: i4 } = e3[r3], { point: o4, vector: s4, distance: W2, runningLength: I2 } = e3[r3];
    if (r3 < e3.length - 1 && p3 - I2 < 3)
      continue;
    if (h3) {
      if (y3) {
        let v3 = C(1, W2 / u3), Z = C(1, 1 - v3);
        i4 = C(1, H2 + (Z - H2) * (v3 * pe));
      }
      m3 = $(u3, h3, i4, n4);
    } else
      m3 = u3 / 2;
    U === void 0 && (U = m3);
    let le = I2 < g3 ? j(I2 / g3) : 1, fe = p3 - I2 < T3 ? c3((p3 - I2) / T3) : 1;
    m3 = Math.max(0.01, m3 * Math.min(le, fe));
    let re = (r3 < e3.length - 1 ? e3[r3 + 1] : e3[r3]).vector, Y = r3 < e3.length - 1 ? B(s4, re) : 1, be = B(s4, X) < 0 && !J, ne = Y !== null && Y < 0;
    if (be || ne) {
      let v3 = b(R(X), m3);
      for (let Z = 1 / 13, w3 = 0; w3 <= 1; w3 += Z)
        O2 = L(a(o4, v3), o4, V * w3), _.push(O2), E4 = L(l(o4, v3), o4, V * -w3), M.push(E4);
      z2 = O2, F = E4, ne && (J = true);
      continue;
    }
    if (J = false, r3 === e3.length - 1) {
      let v3 = b(R(s4), m3);
      _.push(a(o4, v3)), M.push(l(o4, v3));
      continue;
    }
    let oe = b(R(K(re, s4, Y)), m3);
    O2 = a(o4, oe), (r3 <= 1 || A(z2, O2) > te) && (_.push(O2), z2 = O2), E4 = l(o4, oe), (r3 <= 1 || A(F, E4) > te) && (M.push(E4), F = E4), H2 = i4, X = s4;
  }
  let P2 = e3[0].point.slice(0, 2), k2 = e3.length > 1 ? e3[e3.length - 1].point.slice(0, 2) : l(e3[0].point, [1, 1]), Q = [], N2 = [];
  if (e3.length === 1) {
    if (!(g3 || T3) || D3) {
      let r3 = ee(P2, G(R(a(P2, k2))), -(U || m3)), i4 = [];
      for (let o4 = 1 / 13, s4 = o4; s4 <= 1; s4 += o4)
        i4.push(L(r3, P2, V * 2 * s4));
      return i4;
    }
  } else {
    if (!(g3 || T3 && e3.length === 1))
      if (S2)
        for (let i4 = 1 / 13, o4 = i4; o4 <= 1; o4 += i4) {
          let s4 = L(M[0], P2, V * o4);
          Q.push(s4);
        }
      else {
        let i4 = a(_[0], M[0]), o4 = b(i4, 0.5), s4 = b(i4, 0.51);
        Q.push(a(P2, o4), a(P2, s4), l(P2, s4), l(P2, o4));
      }
    let r3 = R(se(e3[e3.length - 1].vector));
    if (T3 || g3 && e3.length === 1)
      N2.push(k2);
    else if (q) {
      let i4 = ee(k2, r3, m3);
      for (let o4 = 1 / 29, s4 = o4; s4 < 1; s4 += o4)
        N2.push(L(i4, k2, V * 3 * s4));
    } else
      N2.push(l(k2, b(r3, m3)), l(k2, b(r3, m3 * 0.99)), a(k2, b(r3, m3 * 0.99)), a(k2, b(r3, m3)));
  }
  return _.concat(N2, M.reverse(), Q);
}
function me(e3, t4 = {}) {
  var q;
  let { streamline: u3 = 0.5, size: x3 = 16, last: h3 = false } = t4;
  if (e3.length === 0)
    return [];
  let y3 = 0.15 + (1 - u3) * 0.85, n4 = Array.isArray(e3[0]) ? e3 : e3.map(({ x: c3, y: p3, pressure: g3 = 0.5 }) => [c3, p3, g3]);
  if (n4.length === 2) {
    let c3 = n4[1];
    n4 = n4.slice(0, -1);
    for (let p3 = 1; p3 < 5; p3++)
      n4.push(K(n4[0], c3, p3 / 4));
  }
  n4.length === 1 && (n4 = [...n4, [...l(n4[0], [1, 1]), ...n4[0].slice(2)]]);
  let f3 = [{ point: [n4[0][0], n4[0][1]], pressure: n4[0][2] >= 0 ? n4[0][2] : 0.25, vector: [1, 1], distance: 0, runningLength: 0 }], d3 = false, D3 = 0, S2 = f3[0], j = n4.length - 1;
  for (let c3 = 1; c3 < n4.length; c3++) {
    let p3 = h3 && c3 === j ? n4[c3].slice(0, 2) : K(S2.point, n4[c3], y3);
    if (ue(S2.point, p3))
      continue;
    let g3 = ie(p3, S2.point);
    if (D3 += g3, c3 < j && !d3) {
      if (D3 < x3)
        continue;
      d3 = true;
    }
    S2 = { point: p3, pressure: n4[c3][2] >= 0 ? n4[c3][2] : 0.5, vector: G(a(S2.point, p3)), distance: g3, runningLength: D3 }, f3.push(S2);
  }
  return f3[0].vector = ((q = f3[1]) == null ? void 0 : q.vector) || [0, 0], f3;
}
function ae(e3, t4 = {}) {
  return ce(me(e3, t4), t4);
}

// element/textElement.ts
init_define_import_meta_env();

// element/linearElementEditor.ts
init_define_import_meta_env();

// element/binding.ts
init_define_import_meta_env();

// scene/index.ts
init_define_import_meta_env();

// scene/scroll.ts
init_define_import_meta_env();
var isOutsideViewPort = (appState, cords) => {
  const [x1, y1, x22, y22] = cords;
  const { x: viewportX1, y: viewportY1 } = sceneCoordsToViewportCoords(
    { sceneX: x1, sceneY: y1 },
    appState
  );
  const { x: viewportX2, y: viewportY2 } = sceneCoordsToViewportCoords(
    { sceneX: x22, sceneY: y22 },
    appState
  );
  return viewportX2 - viewportX1 > appState.width || viewportY2 - viewportY1 > appState.height;
};
var centerScrollOn = ({
  scenePoint,
  viewportDimensions,
  zoom
}) => {
  return {
    scrollX: viewportDimensions.width / 2 / zoom.value - scenePoint.x,
    scrollY: viewportDimensions.height / 2 / zoom.value - scenePoint.y
  };
};
var calculateScrollCenter = (elements, appState) => {
  elements = getVisibleElements(elements);
  if (!elements.length) {
    return {
      scrollX: 0,
      scrollY: 0
    };
  }
  let [x1, y1, x22, y22] = getCommonBounds(elements);
  if (isOutsideViewPort(appState, [x1, y1, x22, y22])) {
    [x1, y1, x22, y22] = getClosestElementBounds(
      elements,
      viewportCoordsToSceneCoords(
        { clientX: appState.scrollX, clientY: appState.scrollY },
        appState
      )
    );
  }
  const centerX = (x1 + x22) / 2;
  const centerY = (y1 + y22) / 2;
  return centerScrollOn({
    scenePoint: { x: centerX, y: centerY },
    viewportDimensions: { width: appState.width, height: appState.height },
    zoom: appState.zoom
  });
};

// scene/comparisons.ts
init_define_import_meta_env();
var hasBackground = (type) => type === "rectangle" || type === "iframe" || type === "embeddable" || type === "ellipse" || type === "diamond" || type === "line" || type === "freedraw";
var hasStrokeColor = (type) => type !== "image" && type !== "frame" && type !== "magicframe";
var hasStrokeWidth = (type) => type === "rectangle" || type === "iframe" || type === "embeddable" || type === "ellipse" || type === "diamond" || type === "freedraw" || type === "arrow" || type === "line";
var hasStrokeStyle = (type) => type === "rectangle" || type === "iframe" || type === "embeddable" || type === "ellipse" || type === "diamond" || type === "arrow" || type === "line";
var canChangeRoundness = (type) => type === "rectangle" || type === "iframe" || type === "embeddable" || type === "arrow" || type === "line" || type === "diamond" || type === "image";
var canHaveArrowheads = (type) => type === "arrow";
var getElementAtPosition = (elements, isAtPositionFn) => {
  let hitElement = null;
  for (let index2 = elements.length - 1; index2 >= 0; --index2) {
    const element = elements[index2];
    if (element.isDeleted) {
      continue;
    }
    if (isAtPositionFn(element)) {
      hitElement = element;
      break;
    }
  }
  return hitElement;
};
var getElementsAtPosition = (elements, isAtPositionFn) => {
  const iframeLikes = [];
  const elsAtPos = elements.filter((element) => {
    const hit = !element.isDeleted && isAtPositionFn(element);
    if (hit) {
      if (isIframeElement(element)) {
        iframeLikes.push(element);
        return false;
      }
      return true;
    }
    return false;
  });
  return elsAtPos.concat(iframeLikes);
};

// scene/zoom.ts
init_define_import_meta_env();
var getNormalizedZoom = (zoom) => {
  return Math.max(MIN_ZOOM, Math.min(zoom, 30));
};
var getStateForZoom = ({
  viewportX,
  viewportY,
  nextZoom
}, appState) => {
  const appLayerX = viewportX - appState.offsetLeft;
  const appLayerY = viewportY - appState.offsetTop;
  const currentZoom = appState.zoom.value;
  const baseScrollX = appState.scrollX + (appLayerX - appLayerX / currentZoom);
  const baseScrollY = appState.scrollY + (appLayerY - appLayerY / currentZoom);
  const zoomOffsetScrollX = -(appLayerX - appLayerX / nextZoom);
  const zoomOffsetScrollY = -(appLayerY - appLayerY / nextZoom);
  return {
    scrollX: baseScrollX + zoomOffsetScrollX,
    scrollY: baseScrollY + zoomOffsetScrollY,
    zoom: {
      value: nextZoom
    }
  };
};

// element/collision.ts
init_define_import_meta_env();

// ga.ts
init_define_import_meta_env();
var point = (x3, y3) => [0, 0, 0, 0, y3, x3, 1, 0];
var offset = (x3, y3) => [
  0,
  0,
  0,
  0,
  y3,
  x3,
  0,
  0
];
var nvector = (value = 0, index2 = 0) => {
  const result = [0, 0, 0, 0, 0, 0, 0, 0];
  if (index2 < 0 || index2 > 7) {
    throw new Error(`Expected \`index\` between 0 and 7, got \`${index2}\``);
  }
  if (value !== 0) {
    result[index2] = value;
  }
  return result;
};
var reverse = (nvector2) => [
  nvector2[0],
  nvector2[1],
  nvector2[2],
  nvector2[3],
  -nvector2[4],
  -nvector2[5],
  -nvector2[6],
  -nvector2[7]
];
var add = (a4, b4) => {
  if (isNumber(b4)) {
    return [a4[0] + b4, a4[1], a4[2], a4[3], a4[4], a4[5], a4[6], a4[7]];
  }
  return [
    a4[0] + b4[0],
    a4[1] + b4[1],
    a4[2] + b4[2],
    a4[3] + b4[3],
    a4[4] + b4[4],
    a4[5] + b4[5],
    a4[6] + b4[6],
    a4[7] + b4[7]
  ];
};
var sub = (a4, b4) => {
  if (isNumber(b4)) {
    return [a4[0] - b4, a4[1], a4[2], a4[3], a4[4], a4[5], a4[6], a4[7]];
  }
  return [
    a4[0] - b4[0],
    a4[1] - b4[1],
    a4[2] - b4[2],
    a4[3] - b4[3],
    a4[4] - b4[4],
    a4[5] - b4[5],
    a4[6] - b4[6],
    a4[7] - b4[7]
  ];
};
var mul = (a4, b4) => {
  if (isNumber(b4)) {
    return [
      a4[0] * b4,
      a4[1] * b4,
      a4[2] * b4,
      a4[3] * b4,
      a4[4] * b4,
      a4[5] * b4,
      a4[6] * b4,
      a4[7] * b4
    ];
  }
  return [
    mulScalar(a4, b4),
    b4[1] * a4[0] + b4[0] * a4[1] - b4[4] * a4[2] + b4[5] * a4[3] + b4[2] * a4[4] - b4[3] * a4[5] - b4[7] * a4[6] - b4[6] * a4[7],
    b4[2] * a4[0] + b4[0] * a4[2] - b4[6] * a4[3] + b4[3] * a4[6],
    b4[3] * a4[0] + b4[6] * a4[2] + b4[0] * a4[3] - b4[2] * a4[6],
    b4[4] * a4[0] + b4[2] * a4[1] - b4[1] * a4[2] + b4[7] * a4[3] + b4[0] * a4[4] + b4[6] * a4[5] - b4[5] * a4[6] + b4[3] * a4[7],
    b4[5] * a4[0] - b4[3] * a4[1] + b4[7] * a4[2] + b4[1] * a4[3] - b4[6] * a4[4] + b4[0] * a4[5] + b4[4] * a4[6] + b4[2] * a4[7],
    b4[6] * a4[0] + b4[3] * a4[2] - b4[2] * a4[3] + b4[0] * a4[6],
    b4[7] * a4[0] + b4[6] * a4[1] + b4[5] * a4[2] + b4[4] * a4[3] + b4[3] * a4[4] + b4[2] * a4[5] + b4[1] * a4[6] + b4[0] * a4[7]
  ];
};
var mulScalar = (a4, b4) => b4[0] * a4[0] + b4[2] * a4[2] + b4[3] * a4[3] - b4[6] * a4[6];
var meet = (a4, b4) => [
  b4[0] * a4[0],
  b4[1] * a4[0] + b4[0] * a4[1],
  b4[2] * a4[0] + b4[0] * a4[2],
  b4[3] * a4[0] + b4[0] * a4[3],
  b4[4] * a4[0] + b4[2] * a4[1] - b4[1] * a4[2] + b4[0] * a4[4],
  b4[5] * a4[0] - b4[3] * a4[1] + b4[1] * a4[3] + b4[0] * a4[5],
  b4[6] * a4[0] + b4[3] * a4[2] - b4[2] * a4[3] + b4[0] * a4[6],
  b4[7] * a4[0] + b4[6] * a4[1] + b4[5] * a4[2] + b4[4] * a4[3] + b4[3] * a4[4] + b4[2] * a4[5] + b4[1] * a4[6]
];
var join = (a4, b4) => [
  joinScalar(a4, b4),
  a4[1] * b4[7] + a4[4] * b4[5] - a4[5] * b4[4] + a4[7] * b4[1],
  a4[2] * b4[7] - a4[4] * b4[6] + a4[6] * b4[4] + a4[7] * b4[2],
  a4[3] * b4[7] + a4[5] * b4[6] - a4[6] * b4[5] + a4[7] * b4[3],
  a4[4] * b4[7] + a4[7] * b4[4],
  a4[5] * b4[7] + a4[7] * b4[5],
  a4[6] * b4[7] + a4[7] * b4[6],
  a4[7] * b4[7]
];
var joinScalar = (a4, b4) => a4[0] * b4[7] + a4[1] * b4[6] + a4[2] * b4[5] + a4[3] * b4[4] + a4[4] * b4[3] + a4[5] * b4[2] + a4[6] * b4[1] + a4[7] * b4[0];
var dot = (a4, b4) => [
  b4[0] * a4[0] + b4[2] * a4[2] + b4[3] * a4[3] - b4[6] * a4[6],
  b4[1] * a4[0] + b4[0] * a4[1] - b4[4] * a4[2] + b4[5] * a4[3] + b4[2] * a4[4] - b4[3] * a4[5] - b4[7] * a4[6] - b4[6] * a4[7],
  b4[2] * a4[0] + b4[0] * a4[2] - b4[6] * a4[3] + b4[3] * a4[6],
  b4[3] * a4[0] + b4[6] * a4[2] + b4[0] * a4[3] - b4[2] * a4[6],
  b4[4] * a4[0] + b4[7] * a4[3] + b4[0] * a4[4] + b4[3] * a4[7],
  b4[5] * a4[0] + b4[7] * a4[2] + b4[0] * a4[5] + b4[2] * a4[7],
  b4[6] * a4[0] + b4[0] * a4[6],
  b4[7] * a4[0] + b4[0] * a4[7]
];
var norm = (a4) => Math.sqrt(Math.abs(a4[0] * a4[0] - a4[2] * a4[2] - a4[3] * a4[3] + a4[6] * a4[6]));
var inorm = (a4) => Math.sqrt(Math.abs(a4[7] * a4[7] - a4[5] * a4[5] - a4[4] * a4[4] + a4[1] * a4[1]));
var normalized = (a4) => {
  const n4 = norm(a4);
  if (n4 === 0 || n4 === 1) {
    return a4;
  }
  const sign2 = a4[6] < 0 ? -1 : 1;
  return mul(a4, sign2 / n4);
};
var inormalized = (a4) => {
  const n4 = inorm(a4);
  if (n4 === 0 || n4 === 1) {
    return a4;
  }
  return mul(a4, 1 / n4);
};
var isNumber = (a4) => typeof a4 === "number";
var E0 = nvector(1, 1);
var E1 = nvector(1, 2);
var E2 = nvector(1, 3);
var E01 = nvector(1, 4);
var E20 = nvector(1, 5);
var E12 = nvector(1, 6);
var E012 = nvector(1, 7);

// gapoints.ts
init_define_import_meta_env();

// galines.ts
init_define_import_meta_env();
var equation = (a4, b4, c3) => normalized([0, c3, a4, b4, 0, 0, 0, 0]);
var through = (from3, to) => normalized(join(to, from3));
var orthogonal = (line2, point2) => dot(line2, point2);
var orthogonalThrough = (against, intersection) => orthogonal(through(against, intersection), intersection);
var sign = (line2) => Math.sign(line2[1]);

// gapoints.ts
var from = ([x3, y3]) => [
  0,
  0,
  0,
  0,
  y3,
  x3,
  1,
  0
];
var toTuple = (point2) => [point2[5], point2[4]];
var abs = (point2) => [
  0,
  0,
  0,
  0,
  Math.abs(point2[4]),
  Math.abs(point2[5]),
  1,
  0
];
var intersect = (line1, line2) => normalized(meet(line1, line2));
var distance3 = (point1, point2) => norm(join(point1, point2));
var distanceToLine = (point2, line2) => joinScalar(point2, line2);

// gadirections.ts
init_define_import_meta_env();
var from2 = (point2) => [
  0,
  0,
  0,
  0,
  point2[4],
  point2[5],
  0,
  0
];
var fromTo = (from3, to) => inormalized([0, 0, 0, 0, to[4] - from3[4], to[5] - from3[5], 0, 0]);

// gatransforms.ts
init_define_import_meta_env();
var rotation = (pivot, angle) => add(mul(pivot, Math.sin(angle / 2)), Math.cos(angle / 2));
var translation = (direction) => [
  1,
  0,
  0,
  0,
  -(0.5 * direction[5]),
  0.5 * direction[4],
  0,
  0
];
var translationOrthogonal = (direction, distance5) => {
  const scale = 0.5 * distance5;
  return [1, 0, 0, 0, scale * direction[4], scale * direction[5], 0, 0];
};
var compose = (motor1, motor2) => mul(motor2, motor1);
var apply = (motor, nvector2) => normalized(mul(mul(motor, nvector2), reverse(motor)));

// node_modules/points-on-curve/lib/index.js
init_define_import_meta_env();
function distance4(p1, p22) {
  return Math.sqrt(distanceSq2(p1, p22));
}
function distanceSq2(p1, p22) {
  return Math.pow(p1[0] - p22[0], 2) + Math.pow(p1[1] - p22[1], 2);
}
function distanceToSegmentSq2(p3, v3, w3) {
  const l22 = distanceSq2(v3, w3);
  if (l22 === 0) {
    return distanceSq2(p3, v3);
  }
  let t4 = ((p3[0] - v3[0]) * (w3[0] - v3[0]) + (p3[1] - v3[1]) * (w3[1] - v3[1])) / l22;
  t4 = Math.max(0, Math.min(1, t4));
  return distanceSq2(p3, lerp2(v3, w3, t4));
}
function lerp2(a4, b4, t4) {
  return [
    a4[0] + (b4[0] - a4[0]) * t4,
    a4[1] + (b4[1] - a4[1]) * t4
  ];
}
function flatness2(points, offset2) {
  const p1 = points[offset2 + 0];
  const p22 = points[offset2 + 1];
  const p3 = points[offset2 + 2];
  const p4 = points[offset2 + 3];
  let ux = 3 * p22[0] - 2 * p1[0] - p4[0];
  ux *= ux;
  let uy = 3 * p22[1] - 2 * p1[1] - p4[1];
  uy *= uy;
  let vx = 3 * p3[0] - 2 * p4[0] - p1[0];
  vx *= vx;
  let vy = 3 * p3[1] - 2 * p4[1] - p1[1];
  vy *= vy;
  if (ux < vx) {
    ux = vx;
  }
  if (uy < vy) {
    uy = vy;
  }
  return ux + uy;
}
function getPointsOnBezierCurveWithSplitting2(points, offset2, tolerance, newPoints) {
  const outPoints = newPoints || [];
  if (flatness2(points, offset2) < tolerance) {
    const p0 = points[offset2 + 0];
    if (outPoints.length) {
      const d3 = distance4(outPoints[outPoints.length - 1], p0);
      if (d3 > 1) {
        outPoints.push(p0);
      }
    } else {
      outPoints.push(p0);
    }
    outPoints.push(points[offset2 + 3]);
  } else {
    const t4 = 0.5;
    const p1 = points[offset2 + 0];
    const p22 = points[offset2 + 1];
    const p3 = points[offset2 + 2];
    const p4 = points[offset2 + 3];
    const q1 = lerp2(p1, p22, t4);
    const q2 = lerp2(p22, p3, t4);
    const q3 = lerp2(p3, p4, t4);
    const r1 = lerp2(q1, q2, t4);
    const r22 = lerp2(q2, q3, t4);
    const red = lerp2(r1, r22, t4);
    getPointsOnBezierCurveWithSplitting2([p1, q1, r1, red], 0, tolerance, outPoints);
    getPointsOnBezierCurveWithSplitting2([red, r22, q3, p4], 0, tolerance, outPoints);
  }
  return outPoints;
}
function simplify2(points, distance5) {
  return simplifyPoints2(points, 0, points.length, distance5);
}
function simplifyPoints2(points, start2, end, epsilon, newPoints) {
  const outPoints = newPoints || [];
  const s4 = points[start2];
  const e3 = points[end - 1];
  let maxDistSq = 0;
  let maxNdx = 1;
  for (let i4 = start2 + 1; i4 < end - 1; ++i4) {
    const distSq = distanceToSegmentSq2(points[i4], s4, e3);
    if (distSq > maxDistSq) {
      maxDistSq = distSq;
      maxNdx = i4;
    }
  }
  if (Math.sqrt(maxDistSq) > epsilon) {
    simplifyPoints2(points, start2, maxNdx + 1, epsilon, outPoints);
    simplifyPoints2(points, maxNdx, end, epsilon, outPoints);
  } else {
    if (!outPoints.length) {
      outPoints.push(s4);
    }
    outPoints.push(e3);
  }
  return outPoints;
}
function pointsOnBezierCurves2(points, tolerance = 0.15, distance5) {
  const newPoints = [];
  const numSegments = (points.length - 1) / 3;
  for (let i4 = 0; i4 < numSegments; i4++) {
    const offset2 = i4 * 3;
    getPointsOnBezierCurveWithSplitting2(points, offset2, tolerance, newPoints);
  }
  if (distance5 && distance5 > 0) {
    return simplifyPoints2(newPoints, 0, newPoints.length, distance5);
  }
  return newPoints;
}

// element/transformHandles.ts
init_define_import_meta_env();
var transformHandleSizes = {
  mouse: 8,
  pen: 16,
  touch: 28
};
var ROTATION_RESIZE_HANDLE_GAP = 16;
var OMIT_SIDES_FOR_MULTIPLE_ELEMENTS = {
  e: true,
  s: true,
  n: true,
  w: true
};
var OMIT_SIDES_FOR_FRAME = {
  e: true,
  s: true,
  n: true,
  w: true,
  rotation: true
};
var OMIT_SIDES_FOR_TEXT_ELEMENT = {
  e: true,
  s: true,
  n: true,
  w: true
};
var OMIT_SIDES_FOR_LINE_SLASH = {
  e: true,
  s: true,
  n: true,
  w: true,
  nw: true,
  se: true
};
var OMIT_SIDES_FOR_LINE_BACKSLASH = {
  e: true,
  s: true,
  n: true,
  w: true
};
var generateTransformHandle = (x3, y3, width, height, cx, cy, angle) => {
  const [xx, yy] = rotate2(x3 + width / 2, y3 + height / 2, cx, cy, angle);
  return [xx - width / 2, yy - height / 2, width, height];
};
var getTransformHandlesFromCoords = ([x1, y1, x22, y22, cx, cy], angle, zoom, pointerType, omitSides = {}, margin = 4) => {
  const size = transformHandleSizes[pointerType];
  const handleWidth = size / zoom.value;
  const handleHeight = size / zoom.value;
  const handleMarginX = size / zoom.value;
  const handleMarginY = size / zoom.value;
  const width = x22 - x1;
  const height = y22 - y1;
  const dashedLineMargin = margin / zoom.value;
  const centeringOffset = (size - DEFAULT_TRANSFORM_HANDLE_SPACING * 2) / (2 * zoom.value);
  const transformHandles = {
    nw: omitSides.nw ? void 0 : generateTransformHandle(
      x1 - dashedLineMargin - handleMarginX + centeringOffset,
      y1 - dashedLineMargin - handleMarginY + centeringOffset,
      handleWidth,
      handleHeight,
      cx,
      cy,
      angle
    ),
    ne: omitSides.ne ? void 0 : generateTransformHandle(
      x22 + dashedLineMargin - centeringOffset,
      y1 - dashedLineMargin - handleMarginY + centeringOffset,
      handleWidth,
      handleHeight,
      cx,
      cy,
      angle
    ),
    sw: omitSides.sw ? void 0 : generateTransformHandle(
      x1 - dashedLineMargin - handleMarginX + centeringOffset,
      y22 + dashedLineMargin - centeringOffset,
      handleWidth,
      handleHeight,
      cx,
      cy,
      angle
    ),
    se: omitSides.se ? void 0 : generateTransformHandle(
      x22 + dashedLineMargin - centeringOffset,
      y22 + dashedLineMargin - centeringOffset,
      handleWidth,
      handleHeight,
      cx,
      cy,
      angle
    ),
    rotation: omitSides.rotation ? void 0 : generateTransformHandle(
      x1 + width / 2 - handleWidth / 2,
      y1 - dashedLineMargin - handleMarginY + centeringOffset - ROTATION_RESIZE_HANDLE_GAP / zoom.value,
      handleWidth,
      handleHeight,
      cx,
      cy,
      angle
    )
  };
  const minimumSizeForEightHandles = 5 * transformHandleSizes.mouse / zoom.value;
  if (Math.abs(width) > minimumSizeForEightHandles) {
    if (!omitSides.n) {
      transformHandles.n = generateTransformHandle(
        x1 + width / 2 - handleWidth / 2,
        y1 - dashedLineMargin - handleMarginY + centeringOffset,
        handleWidth,
        handleHeight,
        cx,
        cy,
        angle
      );
    }
    if (!omitSides.s) {
      transformHandles.s = generateTransformHandle(
        x1 + width / 2 - handleWidth / 2,
        y22 + dashedLineMargin - centeringOffset,
        handleWidth,
        handleHeight,
        cx,
        cy,
        angle
      );
    }
  }
  if (Math.abs(height) > minimumSizeForEightHandles) {
    if (!omitSides.w) {
      transformHandles.w = generateTransformHandle(
        x1 - dashedLineMargin - handleMarginX + centeringOffset,
        y1 + height / 2 - handleHeight / 2,
        handleWidth,
        handleHeight,
        cx,
        cy,
        angle
      );
    }
    if (!omitSides.e) {
      transformHandles.e = generateTransformHandle(
        x22 + dashedLineMargin - centeringOffset,
        y1 + height / 2 - handleHeight / 2,
        handleWidth,
        handleHeight,
        cx,
        cy,
        angle
      );
    }
  }
  return transformHandles;
};
var getTransformHandles = (element, zoom, elementsMap, pointerType = "mouse") => {
  if (element.locked) {
    return {};
  }
  let omitSides = {};
  if (element.type === "freedraw" || isLinearElement(element)) {
    if (element.points.length === 2) {
      const [, p1] = element.points;
      if (p1[0] === 0 || p1[1] === 0) {
        omitSides = OMIT_SIDES_FOR_LINE_BACKSLASH;
      } else if (p1[0] > 0 && p1[1] < 0) {
        omitSides = OMIT_SIDES_FOR_LINE_SLASH;
      } else if (p1[0] > 0 && p1[1] > 0) {
        omitSides = OMIT_SIDES_FOR_LINE_BACKSLASH;
      } else if (p1[0] < 0 && p1[1] > 0) {
        omitSides = OMIT_SIDES_FOR_LINE_SLASH;
      } else if (p1[0] < 0 && p1[1] < 0) {
        omitSides = OMIT_SIDES_FOR_LINE_BACKSLASH;
      }
    }
  } else if (isTextElement(element)) {
    omitSides = OMIT_SIDES_FOR_TEXT_ELEMENT;
  } else if (isFrameLikeElement(element)) {
    omitSides = {
      rotation: true
    };
  }
  const dashedLineMargin = isLinearElement(element) ? DEFAULT_TRANSFORM_HANDLE_SPACING + 8 : DEFAULT_TRANSFORM_HANDLE_SPACING;
  return getTransformHandlesFromCoords(
    getElementAbsoluteCoords(element, elementsMap, true),
    element.angle,
    zoom,
    pointerType,
    omitSides,
    dashedLineMargin
  );
};
var shouldShowBoundingBox = (elements, appState) => {
  if (appState.editingLinearElement) {
    return false;
  }
  if (elements.length > 1) {
    return true;
  }
  const element = elements[0];
  if (!isLinearElement(element)) {
    return true;
  }
  return element.points.length > 2;
};

// scene/ShapeCache.ts
init_define_import_meta_env();
var ShapeCache = class _ShapeCache {
  static rg = new RoughGenerator();
  static cache = /* @__PURE__ */ new WeakMap();
  /**
   * Retrieves shape from cache if available. Use this only if shape
   * is optional and you have a fallback in case it's not cached.
   */
  static get = (element) => {
    return _ShapeCache.cache.get(
      element
    );
  };
  static set = (element, shape) => _ShapeCache.cache.set(element, shape);
  static delete = (element) => _ShapeCache.cache.delete(element);
  static destroy = () => {
    _ShapeCache.cache = /* @__PURE__ */ new WeakMap();
  };
  /**
   * Generates & caches shape for element if not already cached, otherwise
   * returns cached shape.
   */
  static generateElementShape = (element, renderConfig) => {
    const cachedShape = renderConfig?.isExporting ? void 0 : _ShapeCache.get(element);
    if (cachedShape !== void 0) {
      return cachedShape;
    }
    elementWithCanvasCache.delete(element);
    const shape = _generateElementShape(
      element,
      _ShapeCache.rg,
      renderConfig || {
        isExporting: false,
        canvasBackgroundColor: COLOR_PALETTE.white,
        embedsValidationStatus: null
      }
    );
    _ShapeCache.cache.set(element, shape);
    return shape;
  };
};

// element/collision.ts
var isElementDraggableFromInside = (element) => {
  if (element.type === "arrow") {
    return false;
  }
  if (element.type === "freedraw") {
    return true;
  }
  const isDraggableFromInside = !isTransparent(element.backgroundColor) || hasBoundTextElement(element) || isIframeLikeElement(element);
  if (element.type === "line") {
    return isDraggableFromInside && isPathALoop(element.points);
  }
  return isDraggableFromInside || isImageElement(element);
};
var hitTest = (element, appState, frameNameBoundsCache, x3, y3, elementsMap) => {
  const threshold = 10 / appState.zoom.value;
  const point2 = [x3, y3];
  if (isElementSelected(appState, element) && shouldShowBoundingBox([element], appState)) {
    return isPointHittingElementBoundingBox(
      element,
      elementsMap,
      point2,
      threshold,
      frameNameBoundsCache
    );
  }
  const boundTextElement = getBoundTextElement(element, elementsMap);
  if (boundTextElement) {
    const isHittingBoundTextElement = hitTest(
      boundTextElement,
      appState,
      frameNameBoundsCache,
      x3,
      y3,
      elementsMap
    );
    if (isHittingBoundTextElement) {
      return true;
    }
  }
  return isHittingElementNotConsideringBoundingBox(
    element,
    appState,
    frameNameBoundsCache,
    point2,
    elementsMap
  );
};
var isHittingElementBoundingBoxWithoutHittingElement = (element, appState, frameNameBoundsCache, x3, y3, elementsMap) => {
  const threshold = 10 / appState.zoom.value;
  const boundTextElement = getBoundTextElement(element, elementsMap);
  if (boundTextElement && hitTest(boundTextElement, appState, frameNameBoundsCache, x3, y3, elementsMap)) {
    return false;
  }
  return !isHittingElementNotConsideringBoundingBox(
    element,
    appState,
    frameNameBoundsCache,
    [x3, y3],
    elementsMap
  ) && isPointHittingElementBoundingBox(
    element,
    elementsMap,
    [x3, y3],
    threshold,
    frameNameBoundsCache
  );
};
var isHittingElementNotConsideringBoundingBox = (element, appState, frameNameBoundsCache, point2, elementsMap) => {
  const threshold = 10 / appState.zoom.value;
  const check = isTextElement(element) ? isStrictlyInside : isElementDraggableFromInside(element) ? isInsideCheck : isNearCheck;
  return hitTestPointAgainstElement({
    element,
    elementsMap,
    point: point2,
    threshold,
    check,
    frameNameBoundsCache
  });
};
var isElementSelected = (appState, element) => appState.selectedElementIds[element.id];
var isPointHittingElementBoundingBox = (element, elementsMap, [x3, y3], threshold, frameNameBoundsCache) => {
  if (isFrameLikeElement(element)) {
    return hitTestPointAgainstElement({
      element,
      elementsMap,
      point: [x3, y3],
      threshold,
      check: isInsideCheck,
      frameNameBoundsCache
    });
  }
  const [x1, y1, x22, y22] = getElementAbsoluteCoords(element, elementsMap);
  const elementCenterX = (x1 + x22) / 2;
  const elementCenterY = (y1 + y22) / 2;
  const [rotatedX, rotatedY] = rotate2(
    x3,
    y3,
    elementCenterX,
    elementCenterY,
    -element.angle
  );
  return rotatedX > x1 - threshold && rotatedX < x22 + threshold && rotatedY > y1 - threshold && rotatedY < y22 + threshold;
};
var bindingBorderTest = (element, { x: x3, y: y3 }, elementsMap) => {
  const threshold = maxBindingGap(element, element.width, element.height);
  const check = isOutsideCheck;
  const point2 = [x3, y3];
  return hitTestPointAgainstElement({
    element,
    elementsMap,
    point: point2,
    threshold,
    check,
    frameNameBoundsCache: null
  });
};
var maxBindingGap = (element, elementWidth, elementHeight) => {
  const shapeRatio = element.type === "diamond" ? 1 / Math.sqrt(2) : 1;
  const smallerDimension = shapeRatio * Math.min(elementWidth, elementHeight);
  return Math.max(16, Math.min(0.25 * smallerDimension, 32));
};
var hitTestPointAgainstElement = (args) => {
  switch (args.element.type) {
    case "rectangle":
    case "iframe":
    case "embeddable":
    case "image":
    case "text":
    case "diamond":
    case "ellipse":
      const distance5 = distanceToBindableElement(
        args.element,
        args.point,
        args.elementsMap
      );
      return args.check(distance5, args.threshold);
    case "freedraw": {
      if (!args.check(
        distanceToRectangle(args.element, args.point, args.elementsMap),
        args.threshold
      )) {
        return false;
      }
      return hitTestFreeDrawElement(
        args.element,
        args.point,
        args.threshold,
        args.elementsMap
      );
    }
    case "arrow":
    case "line":
      return hitTestLinear(args);
    case "selection":
      console.warn(
        "This should not happen, we need to investigate why it does."
      );
      return false;
    case "frame":
    case "magicframe": {
      if (args.check(
        distanceToBindableElement(args.element, args.point, args.elementsMap),
        args.threshold
      )) {
        return true;
      }
      const frameNameBounds = args.frameNameBoundsCache?.get(args.element);
      if (frameNameBounds) {
        return args.check(
          distanceToRectangleBox(frameNameBounds, args.point),
          args.threshold
        );
      }
      return false;
    }
  }
};
var distanceToBindableElement = (element, point2, elementsMap) => {
  switch (element.type) {
    case "rectangle":
    case "image":
    case "text":
    case "iframe":
    case "embeddable":
    case "frame":
    case "magicframe":
      return distanceToRectangle(element, point2, elementsMap);
    case "diamond":
      return distanceToDiamond(element, point2, elementsMap);
    case "ellipse":
      return distanceToEllipse(element, point2, elementsMap);
  }
};
var isStrictlyInside = (distance5, threshold) => {
  return distance5 < 0;
};
var isInsideCheck = (distance5, threshold) => {
  return distance5 < threshold;
};
var isNearCheck = (distance5, threshold) => {
  return Math.abs(distance5) < threshold;
};
var isOutsideCheck = (distance5, threshold) => {
  return 0 <= distance5 && distance5 < threshold;
};
var distanceToRectangle = (element, point2, elementsMap) => {
  const [, pointRel, hwidth, hheight] = pointRelativeToElement(
    element,
    point2,
    elementsMap
  );
  return Math.max(
    distanceToLine(pointRel, equation(0, 1, -hheight)),
    distanceToLine(pointRel, equation(1, 0, -hwidth))
  );
};
var distanceToRectangleBox = (box, point2) => {
  const [, pointRel, hwidth, hheight] = pointRelativeToDivElement(point2, box);
  return Math.max(
    distanceToLine(pointRel, equation(0, 1, -hheight)),
    distanceToLine(pointRel, equation(1, 0, -hwidth))
  );
};
var distanceToDiamond = (element, point2, elementsMap) => {
  const [, pointRel, hwidth, hheight] = pointRelativeToElement(
    element,
    point2,
    elementsMap
  );
  const side = equation(hheight, hwidth, -hheight * hwidth);
  return distanceToLine(pointRel, side);
};
var distanceToEllipse = (element, point2, elementsMap) => {
  const [pointRel, tangent] = ellipseParamsForTest(element, point2, elementsMap);
  return -sign(tangent) * distanceToLine(pointRel, tangent);
};
var ellipseParamsForTest = (element, point2, elementsMap) => {
  const [, pointRel, hwidth, hheight] = pointRelativeToElement(
    element,
    point2,
    elementsMap
  );
  const [px, py] = toTuple(pointRel);
  let tx = 0.707;
  let ty = 0.707;
  const a4 = hwidth;
  const b4 = hheight;
  [0, 1, 2, 3].forEach((_) => {
    const xx = a4 * tx;
    const yy = b4 * ty;
    const ex = (a4 * a4 - b4 * b4) * tx ** 3 / a4;
    const ey = (b4 * b4 - a4 * a4) * ty ** 3 / b4;
    const rx = xx - ex;
    const ry = yy - ey;
    const qx = px - ex;
    const qy = py - ey;
    const r3 = Math.hypot(ry, rx);
    const q = Math.hypot(qy, qx);
    tx = Math.min(1, Math.max(0, (qx * r3 / q + ex) / a4));
    ty = Math.min(1, Math.max(0, (qy * r3 / q + ey) / b4));
    const t4 = Math.hypot(ty, tx);
    tx /= t4;
    ty /= t4;
  });
  const closestPoint = point(a4 * tx, b4 * ty);
  const tangent = orthogonalThrough(pointRel, closestPoint);
  return [pointRel, tangent];
};
var hitTestFreeDrawElement = (element, point2, threshold, elementsMap) => {
  let x3;
  let y3;
  if (element.angle === 0) {
    x3 = point2[0] - element.x;
    y3 = point2[1] - element.y;
  } else {
    const [minX, minY, maxX, maxY] = getElementAbsoluteCoords(
      element,
      elementsMap
    );
    const rotatedPoint = rotatePoint(
      point2,
      [minX + (maxX - minX) / 2, minY + (maxY - minY) / 2],
      -element.angle
    );
    x3 = rotatedPoint[0] - element.x;
    y3 = rotatedPoint[1] - element.y;
  }
  let [A3, B2] = element.points;
  let P2;
  if (distance2d(A3[0], A3[1], x3, y3) < threshold || distance2d(B2[0], B2[1], x3, y3) < threshold) {
    return true;
  }
  for (let i4 = 0; i4 < element.points.length; i4++) {
    const delta = [B2[0] - A3[0], B2[1] - A3[1]];
    const length = Math.hypot(delta[1], delta[0]);
    const U = [delta[0] / length, delta[1] / length];
    const C3 = [x3 - A3[0], y3 - A3[1]];
    const d3 = (C3[0] * U[0] + C3[1] * U[1]) / Math.hypot(U[1], U[0]);
    P2 = [A3[0] + U[0] * d3, A3[1] + U[1] * d3];
    const da = distance2d(P2[0], P2[1], A3[0], A3[1]);
    const db = distance2d(P2[0], P2[1], B2[0], B2[1]);
    P2 = db < da && da > length ? B2 : da < db && db > length ? A3 : P2;
    if (Math.hypot(y3 - P2[1], x3 - P2[0]) < threshold) {
      return true;
    }
    A3 = B2;
    B2 = element.points[i4 + 1];
  }
  const shape = ShapeCache.get(element);
  if (shape && shape.sets.length) {
    return element.fillStyle === "solid" ? hitTestCurveInside(shape, x3, y3, "round") : hitTestRoughShape(shape, x3, y3, threshold);
  }
  return false;
};
var hitTestLinear = (args) => {
  const { element, threshold } = args;
  if (!ShapeCache.get(element)) {
    return false;
  }
  const [point2, pointAbs, hwidth, hheight] = pointRelativeToElement(
    args.element,
    args.point,
    args.elementsMap
  );
  const side1 = equation(0, 1, -hheight);
  const side2 = equation(1, 0, -hwidth);
  if (!isInsideCheck(distanceToLine(pointAbs, side1), threshold) || !isInsideCheck(distanceToLine(pointAbs, side2), threshold)) {
    return false;
  }
  const [relX, relY] = toTuple(point2);
  const shape = ShapeCache.get(element);
  if (!shape) {
    return false;
  }
  if (args.check === isInsideCheck) {
    const hit = shape.some(
      (subshape) => hitTestCurveInside(
        subshape,
        relX,
        relY,
        element.roundness ? "round" : "sharp"
      )
    );
    if (hit) {
      return true;
    }
  }
  return shape.some(
    (subshape) => hitTestRoughShape(subshape, relX, relY, threshold)
  );
};
var pointRelativeToElement = (element, pointTuple, elementsMap) => {
  const point2 = from(pointTuple);
  const [x1, y1, x22, y22] = getElementAbsoluteCoords(element, elementsMap);
  const center = coordsCenter(x1, y1, x22, y22);
  const rotate3 = rotation(center, element.angle);
  const pointRotated = apply(rotate3, point2);
  const pointRelToCenter = sub(pointRotated, from2(center));
  const pointRelToCenterAbs = abs(pointRelToCenter);
  const elementPos = offset(element.x, element.y);
  const pointRelToPos = sub(pointRotated, elementPos);
  const halfWidth = (x22 - x1) / 2;
  const halfHeight = (y22 - y1) / 2;
  return [pointRelToPos, pointRelToCenterAbs, halfWidth, halfHeight];
};
var pointRelativeToDivElement = (pointTuple, rectangle2) => {
  const point2 = from(pointTuple);
  const [x1, y1, x22, y22] = getRectangleBoxAbsoluteCoords(rectangle2);
  const center = coordsCenter(x1, y1, x22, y22);
  const rotate3 = rotation(center, rectangle2.angle);
  const pointRotated = apply(rotate3, point2);
  const pointRelToCenter = sub(pointRotated, from2(center));
  const pointRelToCenterAbs = abs(pointRelToCenter);
  const elementPos = offset(rectangle2.x, rectangle2.y);
  const pointRelToPos = sub(pointRotated, elementPos);
  const halfWidth = (x22 - x1) / 2;
  const halfHeight = (y22 - y1) / 2;
  return [pointRelToPos, pointRelToCenterAbs, halfWidth, halfHeight];
};
var relativizationToElementCenter = (element, elementsMap) => {
  const [x1, y1, x22, y22] = getElementAbsoluteCoords(element, elementsMap);
  const center = coordsCenter(x1, y1, x22, y22);
  const rotate3 = rotation(center, element.angle);
  const translate2 = reverse(
    translation(from2(center))
  );
  return compose(rotate3, translate2);
};
var coordsCenter = (x1, y1, x22, y22) => {
  return point((x1 + x22) / 2, (y1 + y22) / 2);
};
var determineFocusDistance = (element, a4, b4, elementsMap) => {
  const relateToCenter = relativizationToElementCenter(element, elementsMap);
  const aRel = apply(relateToCenter, from(a4));
  const bRel = apply(relateToCenter, from(b4));
  const line2 = through(aRel, bRel);
  const q = element.height / element.width;
  const hwidth = element.width / 2;
  const hheight = element.height / 2;
  const n4 = line2[2];
  const m3 = line2[3];
  const c3 = line2[1];
  const mabs = Math.abs(m3);
  const nabs = Math.abs(n4);
  let ret;
  switch (element.type) {
    case "rectangle":
    case "image":
    case "text":
    case "iframe":
    case "embeddable":
    case "frame":
    case "magicframe":
      ret = c3 / (hwidth * (nabs + q * mabs));
      break;
    case "diamond":
      ret = mabs < nabs ? c3 / (nabs * hwidth) : c3 / (mabs * hheight);
      break;
    case "ellipse":
      ret = c3 / (hwidth * Math.sqrt(n4 ** 2 + q ** 2 * m3 ** 2));
      break;
  }
  return ret || 0;
};
var determineFocusPoint = (element, focus, adjecentPoint, elementsMap) => {
  if (focus === 0) {
    const [x1, y1, x22, y22] = getElementAbsoluteCoords(element, elementsMap);
    const center = coordsCenter(x1, y1, x22, y22);
    return toTuple(center);
  }
  const relateToCenter = relativizationToElementCenter(element, elementsMap);
  const adjecentPointRel = apply(
    relateToCenter,
    from(adjecentPoint)
  );
  const reverseRelateToCenter = reverse(relateToCenter);
  let point2;
  switch (element.type) {
    case "rectangle":
    case "image":
    case "text":
    case "diamond":
    case "iframe":
    case "embeddable":
    case "frame":
    case "magicframe":
      point2 = findFocusPointForRectangulars(element, focus, adjecentPointRel);
      break;
    case "ellipse":
      point2 = findFocusPointForEllipse(element, focus, adjecentPointRel);
      break;
  }
  return toTuple(apply(reverseRelateToCenter, point2));
};
var intersectElementWithLine = (element, a4, b4, gap = 0, elementsMap) => {
  const relateToCenter = relativizationToElementCenter(element, elementsMap);
  const aRel = apply(relateToCenter, from(a4));
  const bRel = apply(relateToCenter, from(b4));
  const line2 = through(aRel, bRel);
  const reverseRelateToCenter = reverse(relateToCenter);
  const intersections = getSortedElementLineIntersections(
    element,
    line2,
    aRel,
    gap
  );
  return intersections.map(
    (point2) => toTuple(apply(reverseRelateToCenter, point2))
  );
};
var getSortedElementLineIntersections = (element, line2, nearPoint, gap = 0) => {
  let intersections;
  switch (element.type) {
    case "rectangle":
    case "image":
    case "text":
    case "diamond":
    case "iframe":
    case "embeddable":
    case "frame":
    case "magicframe":
      const corners = getCorners(element);
      intersections = corners.flatMap((point2, i4) => {
        const edge = [point2, corners[(i4 + 1) % 4]];
        return intersectSegment(line2, offsetSegment(edge, gap));
      }).concat(
        corners.flatMap((point2) => getCircleIntersections(point2, gap, line2))
      );
      break;
    case "ellipse":
      intersections = getEllipseIntersections(element, gap, line2);
      break;
  }
  if (intersections.length < 2) {
    return [];
  }
  const sortedIntersections = intersections.sort(
    (i1, i22) => distance3(i1, nearPoint) - distance3(i22, nearPoint)
  );
  return [
    sortedIntersections[0],
    sortedIntersections[sortedIntersections.length - 1]
  ];
};
var getCorners = (element, scale = 1) => {
  const hx = scale * element.width / 2;
  const hy = scale * element.height / 2;
  switch (element.type) {
    case "rectangle":
    case "image":
    case "text":
    case "iframe":
    case "embeddable":
    case "frame":
    case "magicframe":
      return [
        point(hx, hy),
        point(hx, -hy),
        point(-hx, -hy),
        point(-hx, hy)
      ];
    case "diamond":
      return [
        point(0, hy),
        point(hx, 0),
        point(0, -hy),
        point(-hx, 0)
      ];
  }
};
var intersectSegment = (line2, segment) => {
  const [a4, b4] = segment;
  const aDist = distanceToLine(a4, line2);
  const bDist = distanceToLine(b4, line2);
  if (aDist * bDist >= 0) {
    return [];
  }
  return [intersect(line2, through(a4, b4))];
};
var offsetSegment = (segment, distance5) => {
  const [a4, b4] = segment;
  const offset2 = translationOrthogonal(
    fromTo(a4, b4),
    distance5
  );
  return [apply(offset2, a4), apply(offset2, b4)];
};
var getEllipseIntersections = (element, gap, line2) => {
  const a4 = element.width / 2 + gap;
  const b4 = element.height / 2 + gap;
  const m3 = line2[2];
  const n4 = line2[3];
  const c3 = line2[1];
  const squares = a4 * a4 * m3 * m3 + b4 * b4 * n4 * n4;
  const discr = squares - c3 * c3;
  if (squares === 0 || discr <= 0) {
    return [];
  }
  const discrRoot = Math.sqrt(discr);
  const xn = -a4 * a4 * m3 * c3;
  const yn = -b4 * b4 * n4 * c3;
  return [
    point(
      (xn + a4 * b4 * n4 * discrRoot) / squares,
      (yn - a4 * b4 * m3 * discrRoot) / squares
    ),
    point(
      (xn - a4 * b4 * n4 * discrRoot) / squares,
      (yn + a4 * b4 * m3 * discrRoot) / squares
    )
  ];
};
var getCircleIntersections = (center, radius, line2) => {
  if (radius === 0) {
    return distanceToLine(line2, center) === 0 ? [center] : [];
  }
  const m3 = line2[2];
  const n4 = line2[3];
  const c3 = line2[1];
  const [a4, b4] = toTuple(center);
  const r3 = radius;
  const squares = m3 * m3 + n4 * n4;
  const discr = r3 * r3 * squares - (m3 * a4 + n4 * b4 + c3) ** 2;
  if (squares === 0 || discr <= 0) {
    return [];
  }
  const discrRoot = Math.sqrt(discr);
  const xn = a4 * n4 * n4 - b4 * m3 * n4 - m3 * c3;
  const yn = b4 * m3 * m3 - a4 * m3 * n4 - n4 * c3;
  return [
    point((xn + n4 * discrRoot) / squares, (yn - m3 * discrRoot) / squares),
    point((xn - n4 * discrRoot) / squares, (yn + m3 * discrRoot) / squares)
  ];
};
var findFocusPointForEllipse = (ellipse2, relativeDistance, point2) => {
  const relativeDistanceAbs = Math.abs(relativeDistance);
  const a4 = ellipse2.width * relativeDistanceAbs / 2;
  const b4 = ellipse2.height * relativeDistanceAbs / 2;
  const orientation = Math.sign(relativeDistance);
  const [px, pyo] = toTuple(point2);
  const py = pyo === 0 ? 1e-4 : pyo;
  const squares = px ** 2 * b4 ** 2 + py ** 2 * a4 ** 2;
  const m3 = (-px * b4 ** 2 + orientation * py * Math.sqrt(Math.max(0, squares - a4 ** 2 * b4 ** 2))) / squares;
  let n4 = (-m3 * px - 1) / py;
  if (n4 === 0) {
    n4 = (Object.is(n4, -0) ? -1 : 1) * 0.01;
  }
  const x3 = -(a4 ** 2 * m3) / (n4 ** 2 * b4 ** 2 + m3 ** 2 * a4 ** 2);
  return point(x3, (-m3 * x3 - 1) / n4);
};
var findFocusPointForRectangulars = (element, relativeDistance, point2) => {
  const relativeDistanceAbs = Math.abs(relativeDistance);
  const orientation = Math.sign(relativeDistance);
  const corners = getCorners(element, relativeDistanceAbs);
  let maxDistance = 0;
  let tangentPoint = null;
  corners.forEach((corner) => {
    const distance5 = orientation * through(point2, corner)[1];
    if (distance5 > maxDistance) {
      maxDistance = distance5;
      tangentPoint = corner;
    }
  });
  return tangentPoint;
};
var pointInBezierEquation = (p0, p1, p22, p3, [mx, my], lineThreshold) => {
  const equation2 = (t5, idx) => Math.pow(1 - t5, 3) * p3[idx] + 3 * t5 * Math.pow(1 - t5, 2) * p22[idx] + 3 * Math.pow(t5, 2) * (1 - t5) * p1[idx] + p0[idx] * Math.pow(t5, 3);
  let t4 = 0;
  while (t4 <= 1) {
    const tx = equation2(t4, 0);
    const ty = equation2(t4, 1);
    const diff = Math.sqrt(Math.pow(tx - mx, 2) + Math.pow(ty - my, 2));
    if (diff < lineThreshold) {
      return true;
    }
    t4 += 0.01;
  }
  return false;
};
var hitTestCurveInside = (drawable, x3, y3, roundness) => {
  const ops = getCurvePathOps(drawable);
  const points = [];
  let odd = false;
  for (const operation of ops) {
    if (operation.op === "move") {
      odd = !odd;
      if (odd) {
        points.push([operation.data[0], operation.data[1]]);
      }
    } else if (operation.op === "bcurveTo") {
      if (odd) {
        points.push([operation.data[0], operation.data[1]]);
        points.push([operation.data[2], operation.data[3]]);
        points.push([operation.data[4], operation.data[5]]);
      }
    } else if (operation.op === "lineTo") {
      if (odd) {
        points.push([operation.data[0], operation.data[1]]);
      }
    }
  }
  if (points.length >= 4) {
    if (roundness === "sharp") {
      return isPointInPolygon(points, x3, y3);
    }
    const polygonPoints = pointsOnBezierCurves2(points, 10, 5);
    return isPointInPolygon(polygonPoints, x3, y3);
  }
  return false;
};
var hitTestRoughShape = (drawable, x3, y3, lineThreshold) => {
  const ops = getCurvePathOps(drawable);
  let currentP = [0, 0];
  return ops.some(({ op, data }, idx) => {
    if (op === "move") {
      currentP = data;
    } else if (op === "bcurveTo") {
      const p1 = [data[0], data[1]];
      const p22 = [data[2], data[3]];
      const p3 = [data[4], data[5]];
      const p0 = currentP;
      currentP = p3;
      const retVal = pointInBezierEquation(
        p0,
        p1,
        p22,
        p3,
        [x3, y3],
        lineThreshold
      );
      return retVal;
    } else if (op === "lineTo") {
      return hitTestCurveInside(drawable, x3, y3, "sharp");
    } else if (op === "qcurveTo") {
      console.warn("qcurveTo is not implemented yet");
    }
    return false;
  });
};

// keys.ts
init_define_import_meta_env();
var CODES = {
  EQUAL: "Equal",
  MINUS: "Minus",
  NUM_ADD: "NumpadAdd",
  NUM_SUBTRACT: "NumpadSubtract",
  NUM_ZERO: "Numpad0",
  BRACKET_RIGHT: "BracketRight",
  BRACKET_LEFT: "BracketLeft",
  ONE: "Digit1",
  TWO: "Digit2",
  THREE: "Digit3",
  NINE: "Digit9",
  QUOTE: "Quote",
  ZERO: "Digit0",
  SLASH: "Slash",
  C: "KeyC",
  D: "KeyD",
  H: "KeyH",
  V: "KeyV",
  Z: "KeyZ",
  R: "KeyR",
  S: "KeyS"
};
var KEYS = {
  ARROW_DOWN: "ArrowDown",
  ARROW_LEFT: "ArrowLeft",
  ARROW_RIGHT: "ArrowRight",
  ARROW_UP: "ArrowUp",
  PAGE_UP: "PageUp",
  PAGE_DOWN: "PageDown",
  BACKSPACE: "Backspace",
  ALT: "Alt",
  CTRL_OR_CMD: isDarwin ? "metaKey" : "ctrlKey",
  DELETE: "Delete",
  ENTER: "Enter",
  ESCAPE: "Escape",
  QUESTION_MARK: "?",
  SPACE: " ",
  TAB: "Tab",
  CHEVRON_LEFT: "<",
  CHEVRON_RIGHT: ">",
  PERIOD: ".",
  COMMA: ",",
  SUBTRACT: "-",
  A: "a",
  C: "c",
  D: "d",
  E: "e",
  F: "f",
  G: "g",
  H: "h",
  I: "i",
  L: "l",
  O: "o",
  P: "p",
  Q: "q",
  R: "r",
  S: "s",
  T: "t",
  V: "v",
  X: "x",
  Y: "y",
  Z: "z",
  K: "k",
  W: "w",
  0: "0",
  1: "1",
  2: "2",
  3: "3",
  4: "4",
  5: "5",
  6: "6",
  7: "7",
  8: "8",
  9: "9"
};
var isArrowKey = (key) => key === KEYS.ARROW_LEFT || key === KEYS.ARROW_RIGHT || key === KEYS.ARROW_DOWN || key === KEYS.ARROW_UP;
var shouldResizeFromCenter = (event) => event.altKey;
var shouldMaintainAspectRatio = (event) => event.shiftKey;
var shouldRotateWithDiscreteAngle = (event) => event.shiftKey;

// element/binding.ts
var shouldEnableBindingForPointerEvent = (event) => {
  return !event[KEYS.CTRL_OR_CMD];
};
var isBindingEnabled = (appState) => {
  return appState.isBindingEnabled;
};
var getNonDeletedElements = (scene, ids) => {
  const result = [];
  ids.forEach((id) => {
    const element = scene.getNonDeletedElement(id);
    if (element != null) {
      result.push(element);
    }
  });
  return result;
};
var bindOrUnbindLinearElement = (linearElement, startBindingElement, endBindingElement, elementsMap) => {
  const boundToElementIds = /* @__PURE__ */ new Set();
  const unboundFromElementIds = /* @__PURE__ */ new Set();
  bindOrUnbindLinearElementEdge(
    linearElement,
    startBindingElement,
    endBindingElement,
    "start",
    boundToElementIds,
    unboundFromElementIds,
    elementsMap
  );
  bindOrUnbindLinearElementEdge(
    linearElement,
    endBindingElement,
    startBindingElement,
    "end",
    boundToElementIds,
    unboundFromElementIds,
    elementsMap
  );
  const onlyUnbound = Array.from(unboundFromElementIds).filter(
    (id) => !boundToElementIds.has(id)
  );
  getNonDeletedElements(Scene_default.getScene(linearElement), onlyUnbound).forEach(
    (element) => {
      mutateElement(element, {
        boundElements: element.boundElements?.filter(
          (element2) => element2.type !== "arrow" || element2.id !== linearElement.id
        )
      });
    }
  );
};
var bindOrUnbindLinearElementEdge = (linearElement, bindableElement, otherEdgeBindableElement, startOrEnd, boundToElementIds, unboundFromElementIds, elementsMap) => {
  if (bindableElement !== "keep") {
    if (bindableElement != null) {
      if (otherEdgeBindableElement == null || (otherEdgeBindableElement === "keep" ? !isLinearElementSimpleAndAlreadyBoundOnOppositeEdge(
        linearElement,
        bindableElement,
        startOrEnd
      ) : startOrEnd === "start" || otherEdgeBindableElement.id !== bindableElement.id)) {
        bindLinearElement(
          linearElement,
          bindableElement,
          startOrEnd,
          elementsMap
        );
        boundToElementIds.add(bindableElement.id);
      }
    } else {
      const unbound = unbindLinearElement(linearElement, startOrEnd);
      if (unbound != null) {
        unboundFromElementIds.add(unbound);
      }
    }
  }
};
var bindOrUnbindSelectedElements = (selectedElements, elements, elementsMap) => {
  selectedElements.forEach((selectedElement) => {
    if (isBindingElement(selectedElement)) {
      bindOrUnbindLinearElement(
        selectedElement,
        getElligibleElementForBindingElement(
          selectedElement,
          "start",
          elements,
          elementsMap
        ),
        getElligibleElementForBindingElement(
          selectedElement,
          "end",
          elements,
          elementsMap
        ),
        elementsMap
      );
    } else if (isBindableElement(selectedElement)) {
      maybeBindBindableElement(selectedElement, elementsMap);
    }
  });
};
var maybeBindBindableElement = (bindableElement, elementsMap) => {
  getElligibleElementsForBindableElementAndWhere(
    bindableElement,
    elementsMap
  ).forEach(
    ([linearElement, where]) => bindOrUnbindLinearElement(
      linearElement,
      where === "end" ? "keep" : bindableElement,
      where === "start" ? "keep" : bindableElement,
      elementsMap
    )
  );
};
var maybeBindLinearElement = (linearElement, appState, scene, pointerCoords, elementsMap) => {
  if (appState.startBoundElement != null) {
    bindLinearElement(
      linearElement,
      appState.startBoundElement,
      "start",
      elementsMap
    );
  }
  const hoveredElement = getHoveredElementForBinding(
    pointerCoords,
    scene.getNonDeletedElements(),
    elementsMap
  );
  if (hoveredElement != null && !isLinearElementSimpleAndAlreadyBoundOnOppositeEdge(
    linearElement,
    hoveredElement,
    "end"
  )) {
    bindLinearElement(linearElement, hoveredElement, "end", elementsMap);
  }
};
var bindLinearElement = (linearElement, hoveredElement, startOrEnd, elementsMap) => {
  mutateElement(linearElement, {
    [startOrEnd === "start" ? "startBinding" : "endBinding"]: {
      elementId: hoveredElement.id,
      ...calculateFocusAndGap(
        linearElement,
        hoveredElement,
        startOrEnd,
        elementsMap
      )
    }
  });
  const boundElementsMap = arrayToMap(hoveredElement.boundElements || []);
  if (!boundElementsMap.has(linearElement.id)) {
    mutateElement(hoveredElement, {
      boundElements: (hoveredElement.boundElements || []).concat({
        id: linearElement.id,
        type: "arrow"
      })
    });
  }
};
var isLinearElementSimpleAndAlreadyBoundOnOppositeEdge = (linearElement, bindableElement, startOrEnd) => {
  const otherBinding = linearElement[startOrEnd === "start" ? "endBinding" : "startBinding"];
  return isLinearElementSimpleAndAlreadyBound(
    linearElement,
    otherBinding?.elementId,
    bindableElement
  );
};
var isLinearElementSimpleAndAlreadyBound = (linearElement, alreadyBoundToId, bindableElement) => {
  return alreadyBoundToId === bindableElement.id && linearElement.points.length < 3;
};
var unbindLinearElements = (elements, elementsMap) => {
  elements.forEach((element) => {
    if (isBindingElement(element)) {
      bindOrUnbindLinearElement(element, null, null, elementsMap);
    }
  });
};
var unbindLinearElement = (linearElement, startOrEnd) => {
  const field = startOrEnd === "start" ? "startBinding" : "endBinding";
  const binding = linearElement[field];
  if (binding == null) {
    return null;
  }
  mutateElement(linearElement, { [field]: null });
  return binding.elementId;
};
var getHoveredElementForBinding = (pointerCoords, elements, elementsMap) => {
  const hoveredElement = getElementAtPosition(
    elements,
    (element) => isBindableElement(element, false) && bindingBorderTest(element, pointerCoords, elementsMap)
  );
  return hoveredElement;
};
var calculateFocusAndGap = (linearElement, hoveredElement, startOrEnd, elementsMap) => {
  const direction = startOrEnd === "start" ? -1 : 1;
  const edgePointIndex = direction === -1 ? 0 : linearElement.points.length - 1;
  const adjacentPointIndex = edgePointIndex - direction;
  const edgePoint = LinearElementEditor.getPointAtIndexGlobalCoordinates(
    linearElement,
    edgePointIndex,
    elementsMap
  );
  const adjacentPoint = LinearElementEditor.getPointAtIndexGlobalCoordinates(
    linearElement,
    adjacentPointIndex,
    elementsMap
  );
  return {
    focus: determineFocusDistance(
      hoveredElement,
      adjacentPoint,
      edgePoint,
      elementsMap
    ),
    gap: Math.max(
      1,
      distanceToBindableElement(hoveredElement, edgePoint, elementsMap)
    )
  };
};
var updateBoundElements = (changedElement, elementsMap, options) => {
  const boundLinearElements = (changedElement.boundElements ?? []).filter(
    (el) => el.type === "arrow"
  );
  if (boundLinearElements.length === 0) {
    return;
  }
  const { newSize, simultaneouslyUpdated } = options ?? {};
  const simultaneouslyUpdatedElementIds = getSimultaneouslyUpdatedElementIds(
    simultaneouslyUpdated
  );
  const scene = Scene_default.getScene(changedElement);
  getNonDeletedElements(
    scene,
    boundLinearElements.map((el) => el.id)
  ).forEach((element) => {
    if (!isLinearElement(element)) {
      return;
    }
    const bindableElement = changedElement;
    if (!doesNeedUpdate(element, bindableElement)) {
      return;
    }
    const startBinding = maybeCalculateNewGapWhenScaling(
      bindableElement,
      element.startBinding,
      newSize
    );
    const endBinding = maybeCalculateNewGapWhenScaling(
      bindableElement,
      element.endBinding,
      newSize
    );
    if (simultaneouslyUpdatedElementIds.has(element.id)) {
      mutateElement(element, { startBinding, endBinding });
      return;
    }
    updateBoundPoint(
      element,
      "start",
      startBinding,
      changedElement,
      elementsMap
    );
    updateBoundPoint(
      element,
      "end",
      endBinding,
      changedElement,
      elementsMap
    );
    const boundText = getBoundTextElement(
      element,
      scene.getNonDeletedElementsMap()
    );
    if (boundText) {
      handleBindTextResize(element, scene.getNonDeletedElementsMap(), false);
    }
  });
};
var doesNeedUpdate = (boundElement, changedElement) => {
  return boundElement.startBinding?.elementId === changedElement.id || boundElement.endBinding?.elementId === changedElement.id;
};
var getSimultaneouslyUpdatedElementIds = (simultaneouslyUpdated) => {
  return new Set((simultaneouslyUpdated || []).map((element) => element.id));
};
var updateBoundPoint = (linearElement, startOrEnd, binding, changedElement, elementsMap) => {
  if (binding == null || // We only need to update the other end if this is a 2 point line element
  binding.elementId !== changedElement.id && linearElement.points.length > 2) {
    return;
  }
  const bindingElement = Scene_default.getScene(linearElement).getElement(
    binding.elementId
  );
  if (bindingElement == null) {
    return;
  }
  const direction = startOrEnd === "start" ? -1 : 1;
  const edgePointIndex = direction === -1 ? 0 : linearElement.points.length - 1;
  const adjacentPointIndex = edgePointIndex - direction;
  const adjacentPoint = LinearElementEditor.getPointAtIndexGlobalCoordinates(
    linearElement,
    adjacentPointIndex,
    elementsMap
  );
  const focusPointAbsolute = determineFocusPoint(
    bindingElement,
    binding.focus,
    adjacentPoint,
    elementsMap
  );
  let newEdgePoint;
  if (binding.gap === 0) {
    newEdgePoint = focusPointAbsolute;
  } else {
    const intersections = intersectElementWithLine(
      bindingElement,
      adjacentPoint,
      focusPointAbsolute,
      binding.gap,
      elementsMap
    );
    if (intersections.length === 0) {
      newEdgePoint = focusPointAbsolute;
    } else {
      newEdgePoint = intersections[0];
    }
  }
  LinearElementEditor.movePoints(
    linearElement,
    [
      {
        index: edgePointIndex,
        point: LinearElementEditor.pointFromAbsoluteCoords(
          linearElement,
          newEdgePoint,
          elementsMap
        )
      }
    ],
    { [startOrEnd === "start" ? "startBinding" : "endBinding"]: binding }
  );
};
var maybeCalculateNewGapWhenScaling = (changedElement, currentBinding, newSize) => {
  if (currentBinding == null || newSize == null) {
    return currentBinding;
  }
  const { gap, focus, elementId } = currentBinding;
  const { width: newWidth, height: newHeight } = newSize;
  const { width, height } = changedElement;
  const newGap = Math.max(
    1,
    Math.min(
      maxBindingGap(changedElement, newWidth, newHeight),
      gap * (newWidth < newHeight ? newWidth / width : newHeight / height)
    )
  );
  return { elementId, gap: newGap, focus };
};
var getEligibleElementsForBinding = (selectedElements, elements, elementsMap) => {
  const includedElementIds = new Set(selectedElements.map(({ id }) => id));
  return selectedElements.flatMap(
    (selectedElement) => isBindingElement(selectedElement, false) ? getElligibleElementsForBindingElement(
      selectedElement,
      elements,
      elementsMap
    ).filter(
      (element) => !includedElementIds.has(element.id)
    ) : isBindableElement(selectedElement, false) ? getElligibleElementsForBindableElementAndWhere(
      selectedElement,
      elementsMap
    ).filter((binding) => !includedElementIds.has(binding[0].id)) : []
  );
};
var getElligibleElementsForBindingElement = (linearElement, elements, elementsMap) => {
  return [
    getElligibleElementForBindingElement(
      linearElement,
      "start",
      elements,
      elementsMap
    ),
    getElligibleElementForBindingElement(
      linearElement,
      "end",
      elements,
      elementsMap
    )
  ].filter(
    (element) => element != null
  );
};
var getElligibleElementForBindingElement = (linearElement, startOrEnd, elements, elementsMap) => {
  return getHoveredElementForBinding(
    getLinearElementEdgeCoors(linearElement, startOrEnd, elementsMap),
    elements,
    elementsMap
  );
};
var getLinearElementEdgeCoors = (linearElement, startOrEnd, elementsMap) => {
  const index2 = startOrEnd === "start" ? 0 : -1;
  return tupleToCoors(
    LinearElementEditor.getPointAtIndexGlobalCoordinates(
      linearElement,
      index2,
      elementsMap
    )
  );
};
var getElligibleElementsForBindableElementAndWhere = (bindableElement, elementsMap) => {
  const scene = Scene_default.getScene(bindableElement);
  return scene.getNonDeletedElements().map((element) => {
    if (!isBindingElement(element, false)) {
      return null;
    }
    const canBindStart = isLinearElementEligibleForNewBindingByBindable(
      element,
      "start",
      bindableElement,
      elementsMap
    );
    const canBindEnd = isLinearElementEligibleForNewBindingByBindable(
      element,
      "end",
      bindableElement,
      elementsMap
    );
    if (!canBindStart && !canBindEnd) {
      return null;
    }
    return [
      element,
      canBindStart && canBindEnd ? "both" : canBindStart ? "start" : "end",
      bindableElement
    ];
  }).filter((maybeElement) => maybeElement != null);
};
var isLinearElementEligibleForNewBindingByBindable = (linearElement, startOrEnd, bindableElement, elementsMap) => {
  const existingBinding = linearElement[startOrEnd === "start" ? "startBinding" : "endBinding"];
  return existingBinding == null && !isLinearElementSimpleAndAlreadyBoundOnOppositeEdge(
    linearElement,
    bindableElement,
    startOrEnd
  ) && bindingBorderTest(
    bindableElement,
    getLinearElementEdgeCoors(linearElement, startOrEnd, elementsMap),
    elementsMap
  );
};
var fixBindingsAfterDuplication = (sceneElements, oldElements, oldIdToDuplicatedId, duplicatesServeAsOld) => {
  const allBoundElementIds = /* @__PURE__ */ new Set();
  const allBindableElementIds = /* @__PURE__ */ new Set();
  const shouldReverseRoles = duplicatesServeAsOld === "duplicatesServeAsOld";
  oldElements.forEach((oldElement) => {
    const { boundElements } = oldElement;
    if (boundElements != null && boundElements.length > 0) {
      boundElements.forEach((boundElement) => {
        if (shouldReverseRoles && !oldIdToDuplicatedId.has(boundElement.id)) {
          allBoundElementIds.add(boundElement.id);
        }
      });
      allBindableElementIds.add(oldIdToDuplicatedId.get(oldElement.id));
    }
    if (isBindingElement(oldElement)) {
      if (oldElement.startBinding != null) {
        const { elementId } = oldElement.startBinding;
        if (shouldReverseRoles && !oldIdToDuplicatedId.has(elementId)) {
          allBindableElementIds.add(elementId);
        }
      }
      if (oldElement.endBinding != null) {
        const { elementId } = oldElement.endBinding;
        if (shouldReverseRoles && !oldIdToDuplicatedId.has(elementId)) {
          allBindableElementIds.add(elementId);
        }
      }
      if (oldElement.startBinding != null || oldElement.endBinding != null) {
        allBoundElementIds.add(oldIdToDuplicatedId.get(oldElement.id));
      }
    }
  });
  sceneElements.filter(
    ({ id }) => allBoundElementIds.has(id)
  ).forEach((element) => {
    const { startBinding, endBinding } = element;
    mutateElement(element, {
      startBinding: newBindingAfterDuplication(
        startBinding,
        oldIdToDuplicatedId
      ),
      endBinding: newBindingAfterDuplication(endBinding, oldIdToDuplicatedId)
    });
  });
  sceneElements.filter(({ id }) => allBindableElementIds.has(id)).forEach((bindableElement) => {
    const { boundElements } = bindableElement;
    if (boundElements != null && boundElements.length > 0) {
      mutateElement(bindableElement, {
        boundElements: boundElements.map(
          (boundElement) => oldIdToDuplicatedId.has(boundElement.id) ? {
            id: oldIdToDuplicatedId.get(boundElement.id),
            type: boundElement.type
          } : boundElement
        )
      });
    }
  });
};
var newBindingAfterDuplication = (binding, oldIdToDuplicatedId) => {
  if (binding == null) {
    return null;
  }
  const { elementId, focus, gap } = binding;
  return {
    focus,
    gap,
    elementId: oldIdToDuplicatedId.get(elementId) ?? elementId
  };
};
var fixBindingsAfterDeletion = (sceneElements, deletedElements) => {
  const deletedElementIds = new Set(
    deletedElements.map((element) => element.id)
  );
  const affectedElements = /* @__PURE__ */ new Set();
  deletedElements.forEach((deletedElement) => {
    if (isBindableElement(deletedElement)) {
      deletedElement.boundElements?.forEach((element) => {
        if (!deletedElementIds.has(element.id)) {
          affectedElements.add(element.id);
        }
      });
    } else if (isBindingElement(deletedElement)) {
      if (deletedElement.startBinding) {
        affectedElements.add(deletedElement.startBinding.elementId);
      }
      if (deletedElement.endBinding) {
        affectedElements.add(deletedElement.endBinding.elementId);
      }
    }
  });
  sceneElements.filter(({ id }) => affectedElements.has(id)).forEach((element) => {
    if (isBindableElement(element)) {
      mutateElement(element, {
        boundElements: newBoundElementsAfterDeletion(
          element.boundElements,
          deletedElementIds
        )
      });
    } else if (isBindingElement(element)) {
      mutateElement(element, {
        startBinding: newBindingAfterDeletion(
          element.startBinding,
          deletedElementIds
        ),
        endBinding: newBindingAfterDeletion(
          element.endBinding,
          deletedElementIds
        )
      });
    }
  });
};
var newBindingAfterDeletion = (binding, deletedElementIds) => {
  if (binding == null || deletedElementIds.has(binding.elementId)) {
    return null;
  }
  return binding;
};
var newBoundElementsAfterDeletion = (boundElements, deletedElementIds) => {
  if (!boundElements) {
    return null;
  }
  return boundElements.filter((ele) => !deletedElementIds.has(ele.id));
};

// element/linearElementEditor.ts
var editorMidPointsCache = { version: null, points: [], zoom: null };
var LinearElementEditor = class _LinearElementEditor {
  elementId;
  /** indices */
  selectedPointsIndices;
  pointerDownState;
  /** whether you're dragging a point */
  isDragging;
  lastUncommittedPoint;
  pointerOffset;
  startBindingElement;
  endBindingElement;
  hoverPointIndex;
  segmentMidPointHoveredCoords;
  constructor(element) {
    this.elementId = element.id;
    _LinearElementEditor.normalizePoints(element);
    this.selectedPointsIndices = null;
    this.lastUncommittedPoint = null;
    this.isDragging = false;
    this.pointerOffset = { x: 0, y: 0 };
    this.startBindingElement = "keep";
    this.endBindingElement = "keep";
    this.pointerDownState = {
      prevSelectedPointsIndices: null,
      lastClickedPoint: -1,
      origin: null,
      segmentMidpoint: {
        value: null,
        index: null,
        added: false
      }
    };
    this.hoverPointIndex = -1;
    this.segmentMidPointHoveredCoords = null;
  }
  // ---------------------------------------------------------------------------
  // static methods
  // ---------------------------------------------------------------------------
  static POINT_HANDLE_SIZE = 10;
  /**
   * @param id the `elementId` from the instance of this class (so that we can
   *  statically guarantee this method returns an ExcalidrawLinearElement)
   */
  static getElement(id, elementsMap) {
    const element = elementsMap.get(id);
    if (element) {
      return element;
    }
    return null;
  }
  static handleBoxSelection(event, appState, setState, elementsMap) {
    if (!appState.editingLinearElement || appState.draggingElement?.type !== "selection") {
      return false;
    }
    const { editingLinearElement } = appState;
    const { selectedPointsIndices, elementId } = editingLinearElement;
    const element = _LinearElementEditor.getElement(elementId, elementsMap);
    if (!element) {
      return false;
    }
    const [selectionX1, selectionY1, selectionX2, selectionY2] = getElementAbsoluteCoords(appState.draggingElement, elementsMap);
    const pointsSceneCoords = _LinearElementEditor.getPointsGlobalCoordinates(
      element,
      elementsMap
    );
    const nextSelectedPoints = pointsSceneCoords.reduce(
      (acc, point2, index2) => {
        if (point2[0] >= selectionX1 && point2[0] <= selectionX2 && point2[1] >= selectionY1 && point2[1] <= selectionY2 || event.shiftKey && selectedPointsIndices?.includes(index2)) {
          acc.push(index2);
        }
        return acc;
      },
      []
    );
    setState({
      editingLinearElement: {
        ...editingLinearElement,
        selectedPointsIndices: nextSelectedPoints.length ? nextSelectedPoints : null
      }
    });
  }
  /** @returns whether point was dragged */
  static handlePointDragging(event, appState, scenePointerX, scenePointerY, maybeSuggestBinding, linearElementEditor, elementsMap) {
    if (!linearElementEditor) {
      return false;
    }
    const { selectedPointsIndices, elementId } = linearElementEditor;
    const element = _LinearElementEditor.getElement(elementId, elementsMap);
    if (!element) {
      return false;
    }
    const draggingPoint = element.points[linearElementEditor.pointerDownState.lastClickedPoint];
    if (selectedPointsIndices && draggingPoint) {
      if (shouldRotateWithDiscreteAngle(event) && selectedPointsIndices.length === 1 && element.points.length > 1) {
        const selectedIndex = selectedPointsIndices[0];
        const referencePoint = element.points[selectedIndex === 0 ? 1 : selectedIndex - 1];
        const [width, height] = _LinearElementEditor._getShiftLockedDelta(
          element,
          elementsMap,
          referencePoint,
          [scenePointerX, scenePointerY],
          event[KEYS.CTRL_OR_CMD] ? null : appState.gridSize
        );
        _LinearElementEditor.movePoints(element, [
          {
            index: selectedIndex,
            point: [width + referencePoint[0], height + referencePoint[1]],
            isDragging: selectedIndex === linearElementEditor.pointerDownState.lastClickedPoint
          }
        ]);
      } else {
        const newDraggingPointPosition = _LinearElementEditor.createPointAt(
          element,
          elementsMap,
          scenePointerX - linearElementEditor.pointerOffset.x,
          scenePointerY - linearElementEditor.pointerOffset.y,
          event[KEYS.CTRL_OR_CMD] ? null : appState.gridSize
        );
        const deltaX = newDraggingPointPosition[0] - draggingPoint[0];
        const deltaY = newDraggingPointPosition[1] - draggingPoint[1];
        _LinearElementEditor.movePoints(
          element,
          selectedPointsIndices.map((pointIndex) => {
            const newPointPosition = pointIndex === linearElementEditor.pointerDownState.lastClickedPoint ? _LinearElementEditor.createPointAt(
              element,
              elementsMap,
              scenePointerX - linearElementEditor.pointerOffset.x,
              scenePointerY - linearElementEditor.pointerOffset.y,
              event[KEYS.CTRL_OR_CMD] ? null : appState.gridSize
            ) : [
              element.points[pointIndex][0] + deltaX,
              element.points[pointIndex][1] + deltaY
            ];
            return {
              index: pointIndex,
              point: newPointPosition,
              isDragging: pointIndex === linearElementEditor.pointerDownState.lastClickedPoint
            };
          })
        );
      }
      const boundTextElement = getBoundTextElement(element, elementsMap);
      if (boundTextElement) {
        handleBindTextResize(element, elementsMap, false);
      }
      if (isBindingElement(element, false)) {
        const coords = [];
        const firstSelectedIndex = selectedPointsIndices[0];
        if (firstSelectedIndex === 0) {
          coords.push(
            tupleToCoors(
              _LinearElementEditor.getPointGlobalCoordinates(
                element,
                element.points[0],
                elementsMap
              )
            )
          );
        }
        const lastSelectedIndex = selectedPointsIndices[selectedPointsIndices.length - 1];
        if (lastSelectedIndex === element.points.length - 1) {
          coords.push(
            tupleToCoors(
              _LinearElementEditor.getPointGlobalCoordinates(
                element,
                element.points[lastSelectedIndex],
                elementsMap
              )
            )
          );
        }
        if (coords.length) {
          maybeSuggestBinding(element, coords);
        }
      }
      return true;
    }
    return false;
  }
  static handlePointerUp(event, editingLinearElement, appState, elements, elementsMap) {
    const { elementId, selectedPointsIndices, isDragging, pointerDownState } = editingLinearElement;
    const element = _LinearElementEditor.getElement(elementId, elementsMap);
    if (!element) {
      return editingLinearElement;
    }
    const bindings = {};
    if (isDragging && selectedPointsIndices) {
      for (const selectedPoint of selectedPointsIndices) {
        if (selectedPoint === 0 || selectedPoint === element.points.length - 1) {
          if (isPathALoop(element.points, appState.zoom.value)) {
            _LinearElementEditor.movePoints(element, [
              {
                index: selectedPoint,
                point: selectedPoint === 0 ? element.points[element.points.length - 1] : element.points[0]
              }
            ]);
          }
          const bindingElement = isBindingEnabled(appState) ? getHoveredElementForBinding(
            tupleToCoors(
              _LinearElementEditor.getPointAtIndexGlobalCoordinates(
                element,
                selectedPoint,
                elementsMap
              )
            ),
            elements,
            elementsMap
          ) : null;
          bindings[selectedPoint === 0 ? "startBindingElement" : "endBindingElement"] = bindingElement;
        }
      }
    }
    return {
      ...editingLinearElement,
      ...bindings,
      // if clicking without previously dragging a point(s), and not holding
      // shift, deselect all points except the one clicked. If holding shift,
      // toggle the point.
      selectedPointsIndices: isDragging || event.shiftKey ? !isDragging && event.shiftKey && pointerDownState.prevSelectedPointsIndices?.includes(
        pointerDownState.lastClickedPoint
      ) ? selectedPointsIndices && selectedPointsIndices.filter(
        (pointIndex) => pointIndex !== pointerDownState.lastClickedPoint
      ) : selectedPointsIndices : selectedPointsIndices?.includes(pointerDownState.lastClickedPoint) ? [pointerDownState.lastClickedPoint] : selectedPointsIndices,
      isDragging: false,
      pointerOffset: { x: 0, y: 0 }
    };
  }
  static getEditorMidPoints = (element, elementsMap, appState) => {
    const boundText = getBoundTextElement(element, elementsMap);
    if (!appState.editingLinearElement && element.points.length > 2 && !boundText) {
      return [];
    }
    if (editorMidPointsCache.version === element.version && editorMidPointsCache.zoom === appState.zoom.value) {
      return editorMidPointsCache.points;
    }
    _LinearElementEditor.updateEditorMidPointsCache(
      element,
      elementsMap,
      appState
    );
    return editorMidPointsCache.points;
  };
  static updateEditorMidPointsCache = (element, elementsMap, appState) => {
    const points = _LinearElementEditor.getPointsGlobalCoordinates(
      element,
      elementsMap
    );
    let index2 = 0;
    const midpoints = [];
    while (index2 < points.length - 1) {
      if (_LinearElementEditor.isSegmentTooShort(
        element,
        element.points[index2],
        element.points[index2 + 1],
        appState.zoom
      )) {
        midpoints.push(null);
        index2++;
        continue;
      }
      const segmentMidPoint = _LinearElementEditor.getSegmentMidPoint(
        element,
        points[index2],
        points[index2 + 1],
        index2 + 1,
        elementsMap
      );
      midpoints.push(segmentMidPoint);
      index2++;
    }
    editorMidPointsCache.points = midpoints;
    editorMidPointsCache.version = element.version;
    editorMidPointsCache.zoom = appState.zoom.value;
  };
  static getSegmentMidpointHitCoords = (linearElementEditor, scenePointer, appState, elementsMap) => {
    const { elementId } = linearElementEditor;
    const element = _LinearElementEditor.getElement(elementId, elementsMap);
    if (!element) {
      return null;
    }
    const clickedPointIndex = _LinearElementEditor.getPointIndexUnderCursor(
      element,
      elementsMap,
      appState.zoom,
      scenePointer.x,
      scenePointer.y
    );
    if (clickedPointIndex >= 0) {
      return null;
    }
    const points = _LinearElementEditor.getPointsGlobalCoordinates(
      element,
      elementsMap
    );
    if (points.length >= 3 && !appState.editingLinearElement) {
      return null;
    }
    const threshold = _LinearElementEditor.POINT_HANDLE_SIZE / appState.zoom.value;
    const existingSegmentMidpointHitCoords = linearElementEditor.segmentMidPointHoveredCoords;
    if (existingSegmentMidpointHitCoords) {
      const distance5 = distance2d(
        existingSegmentMidpointHitCoords[0],
        existingSegmentMidpointHitCoords[1],
        scenePointer.x,
        scenePointer.y
      );
      if (distance5 <= threshold) {
        return existingSegmentMidpointHitCoords;
      }
    }
    let index2 = 0;
    const midPoints = _LinearElementEditor.getEditorMidPoints(element, elementsMap, appState);
    while (index2 < midPoints.length) {
      if (midPoints[index2] !== null) {
        const distance5 = distance2d(
          midPoints[index2][0],
          midPoints[index2][1],
          scenePointer.x,
          scenePointer.y
        );
        if (distance5 <= threshold) {
          return midPoints[index2];
        }
      }
      index2++;
    }
    return null;
  };
  static isSegmentTooShort(element, startPoint, endPoint, zoom) {
    let distance5 = distance2d(
      startPoint[0],
      startPoint[1],
      endPoint[0],
      endPoint[1]
    );
    if (element.points.length > 2 && element.roundness) {
      distance5 = getBezierCurveLength(element, endPoint);
    }
    return distance5 * zoom.value < _LinearElementEditor.POINT_HANDLE_SIZE * 4;
  }
  static getSegmentMidPoint(element, startPoint, endPoint, endPointIndex, elementsMap) {
    let segmentMidPoint = centerPoint(startPoint, endPoint);
    if (element.points.length > 2 && element.roundness) {
      const controlPoints = getControlPointsForBezierCurve(
        element,
        element.points[endPointIndex]
      );
      if (controlPoints) {
        const t4 = mapIntervalToBezierT(
          element,
          element.points[endPointIndex],
          0.5
        );
        const [tx, ty] = getBezierXY(
          controlPoints[0],
          controlPoints[1],
          controlPoints[2],
          controlPoints[3],
          t4
        );
        segmentMidPoint = _LinearElementEditor.getPointGlobalCoordinates(
          element,
          [tx, ty],
          elementsMap
        );
      }
    }
    return segmentMidPoint;
  }
  static getSegmentMidPointIndex(linearElementEditor, appState, midPoint, elementsMap) {
    const element = _LinearElementEditor.getElement(
      linearElementEditor.elementId,
      elementsMap
    );
    if (!element) {
      return -1;
    }
    const midPoints = _LinearElementEditor.getEditorMidPoints(
      element,
      elementsMap,
      appState
    );
    let index2 = 0;
    while (index2 < midPoints.length) {
      if (_LinearElementEditor.arePointsEqual(midPoint, midPoints[index2])) {
        return index2 + 1;
      }
      index2++;
    }
    return -1;
  }
  static handlePointerDown(event, appState, history, scenePointer, linearElementEditor, elements, elementsMap) {
    const ret = {
      didAddPoint: false,
      hitElement: null,
      linearElementEditor: null
    };
    if (!linearElementEditor) {
      return ret;
    }
    const { elementId } = linearElementEditor;
    const element = _LinearElementEditor.getElement(elementId, elementsMap);
    if (!element) {
      return ret;
    }
    const segmentMidpoint = _LinearElementEditor.getSegmentMidpointHitCoords(
      linearElementEditor,
      scenePointer,
      appState,
      elementsMap
    );
    let segmentMidpointIndex = null;
    if (segmentMidpoint) {
      segmentMidpointIndex = _LinearElementEditor.getSegmentMidPointIndex(
        linearElementEditor,
        appState,
        segmentMidpoint,
        elementsMap
      );
    }
    if (event.altKey && appState.editingLinearElement) {
      if (linearElementEditor.lastUncommittedPoint == null) {
        mutateElement(element, {
          points: [
            ...element.points,
            _LinearElementEditor.createPointAt(
              element,
              elementsMap,
              scenePointer.x,
              scenePointer.y,
              event[KEYS.CTRL_OR_CMD] ? null : appState.gridSize
            )
          ]
        });
        ret.didAddPoint = true;
      }
      history.resumeRecording();
      ret.linearElementEditor = {
        ...linearElementEditor,
        pointerDownState: {
          prevSelectedPointsIndices: linearElementEditor.selectedPointsIndices,
          lastClickedPoint: -1,
          origin: { x: scenePointer.x, y: scenePointer.y },
          segmentMidpoint: {
            value: segmentMidpoint,
            index: segmentMidpointIndex,
            added: false
          }
        },
        selectedPointsIndices: [element.points.length - 1],
        lastUncommittedPoint: null,
        endBindingElement: getHoveredElementForBinding(
          scenePointer,
          elements,
          elementsMap
        )
      };
      ret.didAddPoint = true;
      return ret;
    }
    const clickedPointIndex = _LinearElementEditor.getPointIndexUnderCursor(
      element,
      elementsMap,
      appState.zoom,
      scenePointer.x,
      scenePointer.y
    );
    if (clickedPointIndex >= 0 || segmentMidpoint) {
      ret.hitElement = element;
    } else {
      const { startBindingElement, endBindingElement } = linearElementEditor;
      if (isBindingEnabled(appState) && isBindingElement(element)) {
        bindOrUnbindLinearElement(
          element,
          startBindingElement,
          endBindingElement,
          elementsMap
        );
      }
    }
    const [x1, y1, x22, y22] = getElementAbsoluteCoords(element, elementsMap);
    const cx = (x1 + x22) / 2;
    const cy = (y1 + y22) / 2;
    const targetPoint = clickedPointIndex > -1 && rotate2(
      element.x + element.points[clickedPointIndex][0],
      element.y + element.points[clickedPointIndex][1],
      cx,
      cy,
      element.angle
    );
    const nextSelectedPointsIndices = clickedPointIndex > -1 || event.shiftKey ? event.shiftKey || linearElementEditor.selectedPointsIndices?.includes(clickedPointIndex) ? normalizeSelectedPoints([
      ...linearElementEditor.selectedPointsIndices || [],
      clickedPointIndex
    ]) : [clickedPointIndex] : null;
    ret.linearElementEditor = {
      ...linearElementEditor,
      pointerDownState: {
        prevSelectedPointsIndices: linearElementEditor.selectedPointsIndices,
        lastClickedPoint: clickedPointIndex,
        origin: { x: scenePointer.x, y: scenePointer.y },
        segmentMidpoint: {
          value: segmentMidpoint,
          index: segmentMidpointIndex,
          added: false
        }
      },
      selectedPointsIndices: nextSelectedPointsIndices,
      pointerOffset: targetPoint ? {
        x: scenePointer.x - targetPoint[0],
        y: scenePointer.y - targetPoint[1]
      } : { x: 0, y: 0 }
    };
    return ret;
  }
  static arePointsEqual(point1, point2) {
    if (!point1 && !point2) {
      return true;
    }
    if (!point1 || !point2) {
      return false;
    }
    return arePointsEqual(point1, point2);
  }
  static handlePointerMove(event, scenePointerX, scenePointerY, appState, elementsMap) {
    if (!appState.editingLinearElement) {
      return null;
    }
    const { elementId, lastUncommittedPoint } = appState.editingLinearElement;
    const element = _LinearElementEditor.getElement(elementId, elementsMap);
    if (!element) {
      return appState.editingLinearElement;
    }
    const { points } = element;
    const lastPoint = points[points.length - 1];
    if (!event.altKey) {
      if (lastPoint === lastUncommittedPoint) {
        _LinearElementEditor.deletePoints(element, [points.length - 1]);
      }
      return {
        ...appState.editingLinearElement,
        lastUncommittedPoint: null
      };
    }
    let newPoint;
    if (shouldRotateWithDiscreteAngle(event) && points.length >= 2) {
      const lastCommittedPoint = points[points.length - 2];
      const [width, height] = _LinearElementEditor._getShiftLockedDelta(
        element,
        elementsMap,
        lastCommittedPoint,
        [scenePointerX, scenePointerY],
        event[KEYS.CTRL_OR_CMD] ? null : appState.gridSize
      );
      newPoint = [
        width + lastCommittedPoint[0],
        height + lastCommittedPoint[1]
      ];
    } else {
      newPoint = _LinearElementEditor.createPointAt(
        element,
        elementsMap,
        scenePointerX - appState.editingLinearElement.pointerOffset.x,
        scenePointerY - appState.editingLinearElement.pointerOffset.y,
        event[KEYS.CTRL_OR_CMD] ? null : appState.gridSize
      );
    }
    if (lastPoint === lastUncommittedPoint) {
      _LinearElementEditor.movePoints(element, [
        {
          index: element.points.length - 1,
          point: newPoint
        }
      ]);
    } else {
      _LinearElementEditor.addPoints(element, appState, [{ point: newPoint }]);
    }
    return {
      ...appState.editingLinearElement,
      lastUncommittedPoint: element.points[element.points.length - 1]
    };
  }
  /** scene coords */
  static getPointGlobalCoordinates(element, point2, elementsMap) {
    const [x1, y1, x22, y22] = getElementAbsoluteCoords(element, elementsMap);
    const cx = (x1 + x22) / 2;
    const cy = (y1 + y22) / 2;
    let { x: x3, y: y3 } = element;
    [x3, y3] = rotate2(x3 + point2[0], y3 + point2[1], cx, cy, element.angle);
    return [x3, y3];
  }
  /** scene coords */
  static getPointsGlobalCoordinates(element, elementsMap) {
    const [x1, y1, x22, y22] = getElementAbsoluteCoords(element, elementsMap);
    const cx = (x1 + x22) / 2;
    const cy = (y1 + y22) / 2;
    return element.points.map((point2) => {
      let { x: x3, y: y3 } = element;
      [x3, y3] = rotate2(x3 + point2[0], y3 + point2[1], cx, cy, element.angle);
      return [x3, y3];
    });
  }
  static getPointAtIndexGlobalCoordinates(element, indexMaybeFromEnd, elementsMap) {
    const index2 = indexMaybeFromEnd < 0 ? element.points.length + indexMaybeFromEnd : indexMaybeFromEnd;
    const [x1, y1, x22, y22] = getElementAbsoluteCoords(element, elementsMap);
    const cx = (x1 + x22) / 2;
    const cy = (y1 + y22) / 2;
    const point2 = element.points[index2];
    const { x: x3, y: y3 } = element;
    return point2 ? rotate2(x3 + point2[0], y3 + point2[1], cx, cy, element.angle) : rotate2(x3, y3, cx, cy, element.angle);
  }
  static pointFromAbsoluteCoords(element, absoluteCoords, elementsMap) {
    const [x1, y1, x22, y22] = getElementAbsoluteCoords(element, elementsMap);
    const cx = (x1 + x22) / 2;
    const cy = (y1 + y22) / 2;
    const [x3, y3] = rotate2(
      absoluteCoords[0],
      absoluteCoords[1],
      cx,
      cy,
      -element.angle
    );
    return [x3 - element.x, y3 - element.y];
  }
  static getPointIndexUnderCursor(element, elementsMap, zoom, x3, y3) {
    const pointHandles = _LinearElementEditor.getPointsGlobalCoordinates(
      element,
      elementsMap
    );
    let idx = pointHandles.length;
    while (--idx > -1) {
      const point2 = pointHandles[idx];
      if (distance2d(x3, y3, point2[0], point2[1]) * zoom.value < // +1px to account for outline stroke
      _LinearElementEditor.POINT_HANDLE_SIZE + 1) {
        return idx;
      }
    }
    return -1;
  }
  static createPointAt(element, elementsMap, scenePointerX, scenePointerY, gridSize) {
    const pointerOnGrid = getGridPoint(scenePointerX, scenePointerY, gridSize);
    const [x1, y1, x22, y22] = getElementAbsoluteCoords(element, elementsMap);
    const cx = (x1 + x22) / 2;
    const cy = (y1 + y22) / 2;
    const [rotatedX, rotatedY] = rotate2(
      pointerOnGrid[0],
      pointerOnGrid[1],
      cx,
      cy,
      -element.angle
    );
    return [rotatedX - element.x, rotatedY - element.y];
  }
  /**
   * Normalizes line points so that the start point is at [0,0]. This is
   * expected in various parts of the codebase. Also returns new x/y to account
   * for the potential normalization.
   */
  static getNormalizedPoints(element) {
    const { points } = element;
    const offsetX = points[0][0];
    const offsetY = points[0][1];
    return {
      points: points.map((point2, _idx) => {
        return [point2[0] - offsetX, point2[1] - offsetY];
      }),
      x: element.x + offsetX,
      y: element.y + offsetY
    };
  }
  // element-mutating methods
  // ---------------------------------------------------------------------------
  static normalizePoints(element) {
    mutateElement(element, _LinearElementEditor.getNormalizedPoints(element));
  }
  static duplicateSelectedPoints(appState, elementsMap) {
    if (!appState.editingLinearElement) {
      return false;
    }
    const { selectedPointsIndices, elementId } = appState.editingLinearElement;
    const element = _LinearElementEditor.getElement(elementId, elementsMap);
    if (!element || selectedPointsIndices === null) {
      return false;
    }
    const { points } = element;
    const nextSelectedIndices = [];
    let pointAddedToEnd = false;
    let indexCursor = -1;
    const nextPoints = points.reduce((acc, point2, index2) => {
      ++indexCursor;
      acc.push(point2);
      const isSelected = selectedPointsIndices.includes(index2);
      if (isSelected) {
        const nextPoint = points[index2 + 1];
        if (!nextPoint) {
          pointAddedToEnd = true;
        }
        acc.push(
          nextPoint ? [(point2[0] + nextPoint[0]) / 2, (point2[1] + nextPoint[1]) / 2] : [point2[0], point2[1]]
        );
        nextSelectedIndices.push(indexCursor + 1);
        ++indexCursor;
      }
      return acc;
    }, []);
    mutateElement(element, { points: nextPoints });
    if (pointAddedToEnd) {
      const lastPoint = element.points[element.points.length - 1];
      _LinearElementEditor.movePoints(element, [
        {
          index: element.points.length - 1,
          point: [lastPoint[0] + 30, lastPoint[1] + 30]
        }
      ]);
    }
    return {
      appState: {
        ...appState,
        editingLinearElement: {
          ...appState.editingLinearElement,
          selectedPointsIndices: nextSelectedIndices
        }
      }
    };
  }
  static deletePoints(element, pointIndices) {
    let offsetX = 0;
    let offsetY = 0;
    const isDeletingOriginPoint = pointIndices.includes(0);
    if (isDeletingOriginPoint) {
      const firstNonDeletedPoint = element.points.find((point2, idx) => {
        return !pointIndices.includes(idx);
      });
      if (firstNonDeletedPoint) {
        offsetX = firstNonDeletedPoint[0];
        offsetY = firstNonDeletedPoint[1];
      }
    }
    const nextPoints = element.points.reduce((acc, point2, idx) => {
      if (!pointIndices.includes(idx)) {
        acc.push(
          !acc.length ? [0, 0] : [point2[0] - offsetX, point2[1] - offsetY]
        );
      }
      return acc;
    }, []);
    _LinearElementEditor._updatePoints(element, nextPoints, offsetX, offsetY);
  }
  static addPoints(element, appState, targetPoints) {
    const offsetX = 0;
    const offsetY = 0;
    const nextPoints = [...element.points, ...targetPoints.map((x3) => x3.point)];
    _LinearElementEditor._updatePoints(element, nextPoints, offsetX, offsetY);
  }
  static movePoints(element, targetPoints, otherUpdates) {
    const { points } = element;
    let offsetX = 0;
    let offsetY = 0;
    const selectedOriginPoint = targetPoints.find(({ index: index2 }) => index2 === 0);
    if (selectedOriginPoint) {
      offsetX = selectedOriginPoint.point[0] + points[selectedOriginPoint.index][0];
      offsetY = selectedOriginPoint.point[1] + points[selectedOriginPoint.index][1];
    }
    const nextPoints = points.map((point2, idx) => {
      const selectedPointData = targetPoints.find((p3) => p3.index === idx);
      if (selectedPointData) {
        if (selectedOriginPoint) {
          return point2;
        }
        const deltaX = selectedPointData.point[0] - points[selectedPointData.index][0];
        const deltaY = selectedPointData.point[1] - points[selectedPointData.index][1];
        return [point2[0] + deltaX, point2[1] + deltaY];
      }
      return offsetX || offsetY ? [point2[0] - offsetX, point2[1] - offsetY] : point2;
    });
    _LinearElementEditor._updatePoints(
      element,
      nextPoints,
      offsetX,
      offsetY,
      otherUpdates
    );
  }
  static shouldAddMidpoint(linearElementEditor, pointerCoords, appState, elementsMap) {
    const element = _LinearElementEditor.getElement(
      linearElementEditor.elementId,
      elementsMap
    );
    if (!element) {
      return false;
    }
    const { segmentMidpoint } = linearElementEditor.pointerDownState;
    if (segmentMidpoint.added || segmentMidpoint.value === null || segmentMidpoint.index === null || linearElementEditor.pointerDownState.origin === null) {
      return false;
    }
    const origin = linearElementEditor.pointerDownState.origin;
    const dist = distance2d(
      origin.x,
      origin.y,
      pointerCoords.x,
      pointerCoords.y
    );
    if (!appState.editingLinearElement && dist < DRAGGING_THRESHOLD / appState.zoom.value) {
      return false;
    }
    return true;
  }
  static addMidpoint(linearElementEditor, pointerCoords, appState, snapToGrid, elementsMap) {
    const element = _LinearElementEditor.getElement(
      linearElementEditor.elementId,
      elementsMap
    );
    if (!element) {
      return;
    }
    const { segmentMidpoint } = linearElementEditor.pointerDownState;
    const ret = {
      pointerDownState: linearElementEditor.pointerDownState,
      selectedPointsIndices: linearElementEditor.selectedPointsIndices
    };
    const midpoint = _LinearElementEditor.createPointAt(
      element,
      elementsMap,
      pointerCoords.x,
      pointerCoords.y,
      snapToGrid ? appState.gridSize : null
    );
    const points = [
      ...element.points.slice(0, segmentMidpoint.index),
      midpoint,
      ...element.points.slice(segmentMidpoint.index)
    ];
    mutateElement(element, {
      points
    });
    ret.pointerDownState = {
      ...linearElementEditor.pointerDownState,
      segmentMidpoint: {
        ...linearElementEditor.pointerDownState.segmentMidpoint,
        added: true
      },
      lastClickedPoint: segmentMidpoint.index
    };
    ret.selectedPointsIndices = [segmentMidpoint.index];
    return ret;
  }
  static _updatePoints(element, nextPoints, offsetX, offsetY, otherUpdates) {
    const nextCoords = getElementPointsCoords(element, nextPoints);
    const prevCoords = getElementPointsCoords(element, element.points);
    const nextCenterX = (nextCoords[0] + nextCoords[2]) / 2;
    const nextCenterY = (nextCoords[1] + nextCoords[3]) / 2;
    const prevCenterX = (prevCoords[0] + prevCoords[2]) / 2;
    const prevCenterY = (prevCoords[1] + prevCoords[3]) / 2;
    const dX = prevCenterX - nextCenterX;
    const dY = prevCenterY - nextCenterY;
    const rotated = rotate2(offsetX, offsetY, dX, dY, element.angle);
    mutateElement(element, {
      ...otherUpdates,
      points: nextPoints,
      x: element.x + rotated[0],
      y: element.y + rotated[1]
    });
  }
  static _getShiftLockedDelta(element, elementsMap, referencePoint, scenePointer, gridSize) {
    const referencePointCoords = _LinearElementEditor.getPointGlobalCoordinates(
      element,
      referencePoint,
      elementsMap
    );
    const [gridX, gridY] = getGridPoint(
      scenePointer[0],
      scenePointer[1],
      gridSize
    );
    const { width, height } = getLockedLinearCursorAlignSize(
      referencePointCoords[0],
      referencePointCoords[1],
      gridX,
      gridY
    );
    return rotatePoint([width, height], [0, 0], -element.angle);
  }
  static getBoundTextElementPosition = (element, boundTextElement, elementsMap) => {
    const points = _LinearElementEditor.getPointsGlobalCoordinates(
      element,
      elementsMap
    );
    if (points.length < 2) {
      mutateElement(boundTextElement, { isDeleted: true });
    }
    let x3 = 0;
    let y3 = 0;
    if (element.points.length % 2 === 1) {
      const index2 = Math.floor(element.points.length / 2);
      const midPoint = _LinearElementEditor.getPointGlobalCoordinates(
        element,
        element.points[index2],
        elementsMap
      );
      x3 = midPoint[0] - boundTextElement.width / 2;
      y3 = midPoint[1] - boundTextElement.height / 2;
    } else {
      const index2 = element.points.length / 2 - 1;
      let midSegmentMidpoint = editorMidPointsCache.points[index2];
      if (element.points.length === 2) {
        midSegmentMidpoint = centerPoint(points[0], points[1]);
      }
      if (!midSegmentMidpoint || editorMidPointsCache.version !== element.version) {
        midSegmentMidpoint = _LinearElementEditor.getSegmentMidPoint(
          element,
          points[index2],
          points[index2 + 1],
          index2 + 1,
          elementsMap
        );
      }
      x3 = midSegmentMidpoint[0] - boundTextElement.width / 2;
      y3 = midSegmentMidpoint[1] - boundTextElement.height / 2;
    }
    return { x: x3, y: y3 };
  };
  static getMinMaxXYWithBoundText = (element, elementsMap, elementBounds, boundTextElement) => {
    let [x1, y1, x22, y22] = elementBounds;
    const cx = (x1 + x22) / 2;
    const cy = (y1 + y22) / 2;
    const { x: boundTextX1, y: boundTextY1 } = _LinearElementEditor.getBoundTextElementPosition(
      element,
      boundTextElement,
      elementsMap
    );
    const boundTextX2 = boundTextX1 + boundTextElement.width;
    const boundTextY2 = boundTextY1 + boundTextElement.height;
    const topLeftRotatedPoint = rotatePoint([x1, y1], [cx, cy], element.angle);
    const topRightRotatedPoint = rotatePoint([x22, y1], [cx, cy], element.angle);
    const counterRotateBoundTextTopLeft = rotatePoint(
      [boundTextX1, boundTextY1],
      [cx, cy],
      -element.angle
    );
    const counterRotateBoundTextTopRight = rotatePoint(
      [boundTextX2, boundTextY1],
      [cx, cy],
      -element.angle
    );
    const counterRotateBoundTextBottomLeft = rotatePoint(
      [boundTextX1, boundTextY2],
      [cx, cy],
      -element.angle
    );
    const counterRotateBoundTextBottomRight = rotatePoint(
      [boundTextX2, boundTextY2],
      [cx, cy],
      -element.angle
    );
    if (topLeftRotatedPoint[0] < topRightRotatedPoint[0] && topLeftRotatedPoint[1] >= topRightRotatedPoint[1]) {
      x1 = Math.min(x1, counterRotateBoundTextBottomLeft[0]);
      x22 = Math.max(
        x22,
        Math.max(
          counterRotateBoundTextTopRight[0],
          counterRotateBoundTextBottomRight[0]
        )
      );
      y1 = Math.min(y1, counterRotateBoundTextTopLeft[1]);
      y22 = Math.max(y22, counterRotateBoundTextBottomRight[1]);
    } else if (topLeftRotatedPoint[0] >= topRightRotatedPoint[0] && topLeftRotatedPoint[1] > topRightRotatedPoint[1]) {
      x1 = Math.min(x1, counterRotateBoundTextBottomRight[0]);
      x22 = Math.max(
        x22,
        Math.max(
          counterRotateBoundTextTopLeft[0],
          counterRotateBoundTextTopRight[0]
        )
      );
      y1 = Math.min(y1, counterRotateBoundTextBottomLeft[1]);
      y22 = Math.max(y22, counterRotateBoundTextTopRight[1]);
    } else if (topLeftRotatedPoint[0] >= topRightRotatedPoint[0]) {
      x1 = Math.min(x1, counterRotateBoundTextTopRight[0]);
      x22 = Math.max(x22, counterRotateBoundTextBottomLeft[0]);
      y1 = Math.min(y1, counterRotateBoundTextBottomRight[1]);
      y22 = Math.max(y22, counterRotateBoundTextTopLeft[1]);
    } else if (topLeftRotatedPoint[1] <= topRightRotatedPoint[1]) {
      x1 = Math.min(
        x1,
        Math.min(
          counterRotateBoundTextTopRight[0],
          counterRotateBoundTextTopLeft[0]
        )
      );
      x22 = Math.max(x22, counterRotateBoundTextBottomRight[0]);
      y1 = Math.min(y1, counterRotateBoundTextTopRight[1]);
      y22 = Math.max(y22, counterRotateBoundTextBottomLeft[1]);
    }
    return [x1, y1, x22, y22, cx, cy];
  };
  static getElementAbsoluteCoords = (element, elementsMap, includeBoundText = false) => {
    let coords;
    let x1;
    let y1;
    let x22;
    let y22;
    if (element.points.length < 2 || !ShapeCache.get(element)) {
      const { minX, minY, maxX, maxY } = element.points.reduce(
        (limits, [x3, y3]) => {
          limits.minY = Math.min(limits.minY, y3);
          limits.minX = Math.min(limits.minX, x3);
          limits.maxX = Math.max(limits.maxX, x3);
          limits.maxY = Math.max(limits.maxY, y3);
          return limits;
        },
        { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity }
      );
      x1 = minX + element.x;
      y1 = minY + element.y;
      x22 = maxX + element.x;
      y22 = maxY + element.y;
    } else {
      const shape = ShapeCache.generateElementShape(element, null);
      const ops = getCurvePathOps(shape[0]);
      const [minX, minY, maxX, maxY] = getMinMaxXYFromCurvePathOps(ops);
      x1 = minX + element.x;
      y1 = minY + element.y;
      x22 = maxX + element.x;
      y22 = maxY + element.y;
    }
    const cx = (x1 + x22) / 2;
    const cy = (y1 + y22) / 2;
    coords = [x1, y1, x22, y22, cx, cy];
    if (!includeBoundText) {
      return coords;
    }
    const boundTextElement = getBoundTextElement(element, elementsMap);
    if (boundTextElement) {
      coords = _LinearElementEditor.getMinMaxXYWithBoundText(
        element,
        elementsMap,
        [x1, y1, x22, y22],
        boundTextElement
      );
    }
    return coords;
  };
};
var normalizeSelectedPoints = (points) => {
  let nextPoints = [
    ...new Set(points.filter((p3) => p3 !== null && p3 !== -1))
  ];
  nextPoints = nextPoints.sort((a4, b4) => a4 - b4);
  return nextPoints.length ? nextPoints : null;
};

// element/containerCache.ts
init_define_import_meta_env();
var originalContainerCache = {};
var updateOriginalContainerCache = (id, height) => {
  const data = originalContainerCache[id] || (originalContainerCache[id] = { height });
  data.height = height;
  return data;
};
var resetOriginalContainerCache = (id) => {
  if (originalContainerCache[id]) {
    delete originalContainerCache[id];
  }
};
var getOriginalContainerHeightFromCache = (id) => {
  return originalContainerCache[id]?.height ?? null;
};

// element/textElement.ts
var normalizeText = (text) => {
  return normalizeEOL(text).replace(/\t/g, "        ");
};
var splitIntoLines = (text) => {
  return normalizeText(text).split("\n");
};
var redrawTextBoundingBox = (textElement, container, elementsMap) => {
  let maxWidth = void 0;
  const boundTextUpdates = {
    x: textElement.x,
    y: textElement.y,
    text: textElement.text,
    width: textElement.width,
    height: textElement.height,
    baseline: textElement.baseline
  };
  boundTextUpdates.text = textElement.text;
  if (container) {
    maxWidth = getBoundTextMaxWidth(container, textElement);
    boundTextUpdates.text = wrapText(
      textElement.originalText,
      getFontString(textElement),
      maxWidth
    );
  }
  const metrics = measureText(
    boundTextUpdates.text,
    getFontString(textElement),
    textElement.lineHeight
  );
  boundTextUpdates.width = metrics.width;
  boundTextUpdates.height = metrics.height;
  boundTextUpdates.baseline = metrics.baseline;
  if (container) {
    const maxContainerHeight = getBoundTextMaxHeight(
      container,
      textElement
    );
    const maxContainerWidth = getBoundTextMaxWidth(container, textElement);
    if (!isArrowElement(container) && metrics.height > maxContainerHeight) {
      const nextHeight = computeContainerDimensionForBoundText(
        metrics.height,
        container.type
      );
      mutateElement(container, { height: nextHeight });
      updateOriginalContainerCache(container.id, nextHeight);
    }
    if (metrics.width > maxContainerWidth) {
      const nextWidth = computeContainerDimensionForBoundText(
        metrics.width,
        container.type
      );
      mutateElement(container, { width: nextWidth });
    }
    const updatedTextElement = {
      ...textElement,
      ...boundTextUpdates
    };
    const { x: x3, y: y3 } = computeBoundTextPosition(
      container,
      updatedTextElement,
      elementsMap
    );
    boundTextUpdates.x = x3;
    boundTextUpdates.y = y3;
  }
  mutateElement(textElement, boundTextUpdates);
};
var bindTextToShapeAfterDuplication = (newElements, oldElements, oldIdToDuplicatedId) => {
  const newElementsMap = arrayToMap(newElements);
  oldElements.forEach((element) => {
    const newElementId = oldIdToDuplicatedId.get(element.id);
    const boundTextElementId = getBoundTextElementId(element);
    if (boundTextElementId) {
      const newTextElementId = oldIdToDuplicatedId.get(boundTextElementId);
      if (newTextElementId) {
        const newContainer = newElementsMap.get(newElementId);
        if (newContainer) {
          mutateElement(newContainer, {
            boundElements: (element.boundElements || []).filter(
              (boundElement) => boundElement.id !== newTextElementId && boundElement.id !== boundTextElementId
            ).concat({
              type: "text",
              id: newTextElementId
            })
          });
        }
        const newTextElement2 = newElementsMap.get(newTextElementId);
        if (newTextElement2 && isTextElement(newTextElement2)) {
          mutateElement(newTextElement2, {
            containerId: newContainer ? newElementId : null
          });
        }
      }
    }
  });
};
var handleBindTextResize = (container, elementsMap, transformHandleType, shouldMaintainAspectRatio2 = false) => {
  const boundTextElementId = getBoundTextElementId(container);
  if (!boundTextElementId) {
    return;
  }
  resetOriginalContainerCache(container.id);
  const textElement = getBoundTextElement(container, elementsMap);
  if (textElement && textElement.text) {
    if (!container) {
      return;
    }
    let text = textElement.text;
    let nextHeight = textElement.height;
    let nextWidth = textElement.width;
    const maxWidth = getBoundTextMaxWidth(container, textElement);
    const maxHeight = getBoundTextMaxHeight(container, textElement);
    let containerHeight = container.height;
    let nextBaseLine = textElement.baseline;
    if (shouldMaintainAspectRatio2 || transformHandleType !== "n" && transformHandleType !== "s") {
      if (text) {
        text = wrapText(
          textElement.originalText,
          getFontString(textElement),
          maxWidth
        );
      }
      const metrics = measureText(
        text,
        getFontString(textElement),
        textElement.lineHeight
      );
      nextHeight = metrics.height;
      nextWidth = metrics.width;
      nextBaseLine = metrics.baseline;
    }
    if (nextHeight > maxHeight) {
      containerHeight = computeContainerDimensionForBoundText(
        nextHeight,
        container.type
      );
      const diff = containerHeight - container.height;
      const updatedY = !isArrowElement(container) && (transformHandleType === "ne" || transformHandleType === "nw" || transformHandleType === "n") ? container.y - diff : container.y;
      mutateElement(container, {
        height: containerHeight,
        y: updatedY
      });
    }
    mutateElement(textElement, {
      text,
      width: nextWidth,
      height: nextHeight,
      baseline: nextBaseLine
    });
    if (!isArrowElement(container)) {
      mutateElement(
        textElement,
        computeBoundTextPosition(container, textElement, elementsMap)
      );
    }
  }
};
var computeBoundTextPosition = (container, boundTextElement, elementsMap) => {
  if (isArrowElement(container)) {
    return LinearElementEditor.getBoundTextElementPosition(
      container,
      boundTextElement,
      elementsMap
    );
  }
  const containerCoords = getContainerCoords(container);
  const maxContainerHeight = getBoundTextMaxHeight(container, boundTextElement);
  const maxContainerWidth = getBoundTextMaxWidth(container, boundTextElement);
  let x3;
  let y3;
  if (boundTextElement.verticalAlign === VERTICAL_ALIGN.TOP) {
    y3 = containerCoords.y;
  } else if (boundTextElement.verticalAlign === VERTICAL_ALIGN.BOTTOM) {
    y3 = containerCoords.y + (maxContainerHeight - boundTextElement.height);
  } else {
    y3 = containerCoords.y + (maxContainerHeight / 2 - boundTextElement.height / 2);
  }
  if (boundTextElement.textAlign === TEXT_ALIGN.LEFT) {
    x3 = containerCoords.x;
  } else if (boundTextElement.textAlign === TEXT_ALIGN.RIGHT) {
    x3 = containerCoords.x + (maxContainerWidth - boundTextElement.width);
  } else {
    x3 = containerCoords.x + (maxContainerWidth / 2 - boundTextElement.width / 2);
  }
  return { x: x3, y: y3 };
};
var measureText = (text, font, lineHeight) => {
  text = text.split("\n").map((x3) => x3 || " ").join("\n");
  const fontSize = parseFloat(font);
  const height = getTextHeight(text, fontSize, lineHeight);
  const width = getTextWidth(text, font);
  const baseline = measureBaseline(text, font, lineHeight);
  return { width, height, baseline };
};
var measureBaseline = (text, font, lineHeight, wrapInContainer) => {
  const container = document.createElement("div");
  container.style.position = "absolute";
  container.style.whiteSpace = "pre";
  container.style.font = font;
  container.style.minHeight = "1em";
  if (wrapInContainer) {
    container.style.overflow = "hidden";
    container.style.wordBreak = "break-word";
    container.style.whiteSpace = "pre-wrap";
  }
  container.style.lineHeight = String(lineHeight);
  container.innerText = text;
  document.body.appendChild(container);
  const span = document.createElement("span");
  span.style.display = "inline-block";
  span.style.overflow = "hidden";
  span.style.width = "1px";
  span.style.height = "1px";
  container.appendChild(span);
  let baseline = span.offsetTop + span.offsetHeight;
  const height = container.offsetHeight;
  if (isSafari) {
    const canvasHeight = getTextHeight(text, parseFloat(font), lineHeight);
    const fontSize = parseFloat(font);
    const domHeight = getTextHeight(text, Math.round(fontSize), lineHeight);
    if (canvasHeight > height) {
      baseline += canvasHeight - domHeight;
    }
    if (height > canvasHeight) {
      baseline -= domHeight - canvasHeight;
    }
  }
  document.body.removeChild(container);
  return baseline;
};
var detectLineHeight = (textElement) => {
  const lineCount = splitIntoLines(textElement.text).length;
  return textElement.height / lineCount / textElement.fontSize;
};
var getLineHeightInPx = (fontSize, lineHeight) => {
  return fontSize * lineHeight;
};
var getApproxMinLineHeight = (fontSize, lineHeight) => {
  return getLineHeightInPx(fontSize, lineHeight) + BOUND_TEXT_PADDING * 2;
};
var canvas;
var getLineWidth = (text, font) => {
  if (!canvas) {
    canvas = document.createElement("canvas");
  }
  const canvas2dContext = canvas.getContext("2d");
  canvas2dContext.font = font;
  const width = canvas2dContext.measureText(text).width;
  if (isTestEnv()) {
    return width * 10;
  }
  return width;
};
var getTextWidth = (text, font) => {
  const lines = splitIntoLines(text);
  let width = 0;
  lines.forEach((line2) => {
    width = Math.max(width, getLineWidth(line2, font));
  });
  return width;
};
var getTextHeight = (text, fontSize, lineHeight) => {
  const lineCount = splitIntoLines(text).length;
  return getLineHeightInPx(fontSize, lineHeight) * lineCount;
};
var parseTokens = (text) => {
  const words = text.split("-");
  if (words.length > 1) {
    words.forEach((word, index2) => {
      if (index2 !== words.length - 1) {
        words[index2] = word += "-";
      }
    });
  }
  return words.join(" ").split(" ");
};
var wrapText = (text, font, maxWidth) => {
  if (!Number.isFinite(maxWidth) || maxWidth < 0) {
    return text;
  }
  const lines = [];
  const originalLines = text.split("\n");
  const spaceWidth = getLineWidth(" ", font);
  let currentLine = "";
  let currentLineWidthTillNow = 0;
  const push = (str) => {
    if (str.trim()) {
      lines.push(str);
    }
  };
  const resetParams = () => {
    currentLine = "";
    currentLineWidthTillNow = 0;
  };
  originalLines.forEach((originalLine) => {
    const currentLineWidth = getTextWidth(originalLine, font);
    if (currentLineWidth <= maxWidth) {
      lines.push(originalLine);
      return;
    }
    const words = parseTokens(originalLine);
    resetParams();
    let index2 = 0;
    while (index2 < words.length) {
      const currentWordWidth = getLineWidth(words[index2], font);
      if (currentWordWidth === maxWidth) {
        push(words[index2]);
        index2++;
      } else if (currentWordWidth > maxWidth) {
        push(currentLine);
        resetParams();
        while (words[index2].length > 0) {
          const currentChar = String.fromCodePoint(
            words[index2].codePointAt(0)
          );
          const width = charWidth.calculate(currentChar, font);
          currentLineWidthTillNow += width;
          words[index2] = words[index2].slice(currentChar.length);
          if (currentLineWidthTillNow >= maxWidth) {
            push(currentLine);
            currentLine = currentChar;
            currentLineWidthTillNow = width;
          } else {
            currentLine += currentChar;
          }
        }
        if (currentLineWidthTillNow + spaceWidth >= maxWidth) {
          push(currentLine);
          resetParams();
        } else if (!currentLine.endsWith("-")) {
          currentLine += " ";
          currentLineWidthTillNow += spaceWidth;
        }
        index2++;
      } else {
        while (currentLineWidthTillNow < maxWidth && index2 < words.length) {
          const word = words[index2];
          currentLineWidthTillNow = getLineWidth(currentLine + word, font);
          if (currentLineWidthTillNow > maxWidth) {
            push(currentLine);
            resetParams();
            break;
          }
          index2++;
          const shouldAppendSpace = !word.endsWith("-");
          currentLine += word;
          if (shouldAppendSpace) {
            currentLine += " ";
          }
          if (currentLineWidthTillNow + spaceWidth >= maxWidth) {
            if (shouldAppendSpace) {
              lines.push(currentLine.slice(0, -1));
            } else {
              lines.push(currentLine);
            }
            resetParams();
            break;
          }
        }
      }
    }
    if (currentLine.slice(-1) === " ") {
      currentLine = currentLine.slice(0, -1);
      push(currentLine);
    }
  });
  return lines.join("\n");
};
var charWidth = /* @__PURE__ */ (() => {
  const cachedCharWidth = {};
  const calculate = (char, font) => {
    const ascii = char.charCodeAt(0);
    if (!cachedCharWidth[font]) {
      cachedCharWidth[font] = [];
    }
    if (!cachedCharWidth[font][ascii]) {
      const width = getLineWidth(char, font);
      cachedCharWidth[font][ascii] = width;
    }
    return cachedCharWidth[font][ascii];
  };
  const getCache = (font) => {
    return cachedCharWidth[font];
  };
  return {
    calculate,
    getCache
  };
})();
var DUMMY_TEXT = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789".toLocaleUpperCase();
var getApproxMinLineWidth = (font, lineHeight) => {
  const maxCharWidth = getMaxCharWidth(font);
  if (maxCharWidth === 0) {
    return measureText(DUMMY_TEXT.split("").join("\n"), font, lineHeight).width + BOUND_TEXT_PADDING * 2;
  }
  return maxCharWidth + BOUND_TEXT_PADDING * 2;
};
var getMaxCharWidth = (font) => {
  const cache = charWidth.getCache(font);
  if (!cache) {
    return 0;
  }
  const cacheWithOutEmpty = cache.filter((val) => val !== void 0);
  return Math.max(...cacheWithOutEmpty);
};
var getBoundTextElementId = (container) => {
  return container?.boundElements?.length ? container?.boundElements?.filter((ele) => ele.type === "text")[0]?.id || null : null;
};
var getBoundTextElement = (element, elementsMap) => {
  if (!element) {
    return null;
  }
  const boundTextElementId = getBoundTextElementId(element);
  if (boundTextElementId) {
    return elementsMap.get(boundTextElementId) || null;
  }
  return null;
};
var getContainerElement = (element, elementsMap) => {
  if (!element) {
    return null;
  }
  if (element.containerId) {
    return elementsMap.get(element.containerId) || null;
  }
  return null;
};
var getContainerCenter = (container, appState, elementsMap) => {
  if (!isArrowElement(container)) {
    return {
      x: container.x + container.width / 2,
      y: container.y + container.height / 2
    };
  }
  const points = LinearElementEditor.getPointsGlobalCoordinates(
    container,
    elementsMap
  );
  if (points.length % 2 === 1) {
    const index3 = Math.floor(container.points.length / 2);
    const midPoint = LinearElementEditor.getPointGlobalCoordinates(
      container,
      container.points[index3],
      elementsMap
    );
    return { x: midPoint[0], y: midPoint[1] };
  }
  const index2 = container.points.length / 2 - 1;
  let midSegmentMidpoint = LinearElementEditor.getEditorMidPoints(
    container,
    elementsMap,
    appState
  )[index2];
  if (!midSegmentMidpoint) {
    midSegmentMidpoint = LinearElementEditor.getSegmentMidPoint(
      container,
      points[index2],
      points[index2 + 1],
      index2 + 1,
      elementsMap
    );
  }
  return { x: midSegmentMidpoint[0], y: midSegmentMidpoint[1] };
};
var getContainerCoords = (container) => {
  let offsetX = BOUND_TEXT_PADDING;
  let offsetY = BOUND_TEXT_PADDING;
  if (container.type === "ellipse") {
    offsetX += container.width / 2 * (1 - Math.sqrt(2) / 2);
    offsetY += container.height / 2 * (1 - Math.sqrt(2) / 2);
  }
  if (container.type === "diamond") {
    offsetX += container.width / 4;
    offsetY += container.height / 4;
  }
  return {
    x: container.x + offsetX,
    y: container.y + offsetY
  };
};
var getTextElementAngle = (textElement, container) => {
  if (!container || isArrowElement(container)) {
    return textElement.angle;
  }
  return container.angle;
};
var shouldAllowVerticalAlign = (selectedElements, elementsMap) => {
  return selectedElements.some((element) => {
    if (isBoundToContainer(element)) {
      const container = getContainerElement(element, elementsMap);
      if (isArrowElement(container)) {
        return false;
      }
      return true;
    }
    return false;
  });
};
var suppportsHorizontalAlign = (selectedElements, elementsMap) => {
  return selectedElements.some((element) => {
    if (isBoundToContainer(element)) {
      const container = getContainerElement(element, elementsMap);
      if (isArrowElement(container)) {
        return false;
      }
      return true;
    }
    return isTextElement(element);
  });
};
var getTextBindableContainerAtPosition = (elements, appState, x3, y3, elementsMap) => {
  const selectedElements = getSelectedElements(elements, appState);
  if (selectedElements.length === 1) {
    return isTextBindableContainer(selectedElements[0], false) ? selectedElements[0] : null;
  }
  let hitElement = null;
  for (let index2 = elements.length - 1; index2 >= 0; --index2) {
    if (elements[index2].isDeleted) {
      continue;
    }
    const [x1, y1, x22, y22] = getElementAbsoluteCoords(
      elements[index2],
      elementsMap
    );
    if (isArrowElement(elements[index2]) && isHittingElementNotConsideringBoundingBox(
      elements[index2],
      appState,
      null,
      [x3, y3],
      elementsMap
    )) {
      hitElement = elements[index2];
      break;
    } else if (x1 < x3 && x3 < x22 && y1 < y3 && y3 < y22) {
      hitElement = elements[index2];
      break;
    }
  }
  return isTextBindableContainer(hitElement, false) ? hitElement : null;
};
var VALID_CONTAINER_TYPES = /* @__PURE__ */ new Set([
  "rectangle",
  "ellipse",
  "diamond",
  "arrow"
]);
var isValidTextContainer = (element) => VALID_CONTAINER_TYPES.has(element.type);
var computeContainerDimensionForBoundText = (dimension, containerType) => {
  dimension = Math.ceil(dimension);
  const padding = BOUND_TEXT_PADDING * 2;
  if (containerType === "ellipse") {
    return Math.round((dimension + padding) / Math.sqrt(2) * 2);
  }
  if (containerType === "arrow") {
    return dimension + padding * 8;
  }
  if (containerType === "diamond") {
    return 2 * (dimension + padding);
  }
  return dimension + padding;
};
var getBoundTextMaxWidth = (container, boundTextElement) => {
  const { width } = container;
  if (isArrowElement(container)) {
    const minWidth = (boundTextElement?.fontSize ?? DEFAULT_FONT_SIZE) * ARROW_LABEL_FONT_SIZE_TO_MIN_WIDTH_RATIO;
    return Math.max(ARROW_LABEL_WIDTH_FRACTION * width, minWidth);
  }
  if (container.type === "ellipse") {
    return Math.round(width / 2 * Math.sqrt(2)) - BOUND_TEXT_PADDING * 2;
  }
  if (container.type === "diamond") {
    return Math.round(width / 2) - BOUND_TEXT_PADDING * 2;
  }
  return width - BOUND_TEXT_PADDING * 2;
};
var getBoundTextMaxHeight = (container, boundTextElement) => {
  const { height } = container;
  if (isArrowElement(container)) {
    const containerHeight = height - BOUND_TEXT_PADDING * 8 * 2;
    if (containerHeight <= 0) {
      return boundTextElement.height;
    }
    return height;
  }
  if (container.type === "ellipse") {
    return Math.round(height / 2 * Math.sqrt(2)) - BOUND_TEXT_PADDING * 2;
  }
  if (container.type === "diamond") {
    return Math.round(height / 2) - BOUND_TEXT_PADDING * 2;
  }
  return height - BOUND_TEXT_PADDING * 2;
};
var isMeasureTextSupported = () => {
  const width = getTextWidth(
    DUMMY_TEXT,
    getFontString({
      fontSize: DEFAULT_FONT_SIZE,
      fontFamily: DEFAULT_FONT_FAMILY
    })
  );
  return width > 0;
};
var DEFAULT_LINE_HEIGHT = {
  // ~1.25 is the average for Virgil in WebKit and Blink.
  // Gecko (FF) uses ~1.28.
  [FONT_FAMILY.Virgil]: 1.25,
  // ~1.15 is the average for Virgil in WebKit and Blink.
  // Gecko if all over the place.
  [FONT_FAMILY.Helvetica]: 1.15,
  // ~1.2 is the average for Virgil in WebKit and Blink, and kinda Gecko too
  [FONT_FAMILY.Cascadia]: 1.2
};
var getDefaultLineHeight = (fontFamily) => {
  if (fontFamily in DEFAULT_LINE_HEIGHT) {
    return DEFAULT_LINE_HEIGHT[fontFamily];
  }
  return DEFAULT_LINE_HEIGHT[DEFAULT_FONT_FAMILY];
};

// element/embeddable.ts
init_define_import_meta_env();

// actions/register.ts
init_define_import_meta_env();
var actions = [];
var register = (action) => {
  actions = actions.concat(action);
  return action;
};

// cursor.ts
init_define_import_meta_env();
var laserPointerCursorSVG_tag = `<svg viewBox="0 0 24 24" stroke-width="1" width="28" height="28" xmlns="http://www.w3.org/2000/svg">`;
var laserPointerCursorBackgroundSVG = `<path d="M6.164 11.755a5.314 5.314 0 0 1-4.932-5.298 5.314 5.314 0 0 1 5.311-5.311 5.314 5.314 0 0 1 5.307 5.113l8.773 8.773a3.322 3.322 0 0 1 0 4.696l-.895.895a3.322 3.322 0 0 1-4.696 0l-8.868-8.868Z" style="fill:#fff"/>`;
var laserPointerCursorIconSVG = `<path stroke="#1b1b1f" fill="#fff" d="m7.868 11.113 7.773 7.774a2.359 2.359 0 0 0 1.667.691 2.368 2.368 0 0 0 2.357-2.358c0-.625-.248-1.225-.69-1.667L11.201 7.78 9.558 9.469l-1.69 1.643v.001Zm10.273 3.606-3.333 3.333m-3.25-6.583 2 2m-7-7 3 3M3.664 3.625l1 1M2.529 6.922l1.407-.144m5.735-2.932-1.118.866M4.285 9.823l.758-1.194m1.863-6.207-.13 1.408"/>`;
var laserPointerCursorDataURL_lightMode = `data:${MIME_TYPES.svg},${encodeURIComponent(
  `${laserPointerCursorSVG_tag}${laserPointerCursorIconSVG}</svg>`
)}`;
var laserPointerCursorDataURL_darkMode = `data:${MIME_TYPES.svg},${encodeURIComponent(
  `${laserPointerCursorSVG_tag}${laserPointerCursorBackgroundSVG}${laserPointerCursorIconSVG}</svg>`
)}`;
var resetCursor = (interactiveCanvas) => {
  if (interactiveCanvas) {
    interactiveCanvas.style.cursor = "";
  }
};
var setCursor = (interactiveCanvas, cursor) => {
  if (interactiveCanvas) {
    interactiveCanvas.style.cursor = cursor;
  }
};
var eraserCanvasCache;
var previewDataURL;
var setEraserCursor = (interactiveCanvas, theme) => {
  const cursorImageSizePx = 20;
  const drawCanvas = () => {
    const isDarkTheme = theme === THEME.DARK;
    eraserCanvasCache = document.createElement("canvas");
    eraserCanvasCache.theme = theme;
    eraserCanvasCache.height = cursorImageSizePx;
    eraserCanvasCache.width = cursorImageSizePx;
    const context = eraserCanvasCache.getContext("2d");
    context.lineWidth = 1;
    context.beginPath();
    context.arc(
      eraserCanvasCache.width / 2,
      eraserCanvasCache.height / 2,
      5,
      0,
      2 * Math.PI
    );
    context.fillStyle = isDarkTheme ? open_color_default.black : open_color_default.white;
    context.fill();
    context.strokeStyle = isDarkTheme ? open_color_default.white : open_color_default.black;
    context.stroke();
    previewDataURL = eraserCanvasCache.toDataURL(MIME_TYPES.svg);
  };
  if (!eraserCanvasCache || eraserCanvasCache.theme !== theme) {
    drawCanvas();
  }
  setCursor(
    interactiveCanvas,
    `url(${previewDataURL}) ${cursorImageSizePx / 2} ${cursorImageSizePx / 2}, auto`
  );
};
var setCursorForShape = (interactiveCanvas, appState) => {
  if (!interactiveCanvas) {
    return;
  }
  if (appState.activeTool.type === "selection") {
    resetCursor(interactiveCanvas);
  } else if (isHandToolActive(appState)) {
    interactiveCanvas.style.cursor = CURSOR_TYPE.GRAB;
  } else if (isEraserActive(appState)) {
    setEraserCursor(interactiveCanvas, appState.theme);
  } else if (appState.activeTool.type === "laser") {
    const url = appState.theme === THEME.LIGHT ? laserPointerCursorDataURL_lightMode : laserPointerCursorDataURL_darkMode;
    interactiveCanvas.style.cursor = `url(${url}), auto`;
  } else if (!["image", "custom"].includes(appState.activeTool.type)) {
    interactiveCanvas.style.cursor = CURSOR_TYPE.CROSSHAIR;
  } else if (appState.activeTool.type !== "image") {
    interactiveCanvas.style.cursor = CURSOR_TYPE.AUTO;
  }
};

// element/newElement.ts
init_define_import_meta_env();

// random.ts
init_define_import_meta_env();
var random2 = new Random(Date.now());
var testIdBase = 0;
var randomInteger = () => Math.floor(random2.next() * 2 ** 31);
var randomId = () => isTestEnv() ? `id${testIdBase++}` : nanoid();

// groups.ts
init_define_import_meta_env();
var selectGroup = (groupId, appState, elements) => {
  const elementsInGroup = elements.reduce(
    (acc, element) => {
      if (element.groupIds.includes(groupId)) {
        acc[element.id] = true;
      }
      return acc;
    },
    {}
  );
  if (Object.keys(elementsInGroup).length < 2) {
    if (appState.selectedGroupIds[groupId] || appState.editingGroupId === groupId) {
      return {
        selectedElementIds: appState.selectedElementIds,
        selectedGroupIds: { ...appState.selectedGroupIds, [groupId]: false },
        editingGroupId: null
      };
    }
    return appState;
  }
  return {
    editingGroupId: appState.editingGroupId,
    selectedGroupIds: { ...appState.selectedGroupIds, [groupId]: true },
    selectedElementIds: {
      ...appState.selectedElementIds,
      ...elementsInGroup
    }
  };
};
var selectGroupsForSelectedElements = function() {
  let lastSelectedElements = null;
  let lastElements = null;
  let lastReturnValue = null;
  const _selectGroups = (selectedElements, elements, appState, prevAppState) => {
    if (lastReturnValue !== void 0 && elements === lastElements && selectedElements === lastSelectedElements && appState.editingGroupId === lastReturnValue?.editingGroupId) {
      return lastReturnValue;
    }
    const selectedGroupIds = {};
    for (const selectedElement of selectedElements) {
      let groupIds = selectedElement.groupIds;
      if (appState.editingGroupId) {
        const indexOfEditingGroup = groupIds.indexOf(appState.editingGroupId);
        if (indexOfEditingGroup > -1) {
          groupIds = groupIds.slice(0, indexOfEditingGroup);
        }
      }
      if (groupIds.length > 0) {
        const lastSelectedGroup = groupIds[groupIds.length - 1];
        selectedGroupIds[lastSelectedGroup] = true;
      }
    }
    const groupElementsIndex = {};
    const selectedElementIdsInGroups = elements.reduce(
      (acc, element) => {
        const groupId = element.groupIds.find((id) => selectedGroupIds[id]);
        if (groupId) {
          acc[element.id] = true;
          if (!Array.isArray(groupElementsIndex[groupId])) {
            groupElementsIndex[groupId] = [element.id];
          } else {
            groupElementsIndex[groupId].push(element.id);
          }
        }
        return acc;
      },
      {}
    );
    for (const groupId of Object.keys(groupElementsIndex)) {
      if (groupElementsIndex[groupId].length < 2) {
        if (selectedGroupIds[groupId]) {
          selectedGroupIds[groupId] = false;
        }
      }
    }
    lastElements = elements;
    lastSelectedElements = selectedElements;
    lastReturnValue = {
      editingGroupId: appState.editingGroupId,
      selectedGroupIds,
      selectedElementIds: makeNextSelectedElementIds(
        {
          ...appState.selectedElementIds,
          ...selectedElementIdsInGroups
        },
        prevAppState
      )
    };
    return lastReturnValue;
  };
  const selectGroupsForSelectedElements2 = (appState, elements, prevAppState, app) => {
    const selectedElements = app ? app.scene.getSelectedElements({
      selectedElementIds: appState.selectedElementIds,
      // supplying elements explicitly in case we're passed non-state elements
      elements
    }) : getSelectedElements(elements, appState);
    if (!selectedElements.length) {
      return {
        selectedGroupIds: {},
        editingGroupId: null,
        selectedElementIds: makeNextSelectedElementIds(
          appState.selectedElementIds,
          prevAppState
        )
      };
    }
    return _selectGroups(selectedElements, elements, appState, prevAppState);
  };
  selectGroupsForSelectedElements2.clearCache = () => {
    lastElements = null;
    lastSelectedElements = null;
    lastReturnValue = null;
  };
  return selectGroupsForSelectedElements2;
}();
var isSelectedViaGroup = (appState, element) => getSelectedGroupForElement(appState, element) != null;
var getSelectedGroupForElement = (appState, element) => element.groupIds.filter((groupId) => groupId !== appState.editingGroupId).find((groupId) => appState.selectedGroupIds[groupId]);
var getSelectedGroupIds = (appState) => Object.entries(appState.selectedGroupIds).filter(([groupId, isSelected]) => isSelected).map(([groupId, isSelected]) => groupId);
var selectGroupsFromGivenElements = (elements, appState) => {
  let nextAppState = {
    ...appState,
    selectedGroupIds: {}
  };
  for (const element of elements) {
    let groupIds = element.groupIds;
    if (appState.editingGroupId) {
      const indexOfEditingGroup = groupIds.indexOf(appState.editingGroupId);
      if (indexOfEditingGroup > -1) {
        groupIds = groupIds.slice(0, indexOfEditingGroup);
      }
    }
    if (groupIds.length > 0) {
      const groupId = groupIds[groupIds.length - 1];
      nextAppState = {
        ...nextAppState,
        ...selectGroup(groupId, nextAppState, elements)
      };
    }
  }
  return nextAppState.selectedGroupIds;
};
var editGroupForSelectedElement = (appState, element) => {
  return {
    ...appState,
    editingGroupId: element.groupIds.length ? element.groupIds[0] : null,
    selectedGroupIds: {},
    selectedElementIds: {
      [element.id]: true
    }
  };
};
var isElementInGroup = (element, groupId) => element.groupIds.includes(groupId);
var getElementsInGroup = (elements, groupId) => {
  const elementsInGroup = [];
  for (const element of elements.values()) {
    if (isElementInGroup(element, groupId)) {
      elementsInGroup.push(element);
    }
  }
  return elementsInGroup;
};
var getSelectedGroupIdForElement = (element, selectedGroupIds) => element.groupIds.find((groupId) => selectedGroupIds[groupId]);
var getNewGroupIdsForDuplication = (groupIds, editingGroupId, mapper) => {
  const copy = [...groupIds];
  const positionOfEditingGroupId = editingGroupId ? groupIds.indexOf(editingGroupId) : -1;
  const endIndex = positionOfEditingGroupId > -1 ? positionOfEditingGroupId : groupIds.length;
  for (let index2 = 0; index2 < endIndex; index2++) {
    copy[index2] = mapper(copy[index2]);
  }
  return copy;
};
var addToGroup = (prevGroupIds, newGroupId, editingGroupId) => {
  const groupIds = [...prevGroupIds];
  const positionOfEditingGroupId = editingGroupId ? groupIds.indexOf(editingGroupId) : -1;
  const positionToInsert = positionOfEditingGroupId > -1 ? positionOfEditingGroupId : groupIds.length;
  groupIds.splice(positionToInsert, 0, newGroupId);
  return groupIds;
};
var removeFromSelectedGroups = (groupIds, selectedGroupIds) => groupIds.filter((groupId) => !selectedGroupIds[groupId]);
var getMaximumGroups = (elements, elementsMap) => {
  const groups = /* @__PURE__ */ new Map();
  elements.forEach((element) => {
    const groupId = element.groupIds.length === 0 ? element.id : element.groupIds[element.groupIds.length - 1];
    const currentGroupMembers = groups.get(groupId) || [];
    const boundTextElement = getBoundTextElement(element, elementsMap);
    if (boundTextElement) {
      currentGroupMembers.push(boundTextElement);
    }
    groups.set(groupId, [...currentGroupMembers, element]);
  });
  return Array.from(groups.values());
};

// element/newElement.ts
var _newElementBase = (type, {
  x: x3,
  y: y3,
  strokeColor = DEFAULT_ELEMENT_PROPS.strokeColor,
  backgroundColor = DEFAULT_ELEMENT_PROPS.backgroundColor,
  fillStyle = DEFAULT_ELEMENT_PROPS.fillStyle,
  strokeWidth = DEFAULT_ELEMENT_PROPS.strokeWidth,
  strokeStyle = DEFAULT_ELEMENT_PROPS.strokeStyle,
  roughness = DEFAULT_ELEMENT_PROPS.roughness,
  opacity = DEFAULT_ELEMENT_PROPS.opacity,
  width = 0,
  height = 0,
  angle = 0,
  groupIds = [],
  frameId = null,
  roundness = null,
  boundElements = null,
  link = null,
  locked = DEFAULT_ELEMENT_PROPS.locked,
  ...rest
}) => {
  const element = {
    id: rest.id || randomId(),
    type,
    x: x3,
    y: y3,
    width,
    height,
    angle,
    strokeColor,
    backgroundColor,
    fillStyle,
    strokeWidth,
    strokeStyle,
    roughness,
    opacity,
    groupIds,
    frameId,
    roundness,
    seed: rest.seed ?? randomInteger(),
    version: rest.version || 1,
    versionNonce: rest.versionNonce ?? 0,
    isDeleted: false,
    boundElements,
    updated: getUpdatedTimestamp(),
    link,
    locked,
    customData: rest.customData
  };
  return element;
};
var newElement = (opts) => _newElementBase(opts.type, opts);
var newEmbeddableElement = (opts) => {
  return _newElementBase("embeddable", opts);
};
var newIframeElement = (opts) => {
  return {
    ..._newElementBase("iframe", opts)
  };
};
var newFrameElement = (opts) => {
  const frameElement = newElementWith(
    {
      ..._newElementBase("frame", opts),
      type: "frame",
      name: opts?.name || null
    },
    {}
  );
  return frameElement;
};
var newMagicFrameElement = (opts) => {
  const frameElement = newElementWith(
    {
      ..._newElementBase("magicframe", opts),
      type: "magicframe",
      name: opts?.name || null
    },
    {}
  );
  return frameElement;
};
var getTextElementPositionOffsets = (opts, metrics) => {
  return {
    x: opts.textAlign === "center" ? metrics.width / 2 : opts.textAlign === "right" ? metrics.width : 0,
    y: opts.verticalAlign === "middle" ? metrics.height / 2 : 0
  };
};
var newTextElement = (opts) => {
  const fontFamily = opts.fontFamily || DEFAULT_FONT_FAMILY;
  const fontSize = opts.fontSize || DEFAULT_FONT_SIZE;
  const lineHeight = opts.lineHeight || getDefaultLineHeight(fontFamily);
  const text = normalizeText(opts.text);
  const metrics = measureText(
    text,
    getFontString({ fontFamily, fontSize }),
    lineHeight
  );
  const textAlign = opts.textAlign || DEFAULT_TEXT_ALIGN;
  const verticalAlign = opts.verticalAlign || DEFAULT_VERTICAL_ALIGN;
  const offsets = getTextElementPositionOffsets(
    { textAlign, verticalAlign },
    metrics
  );
  const textElement = newElementWith(
    {
      ..._newElementBase("text", opts),
      text,
      fontSize,
      fontFamily,
      textAlign,
      verticalAlign,
      x: opts.x - offsets.x,
      y: opts.y - offsets.y,
      width: metrics.width,
      height: metrics.height,
      baseline: metrics.baseline,
      containerId: opts.containerId || null,
      originalText: text,
      lineHeight
    },
    {}
  );
  return textElement;
};
var getAdjustedDimensions = (element, elementsMap, nextText) => {
  const {
    width: nextWidth,
    height: nextHeight,
    baseline: nextBaseline
  } = measureText(nextText, getFontString(element), element.lineHeight);
  const { textAlign, verticalAlign } = element;
  let x3;
  let y3;
  if (textAlign === "center" && verticalAlign === VERTICAL_ALIGN.MIDDLE && !element.containerId) {
    const prevMetrics = measureText(
      element.text,
      getFontString(element),
      element.lineHeight
    );
    const offsets = getTextElementPositionOffsets(element, {
      width: nextWidth - prevMetrics.width,
      height: nextHeight - prevMetrics.height
    });
    x3 = element.x - offsets.x;
    y3 = element.y - offsets.y;
  } else {
    const [x1, y1, x22, y22] = getElementAbsoluteCoords(element, elementsMap);
    const [nextX1, nextY1, nextX2, nextY2] = getResizedElementAbsoluteCoords(
      element,
      nextWidth,
      nextHeight,
      false
    );
    const deltaX1 = (x1 - nextX1) / 2;
    const deltaY1 = (y1 - nextY1) / 2;
    const deltaX2 = (x22 - nextX2) / 2;
    const deltaY2 = (y22 - nextY2) / 2;
    [x3, y3] = adjustXYWithRotation(
      {
        s: true,
        e: textAlign === "center" || textAlign === "left",
        w: textAlign === "center" || textAlign === "right"
      },
      element.x,
      element.y,
      element.angle,
      deltaX1,
      deltaY1,
      deltaX2,
      deltaY2
    );
  }
  return {
    width: nextWidth,
    height: nextHeight,
    baseline: nextBaseline,
    x: Number.isFinite(x3) ? x3 : element.x,
    y: Number.isFinite(y3) ? y3 : element.y
  };
};
var refreshTextDimensions = (textElement, container, elementsMap, text = textElement.text) => {
  if (textElement.isDeleted) {
    return;
  }
  if (container) {
    text = wrapText(
      text,
      getFontString(textElement),
      getBoundTextMaxWidth(container, textElement)
    );
  }
  const dimensions = getAdjustedDimensions(textElement, elementsMap, text);
  return { text, ...dimensions };
};
var updateTextElement = (textElement, container, elementsMap, {
  text,
  isDeleted,
  originalText
}) => {
  return newElementWith(textElement, {
    originalText,
    isDeleted: isDeleted ?? textElement.isDeleted,
    ...refreshTextDimensions(textElement, container, elementsMap, originalText)
  });
};
var newFreeDrawElement = (opts) => {
  return {
    ..._newElementBase(opts.type, opts),
    points: opts.points || [],
    pressures: [],
    simulatePressure: opts.simulatePressure,
    lastCommittedPoint: null
  };
};
var newLinearElement = (opts) => {
  return {
    ..._newElementBase(opts.type, opts),
    points: opts.points || [],
    lastCommittedPoint: null,
    startBinding: null,
    endBinding: null,
    startArrowhead: opts.startArrowhead || null,
    endArrowhead: opts.endArrowhead || null
  };
};
var newImageElement = (opts) => {
  return {
    ..._newElementBase("image", opts),
    // in the future we'll support changing stroke color for some SVG elements,
    // and `transparent` will likely mean "use original colors of the image"
    strokeColor: "transparent",
    status: opts.status ?? "pending",
    fileId: opts.fileId ?? null,
    scale: opts.scale ?? [1, 1]
  };
};
var _deepCopyElement = (val, depth = 0) => {
  if (val == null || typeof val !== "object") {
    return val;
  }
  const objectType = Object.prototype.toString.call(val);
  if (objectType === "[object Object]") {
    const tmp = typeof val.constructor === "function" ? Object.create(Object.getPrototypeOf(val)) : {};
    for (const key in val) {
      if (val.hasOwnProperty(key)) {
        if (depth === 0 && (key === "shape" || key === "canvas")) {
          continue;
        }
        tmp[key] = _deepCopyElement(val[key], depth + 1);
      }
    }
    return tmp;
  }
  if (Array.isArray(val)) {
    let k2 = val.length;
    const arr = new Array(k2);
    while (k2--) {
      arr[k2] = _deepCopyElement(val[k2], depth + 1);
    }
    return arr;
  }
  if (define_import_meta_env_default.DEV) {
    if (objectType !== "[object Object]" && objectType !== "[object Array]" && objectType.startsWith("[object ")) {
      console.warn(
        `_deepCloneElement: unexpected object type ${objectType}. This value will not be cloned!`
      );
    }
  }
  return val;
};
var deepCopyElement = (val) => {
  return _deepCopyElement(val);
};
var regenerateId = (previousId) => {
  if (isTestEnv() && previousId) {
    let nextId = `${previousId}_copy`;
    if (window.h?.app?.getSceneElementsIncludingDeleted().find((el) => el.id === nextId)) {
      nextId += "_copy";
    }
    return nextId;
  }
  return randomId();
};
var duplicateElement = (editingGroupId, groupIdMapForOperation, element, overrides) => {
  let copy = deepCopyElement(element);
  copy.id = regenerateId(copy.id);
  copy.boundElements = null;
  copy.updated = getUpdatedTimestamp();
  copy.seed = randomInteger();
  copy.groupIds = getNewGroupIdsForDuplication(
    copy.groupIds,
    editingGroupId,
    (groupId) => {
      if (!groupIdMapForOperation.has(groupId)) {
        groupIdMapForOperation.set(groupId, regenerateId(groupId));
      }
      return groupIdMapForOperation.get(groupId);
    }
  );
  if (overrides) {
    copy = Object.assign(copy, overrides);
  }
  return copy;
};
var duplicateElements = (elements, opts) => {
  const clonedElements = [];
  const origElementsMap = arrayToMap(elements);
  const elementNewIdsMap = /* @__PURE__ */ new Map();
  const maybeGetNewId = (id) => {
    if (elementNewIdsMap.has(id)) {
      return elementNewIdsMap.get(id);
    }
    if (origElementsMap.has(id)) {
      const newId = regenerateId(id);
      elementNewIdsMap.set(id, newId);
      return newId;
    }
    return null;
  };
  const groupNewIdsMap = /* @__PURE__ */ new Map();
  for (const element of elements) {
    const clonedElement = _deepCopyElement(element);
    clonedElement.id = maybeGetNewId(element.id);
    if (opts?.randomizeSeed) {
      clonedElement.seed = randomInteger();
      bumpVersion(clonedElement);
    }
    if (clonedElement.groupIds) {
      clonedElement.groupIds = clonedElement.groupIds.map((groupId) => {
        if (!groupNewIdsMap.has(groupId)) {
          groupNewIdsMap.set(groupId, regenerateId(groupId));
        }
        return groupNewIdsMap.get(groupId);
      });
    }
    if ("containerId" in clonedElement && clonedElement.containerId) {
      const newContainerId = maybeGetNewId(clonedElement.containerId);
      clonedElement.containerId = newContainerId;
    }
    if ("boundElements" in clonedElement && clonedElement.boundElements) {
      clonedElement.boundElements = clonedElement.boundElements.reduce(
        (acc, binding) => {
          const newBindingId = maybeGetNewId(binding.id);
          if (newBindingId) {
            acc.push({ ...binding, id: newBindingId });
          }
          return acc;
        },
        []
      );
    }
    if ("endBinding" in clonedElement && clonedElement.endBinding) {
      const newEndBindingId = maybeGetNewId(clonedElement.endBinding.elementId);
      clonedElement.endBinding = newEndBindingId ? {
        ...clonedElement.endBinding,
        elementId: newEndBindingId
      } : null;
    }
    if ("startBinding" in clonedElement && clonedElement.startBinding) {
      const newEndBindingId = maybeGetNewId(
        clonedElement.startBinding.elementId
      );
      clonedElement.startBinding = newEndBindingId ? {
        ...clonedElement.startBinding,
        elementId: newEndBindingId
      } : null;
    }
    if (clonedElement.frameId) {
      clonedElement.frameId = maybeGetNewId(clonedElement.frameId);
    }
    clonedElements.push(clonedElement);
  }
  return clonedElements;
};

// element/embeddable.ts
var embeddedLinkCache = /* @__PURE__ */ new Map();
var RE_YOUTUBE = /^(?:http(?:s)?:\/\/)?(?:www\.)?youtu(?:be\.com|\.be)\/(embed\/|watch\?v=|shorts\/|playlist\?list=|embed\/videoseries\?list=)?([a-zA-Z0-9_-]+)(?:\?t=|&t=|\?start=|&start=)?([a-zA-Z0-9_-]+)?[^\s]*$/;
var RE_VIMEO = /^(?:http(?:s)?:\/\/)?(?:(?:w){3}.)?(?:player\.)?vimeo\.com\/(?:video\/)?([^?\s]+)(?:\?.*)?$/;
var RE_FIGMA = /^https:\/\/(?:www\.)?figma\.com/;
var RE_GH_GIST = /^https:\/\/gist\.github\.com/;
var RE_GH_GIST_EMBED = /^<script[\s\S]*?\ssrc=["'](https:\/\/gist.github.com\/.*?)\.js["']/i;
var RE_TWITTER = /(?:http(?:s)?:\/\/)?(?:(?:w){3}.)?(?:twitter|x).com/;
var RE_TWITTER_EMBED = /^<blockquote[\s\S]*?\shref=["'](https:\/\/(?:twitter|x).com\/[^"']*)/i;
var RE_VALTOWN = /^https:\/\/(?:www\.)?val.town\/(v|embed)\/[a-zA-Z_$][0-9a-zA-Z_$]+\.[a-zA-Z_$][0-9a-zA-Z_$]+/;
var RE_GENERIC_EMBED = /^<(?:iframe|blockquote)[\s\S]*?\s(?:src|href)=["']([^"']*)["'][\s\S]*?>$/i;
var RE_GIPHY = /giphy.com\/(?:clips|embed|gifs)\/[a-zA-Z0-9]*?-?([a-zA-Z0-9]+)(?:[^a-zA-Z0-9]|$)/;
var ALLOWED_DOMAINS = /* @__PURE__ */ new Set([
  "youtube.com",
  "youtu.be",
  "vimeo.com",
  "player.vimeo.com",
  "figma.com",
  "link.excalidraw.com",
  "gist.github.com",
  "twitter.com",
  "x.com",
  "*.simplepdf.eu",
  "stackblitz.com",
  "val.town",
  "giphy.com",
  "dddice.com"
]);
var createSrcDoc = (body) => {
  return `<html><body>${body}</body></html>`;
};
var getEmbedLink = (link) => {
  if (!link) {
    return null;
  }
  if (embeddedLinkCache.has(link)) {
    return embeddedLinkCache.get(link);
  }
  const originalLink = link;
  let type = "generic";
  let aspectRatio = { w: 560, h: 840 };
  const ytLink = link.match(RE_YOUTUBE);
  if (ytLink?.[2]) {
    const time = ytLink[3] ? `&start=${ytLink[3]}` : ``;
    const isPortrait = link.includes("shorts");
    type = "video";
    switch (ytLink[1]) {
      case "embed/":
      case "watch?v=":
      case "shorts/":
        link = `https://www.youtube.com/embed/${ytLink[2]}?enablejsapi=1${time}`;
        break;
      case "playlist?list=":
      case "embed/videoseries?list=":
        link = `https://www.youtube.com/embed/videoseries?list=${ytLink[2]}&enablejsapi=1${time}`;
        break;
      default:
        link = `https://www.youtube.com/embed/${ytLink[2]}?enablejsapi=1${time}`;
        break;
    }
    aspectRatio = isPortrait ? { w: 315, h: 560 } : { w: 560, h: 315 };
    embeddedLinkCache.set(originalLink, {
      link,
      intrinsicSize: aspectRatio,
      type
    });
    return { link, intrinsicSize: aspectRatio, type };
  }
  const vimeoLink = link.match(RE_VIMEO);
  if (vimeoLink?.[1]) {
    const target = vimeoLink?.[1];
    const error = !/^\d+$/.test(target) ? new URIError("Invalid embed link format") : void 0;
    type = "video";
    link = `https://player.vimeo.com/video/${target}?api=1`;
    aspectRatio = { w: 560, h: 315 };
    embeddedLinkCache.set(originalLink, {
      link,
      intrinsicSize: aspectRatio,
      type
    });
    return { link, intrinsicSize: aspectRatio, type, error };
  }
  const figmaLink = link.match(RE_FIGMA);
  if (figmaLink) {
    type = "generic";
    link = `https://www.figma.com/embed?embed_host=share&url=${encodeURIComponent(
      link
    )}`;
    aspectRatio = { w: 550, h: 550 };
    embeddedLinkCache.set(originalLink, {
      link,
      intrinsicSize: aspectRatio,
      type
    });
    return { link, intrinsicSize: aspectRatio, type };
  }
  const valLink = link.match(RE_VALTOWN);
  if (valLink) {
    link = valLink[1] === "embed" ? valLink[0] : valLink[0].replace("/v", "/embed");
    embeddedLinkCache.set(originalLink, {
      link,
      intrinsicSize: aspectRatio,
      type
    });
    return { link, intrinsicSize: aspectRatio, type };
  }
  if (RE_TWITTER.test(link)) {
    link = link.replace(/\bx.com\b/, "twitter.com");
    let ret;
    if (/<blockquote/.test(link)) {
      const srcDoc = createSrcDoc(link);
      ret = {
        type: "document",
        srcdoc: () => srcDoc,
        intrinsicSize: { w: 480, h: 480 }
      };
    } else {
      ret = {
        type: "document",
        srcdoc: (theme) => createSrcDoc(
          `<blockquote class="twitter-tweet" data-dnt="true" data-theme="${theme}"><a href="${link}"></a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"><\/script>`
        ),
        intrinsicSize: { w: 480, h: 480 }
      };
    }
    embeddedLinkCache.set(originalLink, ret);
    return ret;
  }
  if (RE_GH_GIST.test(link)) {
    let ret;
    if (/<script>/.test(link)) {
      const srcDoc = createSrcDoc(link);
      ret = {
        type: "document",
        srcdoc: () => srcDoc,
        intrinsicSize: { w: 550, h: 720 }
      };
    } else {
      ret = {
        type: "document",
        srcdoc: () => createSrcDoc(`
          <script src="${link}.js"><\/script>
          <style type="text/css">
            * { margin: 0px; }
            table, .gist { height: 100%; }
            .gist .gist-file { height: calc(100vh - 2px); padding: 0px; display: grid; grid-template-rows: 1fr auto; }
          </style>
        `),
        intrinsicSize: { w: 550, h: 720 }
      };
    }
    embeddedLinkCache.set(link, ret);
    return ret;
  }
  embeddedLinkCache.set(link, { link, intrinsicSize: aspectRatio, type });
  return { link, intrinsicSize: aspectRatio, type };
};
var createPlaceholderEmbeddableLabel = (element) => {
  let text;
  if (isIframeElement(element)) {
    text = "IFrame element";
  } else {
    text = !element.link || element?.link === "" ? "Empty Web-Embed" : element.link;
  }
  const fontSize = Math.max(
    Math.min(element.width / 2, element.width / text.length),
    element.width / 30
  );
  const fontFamily = FONT_FAMILY.Helvetica;
  const fontString = getFontString({
    fontSize,
    fontFamily
  });
  return newTextElement({
    x: element.x + element.width / 2,
    y: element.y + element.height / 2,
    strokeColor: element.strokeColor !== "transparent" ? element.strokeColor : "black",
    backgroundColor: "transparent",
    fontFamily,
    fontSize,
    text: wrapText(text, fontString, element.width - 20),
    textAlign: "center",
    verticalAlign: VERTICAL_ALIGN.MIDDLE,
    angle: element.angle ?? 0
  });
};
var actionSetEmbeddableAsActiveTool = register({
  name: "setEmbeddableAsActiveTool",
  trackEvent: { category: "toolbar" },
  perform: (elements, appState, _, app) => {
    const nextActiveTool = updateActiveTool(appState, {
      type: "embeddable"
    });
    setCursorForShape(app.canvas, {
      ...appState,
      activeTool: nextActiveTool
    });
    return {
      elements,
      appState: {
        ...appState,
        activeTool: updateActiveTool(appState, {
          type: "embeddable"
        })
      },
      commitToHistory: false
    };
  }
});
var validateHostname = (url, allowedHostnames) => {
  try {
    const { hostname } = new URL(url);
    const bareDomain = hostname.replace(/^www\./, "");
    const bareDomainWithFirstSubdomainWildcarded = bareDomain.replace(
      /^([^.]+)/,
      "*"
    );
    if (allowedHostnames instanceof Set) {
      return ALLOWED_DOMAINS.has(bareDomain) || ALLOWED_DOMAINS.has(bareDomainWithFirstSubdomainWildcarded);
    }
    if (bareDomain === allowedHostnames.replace(/^www\./, "")) {
      return true;
    }
  } catch (error) {
  }
  return false;
};
var maybeParseEmbedSrc = (str) => {
  const twitterMatch = str.match(RE_TWITTER_EMBED);
  if (twitterMatch && twitterMatch.length === 2) {
    return twitterMatch[1];
  }
  const gistMatch = str.match(RE_GH_GIST_EMBED);
  if (gistMatch && gistMatch.length === 2) {
    return gistMatch[1];
  }
  if (RE_GIPHY.test(str)) {
    return `https://giphy.com/embed/${RE_GIPHY.exec(str)[1]}`;
  }
  const match = str.match(RE_GENERIC_EMBED);
  if (match && match.length === 2) {
    return match[1];
  }
  return str;
};
var embeddableURLValidator = (url, validateEmbeddable) => {
  if (!url) {
    return false;
  }
  if (validateEmbeddable != null) {
    if (typeof validateEmbeddable === "function") {
      const ret = validateEmbeddable(url);
      if (typeof ret === "boolean") {
        return ret;
      }
    } else if (typeof validateEmbeddable === "boolean") {
      return validateEmbeddable;
    } else if (validateEmbeddable instanceof RegExp) {
      return validateEmbeddable.test(url);
    } else if (Array.isArray(validateEmbeddable)) {
      for (const domain of validateEmbeddable) {
        if (domain instanceof RegExp) {
          if (url.match(domain)) {
            return true;
          }
        } else if (validateHostname(url, domain)) {
          return true;
        }
      }
      return false;
    }
  }
  return validateHostname(url, ALLOWED_DOMAINS);
};

// data/url.ts
init_define_import_meta_env();
var import_sanitize_url = __toESM(require_dist(), 1);
var normalizeLink = (link) => {
  link = link.trim();
  if (!link) {
    return link;
  }
  return (0, import_sanitize_url.sanitizeUrl)(link);
};
var isLocalLink = (link) => {
  return !!(link?.includes(location.origin) || link?.startsWith("/"));
};
var toValidURL = (link) => {
  link = normalizeLink(link);
  if (link.startsWith("/")) {
    return `${location.origin}${link}`;
  }
  try {
    new URL(link);
  } catch {
    return "about:blank";
  }
  return link;
};

// renderer/renderElement.ts
var IMAGE_INVERT_FILTER = "invert(100%) hue-rotate(180deg) saturate(1.25)";
var defaultAppState = getDefaultAppState();
var isPendingImageElement = (element, renderConfig) => isInitializedImageElement(element) && !renderConfig.imageCache.has(element.fileId);
var shouldResetImageFilter = (element, renderConfig, appState) => {
  return appState.theme === "dark" && isInitializedImageElement(element) && !isPendingImageElement(element, renderConfig) && renderConfig.imageCache.get(element.fileId)?.mimeType !== MIME_TYPES.svg;
};
var getCanvasPadding = (element) => element.type === "freedraw" ? element.strokeWidth * 12 : 20;
var getRenderOpacity = (element, containingFrame, elementsPendingErasure) => {
  let opacity = (containingFrame?.opacity ?? 100) * element.opacity / 1e4;
  if (elementsPendingErasure.has(element.id) || containingFrame && elementsPendingErasure.has(containingFrame.id)) {
    opacity *= ELEMENT_READY_TO_ERASE_OPACITY / 100;
  }
  return opacity;
};
var cappedElementCanvasSize = (element, elementsMap, zoom) => {
  const AREA_LIMIT = 16777216;
  const WIDTH_HEIGHT_LIMIT = 32767;
  const padding = getCanvasPadding(element);
  const [x1, y1, x22, y22] = getElementAbsoluteCoords(element, elementsMap);
  const elementWidth = isLinearElement(element) || isFreeDrawElement(element) ? distance(x1, x22) : element.width;
  const elementHeight = isLinearElement(element) || isFreeDrawElement(element) ? distance(y1, y22) : element.height;
  let width = elementWidth * window.devicePixelRatio + padding * 2;
  let height = elementHeight * window.devicePixelRatio + padding * 2;
  let scale = zoom.value;
  if (width * scale > WIDTH_HEIGHT_LIMIT || height * scale > WIDTH_HEIGHT_LIMIT) {
    scale = Math.min(WIDTH_HEIGHT_LIMIT / width, WIDTH_HEIGHT_LIMIT / height);
  }
  if (width * height * scale * scale > AREA_LIMIT) {
    scale = Math.sqrt(AREA_LIMIT / (width * height));
  }
  width = Math.floor(width * scale);
  height = Math.floor(height * scale);
  return { width, height, scale };
};
var generateElementCanvas = (element, elementsMap, zoom, renderConfig, appState) => {
  const canvas2 = document.createElement("canvas");
  const context = canvas2.getContext("2d");
  const padding = getCanvasPadding(element);
  const { width, height, scale } = cappedElementCanvasSize(
    element,
    elementsMap,
    zoom
  );
  canvas2.width = width;
  canvas2.height = height;
  let canvasOffsetX = 0;
  let canvasOffsetY = 0;
  if (isLinearElement(element) || isFreeDrawElement(element)) {
    const [x1, y1] = getElementAbsoluteCoords(element, elementsMap);
    canvasOffsetX = element.x > x1 ? distance(element.x, x1) * window.devicePixelRatio * scale : 0;
    canvasOffsetY = element.y > y1 ? distance(element.y, y1) * window.devicePixelRatio * scale : 0;
    context.translate(canvasOffsetX, canvasOffsetY);
  }
  context.save();
  context.translate(padding * scale, padding * scale);
  context.scale(
    window.devicePixelRatio * scale,
    window.devicePixelRatio * scale
  );
  const rc = rough_default.canvas(canvas2);
  if (shouldResetImageFilter(element, renderConfig, appState)) {
    context.filter = IMAGE_INVERT_FILTER;
  }
  drawElementOnCanvas(element, rc, context, renderConfig, appState);
  context.restore();
  return {
    element,
    canvas: canvas2,
    theme: appState.theme,
    scale,
    zoomValue: zoom.value,
    canvasOffsetX,
    canvasOffsetY,
    boundTextElementVersion: getBoundTextElement(element, elementsMap)?.version || null,
    containingFrameOpacity: getContainingFrame(element)?.opacity || 100
  };
};
var DEFAULT_LINK_SIZE = 14;
var IMAGE_PLACEHOLDER_IMG = document.createElement("img");
IMAGE_PLACEHOLDER_IMG.src = `data:${MIME_TYPES.svg},${encodeURIComponent(
  `<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="image" class="svg-inline--fa fa-image fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="#888" d="M464 448H48c-26.51 0-48-21.49-48-48V112c0-26.51 21.49-48 48-48h416c26.51 0 48 21.49 48 48v288c0 26.51-21.49 48-48 48zM112 120c-30.928 0-56 25.072-56 56s25.072 56 56 56 56-25.072 56-56-25.072-56-56-56zM64 384h384V272l-87.515-87.515c-4.686-4.686-12.284-4.686-16.971 0L208 320l-55.515-55.515c-4.686-4.686-12.284-4.686-16.971 0L64 336v48z"></path></svg>`
)}`;
var IMAGE_ERROR_PLACEHOLDER_IMG = document.createElement("img");
IMAGE_ERROR_PLACEHOLDER_IMG.src = `data:${MIME_TYPES.svg},${encodeURIComponent(
  `<svg viewBox="0 0 668 668" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2"><path d="M464 448H48c-26.51 0-48-21.49-48-48V112c0-26.51 21.49-48 48-48h416c26.51 0 48 21.49 48 48v288c0 26.51-21.49 48-48 48ZM112 120c-30.928 0-56 25.072-56 56s25.072 56 56 56 56-25.072 56-56-25.072-56-56-56ZM64 384h384V272l-87.515-87.515c-4.686-4.686-12.284-4.686-16.971 0L208 320l-55.515-55.515c-4.686-4.686-12.284-4.686-16.971 0L64 336v48Z" style="fill:#888;fill-rule:nonzero" transform="matrix(.81709 0 0 .81709 124.825 145.825)"/><path d="M256 8C119.034 8 8 119.033 8 256c0 136.967 111.034 248 248 248s248-111.034 248-248S392.967 8 256 8Zm130.108 117.892c65.448 65.448 70 165.481 20.677 235.637L150.47 105.216c70.204-49.356 170.226-44.735 235.638 20.676ZM125.892 386.108c-65.448-65.448-70-165.481-20.677-235.637L361.53 406.784c-70.203 49.356-170.226 44.736-235.638-20.676Z" style="fill:#888;fill-rule:nonzero" transform="matrix(.30366 0 0 .30366 506.822 60.065)"/></svg>`
)}`;
var drawImagePlaceholder = (element, context, zoomValue) => {
  context.fillStyle = "#E7E7E7";
  context.fillRect(0, 0, element.width, element.height);
  const imageMinWidthOrHeight = Math.min(element.width, element.height);
  const size = Math.min(
    imageMinWidthOrHeight,
    Math.min(imageMinWidthOrHeight * 0.4, 100)
  );
  context.drawImage(
    element.status === "error" ? IMAGE_ERROR_PLACEHOLDER_IMG : IMAGE_PLACEHOLDER_IMG,
    element.width / 2 - size / 2,
    element.height / 2 - size / 2,
    size,
    size
  );
};
var drawElementOnCanvas = (element, rc, context, renderConfig, appState) => {
  switch (element.type) {
    case "rectangle":
    case "iframe":
    case "embeddable":
    case "diamond":
    case "ellipse": {
      context.lineJoin = "round";
      context.lineCap = "round";
      rc.draw(ShapeCache.get(element));
      break;
    }
    case "arrow":
    case "line": {
      context.lineJoin = "round";
      context.lineCap = "round";
      ShapeCache.get(element).forEach((shape) => {
        rc.draw(shape);
      });
      break;
    }
    case "freedraw": {
      context.save();
      context.fillStyle = element.strokeColor;
      const path = getFreeDrawPath2D(element);
      const fillShape = ShapeCache.get(element);
      if (fillShape) {
        rc.draw(fillShape);
      }
      context.fillStyle = element.strokeColor;
      context.fill(path);
      context.restore();
      break;
    }
    case "image": {
      const img = isInitializedImageElement(element) ? renderConfig.imageCache.get(element.fileId)?.image : void 0;
      if (img != null && !(img instanceof Promise)) {
        if (element.roundness && context.roundRect) {
          context.beginPath();
          context.roundRect(
            0,
            0,
            element.width,
            element.height,
            getCornerRadius(Math.min(element.width, element.height), element)
          );
          context.clip();
        }
        context.drawImage(
          img,
          0,
          0,
          element.width,
          element.height
        );
      } else {
        drawImagePlaceholder(element, context, appState.zoom.value);
      }
      break;
    }
    default: {
      if (isTextElement(element)) {
        const rtl = isRTL(element.text);
        const shouldTemporarilyAttach = rtl && !context.canvas.isConnected;
        if (shouldTemporarilyAttach) {
          document.body.appendChild(context.canvas);
        }
        context.canvas.setAttribute("dir", rtl ? "rtl" : "ltr");
        context.save();
        context.font = getFontString(element);
        context.fillStyle = element.strokeColor;
        context.textAlign = element.textAlign;
        const lines = element.text.replace(/\r\n?/g, "\n").split("\n");
        const horizontalOffset = element.textAlign === "center" ? element.width / 2 : element.textAlign === "right" ? element.width : 0;
        const lineHeightPx = getLineHeightInPx(
          element.fontSize,
          element.lineHeight
        );
        const verticalOffset = element.height - element.baseline;
        for (let index2 = 0; index2 < lines.length; index2++) {
          context.fillText(
            lines[index2],
            horizontalOffset,
            (index2 + 1) * lineHeightPx - verticalOffset
          );
        }
        context.restore();
        if (shouldTemporarilyAttach) {
          context.canvas.remove();
        }
      } else {
        throw new Error(`Unimplemented type ${element.type}`);
      }
    }
  }
};
var elementWithCanvasCache = /* @__PURE__ */ new WeakMap();
var generateElementWithCanvas = (element, elementsMap, renderConfig, appState) => {
  const zoom = renderConfig ? appState.zoom : defaultAppState.zoom;
  const prevElementWithCanvas = elementWithCanvasCache.get(element);
  const shouldRegenerateBecauseZoom = prevElementWithCanvas && prevElementWithCanvas.zoomValue !== zoom.value && !appState?.shouldCacheIgnoreZoom;
  const boundTextElementVersion = getBoundTextElement(element, elementsMap)?.version || null;
  const containingFrameOpacity = getContainingFrame(element)?.opacity || 100;
  if (!prevElementWithCanvas || shouldRegenerateBecauseZoom || prevElementWithCanvas.theme !== appState.theme || prevElementWithCanvas.boundTextElementVersion !== boundTextElementVersion || prevElementWithCanvas.containingFrameOpacity !== containingFrameOpacity) {
    const elementWithCanvas = generateElementCanvas(
      element,
      elementsMap,
      zoom,
      renderConfig,
      appState
    );
    elementWithCanvasCache.set(element, elementWithCanvas);
    return elementWithCanvas;
  }
  return prevElementWithCanvas;
};
var drawElementFromCanvas = (elementWithCanvas, context, renderConfig, appState, allElementsMap) => {
  const element = elementWithCanvas.element;
  const padding = getCanvasPadding(element);
  const zoom = elementWithCanvas.scale;
  let [x1, y1, x22, y22] = getElementAbsoluteCoords(element, allElementsMap);
  if (isFreeDrawElement(element)) {
    x1 = Math.floor(x1);
    x22 = Math.ceil(x22);
    y1 = Math.floor(y1);
    y22 = Math.ceil(y22);
  }
  const cx = ((x1 + x22) / 2 + appState.scrollX) * window.devicePixelRatio;
  const cy = ((y1 + y22) / 2 + appState.scrollY) * window.devicePixelRatio;
  context.save();
  context.scale(1 / window.devicePixelRatio, 1 / window.devicePixelRatio);
  const boundTextElement = getBoundTextElement(element, allElementsMap);
  if (isArrowElement(element) && boundTextElement) {
    const tempCanvas = document.createElement("canvas");
    const tempCanvasContext = tempCanvas.getContext("2d");
    const maxDim = Math.max(distance(x1, x22), distance(y1, y22));
    tempCanvas.width = maxDim * window.devicePixelRatio * zoom + padding * elementWithCanvas.scale * 10;
    tempCanvas.height = maxDim * window.devicePixelRatio * zoom + padding * elementWithCanvas.scale * 10;
    const offsetX = (tempCanvas.width - elementWithCanvas.canvas.width) / 2;
    const offsetY = (tempCanvas.height - elementWithCanvas.canvas.height) / 2;
    tempCanvasContext.translate(tempCanvas.width / 2, tempCanvas.height / 2);
    tempCanvasContext.rotate(element.angle);
    tempCanvasContext.drawImage(
      elementWithCanvas.canvas,
      -elementWithCanvas.canvas.width / 2,
      -elementWithCanvas.canvas.height / 2,
      elementWithCanvas.canvas.width,
      elementWithCanvas.canvas.height
    );
    const [, , , , boundTextCx, boundTextCy] = getElementAbsoluteCoords(
      boundTextElement,
      allElementsMap
    );
    tempCanvasContext.rotate(-element.angle);
    const shiftX = tempCanvas.width / 2 - (boundTextCx - x1) * window.devicePixelRatio * zoom - offsetX - padding * zoom;
    const shiftY = tempCanvas.height / 2 - (boundTextCy - y1) * window.devicePixelRatio * zoom - offsetY - padding * zoom;
    tempCanvasContext.translate(-shiftX, -shiftY);
    tempCanvasContext.clearRect(
      -(boundTextElement.width / 2 + BOUND_TEXT_PADDING) * window.devicePixelRatio * zoom,
      -(boundTextElement.height / 2 + BOUND_TEXT_PADDING) * window.devicePixelRatio * zoom,
      (boundTextElement.width + BOUND_TEXT_PADDING * 2) * window.devicePixelRatio * zoom,
      (boundTextElement.height + BOUND_TEXT_PADDING * 2) * window.devicePixelRatio * zoom
    );
    context.translate(cx, cy);
    context.drawImage(
      tempCanvas,
      -(x22 - x1) / 2 * window.devicePixelRatio - offsetX / zoom - padding,
      -(y22 - y1) / 2 * window.devicePixelRatio - offsetY / zoom - padding,
      tempCanvas.width / zoom,
      tempCanvas.height / zoom
    );
  } else {
    context.translate(cx, cy);
    context.rotate(element.angle);
    if ("scale" in elementWithCanvas.element && !isPendingImageElement(element, renderConfig)) {
      context.scale(
        elementWithCanvas.element.scale[0],
        elementWithCanvas.element.scale[1]
      );
    }
    context.translate(-cx, -cy);
    context.drawImage(
      elementWithCanvas.canvas,
      (x1 + appState.scrollX) * window.devicePixelRatio - padding * elementWithCanvas.scale / elementWithCanvas.scale,
      (y1 + appState.scrollY) * window.devicePixelRatio - padding * elementWithCanvas.scale / elementWithCanvas.scale,
      elementWithCanvas.canvas.width / elementWithCanvas.scale,
      elementWithCanvas.canvas.height / elementWithCanvas.scale
    );
    if (define_import_meta_env_default.VITE_APP_DEBUG_ENABLE_TEXT_CONTAINER_BOUNDING_BOX === "true" && hasBoundTextElement(element)) {
      const textElement = getBoundTextElement(
        element,
        allElementsMap
      );
      const coords = getContainerCoords(element);
      context.strokeStyle = "#c92a2a";
      context.lineWidth = 3;
      context.strokeRect(
        (coords.x + appState.scrollX) * window.devicePixelRatio,
        (coords.y + appState.scrollY) * window.devicePixelRatio,
        getBoundTextMaxWidth(element, textElement) * window.devicePixelRatio,
        getBoundTextMaxHeight(element, textElement) * window.devicePixelRatio
      );
    }
  }
  context.restore();
};
var renderSelectionElement = (element, context, appState) => {
  context.save();
  context.translate(element.x + appState.scrollX, element.y + appState.scrollY);
  context.fillStyle = "rgba(0, 0, 200, 0.04)";
  const offset2 = 0.5 / appState.zoom.value;
  context.fillRect(offset2, offset2, element.width, element.height);
  context.lineWidth = 1 / appState.zoom.value;
  context.strokeStyle = " rgb(105, 101, 219)";
  context.strokeRect(offset2, offset2, element.width, element.height);
  context.restore();
};
var renderElement = (element, elementsMap, allElementsMap, rc, context, renderConfig, appState) => {
  context.globalAlpha = getRenderOpacity(
    element,
    getContainingFrame(element),
    renderConfig.elementsPendingErasure
  );
  switch (element.type) {
    case "magicframe":
    case "frame": {
      if (appState.frameRendering.enabled && appState.frameRendering.outline) {
        context.save();
        context.translate(
          element.x + appState.scrollX,
          element.y + appState.scrollY
        );
        context.fillStyle = "rgba(0, 0, 200, 0.04)";
        context.lineWidth = FRAME_STYLE.strokeWidth / appState.zoom.value;
        context.strokeStyle = FRAME_STYLE.strokeColor;
        if (isMagicFrameElement(element)) {
          context.strokeStyle = appState.theme === "light" ? "#7affd7" : "#1d8264";
        }
        if (FRAME_STYLE.radius && context.roundRect) {
          context.beginPath();
          context.roundRect(
            0,
            0,
            element.width,
            element.height,
            FRAME_STYLE.radius / appState.zoom.value
          );
          context.stroke();
          context.closePath();
        } else {
          context.strokeRect(0, 0, element.width, element.height);
        }
        context.restore();
      }
      break;
    }
    case "freedraw": {
      ShapeCache.generateElementShape(element, null);
      if (renderConfig.isExporting) {
        const [x1, y1, x22, y22] = getElementAbsoluteCoords(element, elementsMap);
        const cx = (x1 + x22) / 2 + appState.scrollX;
        const cy = (y1 + y22) / 2 + appState.scrollY;
        const shiftX = (x22 - x1) / 2 - (element.x - x1);
        const shiftY = (y22 - y1) / 2 - (element.y - y1);
        context.save();
        context.translate(cx, cy);
        context.rotate(element.angle);
        context.translate(-shiftX, -shiftY);
        drawElementOnCanvas(element, rc, context, renderConfig, appState);
        context.restore();
      } else {
        const elementWithCanvas = generateElementWithCanvas(
          element,
          elementsMap,
          renderConfig,
          appState
        );
        drawElementFromCanvas(
          elementWithCanvas,
          context,
          renderConfig,
          appState,
          allElementsMap
        );
      }
      break;
    }
    case "rectangle":
    case "diamond":
    case "ellipse":
    case "line":
    case "arrow":
    case "image":
    case "text":
    case "iframe":
    case "embeddable": {
      ShapeCache.generateElementShape(element, renderConfig);
      if (renderConfig.isExporting) {
        const [x1, y1, x22, y22] = getElementAbsoluteCoords(element, elementsMap);
        const cx = (x1 + x22) / 2 + appState.scrollX;
        const cy = (y1 + y22) / 2 + appState.scrollY;
        let shiftX = (x22 - x1) / 2 - (element.x - x1);
        let shiftY = (y22 - y1) / 2 - (element.y - y1);
        if (isTextElement(element)) {
          const container = getContainerElement(element, elementsMap);
          if (isArrowElement(container)) {
            const boundTextCoords = LinearElementEditor.getBoundTextElementPosition(
              container,
              element,
              elementsMap
            );
            shiftX = (x22 - x1) / 2 - (boundTextCoords.x - x1);
            shiftY = (y22 - y1) / 2 - (boundTextCoords.y - y1);
          }
        }
        context.save();
        context.translate(cx, cy);
        if (shouldResetImageFilter(element, renderConfig, appState)) {
          context.filter = "none";
        }
        const boundTextElement = getBoundTextElement(element, elementsMap);
        if (isArrowElement(element) && boundTextElement) {
          const tempCanvas = document.createElement("canvas");
          const tempCanvasContext = tempCanvas.getContext("2d");
          const maxDim = Math.max(distance(x1, x22), distance(y1, y22));
          const padding = getCanvasPadding(element);
          tempCanvas.width = maxDim * appState.exportScale + padding * 10 * appState.exportScale;
          tempCanvas.height = maxDim * appState.exportScale + padding * 10 * appState.exportScale;
          tempCanvasContext.translate(
            tempCanvas.width / 2,
            tempCanvas.height / 2
          );
          tempCanvasContext.scale(appState.exportScale, appState.exportScale);
          shiftX = element.width / 2 - (element.x - x1);
          shiftY = element.height / 2 - (element.y - y1);
          tempCanvasContext.rotate(element.angle);
          const tempRc = rough_default.canvas(tempCanvas);
          tempCanvasContext.translate(-shiftX, -shiftY);
          drawElementOnCanvas(
            element,
            tempRc,
            tempCanvasContext,
            renderConfig,
            appState
          );
          tempCanvasContext.translate(shiftX, shiftY);
          tempCanvasContext.rotate(-element.angle);
          const [, , , , boundTextCx, boundTextCy] = getElementAbsoluteCoords(
            boundTextElement,
            elementsMap
          );
          const boundTextShiftX = (x1 + x22) / 2 - boundTextCx;
          const boundTextShiftY = (y1 + y22) / 2 - boundTextCy;
          tempCanvasContext.translate(-boundTextShiftX, -boundTextShiftY);
          tempCanvasContext.clearRect(
            -boundTextElement.width / 2,
            -boundTextElement.height / 2,
            boundTextElement.width,
            boundTextElement.height
          );
          context.scale(1 / appState.exportScale, 1 / appState.exportScale);
          context.drawImage(
            tempCanvas,
            -tempCanvas.width / 2,
            -tempCanvas.height / 2,
            tempCanvas.width,
            tempCanvas.height
          );
        } else {
          context.rotate(element.angle);
          if (element.type === "image") {
            context.scale(element.scale[0], element.scale[1]);
          }
          context.translate(-shiftX, -shiftY);
          drawElementOnCanvas(element, rc, context, renderConfig, appState);
        }
        context.restore();
      } else {
        const elementWithCanvas = generateElementWithCanvas(
          element,
          elementsMap,
          renderConfig,
          appState
        );
        const currentImageSmoothingStatus = context.imageSmoothingEnabled;
        if (
          // do not disable smoothing during zoom as blurry shapes look better
          // on low resolution (while still zooming in) than sharp ones
          !appState?.shouldCacheIgnoreZoom && // angle is 0 -> always disable smoothing
          (!element.angle || // or check if angle is a right angle in which case we can still
          // disable smoothing without adversely affecting the result
          isRightAngle(element.angle))
        ) {
          context.imageSmoothingEnabled = false;
        }
        drawElementFromCanvas(
          elementWithCanvas,
          context,
          renderConfig,
          appState,
          allElementsMap
        );
        context.imageSmoothingEnabled = currentImageSmoothingStatus;
      }
      break;
    }
    default: {
      throw new Error(`Unimplemented type ${element.type}`);
    }
  }
  context.globalAlpha = 1;
};
var roughSVGDrawWithPrecision = (rsvg, drawable, precision) => {
  if (typeof precision === "undefined") {
    return rsvg.draw(drawable);
  }
  const pshape = {
    sets: drawable.sets,
    shape: drawable.shape,
    options: { ...drawable.options, fixedDecimalPlaceDigits: precision }
  };
  return rsvg.draw(pshape);
};
var maybeWrapNodesInFrameClipPath = (element, root, nodes, frameRendering) => {
  if (!frameRendering.enabled || !frameRendering.clip) {
    return null;
  }
  const frame = getContainingFrame(element);
  if (frame) {
    const g3 = root.ownerDocument.createElementNS(SVG_NS, "g");
    g3.setAttributeNS(SVG_NS, "clip-path", `url(#${frame.id})`);
    nodes.forEach((node) => g3.appendChild(node));
    return g3;
  }
  return null;
};
var renderElementToSvg = (element, elementsMap, rsvg, svgRoot, files, offsetX, offsetY, renderConfig) => {
  const offset2 = { x: offsetX, y: offsetY };
  const [x1, y1, x22, y22] = getElementAbsoluteCoords(element, elementsMap);
  let cx = (x22 - x1) / 2 - (element.x - x1);
  let cy = (y22 - y1) / 2 - (element.y - y1);
  if (isTextElement(element)) {
    const container = getContainerElement(element, elementsMap);
    if (isArrowElement(container)) {
      const [x12, y12, x23, y23] = getElementAbsoluteCoords(container, elementsMap);
      const boundTextCoords = LinearElementEditor.getBoundTextElementPosition(
        container,
        element,
        elementsMap
      );
      cx = (x23 - x12) / 2 - (boundTextCoords.x - x12);
      cy = (y23 - y12) / 2 - (boundTextCoords.y - y12);
      offsetX = offsetX + boundTextCoords.x - element.x;
      offsetY = offsetY + boundTextCoords.y - element.y;
    }
  }
  const degree = 180 * element.angle / Math.PI;
  let root = svgRoot;
  if (element.link) {
    const anchorTag = svgRoot.ownerDocument.createElementNS(SVG_NS, "a");
    anchorTag.setAttribute("href", normalizeLink(element.link));
    root.appendChild(anchorTag);
    root = anchorTag;
  }
  const addToRoot = (node, element2) => {
    if (isTestEnv()) {
      node.setAttribute("data-id", element2.id);
    }
    root.appendChild(node);
  };
  const opacity = (getContainingFrame(element)?.opacity ?? 100) * element.opacity / 1e4;
  switch (element.type) {
    case "selection": {
      throw new Error("Selection rendering is not supported for SVG");
    }
    case "rectangle":
    case "diamond":
    case "ellipse": {
      const shape = ShapeCache.generateElementShape(element, null);
      const node = roughSVGDrawWithPrecision(
        rsvg,
        shape,
        MAX_DECIMALS_FOR_SVG_EXPORT
      );
      if (opacity !== 1) {
        node.setAttribute("stroke-opacity", `${opacity}`);
        node.setAttribute("fill-opacity", `${opacity}`);
      }
      node.setAttribute("stroke-linecap", "round");
      node.setAttribute(
        "transform",
        `translate(${offsetX || 0} ${offsetY || 0}) rotate(${degree} ${cx} ${cy})`
      );
      const g3 = maybeWrapNodesInFrameClipPath(
        element,
        root,
        [node],
        renderConfig.frameRendering
      );
      addToRoot(g3 || node, element);
      break;
    }
    case "iframe":
    case "embeddable": {
      const shape = ShapeCache.generateElementShape(element, renderConfig);
      const node = roughSVGDrawWithPrecision(
        rsvg,
        shape,
        MAX_DECIMALS_FOR_SVG_EXPORT
      );
      const opacity2 = element.opacity / 100;
      if (opacity2 !== 1) {
        node.setAttribute("stroke-opacity", `${opacity2}`);
        node.setAttribute("fill-opacity", `${opacity2}`);
      }
      node.setAttribute("stroke-linecap", "round");
      node.setAttribute(
        "transform",
        `translate(${offsetX || 0} ${offsetY || 0}) rotate(${degree} ${cx} ${cy})`
      );
      addToRoot(node, element);
      const label = createPlaceholderEmbeddableLabel(element);
      renderElementToSvg(
        label,
        elementsMap,
        rsvg,
        root,
        files,
        label.x + offset2.x - element.x,
        label.y + offset2.y - element.y,
        renderConfig
      );
      const embeddableNode = roughSVGDrawWithPrecision(
        rsvg,
        shape,
        MAX_DECIMALS_FOR_SVG_EXPORT
      );
      embeddableNode.setAttribute("stroke-linecap", "round");
      embeddableNode.setAttribute(
        "transform",
        `translate(${offsetX || 0} ${offsetY || 0}) rotate(${degree} ${cx} ${cy})`
      );
      while (embeddableNode.firstChild) {
        embeddableNode.removeChild(embeddableNode.firstChild);
      }
      const radius = getCornerRadius(
        Math.min(element.width, element.height),
        element
      );
      const embedLink = getEmbedLink(toValidURL(element.link || ""));
      if (renderConfig.renderEmbeddables === false || embedLink?.type === "document") {
        const anchorTag = svgRoot.ownerDocument.createElementNS(SVG_NS, "a");
        anchorTag.setAttribute("href", normalizeLink(element.link || ""));
        anchorTag.setAttribute("target", "_blank");
        anchorTag.setAttribute("rel", "noopener noreferrer");
        anchorTag.style.borderRadius = `${radius}px`;
        embeddableNode.appendChild(anchorTag);
      } else {
        const foreignObject = svgRoot.ownerDocument.createElementNS(
          SVG_NS,
          "foreignObject"
        );
        foreignObject.style.width = `${element.width}px`;
        foreignObject.style.height = `${element.height}px`;
        foreignObject.style.border = "none";
        const div = foreignObject.ownerDocument.createElementNS(SVG_NS, "div");
        div.setAttribute("xmlns", "http://www.w3.org/1999/xhtml");
        div.style.width = "100%";
        div.style.height = "100%";
        const iframe = div.ownerDocument.createElement("iframe");
        iframe.src = embedLink?.link ?? "";
        iframe.style.width = "100%";
        iframe.style.height = "100%";
        iframe.style.border = "none";
        iframe.style.borderRadius = `${radius}px`;
        iframe.style.top = "0";
        iframe.style.left = "0";
        iframe.allowFullscreen = true;
        div.appendChild(iframe);
        foreignObject.appendChild(div);
        embeddableNode.appendChild(foreignObject);
      }
      addToRoot(embeddableNode, element);
      break;
    }
    case "line":
    case "arrow": {
      const boundText = getBoundTextElement(element, elementsMap);
      const maskPath = svgRoot.ownerDocument.createElementNS(SVG_NS, "mask");
      if (boundText) {
        maskPath.setAttribute("id", `mask-${element.id}`);
        const maskRectVisible = svgRoot.ownerDocument.createElementNS(
          SVG_NS,
          "rect"
        );
        offsetX = offsetX || 0;
        offsetY = offsetY || 0;
        maskRectVisible.setAttribute("x", "0");
        maskRectVisible.setAttribute("y", "0");
        maskRectVisible.setAttribute("fill", "#fff");
        maskRectVisible.setAttribute(
          "width",
          `${element.width + 100 + offsetX}`
        );
        maskRectVisible.setAttribute(
          "height",
          `${element.height + 100 + offsetY}`
        );
        maskPath.appendChild(maskRectVisible);
        const maskRectInvisible = svgRoot.ownerDocument.createElementNS(
          SVG_NS,
          "rect"
        );
        const boundTextCoords = LinearElementEditor.getBoundTextElementPosition(
          element,
          boundText,
          elementsMap
        );
        const maskX = offsetX + boundTextCoords.x - element.x;
        const maskY = offsetY + boundTextCoords.y - element.y;
        maskRectInvisible.setAttribute("x", maskX.toString());
        maskRectInvisible.setAttribute("y", maskY.toString());
        maskRectInvisible.setAttribute("fill", "#000");
        maskRectInvisible.setAttribute("width", `${boundText.width}`);
        maskRectInvisible.setAttribute("height", `${boundText.height}`);
        maskRectInvisible.setAttribute("opacity", "1");
        maskPath.appendChild(maskRectInvisible);
      }
      const group = svgRoot.ownerDocument.createElementNS(SVG_NS, "g");
      if (boundText) {
        group.setAttribute("mask", `url(#mask-${element.id})`);
      }
      group.setAttribute("stroke-linecap", "round");
      const shapes = ShapeCache.generateElementShape(element, renderConfig);
      shapes.forEach((shape) => {
        const node = roughSVGDrawWithPrecision(
          rsvg,
          shape,
          MAX_DECIMALS_FOR_SVG_EXPORT
        );
        if (opacity !== 1) {
          node.setAttribute("stroke-opacity", `${opacity}`);
          node.setAttribute("fill-opacity", `${opacity}`);
        }
        node.setAttribute(
          "transform",
          `translate(${offsetX || 0} ${offsetY || 0}) rotate(${degree} ${cx} ${cy})`
        );
        if (element.type === "line" && isPathALoop(element.points) && element.backgroundColor !== "transparent") {
          node.setAttribute("fill-rule", "evenodd");
        }
        group.appendChild(node);
      });
      const g3 = maybeWrapNodesInFrameClipPath(
        element,
        root,
        [group, maskPath],
        renderConfig.frameRendering
      );
      if (g3) {
        addToRoot(g3, element);
        root.appendChild(g3);
      } else {
        addToRoot(group, element);
        root.append(maskPath);
      }
      break;
    }
    case "freedraw": {
      const backgroundFillShape = ShapeCache.generateElementShape(
        element,
        renderConfig
      );
      const node = backgroundFillShape ? roughSVGDrawWithPrecision(
        rsvg,
        backgroundFillShape,
        MAX_DECIMALS_FOR_SVG_EXPORT
      ) : svgRoot.ownerDocument.createElementNS(SVG_NS, "g");
      if (opacity !== 1) {
        node.setAttribute("stroke-opacity", `${opacity}`);
        node.setAttribute("fill-opacity", `${opacity}`);
      }
      node.setAttribute(
        "transform",
        `translate(${offsetX || 0} ${offsetY || 0}) rotate(${degree} ${cx} ${cy})`
      );
      node.setAttribute("stroke", "none");
      const path = svgRoot.ownerDocument.createElementNS(SVG_NS, "path");
      path.setAttribute("fill", element.strokeColor);
      path.setAttribute("d", getFreeDrawSvgPath(element));
      node.appendChild(path);
      const g3 = maybeWrapNodesInFrameClipPath(
        element,
        root,
        [node],
        renderConfig.frameRendering
      );
      addToRoot(g3 || node, element);
      break;
    }
    case "image": {
      const width = Math.round(element.width);
      const height = Math.round(element.height);
      const fileData = isInitializedImageElement(element) && files[element.fileId];
      if (fileData) {
        const symbolId = `image-${fileData.id}`;
        let symbol = svgRoot.querySelector(`#${symbolId}`);
        if (!symbol) {
          symbol = svgRoot.ownerDocument.createElementNS(SVG_NS, "symbol");
          symbol.id = symbolId;
          const image = svgRoot.ownerDocument.createElementNS(SVG_NS, "image");
          image.setAttribute("width", "100%");
          image.setAttribute("height", "100%");
          image.setAttribute("href", fileData.dataURL);
          symbol.appendChild(image);
          root.prepend(symbol);
        }
        const use = svgRoot.ownerDocument.createElementNS(SVG_NS, "use");
        use.setAttribute("href", `#${symbolId}`);
        if (renderConfig.exportWithDarkMode && fileData.mimeType !== MIME_TYPES.svg) {
          use.setAttribute("filter", IMAGE_INVERT_FILTER);
        }
        use.setAttribute("width", `${width}`);
        use.setAttribute("height", `${height}`);
        use.setAttribute("opacity", `${opacity}`);
        if (element.scale[0] !== 1 || element.scale[1] !== 1) {
          const translateX = element.scale[0] !== 1 ? -width : 0;
          const translateY = element.scale[1] !== 1 ? -height : 0;
          use.setAttribute(
            "transform",
            `scale(${element.scale[0]}, ${element.scale[1]}) translate(${translateX} ${translateY})`
          );
        }
        const g3 = svgRoot.ownerDocument.createElementNS(SVG_NS, "g");
        g3.appendChild(use);
        g3.setAttribute(
          "transform",
          `translate(${offsetX || 0} ${offsetY || 0}) rotate(${degree} ${cx} ${cy})`
        );
        if (element.roundness) {
          const clipPath = svgRoot.ownerDocument.createElementNS(
            SVG_NS,
            "clipPath"
          );
          clipPath.id = `image-clipPath-${element.id}`;
          const clipRect = svgRoot.ownerDocument.createElementNS(
            SVG_NS,
            "rect"
          );
          const radius = getCornerRadius(
            Math.min(element.width, element.height),
            element
          );
          clipRect.setAttribute("width", `${element.width}`);
          clipRect.setAttribute("height", `${element.height}`);
          clipRect.setAttribute("rx", `${radius}`);
          clipRect.setAttribute("ry", `${radius}`);
          clipPath.appendChild(clipRect);
          addToRoot(clipPath, element);
          g3.setAttributeNS(SVG_NS, "clip-path", `url(#${clipPath.id})`);
        }
        const clipG = maybeWrapNodesInFrameClipPath(
          element,
          root,
          [g3],
          renderConfig.frameRendering
        );
        addToRoot(clipG || g3, element);
      }
      break;
    }
    case "frame":
    case "magicframe": {
      if (renderConfig.frameRendering.enabled && renderConfig.frameRendering.outline) {
        const rect = document.createElementNS(SVG_NS, "rect");
        rect.setAttribute(
          "transform",
          `translate(${offsetX || 0} ${offsetY || 0}) rotate(${degree} ${cx} ${cy})`
        );
        rect.setAttribute("width", `${element.width}px`);
        rect.setAttribute("height", `${element.height}px`);
        rect.setAttribute("rx", FRAME_STYLE.radius.toString());
        rect.setAttribute("ry", FRAME_STYLE.radius.toString());
        rect.setAttribute("fill", "none");
        rect.setAttribute("stroke", FRAME_STYLE.strokeColor);
        rect.setAttribute("stroke-width", FRAME_STYLE.strokeWidth.toString());
        addToRoot(rect, element);
      }
      break;
    }
    default: {
      if (isTextElement(element)) {
        const node = svgRoot.ownerDocument.createElementNS(SVG_NS, "g");
        if (opacity !== 1) {
          node.setAttribute("stroke-opacity", `${opacity}`);
          node.setAttribute("fill-opacity", `${opacity}`);
        }
        node.setAttribute(
          "transform",
          `translate(${offsetX || 0} ${offsetY || 0}) rotate(${degree} ${cx} ${cy})`
        );
        const lines = element.text.replace(/\r\n?/g, "\n").split("\n");
        const lineHeightPx = getLineHeightInPx(
          element.fontSize,
          element.lineHeight
        );
        const horizontalOffset = element.textAlign === "center" ? element.width / 2 : element.textAlign === "right" ? element.width : 0;
        const direction = isRTL(element.text) ? "rtl" : "ltr";
        const textAnchor = element.textAlign === "center" ? "middle" : element.textAlign === "right" || direction === "rtl" ? "end" : "start";
        for (let i4 = 0; i4 < lines.length; i4++) {
          const text = svgRoot.ownerDocument.createElementNS(SVG_NS, "text");
          text.textContent = lines[i4];
          text.setAttribute("x", `${horizontalOffset}`);
          text.setAttribute("y", `${i4 * lineHeightPx}`);
          text.setAttribute("font-family", getFontFamilyString(element));
          text.setAttribute("font-size", `${element.fontSize}px`);
          text.setAttribute("fill", element.strokeColor);
          text.setAttribute("text-anchor", textAnchor);
          text.setAttribute("style", "white-space: pre;");
          text.setAttribute("direction", direction);
          text.setAttribute("dominant-baseline", "text-before-edge");
          node.appendChild(text);
        }
        const g3 = maybeWrapNodesInFrameClipPath(
          element,
          root,
          [node],
          renderConfig.frameRendering
        );
        addToRoot(g3 || node, element);
      } else {
        throw new Error(`Unimplemented type ${element.type}`);
      }
    }
  }
};
var pathsCache = /* @__PURE__ */ new WeakMap([]);
function generateFreeDrawShape(element) {
  const svgPathData = getFreeDrawSvgPath(element);
  const path = new Path2D(svgPathData);
  pathsCache.set(element, path);
  return path;
}
function getFreeDrawPath2D(element) {
  return pathsCache.get(element);
}
function getFreeDrawSvgPath(element) {
  const inputPoints = element.simulatePressure ? element.points : element.points.length ? element.points.map(([x3, y3], i4) => [x3, y3, element.pressures[i4]]) : [[0, 0, 0.5]];
  const options = {
    simulatePressure: element.simulatePressure,
    size: element.strokeWidth * 4.25,
    thinning: 0.6,
    smoothing: 0.5,
    streamline: 0.5,
    easing: (t4) => Math.sin(t4 * Math.PI / 2),
    // https://easings.net/#easeOutSine
    last: !!element.lastCommittedPoint
    // LastCommittedPoint is added on pointerup
  };
  return getSvgPathFromStroke2(ae(inputPoints, options));
}
function med(A3, B2) {
  return [(A3[0] + B2[0]) / 2, (A3[1] + B2[1]) / 2];
}
var TO_FIXED_PRECISION = /(\s?[A-Z]?,?-?[0-9]*\.[0-9]{0,2})(([0-9]|e|-)*)/g;
function getSvgPathFromStroke2(points) {
  if (!points.length) {
    return "";
  }
  const max = points.length - 1;
  return points.reduce(
    (acc, point2, i4, arr) => {
      if (i4 === max) {
        acc.push(point2, med(point2, arr[0]), "L", arr[0], "Z");
      } else {
        acc.push(point2, med(point2, arr[i4 + 1]));
      }
      return acc;
    },
    ["M", points[0], "Q"]
  ).join(" ").replace(TO_FIXED_PRECISION, "$1");
}

// scene/Shape.ts
var getDashArrayDashed = (strokeWidth) => [8, 8 + strokeWidth];
var getDashArrayDotted = (strokeWidth) => [1.5, 6 + strokeWidth];
function adjustRoughness(element) {
  const roughness = element.roughness;
  const maxSize = Math.max(element.width, element.height);
  const minSize = Math.min(element.width, element.height);
  if (
    // both sides relatively big
    minSize >= 20 && maxSize >= 50 || // is round & both sides above 15px
    minSize >= 15 && !!element.roundness && canChangeRoundness(element.type) || // relatively long linear element
    isLinearElement(element) && maxSize >= 50
  ) {
    return roughness;
  }
  return Math.min(roughness / (maxSize < 10 ? 3 : 2), 2.5);
}
var generateRoughOptions = (element, continuousPath = false) => {
  const options = {
    seed: element.seed,
    strokeLineDash: element.strokeStyle === "dashed" ? getDashArrayDashed(element.strokeWidth) : element.strokeStyle === "dotted" ? getDashArrayDotted(element.strokeWidth) : void 0,
    // for non-solid strokes, disable multiStroke because it tends to make
    // dashes/dots overlay each other
    disableMultiStroke: element.strokeStyle !== "solid",
    // for non-solid strokes, increase the width a bit to make it visually
    // similar to solid strokes, because we're also disabling multiStroke
    strokeWidth: element.strokeStyle !== "solid" ? element.strokeWidth + 0.5 : element.strokeWidth,
    // when increasing strokeWidth, we must explicitly set fillWeight and
    // hachureGap because if not specified, roughjs uses strokeWidth to
    // calculate them (and we don't want the fills to be modified)
    fillWeight: element.strokeWidth / 2,
    hachureGap: element.strokeWidth * 4,
    roughness: adjustRoughness(element),
    stroke: element.strokeColor,
    preserveVertices: continuousPath || element.roughness < ROUGHNESS.cartoonist
  };
  switch (element.type) {
    case "rectangle":
    case "iframe":
    case "embeddable":
    case "diamond":
    case "ellipse": {
      options.fillStyle = element.fillStyle;
      options.fill = isTransparent(element.backgroundColor) ? void 0 : element.backgroundColor;
      if (element.type === "ellipse") {
        options.curveFitting = 1;
      }
      return options;
    }
    case "line":
    case "freedraw": {
      if (isPathALoop(element.points)) {
        options.fillStyle = element.fillStyle;
        options.fill = element.backgroundColor === "transparent" ? void 0 : element.backgroundColor;
      }
      return options;
    }
    case "arrow":
      return options;
    default: {
      throw new Error(`Unimplemented type ${element.type}`);
    }
  }
};
var modifyIframeLikeForRoughOptions = (element, isExporting, embedsValidationStatus) => {
  if (isIframeLikeElement(element) && (isExporting || isEmbeddableElement(element) && embedsValidationStatus?.get(element.id) !== true) && isTransparent(element.backgroundColor) && isTransparent(element.strokeColor)) {
    return {
      ...element,
      roughness: 0,
      backgroundColor: "#d3d3d3",
      fillStyle: "solid"
    };
  } else if (isIframeElement(element)) {
    return {
      ...element,
      strokeColor: isTransparent(element.strokeColor) ? "#000000" : element.strokeColor,
      backgroundColor: isTransparent(element.backgroundColor) ? "#f4f4f6" : element.backgroundColor
    };
  }
  return element;
};
var getArrowheadShapes = (element, shape, position, arrowhead, generator, options, canvasBackgroundColor) => {
  const arrowheadPoints = getArrowheadPoints(
    element,
    shape,
    position,
    arrowhead
  );
  if (arrowheadPoints === null) {
    return [];
  }
  switch (arrowhead) {
    case "dot":
    case "circle":
    case "circle_outline": {
      const [x3, y3, diameter] = arrowheadPoints;
      delete options.strokeLineDash;
      return [
        generator.circle(x3, y3, diameter, {
          ...options,
          fill: arrowhead === "circle_outline" ? canvasBackgroundColor : element.strokeColor,
          fillStyle: "solid",
          stroke: element.strokeColor,
          roughness: Math.min(0.5, options.roughness || 0)
        })
      ];
    }
    case "triangle":
    case "triangle_outline": {
      const [x3, y3, x22, y22, x32, y32] = arrowheadPoints;
      delete options.strokeLineDash;
      return [
        generator.polygon(
          [
            [x3, y3],
            [x22, y22],
            [x32, y32],
            [x3, y3]
          ],
          {
            ...options,
            fill: arrowhead === "triangle_outline" ? canvasBackgroundColor : element.strokeColor,
            fillStyle: "solid",
            roughness: Math.min(1, options.roughness || 0)
          }
        )
      ];
    }
    case "diamond":
    case "diamond_outline": {
      const [x3, y3, x22, y22, x32, y32, x4, y4] = arrowheadPoints;
      delete options.strokeLineDash;
      return [
        generator.polygon(
          [
            [x3, y3],
            [x22, y22],
            [x32, y32],
            [x4, y4],
            [x3, y3]
          ],
          {
            ...options,
            fill: arrowhead === "diamond_outline" ? canvasBackgroundColor : element.strokeColor,
            fillStyle: "solid",
            roughness: Math.min(1, options.roughness || 0)
          }
        )
      ];
    }
    case "bar":
    case "arrow":
    default: {
      const [x22, y22, x3, y3, x4, y4] = arrowheadPoints;
      if (element.strokeStyle === "dotted") {
        const dash = getDashArrayDotted(element.strokeWidth - 1);
        options.strokeLineDash = [dash[0], dash[1] - 1];
      } else {
        delete options.strokeLineDash;
      }
      options.roughness = Math.min(1, options.roughness || 0);
      return [
        generator.line(x3, y3, x22, y22, options),
        generator.line(x4, y4, x22, y22, options)
      ];
    }
  }
};
var _generateElementShape = (element, generator, {
  isExporting,
  canvasBackgroundColor,
  embedsValidationStatus
}) => {
  switch (element.type) {
    case "rectangle":
    case "iframe":
    case "embeddable": {
      let shape;
      if (element.roundness) {
        const w3 = element.width;
        const h3 = element.height;
        const r3 = getCornerRadius(Math.min(w3, h3), element);
        shape = generator.path(
          `M ${r3} 0 L ${w3 - r3} 0 Q ${w3} 0, ${w3} ${r3} L ${w3} ${h3 - r3} Q ${w3} ${h3}, ${w3 - r3} ${h3} L ${r3} ${h3} Q 0 ${h3}, 0 ${h3 - r3} L 0 ${r3} Q 0 0, ${r3} 0`,
          generateRoughOptions(
            modifyIframeLikeForRoughOptions(
              element,
              isExporting,
              embedsValidationStatus
            ),
            true
          )
        );
      } else {
        shape = generator.rectangle(
          0,
          0,
          element.width,
          element.height,
          generateRoughOptions(
            modifyIframeLikeForRoughOptions(
              element,
              isExporting,
              embedsValidationStatus
            ),
            false
          )
        );
      }
      return shape;
    }
    case "diamond": {
      let shape;
      const [topX, topY, rightX, rightY, bottomX, bottomY, leftX, leftY] = getDiamondPoints(element);
      if (element.roundness) {
        const verticalRadius = getCornerRadius(Math.abs(topX - leftX), element);
        const horizontalRadius = getCornerRadius(
          Math.abs(rightY - topY),
          element
        );
        shape = generator.path(
          `M ${topX + verticalRadius} ${topY + horizontalRadius} L ${rightX - verticalRadius} ${rightY - horizontalRadius}
            C ${rightX} ${rightY}, ${rightX} ${rightY}, ${rightX - verticalRadius} ${rightY + horizontalRadius}
            L ${bottomX + verticalRadius} ${bottomY - horizontalRadius}
            C ${bottomX} ${bottomY}, ${bottomX} ${bottomY}, ${bottomX - verticalRadius} ${bottomY - horizontalRadius}
            L ${leftX + verticalRadius} ${leftY + horizontalRadius}
            C ${leftX} ${leftY}, ${leftX} ${leftY}, ${leftX + verticalRadius} ${leftY - horizontalRadius}
            L ${topX - verticalRadius} ${topY + horizontalRadius}
            C ${topX} ${topY}, ${topX} ${topY}, ${topX + verticalRadius} ${topY + horizontalRadius}`,
          generateRoughOptions(element, true)
        );
      } else {
        shape = generator.polygon(
          [
            [topX, topY],
            [rightX, rightY],
            [bottomX, bottomY],
            [leftX, leftY]
          ],
          generateRoughOptions(element)
        );
      }
      return shape;
    }
    case "ellipse": {
      const shape = generator.ellipse(
        element.width / 2,
        element.height / 2,
        element.width,
        element.height,
        generateRoughOptions(element)
      );
      return shape;
    }
    case "line":
    case "arrow": {
      let shape;
      const options = generateRoughOptions(element);
      const points = element.points.length ? element.points : [[0, 0]];
      if (!element.roundness) {
        if (options.fill) {
          shape = [generator.polygon(points, options)];
        } else {
          shape = [generator.linearPath(points, options)];
        }
      } else {
        shape = [generator.curve(points, options)];
      }
      if (element.type === "arrow") {
        const { startArrowhead = null, endArrowhead = "arrow" } = element;
        if (startArrowhead !== null) {
          const shapes = getArrowheadShapes(
            element,
            shape,
            "start",
            startArrowhead,
            generator,
            options,
            canvasBackgroundColor
          );
          shape.push(...shapes);
        }
        if (endArrowhead !== null) {
          if (endArrowhead === void 0) {
          }
          const shapes = getArrowheadShapes(
            element,
            shape,
            "end",
            endArrowhead,
            generator,
            options,
            canvasBackgroundColor
          );
          shape.push(...shapes);
        }
      }
      return shape;
    }
    case "freedraw": {
      let shape;
      generateFreeDrawShape(element);
      if (isPathALoop(element.points)) {
        const simplifiedPoints = simplify2(element.points, 0.75);
        shape = generator.curve(simplifiedPoints, {
          ...generateRoughOptions(element),
          stroke: "none"
        });
      } else {
        shape = null;
      }
      return shape;
    }
    case "frame":
    case "magicframe":
    case "text":
    case "image": {
      const shape = null;
      return shape;
    }
    default: {
      assertNever(
        element,
        `generateElementShape(): Unimplemented type ${element?.type}`
      );
      return null;
    }
  }
};

// points.ts
init_define_import_meta_env();
var getSizeFromPoints = (points) => {
  const xs = points.map((point2) => point2[0]);
  const ys = points.map((point2) => point2[1]);
  return {
    width: Math.max(...xs) - Math.min(...xs),
    height: Math.max(...ys) - Math.min(...ys)
  };
};
var rescalePoints = (dimension, newSize, points, normalize2) => {
  const coordinates = points.map((point2) => point2[dimension]);
  const maxCoordinate = Math.max(...coordinates);
  const minCoordinate = Math.min(...coordinates);
  const size = maxCoordinate - minCoordinate;
  const scale = size === 0 ? 1 : newSize / size;
  let nextMinCoordinate = Infinity;
  const scaledPoints = points.map((point2) => {
    const newCoordinate = point2[dimension] * scale;
    const newPoint = [...point2];
    newPoint[dimension] = newCoordinate;
    if (newCoordinate < nextMinCoordinate) {
      nextMinCoordinate = newCoordinate;
    }
    return newPoint;
  });
  if (!normalize2) {
    return scaledPoints;
  }
  if (scaledPoints.length === 2) {
    return scaledPoints;
  }
  const translation2 = minCoordinate - nextMinCoordinate;
  const nextPoints = scaledPoints.map(
    (scaledPoint) => scaledPoint.map((value, currentDimension) => {
      return currentDimension === dimension ? value + translation2 : value;
    })
  );
  return nextPoints;
};

// element/bounds.ts
var ElementBounds = class _ElementBounds {
  static boundsCache = /* @__PURE__ */ new WeakMap();
  static getBounds(element, elementsMap) {
    const cachedBounds = _ElementBounds.boundsCache.get(element);
    if (cachedBounds?.version && cachedBounds.version === element.version && // we don't invalidate cache when we update containers and not labels,
    // which is causing problems down the line. Fix TBA.
    !isBoundToContainer(element)) {
      return cachedBounds.bounds;
    }
    const bounds = _ElementBounds.calculateBounds(element, elementsMap);
    _ElementBounds.boundsCache.set(element, {
      version: element.version,
      bounds
    });
    return bounds;
  }
  static calculateBounds(element, elementsMap) {
    let bounds;
    const [x1, y1, x22, y22, cx, cy] = getElementAbsoluteCoords(
      element,
      elementsMap
    );
    if (isFreeDrawElement(element)) {
      const [minX, minY, maxX, maxY] = getBoundsFromPoints(
        element.points.map(
          ([x3, y3]) => rotate2(x3, y3, cx - element.x, cy - element.y, element.angle)
        )
      );
      return [
        minX + element.x,
        minY + element.y,
        maxX + element.x,
        maxY + element.y
      ];
    } else if (isLinearElement(element)) {
      bounds = getLinearElementRotatedBounds(element, cx, cy, elementsMap);
    } else if (element.type === "diamond") {
      const [x11, y11] = rotate2(cx, y1, cx, cy, element.angle);
      const [x12, y12] = rotate2(cx, y22, cx, cy, element.angle);
      const [x222, y222] = rotate2(x1, cy, cx, cy, element.angle);
      const [x21, y21] = rotate2(x22, cy, cx, cy, element.angle);
      const minX = Math.min(x11, x12, x222, x21);
      const minY = Math.min(y11, y12, y222, y21);
      const maxX = Math.max(x11, x12, x222, x21);
      const maxY = Math.max(y11, y12, y222, y21);
      bounds = [minX, minY, maxX, maxY];
    } else if (element.type === "ellipse") {
      const w3 = (x22 - x1) / 2;
      const h3 = (y22 - y1) / 2;
      const cos = Math.cos(element.angle);
      const sin = Math.sin(element.angle);
      const ww = Math.hypot(w3 * cos, h3 * sin);
      const hh = Math.hypot(h3 * cos, w3 * sin);
      bounds = [cx - ww, cy - hh, cx + ww, cy + hh];
    } else {
      const [x11, y11] = rotate2(x1, y1, cx, cy, element.angle);
      const [x12, y12] = rotate2(x1, y22, cx, cy, element.angle);
      const [x222, y222] = rotate2(x22, y22, cx, cy, element.angle);
      const [x21, y21] = rotate2(x22, y1, cx, cy, element.angle);
      const minX = Math.min(x11, x12, x222, x21);
      const minY = Math.min(y11, y12, y222, y21);
      const maxX = Math.max(x11, x12, x222, x21);
      const maxY = Math.max(y11, y12, y222, y21);
      bounds = [minX, minY, maxX, maxY];
    }
    return bounds;
  }
};
var getElementAbsoluteCoords = (element, elementsMap, includeBoundText = false) => {
  if (isFreeDrawElement(element)) {
    return getFreeDrawElementAbsoluteCoords(element);
  } else if (isLinearElement(element)) {
    return LinearElementEditor.getElementAbsoluteCoords(
      element,
      elementsMap,
      includeBoundText
    );
  } else if (isTextElement(element)) {
    const container = elementsMap ? getContainerElement(element, elementsMap) : null;
    if (isArrowElement(container)) {
      const coords = LinearElementEditor.getBoundTextElementPosition(
        container,
        element,
        elementsMap
      );
      return [
        coords.x,
        coords.y,
        coords.x + element.width,
        coords.y + element.height,
        coords.x + element.width / 2,
        coords.y + element.height / 2
      ];
    }
  }
  return [
    element.x,
    element.y,
    element.x + element.width,
    element.y + element.height,
    element.x + element.width / 2,
    element.y + element.height / 2
  ];
};
var getElementLineSegments = (element, elementsMap) => {
  const [x1, y1, x22, y22, cx, cy] = getElementAbsoluteCoords(
    element,
    elementsMap
  );
  const center = [cx, cy];
  if (isLinearElement(element) || isFreeDrawElement(element)) {
    const segments = [];
    let i4 = 0;
    while (i4 < element.points.length - 1) {
      segments.push([
        rotatePoint(
          [
            element.points[i4][0] + element.x,
            element.points[i4][1] + element.y
          ],
          center,
          element.angle
        ),
        rotatePoint(
          [
            element.points[i4 + 1][0] + element.x,
            element.points[i4 + 1][1] + element.y
          ],
          center,
          element.angle
        )
      ]);
      i4++;
    }
    return segments;
  }
  const [nw, ne, sw, se2, n4, s4, w3, e3] = [
    [x1, y1],
    [x22, y1],
    [x1, y22],
    [x22, y22],
    [cx, y1],
    [cx, y22],
    [x1, cy],
    [x22, cy]
  ].map((point2) => rotatePoint(point2, center, element.angle));
  if (element.type === "diamond") {
    return [
      [n4, w3],
      [n4, e3],
      [s4, w3],
      [s4, e3]
    ];
  }
  if (element.type === "ellipse") {
    return [
      [n4, w3],
      [n4, e3],
      [s4, w3],
      [s4, e3],
      [n4, w3],
      [n4, e3],
      [s4, w3],
      [s4, e3]
    ];
  }
  return [
    [nw, ne],
    [sw, se2],
    [nw, sw],
    [ne, se2],
    [nw, e3],
    [sw, e3],
    [ne, w3],
    [se2, w3]
  ];
};
var getRectangleBoxAbsoluteCoords = (boxSceneCoords) => {
  return [
    boxSceneCoords.x,
    boxSceneCoords.y,
    boxSceneCoords.x + boxSceneCoords.width,
    boxSceneCoords.y + boxSceneCoords.height,
    boxSceneCoords.x + boxSceneCoords.width / 2,
    boxSceneCoords.y + boxSceneCoords.height / 2
  ];
};
var getDiamondPoints = (element) => {
  const topX = Math.floor(element.width / 2) + 1;
  const topY = 0;
  const rightX = element.width;
  const rightY = Math.floor(element.height / 2) + 1;
  const bottomX = topX;
  const bottomY = element.height;
  const leftX = 0;
  const leftY = rightY;
  return [topX, topY, rightX, rightY, bottomX, bottomY, leftX, leftY];
};
var getCurvePathOps = (shape) => {
  for (const set of shape.sets) {
    if (set.type === "path") {
      return set.ops;
    }
  }
  return shape.sets[0].ops;
};
var getBezierValueForT = (t4, p0, p1, p22, p3) => {
  const oneMinusT = 1 - t4;
  return Math.pow(oneMinusT, 3) * p0 + 3 * Math.pow(oneMinusT, 2) * t4 * p1 + 3 * oneMinusT * Math.pow(t4, 2) * p22 + Math.pow(t4, 3) * p3;
};
var solveQuadratic = (p0, p1, p22, p3) => {
  const i4 = p1 - p0;
  const j = p22 - p1;
  const k2 = p3 - p22;
  const a4 = 3 * i4 - 6 * j + 3 * k2;
  const b4 = 6 * j - 6 * i4;
  const c3 = 3 * i4;
  const sqrtPart = b4 * b4 - 4 * a4 * c3;
  const hasSolution = sqrtPart >= 0;
  if (!hasSolution) {
    return false;
  }
  let s1 = null;
  let s22 = null;
  let t1 = Infinity;
  let t22 = Infinity;
  if (a4 === 0) {
    t1 = t22 = -c3 / b4;
  } else {
    t1 = (-b4 + Math.sqrt(sqrtPart)) / (2 * a4);
    t22 = (-b4 - Math.sqrt(sqrtPart)) / (2 * a4);
  }
  if (t1 >= 0 && t1 <= 1) {
    s1 = getBezierValueForT(t1, p0, p1, p22, p3);
  }
  if (t22 >= 0 && t22 <= 1) {
    s22 = getBezierValueForT(t22, p0, p1, p22, p3);
  }
  return [s1, s22];
};
var getCubicBezierCurveBound = (p0, p1, p22, p3) => {
  const solX = solveQuadratic(p0[0], p1[0], p22[0], p3[0]);
  const solY = solveQuadratic(p0[1], p1[1], p22[1], p3[1]);
  let minX = Math.min(p0[0], p3[0]);
  let maxX = Math.max(p0[0], p3[0]);
  if (solX) {
    const xs = solX.filter((x3) => x3 !== null);
    minX = Math.min(minX, ...xs);
    maxX = Math.max(maxX, ...xs);
  }
  let minY = Math.min(p0[1], p3[1]);
  let maxY = Math.max(p0[1], p3[1]);
  if (solY) {
    const ys = solY.filter((y3) => y3 !== null);
    minY = Math.min(minY, ...ys);
    maxY = Math.max(maxY, ...ys);
  }
  return [minX, minY, maxX, maxY];
};
var getMinMaxXYFromCurvePathOps = (ops, transformXY) => {
  let currentP = [0, 0];
  const { minX, minY, maxX, maxY } = ops.reduce(
    (limits, { op, data }) => {
      if (op === "move") {
        currentP = data;
      } else if (op === "bcurveTo") {
        const _p1 = [data[0], data[1]];
        const _p2 = [data[2], data[3]];
        const _p3 = [data[4], data[5]];
        const p1 = transformXY ? transformXY(..._p1) : _p1;
        const p22 = transformXY ? transformXY(..._p2) : _p2;
        const p3 = transformXY ? transformXY(..._p3) : _p3;
        const p0 = transformXY ? transformXY(...currentP) : currentP;
        currentP = _p3;
        const [minX2, minY2, maxX2, maxY2] = getCubicBezierCurveBound(
          p0,
          p1,
          p22,
          p3
        );
        limits.minX = Math.min(limits.minX, minX2);
        limits.minY = Math.min(limits.minY, minY2);
        limits.maxX = Math.max(limits.maxX, maxX2);
        limits.maxY = Math.max(limits.maxY, maxY2);
      } else if (op === "lineTo") {
      } else if (op === "qcurveTo") {
      }
      return limits;
    },
    { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity }
  );
  return [minX, minY, maxX, maxY];
};
var getBoundsFromPoints = (points) => {
  let minX = Infinity;
  let minY = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;
  for (const [x3, y3] of points) {
    minX = Math.min(minX, x3);
    minY = Math.min(minY, y3);
    maxX = Math.max(maxX, x3);
    maxY = Math.max(maxY, y3);
  }
  return [minX, minY, maxX, maxY];
};
var getFreeDrawElementAbsoluteCoords = (element) => {
  const [minX, minY, maxX, maxY] = getBoundsFromPoints(element.points);
  const x1 = minX + element.x;
  const y1 = minY + element.y;
  const x22 = maxX + element.x;
  const y22 = maxY + element.y;
  return [x1, y1, x22, y22, (x1 + x22) / 2, (y1 + y22) / 2];
};
var getArrowheadSize = (arrowhead) => {
  switch (arrowhead) {
    case "arrow":
      return 25;
    case "diamond":
    case "diamond_outline":
      return 12;
    default:
      return 15;
  }
};
var getArrowheadAngle = (arrowhead) => {
  switch (arrowhead) {
    case "bar":
      return 90;
    case "arrow":
      return 20;
    default:
      return 25;
  }
};
var getArrowheadPoints = (element, shape, position, arrowhead) => {
  const ops = getCurvePathOps(shape[0]);
  if (ops.length < 1) {
    return null;
  }
  const index2 = position === "start" ? 1 : ops.length - 1;
  const data = ops[index2].data;
  const p3 = [data[4], data[5]];
  const p22 = [data[2], data[3]];
  const p1 = [data[0], data[1]];
  const prevOp = ops[index2 - 1];
  let p0 = [0, 0];
  if (prevOp.op === "move") {
    p0 = prevOp.data;
  } else if (prevOp.op === "bcurveTo") {
    p0 = [prevOp.data[4], prevOp.data[5]];
  }
  const equation2 = (t4, idx) => Math.pow(1 - t4, 3) * p3[idx] + 3 * t4 * Math.pow(1 - t4, 2) * p22[idx] + 3 * Math.pow(t4, 2) * (1 - t4) * p1[idx] + p0[idx] * Math.pow(t4, 3);
  const [x22, y22] = position === "start" ? p0 : p3;
  const [x1, y1] = [equation2(0.3, 0), equation2(0.3, 1)];
  const distance5 = Math.hypot(x22 - x1, y22 - y1);
  const nx = (x22 - x1) / distance5;
  const ny = (y22 - y1) / distance5;
  const size = getArrowheadSize(arrowhead);
  let length = 0;
  {
    const [cx, cy] = position === "end" ? element.points[element.points.length - 1] : element.points[0];
    const [px, py] = element.points.length > 1 ? position === "end" ? element.points[element.points.length - 2] : element.points[1] : [0, 0];
    length = Math.hypot(cx - px, cy - py);
  }
  const lengthMultiplier = arrowhead === "diamond" || arrowhead === "diamond_outline" ? 0.25 : 0.5;
  const minSize = Math.min(size, length * lengthMultiplier);
  const xs = x22 - nx * minSize;
  const ys = y22 - ny * minSize;
  if (arrowhead === "dot" || arrowhead === "circle" || arrowhead === "circle_outline") {
    const diameter = Math.hypot(ys - y22, xs - x22) + element.strokeWidth - 2;
    return [x22, y22, diameter];
  }
  const angle = getArrowheadAngle(arrowhead);
  const [x3, y3] = rotate2(xs, ys, x22, y22, -angle * Math.PI / 180);
  const [x4, y4] = rotate2(xs, ys, x22, y22, angle * Math.PI / 180);
  if (arrowhead === "diamond" || arrowhead === "diamond_outline") {
    let ox;
    let oy;
    if (position === "start") {
      const [px, py] = element.points.length > 1 ? element.points[1] : [0, 0];
      [ox, oy] = rotate2(
        x22 + minSize * 2,
        y22,
        x22,
        y22,
        Math.atan2(py - y22, px - x22)
      );
    } else {
      const [px, py] = element.points.length > 1 ? element.points[element.points.length - 2] : [0, 0];
      [ox, oy] = rotate2(
        x22 - minSize * 2,
        y22,
        x22,
        y22,
        Math.atan2(y22 - py, x22 - px)
      );
    }
    return [x22, y22, x3, y3, ox, oy, x4, y4];
  }
  return [x22, y22, x3, y3, x4, y4];
};
var generateLinearElementShape = (element) => {
  const generator = rough_default.generator();
  const options = generateRoughOptions(element);
  const method = (() => {
    if (element.roundness) {
      return "curve";
    }
    if (options.fill) {
      return "polygon";
    }
    return "linearPath";
  })();
  return generator[method](element.points, options);
};
var getLinearElementRotatedBounds = (element, cx, cy, elementsMap) => {
  const boundTextElement = getBoundTextElement(element, elementsMap);
  if (element.points.length < 2) {
    const [pointX, pointY] = element.points[0];
    const [x3, y3] = rotate2(
      element.x + pointX,
      element.y + pointY,
      cx,
      cy,
      element.angle
    );
    let coords2 = [x3, y3, x3, y3];
    if (boundTextElement) {
      const coordsWithBoundText = LinearElementEditor.getMinMaxXYWithBoundText(
        element,
        elementsMap,
        [x3, y3, x3, y3],
        boundTextElement
      );
      coords2 = [
        coordsWithBoundText[0],
        coordsWithBoundText[1],
        coordsWithBoundText[2],
        coordsWithBoundText[3]
      ];
    }
    return coords2;
  }
  const cachedShape = ShapeCache.get(element)?.[0];
  const shape = cachedShape ?? generateLinearElementShape(element);
  const ops = getCurvePathOps(shape);
  const transformXY = (x3, y3) => rotate2(element.x + x3, element.y + y3, cx, cy, element.angle);
  const res = getMinMaxXYFromCurvePathOps(ops, transformXY);
  let coords = [res[0], res[1], res[2], res[3]];
  if (boundTextElement) {
    const coordsWithBoundText = LinearElementEditor.getMinMaxXYWithBoundText(
      element,
      elementsMap,
      coords,
      boundTextElement
    );
    coords = [
      coordsWithBoundText[0],
      coordsWithBoundText[1],
      coordsWithBoundText[2],
      coordsWithBoundText[3]
    ];
  }
  return coords;
};
var getElementBounds = (element, elementsMap) => {
  return ElementBounds.getBounds(element, elementsMap);
};
var getCommonBounds = (elements) => {
  if (!elements.length) {
    return [0, 0, 0, 0];
  }
  let minX = Infinity;
  let maxX = -Infinity;
  let minY = Infinity;
  let maxY = -Infinity;
  const elementsMap = arrayToMap(elements);
  elements.forEach((element) => {
    const [x1, y1, x22, y22] = getElementBounds(element, elementsMap);
    minX = Math.min(minX, x1);
    minY = Math.min(minY, y1);
    maxX = Math.max(maxX, x22);
    maxY = Math.max(maxY, y22);
  });
  return [minX, minY, maxX, maxY];
};
var getDraggedElementsBounds = (elements, dragOffset) => {
  const [minX, minY, maxX, maxY] = getCommonBounds(elements);
  return [
    minX + dragOffset.x,
    minY + dragOffset.y,
    maxX + dragOffset.x,
    maxY + dragOffset.y
  ];
};
var getResizedElementAbsoluteCoords = (element, nextWidth, nextHeight, normalizePoints) => {
  if (!(isLinearElement(element) || isFreeDrawElement(element))) {
    return [
      element.x,
      element.y,
      element.x + nextWidth,
      element.y + nextHeight
    ];
  }
  const points = rescalePoints(
    0,
    nextWidth,
    rescalePoints(1, nextHeight, element.points, normalizePoints),
    normalizePoints
  );
  let bounds;
  if (isFreeDrawElement(element)) {
    bounds = getBoundsFromPoints(points);
  } else {
    const gen = rough_default.generator();
    const curve2 = !element.roundness ? gen.linearPath(
      points,
      generateRoughOptions(element)
    ) : gen.curve(points, generateRoughOptions(element));
    const ops = getCurvePathOps(curve2);
    bounds = getMinMaxXYFromCurvePathOps(ops);
  }
  const [minX, minY, maxX, maxY] = bounds;
  return [
    minX + element.x,
    minY + element.y,
    maxX + element.x,
    maxY + element.y
  ];
};
var getElementPointsCoords = (element, points) => {
  const gen = rough_default.generator();
  const curve2 = element.roundness == null ? gen.linearPath(
    points,
    generateRoughOptions(element)
  ) : gen.curve(points, generateRoughOptions(element));
  const ops = getCurvePathOps(curve2);
  const [minX, minY, maxX, maxY] = getMinMaxXYFromCurvePathOps(ops);
  return [
    minX + element.x,
    minY + element.y,
    maxX + element.x,
    maxY + element.y
  ];
};
var getClosestElementBounds = (elements, from3) => {
  if (!elements.length) {
    return [0, 0, 0, 0];
  }
  let minDistance = Infinity;
  let closestElement = elements[0];
  const elementsMap = arrayToMap(elements);
  elements.forEach((element) => {
    const [x1, y1, x22, y22] = getElementBounds(element, elementsMap);
    const distance5 = distance2d((x1 + x22) / 2, (y1 + y22) / 2, from3.x, from3.y);
    if (distance5 < minDistance) {
      minDistance = distance5;
      closestElement = element;
    }
  });
  return getElementBounds(closestElement, elementsMap);
};
var getCommonBoundingBox = (elements) => {
  const [minX, minY, maxX, maxY] = getCommonBounds(elements);
  return {
    minX,
    minY,
    maxX,
    maxY,
    width: maxX - minX,
    height: maxY - minY,
    midX: (minX + maxX) / 2,
    midY: (minY + maxY) / 2
  };
};
var getVisibleSceneBounds = ({
  scrollX,
  scrollY,
  width,
  height,
  zoom
}) => {
  return [
    -scrollX,
    -scrollY,
    -scrollX + width / zoom.value,
    -scrollY + height / zoom.value
  ];
};

// math.ts
var rotate2 = (x3, y3, cx, cy, angle) => (
  // =()cos()sin+
  // =()sin+()cos+.
  // https://math.stackexchange.com/questions/2204520/how-do-i-rotate-a-line-segment-in-a-specific-point-on-the-line
  [
    (x3 - cx) * Math.cos(angle) - (y3 - cy) * Math.sin(angle) + cx,
    (x3 - cx) * Math.sin(angle) + (y3 - cy) * Math.cos(angle) + cy
  ]
);
var rotatePoint = (point2, center, angle) => rotate2(point2[0], point2[1], center[0], center[1], angle);
var adjustXYWithRotation = (sides, x3, y3, angle, deltaX1, deltaY1, deltaX2, deltaY2) => {
  const cos = Math.cos(angle);
  const sin = Math.sin(angle);
  if (sides.e && sides.w) {
    x3 += deltaX1 + deltaX2;
  } else if (sides.e) {
    x3 += deltaX1 * (1 + cos);
    y3 += deltaX1 * sin;
    x3 += deltaX2 * (1 - cos);
    y3 += deltaX2 * -sin;
  } else if (sides.w) {
    x3 += deltaX1 * (1 - cos);
    y3 += deltaX1 * -sin;
    x3 += deltaX2 * (1 + cos);
    y3 += deltaX2 * sin;
  }
  if (sides.n && sides.s) {
    y3 += deltaY1 + deltaY2;
  } else if (sides.n) {
    x3 += deltaY1 * sin;
    y3 += deltaY1 * (1 - cos);
    x3 += deltaY2 * -sin;
    y3 += deltaY2 * (1 + cos);
  } else if (sides.s) {
    x3 += deltaY1 * -sin;
    y3 += deltaY1 * (1 + cos);
    x3 += deltaY2 * sin;
    y3 += deltaY2 * (1 - cos);
  }
  return [x3, y3];
};
var distance2d = (x1, y1, x22, y22) => {
  const xd = x22 - x1;
  const yd = y22 - y1;
  return Math.hypot(xd, yd);
};
var centerPoint = (a4, b4) => {
  return [(a4[0] + b4[0]) / 2, (a4[1] + b4[1]) / 2];
};
var isPathALoop = (points, zoomValue = 1) => {
  if (points.length >= 3) {
    const [first, last] = [points[0], points[points.length - 1]];
    const distance5 = distance2d(first[0], first[1], last[0], last[1]);
    return distance5 <= LINE_CONFIRM_THRESHOLD / zoomValue;
  }
  return false;
};
var isPointInPolygon = (points, x3, y3) => {
  const vertices = points.length;
  if (vertices < 3) {
    return false;
  }
  const extreme = [Number.MAX_SAFE_INTEGER, y3];
  const p3 = [x3, y3];
  let count = 0;
  for (let i4 = 0; i4 < vertices; i4++) {
    const current = points[i4];
    const next = points[(i4 + 1) % vertices];
    if (doSegmentsIntersect(current, next, p3, extreme)) {
      if (orderedColinearOrientation(current, p3, next) === 0) {
        return isPointWithinBounds(current, p3, next);
      }
      count++;
    }
  }
  return count % 2 === 1;
};
var isPointWithinBounds = (p3, q, r3) => {
  return q[0] <= Math.max(p3[0], r3[0]) && q[0] >= Math.min(p3[0], r3[0]) && q[1] <= Math.max(p3[1], r3[1]) && q[1] >= Math.min(p3[1], r3[1]);
};
var orderedColinearOrientation = (p3, q, r3) => {
  const val = (q[1] - p3[1]) * (r3[0] - q[0]) - (q[0] - p3[0]) * (r3[1] - q[1]);
  if (val === 0) {
    return 0;
  }
  return val > 0 ? 1 : 2;
};
var doSegmentsIntersect = (p1, q1, p22, q2) => {
  const o1 = orderedColinearOrientation(p1, q1, p22);
  const o22 = orderedColinearOrientation(p1, q1, q2);
  const o32 = orderedColinearOrientation(p22, q2, p1);
  const o4 = orderedColinearOrientation(p22, q2, q1);
  if (o1 !== o22 && o32 !== o4) {
    return true;
  }
  if (o1 === 0 && isPointWithinBounds(p1, p22, q1)) {
    return true;
  }
  if (o22 === 0 && isPointWithinBounds(p1, q2, q1)) {
    return true;
  }
  if (o32 === 0 && isPointWithinBounds(p22, p1, q2)) {
    return true;
  }
  if (o4 === 0 && isPointWithinBounds(p22, q1, q2)) {
    return true;
  }
  return false;
};
var getGridPoint = (x3, y3, gridSize) => {
  if (gridSize) {
    return [
      Math.round(x3 / gridSize) * gridSize,
      Math.round(y3 / gridSize) * gridSize
    ];
  }
  return [x3, y3];
};
var getCornerRadius = (x3, element) => {
  if (element.roundness?.type === ROUNDNESS.PROPORTIONAL_RADIUS || element.roundness?.type === ROUNDNESS.LEGACY) {
    return x3 * DEFAULT_PROPORTIONAL_RADIUS;
  }
  if (element.roundness?.type === ROUNDNESS.ADAPTIVE_RADIUS) {
    const fixedRadiusSize = element.roundness?.value ?? DEFAULT_ADAPTIVE_RADIUS;
    const CUTOFF_SIZE = fixedRadiusSize / DEFAULT_PROPORTIONAL_RADIUS;
    if (x3 <= CUTOFF_SIZE) {
      return x3 * DEFAULT_PROPORTIONAL_RADIUS;
    }
    return fixedRadiusSize;
  }
  return 0;
};
var getControlPointsForBezierCurve = (element, endPoint) => {
  const shape = ShapeCache.generateElementShape(element, null);
  if (!shape) {
    return null;
  }
  const ops = getCurvePathOps(shape[0]);
  let currentP = [0, 0];
  let index2 = 0;
  let minDistance = Infinity;
  let controlPoints = null;
  while (index2 < ops.length) {
    const { op, data } = ops[index2];
    if (op === "move") {
      currentP = data;
    }
    if (op === "bcurveTo") {
      const p0 = currentP;
      const p1 = [data[0], data[1]];
      const p22 = [data[2], data[3]];
      const p3 = [data[4], data[5]];
      const distance5 = distance2d(p3[0], p3[1], endPoint[0], endPoint[1]);
      if (distance5 < minDistance) {
        minDistance = distance5;
        controlPoints = [p0, p1, p22, p3];
      }
      currentP = p3;
    }
    index2++;
  }
  return controlPoints;
};
var getBezierXY = (p0, p1, p22, p3, t4) => {
  const equation2 = (t5, idx) => Math.pow(1 - t5, 3) * p3[idx] + 3 * t5 * Math.pow(1 - t5, 2) * p22[idx] + 3 * Math.pow(t5, 2) * (1 - t5) * p1[idx] + p0[idx] * Math.pow(t5, 3);
  const tx = equation2(t4, 0);
  const ty = equation2(t4, 1);
  return [tx, ty];
};
var getPointsInBezierCurve = (element, endPoint) => {
  const controlPoints = getControlPointsForBezierCurve(
    element,
    endPoint
  );
  if (!controlPoints) {
    return [];
  }
  const pointsOnCurve = [];
  let t4 = 1;
  while (t4 > 0) {
    const point2 = getBezierXY(
      controlPoints[0],
      controlPoints[1],
      controlPoints[2],
      controlPoints[3],
      t4
    );
    pointsOnCurve.push([point2[0], point2[1]]);
    t4 -= 0.05;
  }
  if (pointsOnCurve.length) {
    if (arePointsEqual(pointsOnCurve.at(-1), endPoint)) {
      pointsOnCurve.push([endPoint[0], endPoint[1]]);
    }
  }
  return pointsOnCurve;
};
var getBezierCurveArcLengths = (element, endPoint) => {
  const arcLengths = [];
  arcLengths[0] = 0;
  const points = getPointsInBezierCurve(element, endPoint);
  let index2 = 0;
  let distance5 = 0;
  while (index2 < points.length - 1) {
    const segmentDistance = distance2d(
      points[index2][0],
      points[index2][1],
      points[index2 + 1][0],
      points[index2 + 1][1]
    );
    distance5 += segmentDistance;
    arcLengths.push(distance5);
    index2++;
  }
  return arcLengths;
};
var getBezierCurveLength = (element, endPoint) => {
  const arcLengths = getBezierCurveArcLengths(element, endPoint);
  return arcLengths.at(-1);
};
var mapIntervalToBezierT = (element, endPoint, interval) => {
  const arcLengths = getBezierCurveArcLengths(element, endPoint);
  const pointsCount = arcLengths.length - 1;
  const curveLength = arcLengths.at(-1);
  const targetLength = interval * curveLength;
  let low = 0;
  let high = pointsCount;
  let index2 = 0;
  while (low < high) {
    index2 = Math.floor(low + (high - low) / 2);
    if (arcLengths[index2] < targetLength) {
      low = index2 + 1;
    } else {
      high = index2;
    }
  }
  if (arcLengths[index2] > targetLength) {
    index2--;
  }
  if (arcLengths[index2] === targetLength) {
    return index2 / pointsCount;
  }
  return 1 - (index2 + (targetLength - arcLengths[index2]) / (arcLengths[index2 + 1] - arcLengths[index2])) / pointsCount;
};
var arePointsEqual = (p1, p22) => {
  return p1[0] === p22[0] && p1[1] === p22[1];
};
var isRightAngle = (angle) => {
  return Math.round(angle / Math.PI * 1e4) % 5e3 === 0;
};
var rangesOverlap = ([a0, a1], [b0, b1]) => {
  if (a0 <= b0) {
    return a1 >= b0;
  }
  if (a0 >= b0) {
    return b1 >= a0;
  }
  return false;
};
var rangeIntersection = (rangeA, rangeB) => {
  const rangeStart = Math.max(rangeA[0], rangeB[0]);
  const rangeEnd = Math.min(rangeA[1], rangeB[1]);
  if (rangeStart <= rangeEnd) {
    return [rangeStart, rangeEnd];
  }
  return null;
};
var isValueInRange = (value, min, max) => {
  return value >= min && value <= max;
};

// ../utils/export.ts
init_define_import_meta_env();

// scene/export.ts
init_define_import_meta_env();

// renderer/renderScene.ts
init_define_import_meta_env();

// renderer/roundRect.ts
init_define_import_meta_env();
var roundRect = (context, x3, y3, width, height, radius, strokeColor) => {
  context.beginPath();
  context.moveTo(x3 + radius, y3);
  context.lineTo(x3 + width - radius, y3);
  context.quadraticCurveTo(x3 + width, y3, x3 + width, y3 + radius);
  context.lineTo(x3 + width, y3 + height - radius);
  context.quadraticCurveTo(
    x3 + width,
    y3 + height,
    x3 + width - radius,
    y3 + height
  );
  context.lineTo(x3 + radius, y3 + height);
  context.quadraticCurveTo(x3, y3 + height, x3, y3 + height - radius);
  context.lineTo(x3, y3 + radius);
  context.quadraticCurveTo(x3, y3, x3 + radius, y3);
  context.closePath();
  context.fill();
  if (strokeColor) {
    context.strokeStyle = strokeColor;
  }
  context.stroke();
};

// scene/scrollbars.ts
init_define_import_meta_env();

// i18n.ts
init_define_import_meta_env();

// jotai.ts
init_define_import_meta_env();

// ../../node_modules/jotai/esm/index.mjs
init_define_import_meta_env();
var import_react = __toESM(require_react(), 1);

// ../../node_modules/jotai/esm/vanilla.mjs
init_define_import_meta_env();
var keyCount = 0;
function atom(read, write) {
  const key = `atom${++keyCount}`;
  const config = {
    toString: () => key
  };
  if (typeof read === "function") {
    config.read = read;
  } else {
    config.init = read;
    config.read = (get) => get(config);
    config.write = (get, set, arg) => set(
      config,
      typeof arg === "function" ? arg(get(config)) : arg
    );
  }
  if (write) {
    config.write = write;
  }
  return config;
}

// ../../node_modules/jotai/esm/index.mjs
var SUSPENSE_PROMISE = Symbol();
var isSuspensePromise = (promise) => !!promise[SUSPENSE_PROMISE];
var isSuspensePromiseAlreadyCancelled = (suspensePromise) => !suspensePromise[SUSPENSE_PROMISE].c;
var cancelSuspensePromise = (suspensePromise) => {
  var _a;
  const { b: basePromise, c: cancelPromise } = suspensePromise[SUSPENSE_PROMISE];
  if (cancelPromise) {
    cancelPromise();
    (_a = promiseAbortMap.get(basePromise)) == null ? void 0 : _a();
  }
};
var isEqualSuspensePromise = (oldSuspensePromise, newSuspensePromise) => {
  const oldOriginalPromise = oldSuspensePromise[SUSPENSE_PROMISE].o;
  const newOriginalPromise = newSuspensePromise[SUSPENSE_PROMISE].o;
  return oldOriginalPromise === newOriginalPromise || oldSuspensePromise === newOriginalPromise || isSuspensePromise(oldOriginalPromise) && isEqualSuspensePromise(oldOriginalPromise, newSuspensePromise);
};
var createSuspensePromise = (basePromise, promise) => {
  const suspensePromiseExtra = {
    b: basePromise,
    o: promise,
    c: null
  };
  const suspensePromise = new Promise((resolve) => {
    suspensePromiseExtra.c = () => {
      suspensePromiseExtra.c = null;
      resolve();
    };
    promise.finally(suspensePromiseExtra.c);
  });
  suspensePromise[SUSPENSE_PROMISE] = suspensePromiseExtra;
  return suspensePromise;
};
var copySuspensePromise = (suspensePromise) => createSuspensePromise(
  suspensePromise[SUSPENSE_PROMISE].b,
  suspensePromise[SUSPENSE_PROMISE].o
);
var promiseAbortMap = /* @__PURE__ */ new WeakMap();
var hasInitialValue = (atom3) => "init" in atom3;
var READ_ATOM = "r";
var WRITE_ATOM = "w";
var COMMIT_ATOM = "c";
var SUBSCRIBE_ATOM = "s";
var RESTORE_ATOMS = "h";
var DEV_SUBSCRIBE_STATE = "n";
var DEV_GET_MOUNTED_ATOMS = "l";
var DEV_GET_ATOM_STATE = "a";
var DEV_GET_MOUNTED = "m";
var createStore = (initialValues) => {
  const committedAtomStateMap = /* @__PURE__ */ new WeakMap();
  const mountedMap = /* @__PURE__ */ new WeakMap();
  const pendingMap = /* @__PURE__ */ new Map();
  let stateListeners;
  let mountedAtoms;
  if ((define_import_meta_env_default && define_import_meta_env_default.MODE) !== "production") {
    stateListeners = /* @__PURE__ */ new Set();
    mountedAtoms = /* @__PURE__ */ new Set();
  }
  if (initialValues) {
    for (const [atom3, value] of initialValues) {
      const atomState = {
        v: value,
        r: 0,
        y: true,
        // not invalidated
        d: /* @__PURE__ */ new Map()
      };
      if ((define_import_meta_env_default && define_import_meta_env_default.MODE) !== "production") {
        Object.freeze(atomState);
        if (!hasInitialValue(atom3)) {
          console.warn(
            "Found initial value for derived atom which can cause unexpected behavior",
            atom3
          );
        }
      }
      committedAtomStateMap.set(atom3, atomState);
    }
  }
  const suspensePromiseCacheMap = /* @__PURE__ */ new WeakMap();
  const addSuspensePromiseToCache = (version, atom3, suspensePromise) => {
    let cache = suspensePromiseCacheMap.get(atom3);
    if (!cache) {
      cache = /* @__PURE__ */ new Map();
      suspensePromiseCacheMap.set(atom3, cache);
    }
    suspensePromise.then(() => {
      if (cache.get(version) === suspensePromise) {
        cache.delete(version);
        if (!cache.size) {
          suspensePromiseCacheMap.delete(atom3);
        }
      }
    });
    cache.set(version, suspensePromise);
  };
  const cancelAllSuspensePromiseInCache = (atom3) => {
    const versionSet = /* @__PURE__ */ new Set();
    const cache = suspensePromiseCacheMap.get(atom3);
    if (cache) {
      suspensePromiseCacheMap.delete(atom3);
      cache.forEach((suspensePromise, version) => {
        cancelSuspensePromise(suspensePromise);
        versionSet.add(version);
      });
    }
    return versionSet;
  };
  const versionedAtomStateMapMap = /* @__PURE__ */ new WeakMap();
  const getVersionedAtomStateMap = (version) => {
    let versionedAtomStateMap = versionedAtomStateMapMap.get(version);
    if (!versionedAtomStateMap) {
      versionedAtomStateMap = /* @__PURE__ */ new Map();
      versionedAtomStateMapMap.set(version, versionedAtomStateMap);
    }
    return versionedAtomStateMap;
  };
  const getAtomState = (version, atom3) => {
    if (version) {
      const versionedAtomStateMap = getVersionedAtomStateMap(version);
      let atomState = versionedAtomStateMap.get(atom3);
      if (!atomState) {
        atomState = getAtomState(version.p, atom3);
        if (atomState && "p" in atomState && isSuspensePromiseAlreadyCancelled(atomState.p)) {
          atomState = void 0;
        }
        if (atomState) {
          versionedAtomStateMap.set(atom3, atomState);
        }
      }
      return atomState;
    }
    return committedAtomStateMap.get(atom3);
  };
  const setAtomState = (version, atom3, atomState) => {
    if ((define_import_meta_env_default && define_import_meta_env_default.MODE) !== "production") {
      Object.freeze(atomState);
    }
    if (version) {
      const versionedAtomStateMap = getVersionedAtomStateMap(version);
      versionedAtomStateMap.set(atom3, atomState);
    } else {
      const prevAtomState = committedAtomStateMap.get(atom3);
      committedAtomStateMap.set(atom3, atomState);
      if (!pendingMap.has(atom3)) {
        pendingMap.set(atom3, prevAtomState);
      }
    }
  };
  const createReadDependencies = (version, prevReadDependencies = /* @__PURE__ */ new Map(), dependencies) => {
    if (!dependencies) {
      return prevReadDependencies;
    }
    const readDependencies = /* @__PURE__ */ new Map();
    let changed = false;
    dependencies.forEach((atom3) => {
      var _a;
      const revision = ((_a = getAtomState(version, atom3)) == null ? void 0 : _a.r) || 0;
      readDependencies.set(atom3, revision);
      if (prevReadDependencies.get(atom3) !== revision) {
        changed = true;
      }
    });
    if (prevReadDependencies.size === readDependencies.size && !changed) {
      return prevReadDependencies;
    }
    return readDependencies;
  };
  const setAtomValue = (version, atom3, value, dependencies, suspensePromise) => {
    const atomState = getAtomState(version, atom3);
    if (atomState) {
      if (suspensePromise && (!("p" in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {
        return atomState;
      }
      if ("p" in atomState) {
        cancelSuspensePromise(atomState.p);
      }
    }
    const nextAtomState = {
      v: value,
      r: (atomState == null ? void 0 : atomState.r) || 0,
      y: true,
      // not invalidated
      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)
    };
    let changed = !(atomState == null ? void 0 : atomState.y);
    if (!atomState || !("v" in atomState) || // new value, or
    !Object.is(atomState.v, value)) {
      changed = true;
      ++nextAtomState.r;
      if (nextAtomState.d.has(atom3)) {
        nextAtomState.d = new Map(nextAtomState.d).set(atom3, nextAtomState.r);
      }
    } else if (nextAtomState.d !== atomState.d && (nextAtomState.d.size !== atomState.d.size || !Array.from(nextAtomState.d.keys()).every((a4) => atomState.d.has(a4)))) {
      changed = true;
      Promise.resolve().then(() => {
        flushPending(version);
      });
    }
    if (atomState && !changed) {
      return atomState;
    }
    setAtomState(version, atom3, nextAtomState);
    return nextAtomState;
  };
  const setAtomReadError = (version, atom3, error, dependencies, suspensePromise) => {
    const atomState = getAtomState(version, atom3);
    if (atomState) {
      if (suspensePromise && (!("p" in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {
        return atomState;
      }
      if ("p" in atomState) {
        cancelSuspensePromise(atomState.p);
      }
    }
    const nextAtomState = {
      e: error,
      // set read error
      r: ((atomState == null ? void 0 : atomState.r) || 0) + 1,
      y: true,
      // not invalidated
      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)
    };
    setAtomState(version, atom3, nextAtomState);
    return nextAtomState;
  };
  const setAtomSuspensePromise = (version, atom3, suspensePromise, dependencies) => {
    const atomState = getAtomState(version, atom3);
    if (atomState && "p" in atomState) {
      if (isEqualSuspensePromise(atomState.p, suspensePromise) && !isSuspensePromiseAlreadyCancelled(atomState.p)) {
        if (!atomState.y) {
          return { ...atomState, y: true };
        }
        return atomState;
      }
      cancelSuspensePromise(atomState.p);
    }
    addSuspensePromiseToCache(version, atom3, suspensePromise);
    const nextAtomState = {
      p: suspensePromise,
      r: ((atomState == null ? void 0 : atomState.r) || 0) + 1,
      y: true,
      // not invalidated
      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)
    };
    setAtomState(version, atom3, nextAtomState);
    return nextAtomState;
  };
  const setAtomPromiseOrValue = (version, atom3, promiseOrValue, dependencies) => {
    if (promiseOrValue instanceof Promise) {
      const suspensePromise = createSuspensePromise(
        promiseOrValue,
        promiseOrValue.then((value) => {
          setAtomValue(version, atom3, value, dependencies, suspensePromise);
        }).catch((e3) => {
          if (e3 instanceof Promise) {
            if (isSuspensePromise(e3)) {
              return e3.then(() => {
                readAtomState(version, atom3, true);
              });
            }
            return e3;
          }
          setAtomReadError(version, atom3, e3, dependencies, suspensePromise);
        })
      );
      return setAtomSuspensePromise(
        version,
        atom3,
        suspensePromise,
        dependencies
      );
    }
    return setAtomValue(
      version,
      atom3,
      promiseOrValue,
      dependencies
    );
  };
  const setAtomInvalidated = (version, atom3) => {
    const atomState = getAtomState(version, atom3);
    if (atomState) {
      const nextAtomState = {
        ...atomState,
        // copy everything
        y: false
        // invalidated
      };
      setAtomState(version, atom3, nextAtomState);
    } else if ((define_import_meta_env_default && define_import_meta_env_default.MODE) !== "production") {
      console.warn("[Bug] could not invalidate non existing atom", atom3);
    }
  };
  const readAtomState = (version, atom3, force) => {
    if (!force) {
      const atomState = getAtomState(version, atom3);
      if (atomState) {
        if (atomState.y && // not invalidated
        "p" in atomState && !isSuspensePromiseAlreadyCancelled(atomState.p)) {
          return atomState;
        }
        atomState.d.forEach((_, a4) => {
          if (a4 !== atom3) {
            if (!mountedMap.has(a4)) {
              readAtomState(version, a4);
            } else {
              const aState = getAtomState(version, a4);
              if (aState && !aState.y) {
                readAtomState(version, a4);
              }
            }
          }
        });
        if (Array.from(atomState.d).every(([a4, r3]) => {
          const aState = getAtomState(version, a4);
          return aState && !("p" in aState) && // has no suspense promise
          aState.r === r3;
        })) {
          if (!atomState.y) {
            return { ...atomState, y: true };
          }
          return atomState;
        }
      }
    }
    const dependencies = /* @__PURE__ */ new Set();
    try {
      const promiseOrValue = atom3.read((a4) => {
        dependencies.add(a4);
        const aState = a4 === atom3 ? getAtomState(version, a4) : readAtomState(version, a4);
        if (aState) {
          if ("e" in aState) {
            throw aState.e;
          }
          if ("p" in aState) {
            throw aState.p;
          }
          return aState.v;
        }
        if (hasInitialValue(a4)) {
          return a4.init;
        }
        throw new Error("no atom init");
      });
      return setAtomPromiseOrValue(version, atom3, promiseOrValue, dependencies);
    } catch (errorOrPromise) {
      if (errorOrPromise instanceof Promise) {
        const suspensePromise = isSuspensePromise(errorOrPromise) && isSuspensePromiseAlreadyCancelled(errorOrPromise) ? copySuspensePromise(errorOrPromise) : createSuspensePromise(errorOrPromise, errorOrPromise);
        return setAtomSuspensePromise(
          version,
          atom3,
          suspensePromise,
          dependencies
        );
      }
      return setAtomReadError(version, atom3, errorOrPromise, dependencies);
    }
  };
  const readAtom = (readingAtom, version) => {
    const atomState = readAtomState(version, readingAtom);
    return atomState;
  };
  const addAtom = (version, addingAtom) => {
    let mounted = mountedMap.get(addingAtom);
    if (!mounted) {
      mounted = mountAtom(version, addingAtom);
    }
    return mounted;
  };
  const canUnmountAtom = (atom3, mounted) => !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom3));
  const delAtom = (version, deletingAtom) => {
    const mounted = mountedMap.get(deletingAtom);
    if (mounted && canUnmountAtom(deletingAtom, mounted)) {
      unmountAtom(version, deletingAtom);
    }
  };
  const invalidateDependents = (version, atom3) => {
    const mounted = mountedMap.get(atom3);
    mounted == null ? void 0 : mounted.t.forEach((dependent) => {
      if (dependent !== atom3) {
        setAtomInvalidated(version, dependent);
        invalidateDependents(version, dependent);
      }
    });
  };
  const writeAtomState = (version, atom3, update) => {
    let isSync = true;
    const writeGetter = (a4, options) => {
      const aState = readAtomState(version, a4);
      if ("e" in aState) {
        throw aState.e;
      }
      if ("p" in aState) {
        if (options == null ? void 0 : options.unstable_promise) {
          return aState.p.then(() => {
            const s4 = getAtomState(version, a4);
            if (s4 && "p" in s4 && s4.p === aState.p) {
              return new Promise((resolve) => setTimeout(resolve)).then(
                () => writeGetter(a4, options)
              );
            }
            return writeGetter(a4, options);
          });
        }
        if ((define_import_meta_env_default && define_import_meta_env_default.MODE) !== "production") {
          console.info(
            "Reading pending atom state in write operation. We throw a promise for now.",
            a4
          );
        }
        throw aState.p;
      }
      if ("v" in aState) {
        return aState.v;
      }
      if ((define_import_meta_env_default && define_import_meta_env_default.MODE) !== "production") {
        console.warn(
          "[Bug] no value found while reading atom in write operation. This is probably a bug.",
          a4
        );
      }
      throw new Error("no value found");
    };
    const setter = (a4, v3) => {
      let promiseOrVoid2;
      if (a4 === atom3) {
        if (!hasInitialValue(a4)) {
          throw new Error("atom not writable");
        }
        const versionSet = cancelAllSuspensePromiseInCache(a4);
        versionSet.forEach((cancelledVersion) => {
          if (cancelledVersion !== version) {
            setAtomPromiseOrValue(cancelledVersion, a4, v3);
          }
        });
        const prevAtomState = getAtomState(version, a4);
        const nextAtomState = setAtomPromiseOrValue(version, a4, v3);
        if (prevAtomState !== nextAtomState) {
          invalidateDependents(version, a4);
        }
      } else {
        promiseOrVoid2 = writeAtomState(version, a4, v3);
      }
      if (!isSync) {
        flushPending(version);
      }
      return promiseOrVoid2;
    };
    const promiseOrVoid = atom3.write(writeGetter, setter, update);
    isSync = false;
    return promiseOrVoid;
  };
  const writeAtom = (writingAtom, update, version) => {
    const promiseOrVoid = writeAtomState(version, writingAtom, update);
    flushPending(version);
    return promiseOrVoid;
  };
  const isActuallyWritableAtom = (atom3) => !!atom3.write;
  const mountAtom = (version, atom3, initialDependent) => {
    const mounted = {
      t: new Set(initialDependent && [initialDependent]),
      l: /* @__PURE__ */ new Set()
    };
    mountedMap.set(atom3, mounted);
    if ((define_import_meta_env_default && define_import_meta_env_default.MODE) !== "production") {
      mountedAtoms.add(atom3);
    }
    const atomState = readAtomState(void 0, atom3);
    atomState.d.forEach((_, a4) => {
      const aMounted = mountedMap.get(a4);
      if (aMounted) {
        aMounted.t.add(atom3);
      } else {
        if (a4 !== atom3) {
          mountAtom(version, a4, atom3);
        }
      }
    });
    if (isActuallyWritableAtom(atom3) && atom3.onMount) {
      const setAtom = (update) => writeAtom(atom3, update, version);
      const onUnmount = atom3.onMount(setAtom);
      version = void 0;
      if (onUnmount) {
        mounted.u = onUnmount;
      }
    }
    return mounted;
  };
  const unmountAtom = (version, atom3) => {
    var _a;
    const onUnmount = (_a = mountedMap.get(atom3)) == null ? void 0 : _a.u;
    if (onUnmount) {
      onUnmount();
    }
    mountedMap.delete(atom3);
    if ((define_import_meta_env_default && define_import_meta_env_default.MODE) !== "production") {
      mountedAtoms.delete(atom3);
    }
    const atomState = getAtomState(version, atom3);
    if (atomState) {
      if ("p" in atomState) {
        cancelSuspensePromise(atomState.p);
      }
      atomState.d.forEach((_, a4) => {
        if (a4 !== atom3) {
          const mounted = mountedMap.get(a4);
          if (mounted) {
            mounted.t.delete(atom3);
            if (canUnmountAtom(a4, mounted)) {
              unmountAtom(version, a4);
            }
          }
        }
      });
    } else if ((define_import_meta_env_default && define_import_meta_env_default.MODE) !== "production") {
      console.warn("[Bug] could not find atom state to unmount", atom3);
    }
  };
  const mountDependencies = (version, atom3, atomState, prevReadDependencies) => {
    const dependencies = new Set(atomState.d.keys());
    prevReadDependencies == null ? void 0 : prevReadDependencies.forEach((_, a4) => {
      if (dependencies.has(a4)) {
        dependencies.delete(a4);
        return;
      }
      const mounted = mountedMap.get(a4);
      if (mounted) {
        mounted.t.delete(atom3);
        if (canUnmountAtom(a4, mounted)) {
          unmountAtom(version, a4);
        }
      }
    });
    dependencies.forEach((a4) => {
      const mounted = mountedMap.get(a4);
      if (mounted) {
        mounted.t.add(atom3);
      } else if (mountedMap.has(atom3)) {
        mountAtom(version, a4, atom3);
      }
    });
  };
  const flushPending = (version) => {
    if (version) {
      const versionedAtomStateMap = getVersionedAtomStateMap(version);
      versionedAtomStateMap.forEach((atomState, atom3) => {
        const committedAtomState = committedAtomStateMap.get(atom3);
        if (atomState !== committedAtomState) {
          const mounted = mountedMap.get(atom3);
          mounted == null ? void 0 : mounted.l.forEach((listener) => listener(version));
        }
      });
      return;
    }
    while (pendingMap.size) {
      const pending = Array.from(pendingMap);
      pendingMap.clear();
      pending.forEach(([atom3, prevAtomState]) => {
        const atomState = getAtomState(void 0, atom3);
        if (atomState && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {
          mountDependencies(void 0, atom3, atomState, prevAtomState == null ? void 0 : prevAtomState.d);
        }
        if (prevAtomState && !prevAtomState.y && // invalidated
        (atomState == null ? void 0 : atomState.y)) {
          return;
        }
        const mounted = mountedMap.get(atom3);
        mounted == null ? void 0 : mounted.l.forEach((listener) => listener());
      });
    }
    if ((define_import_meta_env_default && define_import_meta_env_default.MODE) !== "production") {
      stateListeners.forEach((l4) => l4());
    }
  };
  const commitVersionedAtomStateMap = (version) => {
    const versionedAtomStateMap = getVersionedAtomStateMap(version);
    versionedAtomStateMap.forEach((atomState, atom3) => {
      const prevAtomState = committedAtomStateMap.get(atom3);
      if (!prevAtomState || atomState.r > prevAtomState.r || atomState.y !== prevAtomState.y || atomState.r === prevAtomState.r && atomState.d !== prevAtomState.d) {
        committedAtomStateMap.set(atom3, atomState);
        if (atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {
          mountDependencies(version, atom3, atomState, prevAtomState == null ? void 0 : prevAtomState.d);
        }
      }
    });
  };
  const commitAtom = (_atom, version) => {
    if (version) {
      commitVersionedAtomStateMap(version);
    }
    flushPending(void 0);
  };
  const subscribeAtom = (atom3, callback, version) => {
    const mounted = addAtom(version, atom3);
    const listeners = mounted.l;
    listeners.add(callback);
    return () => {
      listeners.delete(callback);
      delAtom(version, atom3);
    };
  };
  const restoreAtoms = (values, version) => {
    for (const [atom3, value] of values) {
      if (hasInitialValue(atom3)) {
        setAtomPromiseOrValue(version, atom3, value);
        invalidateDependents(version, atom3);
      }
    }
    flushPending(version);
  };
  if ((define_import_meta_env_default && define_import_meta_env_default.MODE) !== "production") {
    return {
      [READ_ATOM]: readAtom,
      [WRITE_ATOM]: writeAtom,
      [COMMIT_ATOM]: commitAtom,
      [SUBSCRIBE_ATOM]: subscribeAtom,
      [RESTORE_ATOMS]: restoreAtoms,
      [DEV_SUBSCRIBE_STATE]: (l4) => {
        stateListeners.add(l4);
        return () => {
          stateListeners.delete(l4);
        };
      },
      [DEV_GET_MOUNTED_ATOMS]: () => mountedAtoms.values(),
      [DEV_GET_ATOM_STATE]: (a4) => committedAtomStateMap.get(a4),
      [DEV_GET_MOUNTED]: (a4) => mountedMap.get(a4)
    };
  }
  return {
    [READ_ATOM]: readAtom,
    [WRITE_ATOM]: writeAtom,
    [COMMIT_ATOM]: commitAtom,
    [SUBSCRIBE_ATOM]: subscribeAtom,
    [RESTORE_ATOMS]: restoreAtoms
  };
};
var createStoreForExport = (initialValues) => {
  const store = createStore(initialValues);
  const get = (atom3) => {
    const atomState = store[READ_ATOM](atom3);
    if ("e" in atomState) {
      throw atomState.e;
    }
    if ("p" in atomState) {
      return void 0;
    }
    return atomState.v;
  };
  const asyncGet = (atom3) => new Promise((resolve, reject) => {
    const atomState = store[READ_ATOM](atom3);
    if ("e" in atomState) {
      reject(atomState.e);
    } else if ("p" in atomState) {
      resolve(atomState.p.then(() => asyncGet(atom3)));
    } else {
      resolve(atomState.v);
    }
  });
  const set = (atom3, update) => store[WRITE_ATOM](atom3, update);
  const sub2 = (atom3, callback) => store[SUBSCRIBE_ATOM](atom3, callback);
  return {
    get,
    asyncGet,
    set,
    sub: sub2,
    SECRET_INTERNAL_store: store
  };
};
var createScopeContainer = (initialValues, unstable_createStore) => {
  const store = unstable_createStore ? unstable_createStore(initialValues).SECRET_INTERNAL_store : createStore(initialValues);
  return { s: store };
};
var ScopeContextMap = /* @__PURE__ */ new Map();
var getScopeContext = (scope) => {
  if (!ScopeContextMap.has(scope)) {
    ScopeContextMap.set(scope, (0, import_react.createContext)(createScopeContainer()));
  }
  return ScopeContextMap.get(scope);
};
var Provider = ({
  children,
  initialValues,
  scope,
  unstable_createStore,
  unstable_enableVersionedWrite
}) => {
  const [version, setVersion] = (0, import_react.useState)({});
  (0, import_react.useEffect)(() => {
    const scopeContainer = scopeContainerRef.current;
    if (scopeContainer.w) {
      scopeContainer.s[COMMIT_ATOM](null, version);
      delete version.p;
      scopeContainer.v = version;
    }
  }, [version]);
  const scopeContainerRef = (0, import_react.useRef)();
  if (!scopeContainerRef.current) {
    const scopeContainer = createScopeContainer(
      initialValues,
      unstable_createStore
    );
    if (unstable_enableVersionedWrite) {
      let retrying = 0;
      scopeContainer.w = (write) => {
        setVersion((parentVersion) => {
          const nextVersion = retrying ? parentVersion : { p: parentVersion };
          write(nextVersion);
          return nextVersion;
        });
      };
      scopeContainer.v = version;
      scopeContainer.r = (fn) => {
        ++retrying;
        fn();
        --retrying;
      };
    }
    scopeContainerRef.current = scopeContainer;
  }
  const ScopeContainerContext = getScopeContext(scope);
  return (0, import_react.createElement)(
    ScopeContainerContext.Provider,
    {
      value: scopeContainerRef.current
    },
    children
  );
};
function atom2(read, write) {
  return atom(read, write);
}
function useAtomValue(atom3, scope) {
  const ScopeContext = getScopeContext(scope);
  const scopeContainer = (0, import_react.useContext)(ScopeContext);
  const { s: store, v: versionFromProvider } = scopeContainer;
  const getAtomValue = (version2) => {
    const atomState = store[READ_ATOM](atom3, version2);
    if ((define_import_meta_env_default && define_import_meta_env_default.MODE) !== "production" && !atomState.y) {
      throw new Error("should not be invalidated");
    }
    if ("e" in atomState) {
      throw atomState.e;
    }
    if ("p" in atomState) {
      throw atomState.p;
    }
    if ("v" in atomState) {
      return atomState.v;
    }
    throw new Error("no atom value");
  };
  const [[version, valueFromReducer, atomFromReducer], rerenderIfChanged] = (0, import_react.useReducer)(
    (prev, nextVersion) => {
      const nextValue = getAtomValue(nextVersion);
      if (Object.is(prev[1], nextValue) && prev[2] === atom3) {
        return prev;
      }
      return [nextVersion, nextValue, atom3];
    },
    versionFromProvider,
    (initialVersion) => {
      const initialValue = getAtomValue(initialVersion);
      return [initialVersion, initialValue, atom3];
    }
  );
  let value = valueFromReducer;
  if (atomFromReducer !== atom3) {
    rerenderIfChanged(version);
    value = getAtomValue(version);
  }
  (0, import_react.useEffect)(() => {
    const { v: versionFromProvider2 } = scopeContainer;
    if (versionFromProvider2) {
      store[COMMIT_ATOM](atom3, versionFromProvider2);
    }
    const unsubscribe = store[SUBSCRIBE_ATOM](
      atom3,
      rerenderIfChanged,
      versionFromProvider2
    );
    rerenderIfChanged(versionFromProvider2);
    return unsubscribe;
  }, [store, atom3, scopeContainer]);
  (0, import_react.useEffect)(() => {
    store[COMMIT_ATOM](atom3, version);
  });
  (0, import_react.useDebugValue)(value);
  return value;
}
function useSetAtom(atom3, scope) {
  const ScopeContext = getScopeContext(scope);
  const { s: store, w: versionedWrite } = (0, import_react.useContext)(ScopeContext);
  const setAtom = (0, import_react.useCallback)(
    (update) => {
      if ((define_import_meta_env_default && define_import_meta_env_default.MODE) !== "production" && !("write" in atom3)) {
        throw new Error("not writable atom");
      }
      const write = (version) => store[WRITE_ATOM](atom3, update, version);
      return versionedWrite ? versionedWrite(write) : write();
    },
    [store, versionedWrite, atom3]
  );
  return setAtom;
}
function useAtom(atom3, scope) {
  if ("scope" in atom3) {
    console.warn(
      "atom.scope is deprecated. Please do useAtom(atom, scope) instead."
    );
    scope = atom3.scope;
  }
  return [
    useAtomValue(atom3, scope),
    // We do wrong type assertion here, which results in throwing an error.
    useSetAtom(atom3, scope)
  ];
}

// jotai.ts
var import_react2 = __toESM(require_react(), 1);
var jotaiScope = Symbol();
var jotaiStore = createStoreForExport();

// import("./locales/**/*.json") in i18n.ts
var globImport_locales_json = __glob({
  "./locales/ar-SA.json": () => import("./ar-SA-JUOY75SY.js"),
  "./locales/az-AZ.json": () => import("./az-AZ-ZTGDEBNA.js"),
  "./locales/bg-BG.json": () => import("./bg-BG-UCJKL6IW.js"),
  "./locales/bn-BD.json": () => import("./bn-BD-D7HJKN5C.js"),
  "./locales/ca-ES.json": () => import("./ca-ES-RPGW7GTT.js"),
  "./locales/cs-CZ.json": () => import("./cs-CZ-XLNNHX2P.js"),
  "./locales/da-DK.json": () => import("./da-DK-6OKJ2GQ6.js"),
  "./locales/de-DE.json": () => import("./de-DE-BD5ICOQ2.js"),
  "./locales/el-GR.json": () => import("./el-GR-JFDBTDHS.js"),
  "./locales/en.json": () => import("./en-S3L7K5H6.js"),
  "./locales/es-ES.json": () => import("./es-ES-CBBTGYGR.js"),
  "./locales/eu-ES.json": () => import("./eu-ES-CHAPMSLE.js"),
  "./locales/fa-IR.json": () => import("./fa-IR-LOJOKEJO.js"),
  "./locales/fi-FI.json": () => import("./fi-FI-F3V5AS4L.js"),
  "./locales/fr-FR.json": () => import("./fr-FR-2N7S6WX3.js"),
  "./locales/gl-ES.json": () => import("./gl-ES-6IHRWREV.js"),
  "./locales/he-IL.json": () => import("./he-IL-LVFJXEFL.js"),
  "./locales/hi-IN.json": () => import("./hi-IN-ID6TO5TY.js"),
  "./locales/hu-HU.json": () => import("./hu-HU-HJRHONHJ.js"),
  "./locales/id-ID.json": () => import("./id-ID-PEJQFNAQ.js"),
  "./locales/it-IT.json": () => import("./it-IT-BBUUF24S.js"),
  "./locales/ja-JP.json": () => import("./ja-JP-FFP3KIX2.js"),
  "./locales/kaa.json": () => import("./kaa-BLBL2DQS.js"),
  "./locales/kab-KAB.json": () => import("./kab-KAB-MISJR6YA.js"),
  "./locales/kk-KZ.json": () => import("./kk-KZ-SZHAXTWQ.js"),
  "./locales/km-KH.json": () => import("./km-KH-DH4CBSZO.js"),
  "./locales/ko-KR.json": () => import("./ko-KR-X46ENAO4.js"),
  "./locales/ku-TR.json": () => import("./ku-TR-KIRZJOQG.js"),
  "./locales/lt-LT.json": () => import("./lt-LT-LYH376GX.js"),
  "./locales/lv-LV.json": () => import("./lv-LV-GW6O7VJB.js"),
  "./locales/mr-IN.json": () => import("./mr-IN-C46Q25TT.js"),
  "./locales/my-MM.json": () => import("./my-MM-6APSZS7C.js"),
  "./locales/nb-NO.json": () => import("./nb-NO-3TYKHCL6.js"),
  "./locales/nl-NL.json": () => import("./nl-NL-EKYDNS5D.js"),
  "./locales/nn-NO.json": () => import("./nn-NO-DGVU75VO.js"),
  "./locales/oc-FR.json": () => import("./oc-FR-L6C7AUZC.js"),
  "./locales/pa-IN.json": () => import("./pa-IN-SRCTDUL7.js"),
  "./locales/percentages.json": () => import("./percentages-O23NFS3D.js"),
  "./locales/pl-PL.json": () => import("./pl-PL-HINSTGCG.js"),
  "./locales/pt-BR.json": () => import("./pt-BR-QVI2MAA2.js"),
  "./locales/pt-PT.json": () => import("./pt-PT-WP2IPC2Q.js"),
  "./locales/ro-RO.json": () => import("./ro-RO-5FIUYQWO.js"),
  "./locales/ru-RU.json": () => import("./ru-RU-L5TOVN4H.js"),
  "./locales/si-LK.json": () => import("./si-LK-P2R2SZBE.js"),
  "./locales/sk-SK.json": () => import("./sk-SK-6EAZ2WVJ.js"),
  "./locales/sl-SI.json": () => import("./sl-SI-GK5NVQ52.js"),
  "./locales/sv-SE.json": () => import("./sv-SE-5NZCZIXB.js"),
  "./locales/ta-IN.json": () => import("./ta-IN-4JINQRFX.js"),
  "./locales/th-TH.json": () => import("./th-TH-H2WCSL7D.js"),
  "./locales/tr-TR.json": () => import("./tr-TR-A3JSCHA5.js"),
  "./locales/uk-UA.json": () => import("./uk-UA-UGR35JOU.js"),
  "./locales/vi-VN.json": () => import("./vi-VN-NU5HK63V.js"),
  "./locales/zh-CN.json": () => import("./zh-CN-O3LIEVWE.js"),
  "./locales/zh-HK.json": () => import("./zh-HK-B6N3R6IG.js"),
  "./locales/zh-TW.json": () => import("./zh-TW-5ZFVGP3Q.js")
});

// i18n.ts
var COMPLETION_THRESHOLD = 85;
var defaultLang = { code: "en", label: "English" };
var languages = [
  defaultLang,
  ...[
    { code: "ar-SA", label: "\u0627\u0644\u0639\u0631\u0628\u064A\u0629", rtl: true },
    { code: "bg-BG", label: "\u0411\u044A\u043B\u0433\u0430\u0440\u0441\u043A\u0438" },
    { code: "ca-ES", label: "Catal\xE0" },
    { code: "cs-CZ", label: "\u010Cesky" },
    { code: "de-DE", label: "Deutsch" },
    { code: "el-GR", label: "\u0395\u03BB\u03BB\u03B7\u03BD\u03B9\u03BA\u03AC" },
    { code: "es-ES", label: "Espa\xF1ol" },
    { code: "eu-ES", label: "Euskara" },
    { code: "fa-IR", label: "\u0641\u0627\u0631\u0633\u06CC", rtl: true },
    { code: "fi-FI", label: "Suomi" },
    { code: "fr-FR", label: "Fran\xE7ais" },
    { code: "gl-ES", label: "Galego" },
    { code: "he-IL", label: "\u05E2\u05D1\u05E8\u05D9\u05EA", rtl: true },
    { code: "hi-IN", label: "\u0939\u093F\u0928\u094D\u0926\u0940" },
    { code: "hu-HU", label: "Magyar" },
    { code: "id-ID", label: "Bahasa Indonesia" },
    { code: "it-IT", label: "Italiano" },
    { code: "ja-JP", label: "\u65E5\u672C\u8A9E" },
    { code: "kab-KAB", label: "Taqbaylit" },
    { code: "kk-KZ", label: "\u049A\u0430\u0437\u0430\u049B \u0442\u0456\u043B\u0456" },
    { code: "ko-KR", label: "\uD55C\uAD6D\uC5B4" },
    { code: "ku-TR", label: "Kurd\xEE" },
    { code: "lt-LT", label: "Lietuvi\u0173" },
    { code: "lv-LV", label: "Latvie\u0161u" },
    { code: "my-MM", label: "Burmese" },
    { code: "nb-NO", label: "Norsk bokm\xE5l" },
    { code: "nl-NL", label: "Nederlands" },
    { code: "nn-NO", label: "Norsk nynorsk" },
    { code: "oc-FR", label: "Occitan" },
    { code: "pa-IN", label: "\u0A2A\u0A70\u0A1C\u0A3E\u0A2C\u0A40" },
    { code: "pl-PL", label: "Polski" },
    { code: "pt-BR", label: "Portugu\xEAs Brasileiro" },
    { code: "pt-PT", label: "Portugu\xEAs" },
    { code: "ro-RO", label: "Rom\xE2n\u0103" },
    { code: "ru-RU", label: "\u0420\u0443\u0441\u0441\u043A\u0438\u0439" },
    { code: "sk-SK", label: "Sloven\u010Dina" },
    { code: "sv-SE", label: "Svenska" },
    { code: "sl-SI", label: "Sloven\u0161\u010Dina" },
    { code: "tr-TR", label: "T\xFCrk\xE7e" },
    { code: "uk-UA", label: "\u0423\u043A\u0440\u0430\u0457\u043D\u0441\u044C\u043A\u0430" },
    { code: "zh-CN", label: "\u7B80\u4F53\u4E2D\u6587" },
    { code: "zh-TW", label: "\u7E41\u9AD4\u4E2D\u6587" },
    { code: "vi-VN", label: "Ti\u1EBFng Vi\u1EC7t" },
    { code: "mr-IN", label: "\u092E\u0930\u093E\u0920\u0940" }
  ].filter(
    (lang) => percentages_default[lang.code] >= COMPLETION_THRESHOLD
  ).sort((left, right) => left.label > right.label ? 1 : -1)
];
var TEST_LANG_CODE = "__test__";
if (define_import_meta_env_default.DEV) {
  languages.unshift(
    { code: TEST_LANG_CODE, label: "test language" },
    {
      code: `${TEST_LANG_CODE}.rtl`,
      label: "\u202Atest language (rtl)\u202C",
      rtl: true
    }
  );
}
var currentLang = defaultLang;
var currentLangData = {};
var setLanguage = async (lang) => {
  currentLang = lang;
  document.documentElement.dir = currentLang.rtl ? "rtl" : "ltr";
  document.documentElement.lang = currentLang.code;
  if (lang.code.startsWith(TEST_LANG_CODE)) {
    currentLangData = {};
  } else {
    try {
      currentLangData = await globImport_locales_json(`./locales/${currentLang.code}.json`);
    } catch (error) {
      console.error(`Failed to load language ${lang.code}:`, error.message);
      currentLangData = en_default;
    }
  }
  jotaiStore.set(editorLangCodeAtom, lang.code);
};
var getLanguage = () => currentLang;
var findPartsForData = (data, parts) => {
  for (let index2 = 0; index2 < parts.length; ++index2) {
    const part = parts[index2];
    if (data[part] === void 0) {
      return void 0;
    }
    data = data[part];
  }
  if (typeof data !== "string") {
    return void 0;
  }
  return data;
};
var t = (path, replacement, fallback) => {
  if (currentLang.code.startsWith(TEST_LANG_CODE)) {
    const name = replacement ? `${path}(${JSON.stringify(replacement).slice(1, -1)})` : path;
    return `\u202A[[${name}]]\u202C`;
  }
  const parts = path.split(".");
  let translation2 = findPartsForData(currentLangData, parts) || findPartsForData(en_default, parts) || fallback;
  if (translation2 === void 0) {
    const errorMessage = `Can't find translation for ${path}`;
    if (define_import_meta_env_default.PROD) {
      console.warn(errorMessage);
      return "";
    }
    throw new Error(errorMessage);
  }
  if (replacement) {
    for (const key in replacement) {
      translation2 = translation2.replace(`{{${key}}}`, String(replacement[key]));
    }
  }
  return translation2;
};
var editorLangCodeAtom = atom2(defaultLang.code);
var useI18n = () => {
  const langCode = useAtomValue(editorLangCodeAtom, jotaiScope);
  return { t, langCode };
};

// scene/scrollbars.ts
var SCROLLBAR_MARGIN = 4;
var SCROLLBAR_WIDTH = 6;
var SCROLLBAR_COLOR = "rgba(0,0,0,0.3)";
var getScrollBars = (elements, viewportWidth, viewportHeight, appState) => {
  if (!elements.length) {
    return {
      horizontal: null,
      vertical: null
    };
  }
  const [elementsMinX, elementsMinY, elementsMaxX, elementsMaxY] = getCommonBounds(elements);
  const viewportWidthWithZoom = viewportWidth / appState.zoom.value;
  const viewportHeightWithZoom = viewportHeight / appState.zoom.value;
  const viewportWidthDiff = viewportWidth - viewportWidthWithZoom;
  const viewportHeightDiff = viewportHeight - viewportHeightWithZoom;
  const safeArea = {
    top: parseInt(getGlobalCSSVariable("sat")) || 0,
    bottom: parseInt(getGlobalCSSVariable("sab")) || 0,
    left: parseInt(getGlobalCSSVariable("sal")) || 0,
    right: parseInt(getGlobalCSSVariable("sar")) || 0
  };
  const isRTL2 = getLanguage().rtl;
  const viewportMinX = -appState.scrollX + viewportWidthDiff / 2 + safeArea.left;
  const viewportMinY = -appState.scrollY + viewportHeightDiff / 2 + safeArea.top;
  const viewportMaxX = viewportMinX + viewportWidthWithZoom - safeArea.right;
  const viewportMaxY = viewportMinY + viewportHeightWithZoom - safeArea.bottom;
  const sceneMinX = Math.min(elementsMinX, viewportMinX);
  const sceneMinY = Math.min(elementsMinY, viewportMinY);
  const sceneMaxX = Math.max(elementsMaxX, viewportMaxX);
  const sceneMaxY = Math.max(elementsMaxY, viewportMaxY);
  return {
    horizontal: viewportMinX === sceneMinX && viewportMaxX === sceneMaxX ? null : {
      x: Math.max(safeArea.left, SCROLLBAR_MARGIN) + (viewportMinX - sceneMinX) / (sceneMaxX - sceneMinX) * viewportWidth,
      y: viewportHeight - SCROLLBAR_WIDTH - Math.max(SCROLLBAR_MARGIN, safeArea.bottom),
      width: (viewportMaxX - viewportMinX) / (sceneMaxX - sceneMinX) * viewportWidth - Math.max(SCROLLBAR_MARGIN * 2, safeArea.left + safeArea.right),
      height: SCROLLBAR_WIDTH
    },
    vertical: viewportMinY === sceneMinY && viewportMaxY === sceneMaxY ? null : {
      x: isRTL2 ? Math.max(safeArea.left, SCROLLBAR_MARGIN) : viewportWidth - SCROLLBAR_WIDTH - Math.max(safeArea.right, SCROLLBAR_MARGIN),
      y: (viewportMinY - sceneMinY) / (sceneMaxY - sceneMinY) * viewportHeight + Math.max(safeArea.top, SCROLLBAR_MARGIN),
      width: SCROLLBAR_WIDTH,
      height: (viewportMaxY - viewportMinY) / (sceneMaxY - sceneMinY) * viewportHeight - Math.max(SCROLLBAR_MARGIN * 2, safeArea.top + safeArea.bottom)
    }
  };
};
var isOverScrollBars = (scrollBars, x3, y3) => {
  const [isOverHorizontal, isOverVertical] = [
    scrollBars.horizontal,
    scrollBars.vertical
  ].map((scrollBar) => {
    return scrollBar != null && scrollBar.x <= x3 && x3 <= scrollBar.x + scrollBar.width && scrollBar.y <= y3 && y3 <= scrollBar.y + scrollBar.height;
  });
  const isOverEither = isOverHorizontal || isOverVertical;
  return { isOverEither, isOverHorizontal, isOverVertical };
};

// clients.ts
init_define_import_meta_env();
function hashToInteger(id) {
  let hash = 0;
  if (id.length === 0) {
    return hash;
  }
  for (let i4 = 0; i4 < id.length; i4++) {
    const char = id.charCodeAt(i4);
    hash = (hash << 5) - hash + char;
  }
  return hash;
}
var getClientColor = (id) => {
  const hash = Math.abs(hashToInteger(id));
  const hue = hash % 37 * 10;
  const saturation = 100;
  const lightness = 83;
  return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
};
var getNameInitial = (name) => {
  const firstCodePoint = name?.trim()?.codePointAt(0);
  return (firstCodePoint ? String.fromCodePoint(firstCodePoint) : "?").toUpperCase();
};

// types.ts
init_define_import_meta_env();

// element/Hyperlink.tsx
init_define_import_meta_env();

// components/ToolButton.tsx
init_define_import_meta_env();
var import_react96 = __toESM(require_react(), 1);

// ../../node_modules/clsx/dist/clsx.m.js
init_define_import_meta_env();
function toVal(mix) {
  var k2, y3, str = "";
  if (typeof mix === "string" || typeof mix === "number") {
    str += mix;
  } else if (typeof mix === "object") {
    if (Array.isArray(mix)) {
      for (k2 = 0; k2 < mix.length; k2++) {
        if (mix[k2]) {
          if (y3 = toVal(mix[k2])) {
            str && (str += " ");
            str += y3;
          }
        }
      }
    } else {
      for (k2 in mix) {
        if (mix[k2]) {
          str && (str += " ");
          str += k2;
        }
      }
    }
  }
  return str;
}
function clsx_m_default() {
  var i4 = 0, tmp, x3, str = "";
  while (i4 < arguments.length) {
    if (tmp = arguments[i4++]) {
      if (x3 = toVal(tmp)) {
        str && (str += " ");
        str += x3;
      }
    }
  }
  return str;
}

// components/App.tsx
init_define_import_meta_env();
var import_react95 = __toESM(require_react(), 1);
var import_react_dom9 = __toESM(require_react_dom(), 1);

// actions/index.ts
init_define_import_meta_env();

// actions/actionDeleteSelected.tsx
init_define_import_meta_env();

// components/icons.tsx
init_define_import_meta_env();
var import_react3 = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var iconFillColor = (theme) => "var(--icon-fill-color)";
var handlerColor = (theme) => theme === THEME.LIGHT ? open_color_default.white : "#1e1e1e";
var createIcon = (d3, opts = 512) => {
  const {
    width = 512,
    height = width,
    mirror,
    style,
    ...rest
  } = typeof opts === "number" ? { width: opts } : opts;
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    "svg",
    {
      "aria-hidden": "true",
      focusable: "false",
      role: "img",
      viewBox: `0 0 ${width} ${height}`,
      className: clsx_m_default({ "rtl-mirror": mirror }),
      style,
      ...rest,
      children: typeof d3 === "string" ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { fill: "currentColor", d: d3 }) : d3
    }
  );
};
var tablerIconProps = {
  width: 24,
  height: 24,
  fill: "none",
  strokeWidth: 2,
  stroke: "currentColor",
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
var modifiedTablerIconProps = {
  width: 20,
  height: 20,
  fill: "none",
  stroke: "currentColor",
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
var PlusPromoIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("g", { strokeWidth: "1.5", children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("rect", { x: 3, y: 8, width: 18, height: 4, rx: 1 }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("line", { x1: 12, y1: 8, x2: 12, y2: 21 }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M19 12v7a2 2 0 0 1 -2 2h-10a2 2 0 0 1 -2 -2v-7" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M7.5 8a2.5 2.5 0 0 1 0 -5a4.8 8 0 0 1 4.5 5a4.8 8 0 0 1 4.5 -5a2.5 2.5 0 0 1 0 5" })
  ] }),
  tablerIconProps
);
var LibraryIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("g", { strokeWidth: "1.5", children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M3 19a9 9 0 0 1 9 0a9 9 0 0 1 9 0" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M3 6a9 9 0 0 1 9 0a9 9 0 0 1 9 0" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("line", { x1: "3", y1: "6", x2: "3", y2: "19" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("line", { x1: "12", y1: "6", x2: "12", y2: "19" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("line", { x1: "21", y1: "6", x2: "21", y2: "19" })
  ] }),
  tablerIconProps
);
var PlusIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("svg", { strokeWidth: "1.5", children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("line", { x1: "12", y1: "5", x2: "12", y2: "19" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("line", { x1: "5", y1: "12", x2: "19", y2: "12" })
  ] }),
  tablerIconProps
);
var DotsIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("g", { strokeWidth: "1.5", children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("circle", { cx: "12", cy: "12", r: "1" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("circle", { cx: "12", cy: "19", r: "1" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("circle", { cx: "12", cy: "5", r: "1" })
  ] }),
  tablerIconProps
);
var PinIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("svg", { strokeWidth: "1.5", children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M9 4v6l-2 4v2h10v-2l-2 -4v-6" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("line", { x1: "12", y1: "16", x2: "12", y2: "21" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("line", { x1: "8", y1: "4", x2: "16", y2: "4" })
  ] }),
  tablerIconProps
);
var UnlockedIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("g", { children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      "path",
      {
        d: "M13.542 8.542H6.458a2.5 2.5 0 0 0-2.5 2.5v3.75a2.5 2.5 0 0 0 2.5 2.5h7.084a2.5 2.5 0 0 0 2.5-2.5v-3.75a2.5 2.5 0 0 0-2.5-2.5Z",
        stroke: "currentColor",
        strokeWidth: "1.25"
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      "path",
      {
        d: "M10 13.958a1.042 1.042 0 1 0 0-2.083 1.042 1.042 0 0 0 0 2.083Z",
        stroke: "currentColor",
        strokeWidth: "1.25"
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      "mask",
      {
        id: "UnlockedIcon",
        style: { maskType: "alpha" },
        maskUnits: "userSpaceOnUse",
        x: 6,
        y: 1,
        width: 9,
        height: 9,
        children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
          "path",
          {
            stroke: "none",
            d: "M6.399 9.561V5.175c0-.93.401-1.823 1.116-2.48a3.981 3.981 0 0 1 2.693-1.028c1.01 0 1.98.37 2.694 1.027.715.658 1.116 1.55 1.116 2.481",
            fill: "#fff"
          }
        )
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("g", { mask: "url(#UnlockedIcon)", children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      "path",
      {
        stroke: "none",
        d: "M5.149 9.561v1.25h2.5v-1.25h-2.5Zm5.06-7.894V.417v1.25Zm2.559 3.508v1.25h2.5v-1.25h-2.5ZM7.648 8.51V5.175h-2.5V8.51h2.5Zm0-3.334c0-.564.243-1.128.713-1.561L6.668 1.775c-.959.883-1.52 2.104-1.52 3.4h2.5Zm.713-1.561a2.732 2.732 0 0 1 1.847-.697v-2.5c-1.31 0-2.585.478-3.54 1.358L8.36 3.614Zm1.847-.697c.71 0 1.374.26 1.847.697l1.694-1.839a5.231 5.231 0 0 0-3.54-1.358v2.5Zm1.847.697c.47.433.713.997.713 1.561h2.5c0-1.296-.56-2.517-1.52-3.4l-1.693 1.839Z",
        fill: "currentColor"
      }
    ) })
  ] }),
  modifiedTablerIconProps
);
var LockedIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("g", { strokeWidth: "1.25", children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M13.542 8.542H6.458a2.5 2.5 0 0 0-2.5 2.5v3.75a2.5 2.5 0 0 0 2.5 2.5h7.084a2.5 2.5 0 0 0 2.5-2.5v-3.75a2.5 2.5 0 0 0-2.5-2.5Z" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M10 13.958a1.042 1.042 0 1 0 0-2.083 1.042 1.042 0 0 0 0 2.083Z" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M6.667 8.333V5.417C6.667 3.806 8.159 2.5 10 2.5c1.841 0 3.333 1.306 3.333 2.917v2.916" })
  ] }),
  modifiedTablerIconProps
);
var WelcomeScreenMenuArrow = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      "path",
      {
        d: "M38.5 83.5c-14-2-17.833-10.473-21-22.5C14.333 48.984 12 22 12 12.5",
        stroke: "currentColor",
        strokeWidth: 2,
        strokeLinecap: "round"
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      "path",
      {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "m12.005 10.478 7.905 14.423L6 25.75l6.005-15.273Z",
        fill: "currentColor"
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      "path",
      {
        d: "M12.005 10.478c1.92 3.495 3.838 7 7.905 14.423m-7.905-14.423c3.11 5.683 6.23 11.368 7.905 14.423m0 0c-3.68.226-7.35.455-13.91.85m13.91-.85c-5.279.33-10.566.647-13.91.85m0 0c1.936-4.931 3.882-9.86 6.005-15.273M6 25.75c2.069-5.257 4.135-10.505 6.005-15.272",
        stroke: "currentColor",
        strokeWidth: 2,
        strokeLinecap: "round"
      }
    )
  ] }),
  { width: 41, height: 94, fill: "none" }
);
var WelcomeScreenHelpArrow = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      "path",
      {
        d: "M18.026 1.232c-5.268 13.125-5.548 33.555 3.285 42.311 8.823 8.75 33.31 12.304 42.422 13.523",
        stroke: "currentColor",
        strokeWidth: 2,
        strokeLinecap: "round"
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      "path",
      {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "m72.181 59.247-13.058-10-2.948 13.62 16.006-3.62Z",
        fill: "currentColor"
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      "path",
      {
        d: "M72.181 59.247c-3.163-2.429-6.337-4.856-13.058-10m13.058 10c-5.145-3.936-10.292-7.882-13.058-10m0 0c-.78 3.603-1.563 7.196-2.948 13.62m2.948-13.62c-1.126 5.168-2.24 10.346-2.948 13.62m0 0c5.168-1.166 10.334-2.343 16.006-3.62m-16.006 3.62c5.51-1.248 11.01-2.495 16.006-3.62",
        stroke: "currentColor",
        strokeWidth: 2,
        strokeLinecap: "round"
      }
    )
  ] }),
  { width: 85, height: 71, fill: "none" }
);
var WelcomeScreenTopToolbarArrow = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      "path",
      {
        d: "M1 77c14-2 31.833-11.973 35-24 3.167-12.016-6-35-9.5-43.5",
        stroke: "currentColor",
        strokeWidth: 2,
        strokeLinecap: "round"
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      "path",
      {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "m24.165 1.093-2.132 16.309 13.27-4.258-11.138-12.05Z",
        fill: "currentColor"
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      "path",
      {
        d: "M24.165 1.093c-.522 3.953-1.037 7.916-2.132 16.309m2.131-16.309c-.835 6.424-1.68 12.854-2.13 16.308m0 0c3.51-1.125 7.013-2.243 13.27-4.257m-13.27 4.257c5.038-1.608 10.08-3.232 13.27-4.257m0 0c-3.595-3.892-7.197-7.777-11.14-12.05m11.14 12.05c-3.837-4.148-7.667-8.287-11.14-12.05",
        stroke: "currentColor",
        strokeWidth: 2,
        strokeLinecap: "round"
      }
    )
  ] }),
  { width: 38, height: 78, fill: "none" }
);
var ExcalLogo = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsx)("g", { fill: "currentColor", children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    "path",
    {
      d: "M39.9 32.889a.326.326 0 0 0-.279-.056c-2.094-3.083-4.774-6-7.343-8.833l-.419-.472a.212.212 0 0 0-.056-.139.586.586 0 0 0-.167-.111l-.084-.083-.056-.056c-.084-.167-.28-.278-.475-.167-.782.39-1.507.973-2.206 1.528-.92.722-1.842 1.445-2.708 2.25a8.405 8.405 0 0 0-.977 1.028c-.14.194-.028.361.14.444-.615.611-1.23 1.223-1.843 1.861a.315.315 0 0 0-.084.223c0 .083.056.166.111.194l1.09.833v.028c1.535 1.528 4.244 3.611 7.12 5.861.418.334.865.667 1.284 1 .195.223.39.473.558.695.084.11.28.139.391.055.056.056.14.111.196.167a.398.398 0 0 0 .167.056.255.255 0 0 0 .224-.111.394.394 0 0 0 .055-.167c.029 0 .028.028.056.028a.318.318 0 0 0 .224-.084l5.082-5.528a.309.309 0 0 0 0-.444Zm-14.63-1.917a.485.485 0 0 0 .111.14c.586.5 1.2 1 1.843 1.555l-2.569-1.945-.251-.166c-.056-.028-.112-.084-.168-.111l-.195-.167.056-.056.055-.055.112-.111c.866-.861 2.346-2.306 3.1-3.028-.81.805-2.43 3.167-2.095 3.944Zm8.767 6.89-2.122-1.612a44.713 44.713 0 0 0-2.625-2.5c1.145.861 2.122 1.611 2.262 1.75 1.117.972 1.06.806 1.815 1.445l.921.666a1.06 1.06 0 0 1-.251.25Zm.558.416-.056-.028c.084-.055.168-.111.252-.194l-.196.222ZM1.089 5.75c.055.361.14.722.195 1.056.335 1.833.67 3.5 1.284 4.75l.252.944c.084.361.223.806.363.917 1.424 1.25 3.602 3.11 5.947 4.889a.295.295 0 0 0 .363 0s0 .027.028.027a.254.254 0 0 0 .196.084.318.318 0 0 0 .223-.084c2.988-3.305 5.221-6.027 6.813-8.305.112-.111.14-.278.14-.417.111-.111.195-.25.307-.333.111-.111.111-.306 0-.39l-.028-.027c0-.055-.028-.139-.084-.167-.698-.666-1.2-1.138-1.731-1.638-.922-.862-1.871-1.75-3.881-3.75l-.028-.028c-.028-.028-.056-.056-.112-.056-.558-.194-1.703-.389-3.127-.639C6.087 2.223 3.21 1.723.614.944c0 0-.168 0-.196.028l-.083.084c-.028.027-.056.055-.224.11h.056-.056c.028.167.028.278.084.473 0 .055.112.5.112.555l.782 3.556Zm15.496 3.278-.335-.334c.084.112.196.195.335.334Zm-3.546 4.666-.056.056c0-.028.028-.056.056-.056Zm-2.038-10c.168.167.866.834 1.033.973-.726-.334-2.54-1.167-3.379-1.445.838.167 1.983.334 2.346.472ZM1.424 2.306c.419.722.754 3.222 1.089 5.666-.196-.778-.335-1.555-.503-2.278-.251-1.277-.503-2.416-.838-3.416.056 0 .14 0 .252.028Zm-.168-.584c-.112 0-.223-.028-.307-.028 0-.027 0-.055-.028-.055.14 0 .223.028.335.083Zm-1.089.222c0-.027 0-.027 0 0ZM39.453 1.333c.028-.11-.558-.61-.363-.639.42-.027.42-.666 0-.666-.558.028-1.144.166-1.675.25-.977.194-1.982.389-2.96.61-2.205.473-4.383.973-6.561 1.557-.67.194-1.424.333-2.066.666-.224.111-.196.333-.084.472-.056.028-.084.028-.14.056-.195.028-.363.056-.558.083-.168.028-.252.167-.224.334 0 .027.028.083.028.11-1.173 1.556-2.485 3.195-3.909 4.945-1.396 1.611-2.876 3.306-4.356 5.056-4.719 5.5-10.052 11.75-15.943 17.25a.268.268 0 0 0 0 .389c.028.027.056.055.084.055-.084.084-.168.14-.252.222-.056.056-.084.111-.084.167a.605.605 0 0 0-.111.139c-.112.111-.112.305.028.389.111.11.307.11.39-.028.029-.028.029-.056.056-.056a.44.44 0 0 1 .615 0c.335.362.67.723.977 1.028l-.698-.583c-.112-.111-.307-.083-.39.028-.113.11-.085.305.027.389l7.427 6.194c.056.056.112.056.196.056s.14-.028.195-.084l.168-.166c.028.027.083.027.111.027.084 0 .14-.027.196-.083 10.052-10.055 18.15-17.639 27.42-24.417.083-.055.111-.166.111-.25.112 0 .196-.083.251-.194 1.704-5.194 2.039-9.806 2.15-12.083v-.028c0-.028.028-.056.028-.083.028-.056.028-.084.028-.084a1.626 1.626 0 0 0-.111-1.028ZM21.472 9.5c.446-.5.893-1.028 1.34-1.5-2.876 3.778-7.65 9.583-14.408 16.5 4.607-5.083 9.242-10.333 13.068-15ZM5.193 35.778h.084-.084Zm3.462 3.194c-.027-.028-.027-.028 0-.028v.028Zm4.16-3.583c.224-.25.448-.472.699-.722 0 0 0 .027.028.027-.252.223-.475.445-.726.695Zm1.146-1.111c.14-.14.279-.334.446-.5l.028-.028c1.648-1.694 3.351-3.389 5.082-5.111l.028-.028c.419-.333.921-.694 1.368-1.028a379.003 379.003 0 0 0-6.952 6.695ZM24.794 6.472c-.921 1.195-1.954 2.778-2.82 4.028-2.736 3.944-11.532 13.583-11.727 13.75a1976.983 1976.983 0 0 1-8.042 7.639l-.167.167c-.14-.167-.14-.417.028-.556C14.49 19.861 22.03 10.167 25.074 5.917c-.084.194-.14.36-.28.555Zm4.83 5.695c-1.116-.64-1.646-1.64-1.34-2.611l.084-.334c.028-.083.084-.194.14-.277.307-.5.754-.917 1.257-1.167.027 0 .055 0 .083-.028-.028-.056-.028-.139-.028-.222.028-.167.14-.278.335-.278.335 0 1.369.306 1.76.639.111.083.223.194.335.305.14.167.363.445.474.667.056.028.112.306.196.445.056.222.111.472.084.694-.028.028 0 .194-.028.194a2.668 2.668 0 0 1-.363 1.028c-.028.028-.028.056-.056.084l-.028.027c-.14.223-.335.417-.53.556-.643.444-1.369.583-2.095.389 0 0-.195-.084-.28-.111Zm8.154-.834a39.098 39.098 0 0 1-.893 3.167c0 .028-.028.083 0 .111-.056 0-.084.028-.14.056-2.206 1.61-4.356 3.305-6.506 5.028 1.843-1.64 3.686-3.306 5.613-4.945.558-.5.949-1.139 1.06-1.861l.28-1.667v-.055c.14-.334.67-.195.586.166Z",
      fill: "currentColor"
    }
  ) }),
  { width: 40, height: 40, fill: "none" }
);
var SelectionIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("g", { stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M6 6l4.153 11.793a0.365 .365 0 0 0 .331 .207a0.366 .366 0 0 0 .332 -.207l2.184 -4.793l4.787 -1.994a0.355 .355 0 0 0 .213 -.323a0.355 .355 0 0 0 -.213 -.323l-11.787 -4.36z" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M13.5 13.5l4.5 4.5" })
  ] }),
  { fill: "none", width: 22, height: 22, strokeWidth: 1.25 }
);
var RectangleIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("g", { strokeWidth: "1.5", children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("rect", { x: "4", y: "4", width: "16", height: "16", rx: "2" })
  ] }),
  tablerIconProps
);
var DiamondIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("g", { strokeWidth: "1.5", children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M10.5 20.4l-6.9 -6.9c-.781 -.781 -.781 -2.219 0 -3l6.9 -6.9c.781 -.781 2.219 -.781 3 0l6.9 6.9c.781 .781 .781 2.219 0 3l-6.9 6.9c-.781 .781 -2.219 .781 -3 0z" })
  ] }),
  tablerIconProps
);
var EllipseIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("g", { strokeWidth: "1.5", children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("circle", { cx: "12", cy: "12", r: "9" })
  ] }),
  tablerIconProps
);
var ArrowIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("g", { strokeWidth: "1.5", children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("line", { x1: "5", y1: "12", x2: "19", y2: "12" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("line", { x1: "15", y1: "16", x2: "19", y2: "12" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("line", { x1: "15", y1: "8", x2: "19", y2: "12" })
  ] }),
  tablerIconProps
);
var LineIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M4.167 10h11.666", strokeWidth: "1.5" }),
  modifiedTablerIconProps
);
var PenModeIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("g", { strokeWidth: "1.25", children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M20 17v-12c0 -1.121 -.879 -2 -2 -2s-2 .879 -2 2v12l2 2l2 -2z" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M16 7h4" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M18 19h-13a2 2 0 1 1 0 -4h4a2 2 0 1 0 0 -4h-3" })
  ] }),
  tablerIconProps
);
var FreedrawIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("g", { strokeWidth: "1.25", children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      "path",
      {
        clipRule: "evenodd",
        d: "m7.643 15.69 7.774-7.773a2.357 2.357 0 1 0-3.334-3.334L4.31 12.357a3.333 3.333 0 0 0-.977 2.357v1.953h1.953c.884 0 1.732-.352 2.357-.977Z"
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "m11.25 5.417 3.333 3.333" })
  ] }),
  modifiedTablerIconProps
);
var TextIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("g", { strokeWidth: "1.5", children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("line", { x1: "4", y1: "20", x2: "7", y2: "20" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("line", { x1: "14", y1: "20", x2: "21", y2: "20" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("line", { x1: "6.9", y1: "15", x2: "13.8", y2: "15" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("line", { x1: "10.2", y1: "6.3", x2: "16", y2: "20" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("polyline", { points: "5 20 11 4 13 4 20 20" })
  ] }),
  tablerIconProps
);
var ImageIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("g", { strokeWidth: "1.25", children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M12.5 6.667h.01" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M4.91 2.625h10.18a2.284 2.284 0 0 1 2.285 2.284v10.182a2.284 2.284 0 0 1-2.284 2.284H4.909a2.284 2.284 0 0 1-2.284-2.284V4.909a2.284 2.284 0 0 1 2.284-2.284Z" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "m3.333 12.5 3.334-3.333c.773-.745 1.726-.745 2.5 0l4.166 4.166" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "m11.667 11.667.833-.834c.774-.744 1.726-.744 2.5 0l1.667 1.667" })
  ] }),
  modifiedTablerIconProps
);
var EraserIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("g", { strokeWidth: "1.5", children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M19 20h-10.5l-4.21 -4.3a1 1 0 0 1 0 -1.41l10 -10a1 1 0 0 1 1.41 0l5 5a1 1 0 0 1 0 1.41l-9.2 9.3" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M18 13.3l-6.3 -6.3" })
  ] }),
  tablerIconProps
);
var ZoomInIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { strokeWidth: "1.25", d: "M10 4.167v11.666M4.167 10h11.666" }),
  modifiedTablerIconProps
);
var ZoomOutIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M5 10h10", strokeWidth: "1.25" }),
  modifiedTablerIconProps
);
var TrashIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    "path",
    {
      strokeWidth: "1.25",
      d: "M3.333 5.833h13.334M8.333 9.167v5M11.667 9.167v5M4.167 5.833l.833 10c0 .92.746 1.667 1.667 1.667h6.666c.92 0 1.667-.746 1.667-1.667l.833-10M7.5 5.833v-2.5c0-.46.373-.833.833-.833h3.334c.46 0 .833.373.833.833v2.5"
    }
  ),
  modifiedTablerIconProps
);
var EmbedIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("g", { strokeWidth: "1.25", children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("polyline", { points: "12 16 18 10 12 4" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("polyline", { points: "8 4 2 10 8 16" })
  ] }),
  modifiedTablerIconProps
);
var DuplicateIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("g", { strokeWidth: "1.25", children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M14.375 6.458H8.958a2.5 2.5 0 0 0-2.5 2.5v5.417a2.5 2.5 0 0 0 2.5 2.5h5.417a2.5 2.5 0 0 0 2.5-2.5V8.958a2.5 2.5 0 0 0-2.5-2.5Z" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      "path",
      {
        clipRule: "evenodd",
        d: "M11.667 3.125c.517 0 .986.21 1.325.55.34.338.55.807.55 1.325v1.458H8.333c-.485 0-.927.185-1.26.487-.343.312-.57.75-.609 1.24l-.005 5.357H5a1.87 1.87 0 0 1-1.326-.55 1.87 1.87 0 0 1-.549-1.325V5c0-.518.21-.987.55-1.326.338-.34.807-.549 1.325-.549h6.667Z"
      }
    )
  ] }),
  modifiedTablerIconProps
);
var MoonIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    "path",
    {
      clipRule: "evenodd",
      d: "M10 2.5h.328a6.25 6.25 0 0 0 6.6 10.372A7.5 7.5 0 1 1 10 2.493V2.5Z",
      stroke: "currentColor"
    }
  ),
  modifiedTablerIconProps
);
var SunIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    "g",
    {
      stroke: "currentColor",
      strokeWidth: "1.25",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M10 12.5a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5ZM10 4.167V2.5M14.167 5.833l1.166-1.166M15.833 10H17.5M14.167 14.167l1.166 1.166M10 15.833V17.5M5.833 14.167l-1.166 1.166M5 10H3.333M5.833 5.833 4.667 4.667" })
    }
  ),
  modifiedTablerIconProps
);
var HamburgerMenuIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("g", { strokeWidth: "1.5", children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("line", { x1: "4", y1: "6", x2: "20", y2: "6" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("line", { x1: "4", y1: "12", x2: "20", y2: "12" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("line", { x1: "4", y1: "18", x2: "20", y2: "18" })
  ] }),
  tablerIconProps
);
var ExportIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    "path",
    {
      strokeWidth: "1.25",
      d: "M3.333 14.167v1.666c0 .92.747 1.667 1.667 1.667h10c.92 0 1.667-.746 1.667-1.667v-1.666M5.833 9.167 10 13.333l4.167-4.166M10 3.333v10"
    }
  ),
  modifiedTablerIconProps
);
var HelpIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("g", { strokeWidth: "1.5", children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("circle", { cx: "12", cy: "12", r: "9" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("line", { x1: "12", y1: "17", x2: "12", y2: "17.01" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M12 13.5a1.5 1.5 0 0 1 1 -1.5a2.6 2.6 0 1 0 -3 -4" })
  ] }),
  tablerIconProps
);
var ExternalLinkIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    "path",
    {
      strokeWidth: "1.25",
      d: "M9.167 5.833H5.833c-1.254 0-2.5 1.282-2.5 2.5v5.834c0 1.283 1.252 2.5 2.5 2.5h5.834c1.251 0 2.5-1.25 2.5-2.5v-3.334M8.333 11.667l8.334-8.334M12.5 3.333h4.167V7.5"
    }
  ),
  modifiedTablerIconProps
);
var GithubIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    "path",
    {
      d: "M7.5 15.833c-3.583 1.167-3.583-2.083-5-2.5m10 4.167v-2.917c0-.833.083-1.166-.417-1.666 2.334-.25 4.584-1.167 4.584-5a3.833 3.833 0 0 0-1.084-2.667 3.5 3.5 0 0 0-.083-2.667s-.917-.25-2.917 1.084a10.25 10.25 0 0 0-5.166 0C5.417 2.333 4.5 2.583 4.5 2.583a3.5 3.5 0 0 0-.083 2.667 3.833 3.833 0 0 0-1.084 2.667c0 3.833 2.25 4.75 4.584 5-.5.5-.5 1-.417 1.666V17.5",
      strokeWidth: "1.25"
    }
  ),
  modifiedTablerIconProps
);
var DiscordIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("g", { strokeWidth: "1.25", children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M7.5 10.833a.833.833 0 1 0 0-1.666.833.833 0 0 0 0 1.666ZM12.5 10.833a.833.833 0 1 0 0-1.666.833.833 0 0 0 0 1.666ZM6.25 6.25c2.917-.833 4.583-.833 7.5 0M5.833 13.75c2.917.833 5.417.833 8.334 0" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M12.917 14.167c0 .833 1.25 2.5 1.666 2.5 1.25 0 2.361-1.39 2.917-2.5.556-1.39.417-4.861-1.25-9.584-1.214-.846-2.5-1.116-3.75-1.25l-.833 2.084M7.083 14.167c0 .833-1.13 2.5-1.526 2.5-1.191 0-2.249-1.39-2.778-2.5-.529-1.39-.397-4.861 1.19-9.584 1.157-.846 2.318-1.116 3.531-1.25l.833 2.084" })
  ] }),
  modifiedTablerIconProps
);
var XBrandIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("g", { strokeWidth: "1.25", children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M4 4l11.733 16h4.267l-11.733 -16z" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M4 20l6.768 -6.768m2.46 -2.46l6.772 -6.772" })
  ] }),
  tablerIconProps
);
var checkIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsx)("polyline", { fill: "none", stroke: "currentColor", points: "20 6 9 17 4 12" }),
  {
    width: 24,
    height: 24
  }
);
var LinkIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("g", { strokeWidth: "1.25", children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M8.333 11.667a2.917 2.917 0 0 0 4.167 0l3.333-3.334a2.946 2.946 0 1 0-4.166-4.166l-.417.416" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M11.667 8.333a2.917 2.917 0 0 0-4.167 0l-3.333 3.334a2.946 2.946 0 0 0 4.166 4.166l.417-.416" })
  ] }),
  modifiedTablerIconProps
);
var save = createIcon(
  "M433.941 129.941l-83.882-83.882A48 48 0 0 0 316.118 32H48C21.49 32 0 53.49 0 80v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V163.882a48 48 0 0 0-14.059-33.941zM224 416c-35.346 0-64-28.654-64-64 0-35.346 28.654-64 64-64s64 28.654 64 64c0 35.346-28.654 64-64 64zm96-304.52V212c0 6.627-5.373 12-12 12H76c-6.627 0-12-5.373-12-12V108c0-6.627 5.373-12 12-12h228.52c3.183 0 6.235 1.264 8.485 3.515l3.48 3.48A11.996 11.996 0 0 1 320 111.48z",
  { width: 448, height: 512 }
);
var saveAs = createIcon(
  "M252 54L203 8a28 27 0 00-20-8H28C12 0 0 12 0 27v195c0 15 12 26 28 26h204c15 0 28-11 28-26V73a28 27 0 00-8-19zM130 213c-21 0-37-16-37-36 0-19 16-35 37-35 20 0 37 16 37 35 0 20-17 36-37 36zm56-169v56c0 4-4 6-7 6H44c-4 0-7-2-7-6V42c0-4 3-7 7-7h133l4 2 3 2a7 7 0 012 5z M296 201l87 95-188 205-78 9c-10 1-19-8-18-20l9-84zm141-14l-41-44a31 31 0 00-46 0l-38 41 87 95 38-42c13-14 13-36 0-50z",
  { width: 448, height: 512 }
);
var LoadIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    "path",
    {
      d: "m9.257 6.351.183.183H15.819c.34 0 .727.182 1.051.506.323.323.505.708.505 1.05v5.819c0 .316-.183.7-.52 1.035-.337.338-.723.522-1.037.522H4.182c-.352 0-.74-.181-1.058-.5-.318-.318-.499-.705-.499-1.057V5.182c0-.351.181-.736.5-1.054.32-.321.71-.503 1.057-.503H6.53l2.726 2.726Z",
      strokeWidth: "1.25"
    }
  ),
  modifiedTablerIconProps
);
var clipboard = createIcon(
  "M384 112v352c0 26.51-21.49 48-48 48H48c-26.51 0-48-21.49-48-48V112c0-26.51 21.49-48 48-48h80c0-35.29 28.71-64 64-64s64 28.71 64 64h80c26.51 0 48 21.49 48 48zM192 40c-13.255 0-24 10.745-24 24s10.745 24 24 24 24-10.745 24-24-10.745-24-24-24m96 114v-20a6 6 0 0 0-6-6H102a6 6 0 0 0-6 6v20a6 6 0 0 0 6 6h180a6 6 0 0 0 6-6z",
  { width: 384, height: 512 }
);
var palette = createIcon(
  "M204.3 5C104.9 24.4 24.8 104.3 5.2 203.4c-37 187 131.7 326.4 258.8 306.7 41.2-6.4 61.4-54.6 42.5-91.7-23.1-45.4 9.9-98.4 60.9-98.4h79.7c35.8 0 64.8-29.6 64.9-65.3C511.5 97.1 368.1-26.9 204.3 5zM96 320c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm32-128c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm128-64c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm128 64c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32z"
);
var ExportImageIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("g", { strokeWidth: "1.25", children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M15 8h.01" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M12 20h-5a3 3 0 0 1 -3 -3v-10a3 3 0 0 1 3 -3h10a3 3 0 0 1 3 3v5" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M4 15l4 -4c.928 -.893 2.072 -.893 3 0l4 4" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M14 14l1 -1c.617 -.593 1.328 -.793 2.009 -.598" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M19 16v6" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M22 19l-3 3l-3 -3" })
  ] }),
  tablerIconProps
);
var exportToFileIcon = createIcon(
  "M216 0h80c13.3 0 24 10.7 24 24v168h87.7c17.8 0 26.7 21.5 14.1 34.1L269.7 378.3c-7.5 7.5-19.8 7.5-27.3 0L90.1 226.1c-12.6-12.6-3.7-34.1 14.1-34.1H192V24c0-13.3 10.7-24 24-24zm296 376v112c0 13.3-10.7 24-24 24H24c-13.3 0-24-10.7-24-24V376c0-13.3 10.7-24 24-24h146.7l49 49c20.1 20.1 52.5 20.1 72.6 0l49-49H488c13.3 0 24 10.7 24 24zm-124 88c0-11-9-20-20-20s-20 9-20 20 9 20 20 20 20-9 20-20zm64 0c0-11-9-20-20-20s-20 9-20 20 9 20 20 20 20-9 20-20z",
  { width: 512, height: 512 }
);
var zoomIn = createIcon(
  "M416 208H272V64c0-17.67-14.33-32-32-32h-32c-17.67 0-32 14.33-32 32v144H32c-17.67 0-32 14.33-32 32v32c0 17.67 14.33 32 32 32h144v144c0 17.67 14.33 32 32 32h32c17.67 0 32-14.33 32-32V304h144c17.67 0 32-14.33 32-32v-32c0-17.67-14.33-32-32-32z",
  { width: 448, height: 512 }
);
var zoomOut = createIcon(
  "M416 208H32c-17.67 0-32 14.33-32 32v32c0 17.67 14.33 32 32 32h384c17.67 0 32-14.33 32-32v-32c0-17.67-14.33-32-32-32z",
  { width: 448, height: 512 }
);
var done = createIcon(
  "M173.898 439.404l-166.4-166.4c-9.997-9.997-9.997-26.206 0-36.204l36.203-36.204c9.997-9.998 26.207-9.998 36.204 0L192 312.69 432.095 72.596c9.997-9.997 26.207-9.997 36.204 0l36.203 36.204c9.997 9.997 9.997 26.206 0 36.204l-294.4 294.401c-9.998 9.997-26.207 9.997-36.204-.001z"
);
var menu = createIcon(
  "M16 132h416c8.837 0 16-7.163 16-16V76c0-8.837-7.163-16-16-16H16C7.163 60 0 67.163 0 76v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16z"
);
var UndoIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    "path",
    {
      d: "M7.5 10.833 4.167 7.5 7.5 4.167M4.167 7.5h9.166a3.333 3.333 0 0 1 0 6.667H12.5",
      strokeWidth: "1.25"
    }
  ),
  modifiedTablerIconProps
);
var RedoIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    "path",
    {
      d: "M12.5 10.833 15.833 7.5 12.5 4.167M15.833 7.5H6.667a3.333 3.333 0 1 0 0 6.667H7.5",
      strokeWidth: "1.25"
    }
  ),
  modifiedTablerIconProps
);
var questionCircle = createIcon(
  "M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zM262.655 90c-54.497 0-89.255 22.957-116.549 63.758-3.536 5.286-2.353 12.415 2.715 16.258l34.699 26.31c5.205 3.947 12.621 3.008 16.665-2.122 17.864-22.658 30.113-35.797 57.303-35.797 20.429 0 45.698 13.148 45.698 32.958 0 14.976-12.363 22.667-32.534 33.976C247.128 238.528 216 254.941 216 296v4c0 6.627 5.373 12 12 12h56c6.627 0 12-5.373 12-12v-1.333c0-28.462 83.186-29.647 83.186-106.667 0-58.002-60.165-102-116.531-102zM256 338c-25.365 0-46 20.635-46 46 0 25.364 20.635 46 46 46s46-20.636 46-46c0-25.365-20.635-46-46-46z",
  { mirror: true }
);
var share = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    "path",
    {
      d: "M5 12.5a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5ZM15 7.5a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5ZM15 17.5a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5ZM7.25 8.917l5.5-2.834M7.25 11.083l5.5 2.834",
      strokeWidth: "1.5"
    }
  ),
  modifiedTablerIconProps
);
var shareIOS = createIcon(
  "M16 5l-1.42 1.42-1.59-1.59V16h-1.98V4.83L9.42 6.42 8 5l4-4 4 4zm4 5v11c0 1.1-.9 2-2 2H6c-1.11 0-2-.9-2-2V10c0-1.11.89-2 2-2h3v2H6v11h12V10h-3V8h3c1.1 0 2 .89 2 2z",
  { width: 24, height: 24 }
);
var shareWindows = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      "path",
      {
        fill: "currentColor",
        d: "M40 5.6v6.1l-4.1.7c-8.9 1.4-16.5 6.9-20.6 15C13 32 10.9 43 12.4 43c.4 0 2.4-1.3 4.4-3 5-3.9 12.1-7 18.2-7.7l5-.6v12.8l11.2-11.3L62.5 22 51.2 10.8 40-.5v6.1zm10.2 22.6L44 34.5v-6.8l-6.9.6c-3.9.3-9.8 1.7-13.2 3.1-3.5 1.4-6.5 2.4-6.7 2.2-.9-1 3-7.5 6.4-10.8C28 18.6 34.4 16 40.1 16c3.7 0 3.9-.1 3.9-3.2V9.5l6.2 6.3 6.3 6.2-6.3 6.2z"
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      "path",
      {
        stroke: "currentColor",
        fill: "currentColor",
        d: "M0 36v20h48v-6.2c0-6 0-6.1-2-4.3-1.1 1-2 2.9-2 4.2V52H4V34c0-17.3-.1-18-2-18s-2 .7-2 20z"
      }
    )
  ] }),
  { width: 64, height: 64 }
);
var resetZoom = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    "path",
    {
      stroke: "currentColor",
      strokeWidth: "40",
      fill: "currentColor",
      d: "M148 560a318 318 0 0 0 522 110 316 316 0 0 0 0-450 316 316 0 0 0-450 0c-11 11-21 22-30 34v4h47c25 0 46 21 46 46s-21 45-46 45H90c-13 0-25-6-33-14-9-9-14-20-14-33V156c0-25 20-45 45-45s45 20 45 45v32l1 1a401 401 0 0 1 623 509l212 212a42 42 0 0 1-59 59L698 757A401 401 0 0 1 65 570a42 42 0 0 1 83-10z"
    }
  ),
  { width: 1024 }
);
var BringForwardIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(
      "g",
      {
        clipPath: "url(#a)",
        stroke: "currentColor",
        strokeWidth: "1.25",
        strokeLinecap: "round",
        strokeLinejoin: "round",
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
            "path",
            {
              d: "M13.889 4.167H8.333c-.767 0-1.389.622-1.389 1.389v5.555c0 .767.622 1.389 1.39 1.389h5.555c.767 0 1.389-.622 1.389-1.389V5.556c0-.767-.622-1.39-1.39-1.39Z",
              fill: "currentColor"
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M12.5 12.5v1.389a1.389 1.389 0 0 1-1.389 1.389H5.556a1.389 1.389 0 0 1-1.39-1.39V8.334a1.389 1.389 0 0 1 1.39-1.389h1.388" })
        ]
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("defs", { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("clipPath", { id: "a", children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
  ] }),
  modifiedTablerIconProps
);
var SendBackwardIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(
      "g",
      {
        clipPath: "url(#a)",
        stroke: "currentColor",
        strokeWidth: "1.25",
        strokeLinecap: "round",
        strokeLinejoin: "round",
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
            "path",
            {
              fillRule: "evenodd",
              clipRule: "evenodd",
              d: "M6.944 12.5H12.5v1.389a1.389 1.389 0 0 1-1.389 1.389H5.556a1.389 1.389 0 0 1-1.39-1.39V8.334a1.389 1.389 0 0 1 1.39-1.389h1.388",
              fill: "currentColor"
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M13.889 4.167H8.333c-.767 0-1.389.621-1.389 1.389v5.555c0 .767.622 1.389 1.39 1.389h5.555c.767 0 1.389-.622 1.389-1.389V5.556c0-.768-.622-1.39-1.39-1.39Z" })
        ]
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("defs", { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("clipPath", { id: "a", children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
  ] }),
  modifiedTablerIconProps
);
var BringToFrontIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("g", { clipPath: "url(#a)", stroke: "currentColor", strokeWidth: "1.25", children: [
      /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
        "path",
        {
          d: "M8.775 6.458h2.45a2.316 2.316 0 0 1 2.317 2.316v2.452a2.316 2.316 0 0 1-2.316 2.316H8.774a2.316 2.316 0 0 1-2.317-2.316V8.774a2.316 2.316 0 0 1 2.317-2.316Z",
          fill: "currentColor"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M5.441 9.792h2.451a2.316 2.316 0 0 1 2.316 2.316v2.45a2.316 2.316 0 0 1-2.316 2.317h-2.45a2.316 2.316 0 0 1-2.317-2.316v-2.451a2.316 2.316 0 0 1 2.316-2.316ZM12.108 3.125h2.45a2.316 2.316 0 0 1 2.317 2.316v2.451a2.316 2.316 0 0 1-2.316 2.316h-2.451a2.316 2.316 0 0 1-2.316-2.316v-2.45a2.316 2.316 0 0 1 2.316-2.317Z" })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("defs", { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("clipPath", { id: "a", children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
  ] }),
  modifiedTablerIconProps
);
var SendToBackIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("g", { clipPath: "url(#a)", children: [
      /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
        "path",
        {
          d: "M5.441 9.792h2.451a2.316 2.316 0 0 1 2.316 2.316v2.45a2.316 2.316 0 0 1-2.316 2.317h-2.45a2.316 2.316 0 0 1-2.317-2.316v-2.451a2.316 2.316 0 0 1 2.316-2.316Z",
          stroke: "currentColor",
          strokeWidth: "1.25"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
        "path",
        {
          d: "M5.441 9.792h2.451a2.316 2.316 0 0 1 2.316 2.316v2.45a2.316 2.316 0 0 1-2.316 2.317h-2.45a2.316 2.316 0 0 1-2.317-2.316v-2.451a2.316 2.316 0 0 1 2.316-2.316Z",
          stroke: "currentColor",
          strokeWidth: "1.25"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime.jsx)("mask", { id: "SendToBackIcon", fill: "#fff", children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
        "path",
        {
          fillRule: "evenodd",
          clipRule: "evenodd",
          d: "M9.167 5.833v2.06a2.941 2.941 0 0 0 2.94 2.94h2.06v.393a2.941 2.941 0 0 1-2.941 2.94h-.393v-2.058a2.941 2.941 0 0 0-2.94-2.941h-2.06v-.393a2.941 2.941 0 0 1 2.942-2.94h.392Z"
        }
      ) }),
      /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
        "path",
        {
          fillRule: "evenodd",
          clipRule: "evenodd",
          d: "M9.167 5.833v2.06a2.941 2.941 0 0 0 2.94 2.94h2.06v.393a2.941 2.941 0 0 1-2.941 2.94h-.393v-2.058a2.941 2.941 0 0 0-2.94-2.941h-2.06v-.393a2.941 2.941 0 0 1 2.942-2.94h.392Z",
          fill: "currentColor"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
        "path",
        {
          d: "M9.167 5.833h1.25v-1.25h-1.25v1.25Zm5 5h1.25v-1.25h-1.25v1.25Zm-3.334 3.334h-1.25v1.25h1.25v-1.25Zm-5-5h-1.25v1.25h1.25v-1.25Zm2.084-3.334v2.06h2.5v-2.06h-2.5Zm0 2.06a4.191 4.191 0 0 0 4.19 4.19v-2.5a1.691 1.691 0 0 1-1.69-1.69h-2.5Zm4.19 4.19h2.06v-2.5h-2.06v2.5Zm.81-1.25v.393h2.5v-.393h-2.5Zm0 .393c0 .933-.758 1.69-1.691 1.69v2.5a4.191 4.191 0 0 0 4.19-4.19h-2.5Zm-1.691 1.69h-.393v2.5h.393v-2.5Zm.857 1.25v-2.058h-2.5v2.059h2.5Zm0-2.058a4.191 4.191 0 0 0-4.19-4.191v2.5c.933 0 1.69.757 1.69 1.69h2.5Zm-4.19-4.191h-2.06v2.5h2.06v-2.5Zm-.81 1.25v-.393h-2.5v.393h2.5Zm0-.393c0-.934.758-1.69 1.692-1.69v-2.5a4.191 4.191 0 0 0-4.192 4.19h2.5Zm1.692-1.69h.392v-2.5h-.392v2.5Z",
          fill: "currentColor",
          mask: "url(#SendToBackIcon)"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
        "path",
        {
          d: "M12.108 3.125h2.45a2.316 2.316 0 0 1 2.317 2.316v2.451a2.316 2.316 0 0 1-2.316 2.316h-2.451a2.316 2.316 0 0 1-2.316-2.316v-2.45a2.316 2.316 0 0 1 2.316-2.317Z",
          stroke: "currentColor",
          strokeWidth: "1.25"
        }
      )
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("defs", { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("clipPath", { id: "a", children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
  ] }),
  modifiedTablerIconProps
);
var AlignTopIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("g", { clipPath: "url(#a)", stroke: "currentColor", strokeWidth: "1.25", children: [
      /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
        "path",
        {
          d: "M3.333 3.333h13.334",
          strokeLinecap: "round",
          strokeLinejoin: "round"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M13.542 6.458h-.417c-.92 0-1.667.747-1.667 1.667v7.083c0 .92.746 1.667 1.667 1.667h.417c.92 0 1.666-.746 1.666-1.667V8.125c0-.92-.746-1.667-1.666-1.667ZM6.875 6.458h-.417c-.92 0-1.666.747-1.666 1.667v3.75c0 .92.746 1.667 1.666 1.667h.417c.92 0 1.667-.746 1.667-1.667v-3.75c0-.92-.747-1.667-1.667-1.667Z" })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("defs", { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("clipPath", { id: "a", children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
  ] }),
  modifiedTablerIconProps
);
var AlignBottomIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("g", { clipPath: "url(#a)", stroke: "currentColor", strokeWidth: "1.25", children: [
      /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
        "path",
        {
          d: "M3.333 16.667h13.334",
          strokeLinecap: "round",
          strokeLinejoin: "round"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M6.875 3.125h-.417c-.92 0-1.666.746-1.666 1.667v7.083c0 .92.746 1.667 1.666 1.667h.417c.92 0 1.667-.746 1.667-1.667V4.792c0-.92-.747-1.667-1.667-1.667ZM13.542 5.817h-.417c-.92 0-1.667.747-1.667 1.667v4.391c0 .92.746 1.667 1.667 1.667h.417c.92 0 1.666-.746 1.666-1.667V7.484c0-.92-.746-1.667-1.666-1.667Z" })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("defs", { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("clipPath", { id: "a", children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
  ] }),
  modifiedTablerIconProps
);
var AlignLeftIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("g", { clipPath: "url(#a)", stroke: "currentColor", strokeWidth: "1.25", children: [
      /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
        "path",
        {
          d: "M3.333 3.333v13.334",
          strokeLinecap: "round",
          strokeLinejoin: "round"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M15.208 4.792H8.125c-.92 0-1.667.746-1.667 1.666v.417c0 .92.747 1.667 1.667 1.667h7.083c.92 0 1.667-.747 1.667-1.667v-.417c0-.92-.746-1.666-1.667-1.666ZM12.516 11.458H8.125c-.92 0-1.667.746-1.667 1.667v.417c0 .92.747 1.666 1.667 1.666h4.391c.92 0 1.667-.746 1.667-1.666v-.417c0-.92-.746-1.667-1.667-1.667Z" })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("defs", { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("clipPath", { id: "a", children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
  ] }),
  modifiedTablerIconProps
);
var AlignRightIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("g", { clipPath: "url(#a)", stroke: "currentColor", strokeWidth: "1.25", children: [
      /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
        "path",
        {
          d: "M16.667 3.333v13.334",
          strokeLinecap: "round",
          strokeLinejoin: "round"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M11.875 4.792H4.792c-.92 0-1.667.746-1.667 1.666v.417c0 .92.746 1.667 1.667 1.667h7.083c.92 0 1.667-.747 1.667-1.667v-.417c0-.92-.746-1.666-1.667-1.666ZM11.683 11.458H7.292c-.92 0-1.667.746-1.667 1.667v.417c0 .92.746 1.666 1.667 1.666h4.39c.921 0 1.667-.746 1.667-1.666v-.417c0-.92-.746-1.667-1.666-1.667Z" })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("defs", { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("clipPath", { id: "a", children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
  ] }),
  modifiedTablerIconProps
);
var DistributeHorizontallyIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("g", { clipPath: "url(#a)", stroke: "currentColor", strokeWidth: "1.25", children: [
      /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
        "path",
        {
          d: "M16.667 3.333v13.334M3.333 3.333v13.334",
          strokeLinecap: "round",
          strokeLinejoin: "round"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M14.375 10.208v-.416c0-.92-.746-1.667-1.667-1.667H7.292c-.92 0-1.667.746-1.667 1.667v.416c0 .92.746 1.667 1.667 1.667h5.416c.92 0 1.667-.746 1.667-1.667Z" })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("defs", { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("clipPath", { id: "a", children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
  ] }),
  modifiedTablerIconProps
);
var DistributeVerticallyIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("g", { clipPath: "url(#a)", stroke: "currentColor", strokeWidth: "1.25", children: [
      /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
        "path",
        {
          d: "M3.333 3.333h13.334M3.333 16.667h13.334",
          strokeLinecap: "round",
          strokeLinejoin: "round"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M10.208 5.625h-.416c-.92 0-1.667.746-1.667 1.667v5.416c0 .92.746 1.667 1.667 1.667h.416c.92 0 1.667-.746 1.667-1.667V7.292c0-.92-.746-1.667-1.667-1.667Z" })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("defs", { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("clipPath", { id: "a", children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
  ] }),
  modifiedTablerIconProps
);
var CenterVerticallyIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("g", { stroke: "currentColor", strokeWidth: "1.25", children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M1.667 10h2.916", strokeLinecap: "round", strokeLinejoin: "round" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M8.333 10h3.334", strokeLinejoin: "round" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M15.417 10h2.916", strokeLinecap: "round", strokeLinejoin: "round" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M6.875 4.792h-.417c-.92 0-1.666.746-1.666 1.666v7.084c0 .92.746 1.666 1.666 1.666h.417c.92 0 1.667-.746 1.667-1.666V6.458c0-.92-.747-1.666-1.667-1.666ZM13.542 6.458h-.417c-.92 0-1.667.747-1.667 1.667v3.75c0 .92.746 1.667 1.667 1.667h.417c.92 0 1.666-.746 1.666-1.667v-3.75c0-.92-.746-1.667-1.666-1.667Z" })
  ] }),
  modifiedTablerIconProps
);
var CenterHorizontallyIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("g", { stroke: "currentColor", strokeWidth: "1.25", children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M10 18.333v-2.916", strokeLinecap: "round", strokeLinejoin: "round" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M10 11.667V8.333", strokeLinejoin: "round" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M10 4.583V1.667", strokeLinecap: "round", strokeLinejoin: "round" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M4.792 13.125v.417c0 .92.746 1.666 1.666 1.666h7.084c.92 0 1.666-.746 1.666-1.666v-.417c0-.92-.746-1.667-1.666-1.667H6.458c-.92 0-1.666.746-1.666 1.667ZM6.458 6.458v.417c0 .92.747 1.667 1.667 1.667h3.75c.92 0 1.667-.747 1.667-1.667v-.417c0-.92-.746-1.666-1.667-1.666h-3.75c-.92 0-1.667.746-1.667 1.666Z" })
  ] }),
  modifiedTablerIconProps
);
var usersIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("g", { strokeWidth: "1.5", children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("circle", { cx: "9", cy: "7", r: "4" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M3 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M16 3.13a4 4 0 0 1 0 7.75" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M21 21v-2a4 4 0 0 0 -3 -3.85" })
  ] }),
  tablerIconProps
);
var start = createIcon(
  "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm115.7 272l-176 101c-15.8 8.8-35.7-2.5-35.7-21V152c0-18.4 19.8-29.8 35.7-21l176 107c16.4 9.2 16.4 32.9 0 42z"
);
var stop = createIcon(
  "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm96 328c0 8.8-7.2 16-16 16H176c-8.8 0-16-7.2-16-16V176c0-8.8 7.2-16 16-16h160c8.8 0 16 7.2 16 16v160z"
);
var CloseIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      "g",
      {
        clipPath: "url(#a)",
        stroke: "currentColor",
        strokeWidth: "1.25",
        strokeLinecap: "round",
        strokeLinejoin: "round",
        children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M15 5 5 15M5 5l10 10" })
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("defs", { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("clipPath", { id: "a", children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
  ] }),
  modifiedTablerIconProps
);
var back = createIcon(
  "M34.52 239.03L228.87 44.69c9.37-9.37 24.57-9.37 33.94 0l22.67 22.67c9.36 9.36 9.37 24.52.04 33.9L131.49 256l154.02 154.75c9.34 9.38 9.32 24.54-.04 33.9l-22.67 22.67c-9.37 9.37-24.57 9.37-33.94 0L34.52 272.97c-9.37-9.37-9.37-24.57 0-33.94z",
  { width: 320, height: 512, style: { marginLeft: "-0.2rem" }, mirror: true }
);
var clone2 = createIcon(
  "M464 0c26.51 0 48 21.49 48 48v288c0 26.51-21.49 48-48 48H176c-26.51 0-48-21.49-48-48V48c0-26.51 21.49-48 48-48h288M176 416c-44.112 0-80-35.888-80-80V128H48c-26.51 0-48 21.49-48 48v288c0 26.51 21.49 48 48 48h288c26.51 0 48-21.49 48-48v-48H176z",
  { mirror: true }
);
var shield = createIcon(
  "M11.553 22.894a.998.998 0 00.894 0s3.037-1.516 5.465-4.097C19.616 16.987 21 14.663 21 12V5a1 1 0 00-.649-.936l-8-3a.998.998 0 00-.702 0l-8 3A1 1 0 003 5v7c0 2.663 1.384 4.987 3.088 6.797 2.428 2.581 5.465 4.097 5.465 4.097zm-1.303-8.481l6.644-6.644a.856.856 0 111.212 1.212l-7.25 7.25a.856.856 0 01-1.212 0l-3.75-3.75a.856.856 0 111.212-1.212l3.144 3.144z",
  { width: 24 }
);
var file = createIcon(
  "M369.9 97.9L286 14C277 5 264.8-.1 252.1-.1H48C21.5 0 0 21.5 0 48v416c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V131.9c0-12.7-5.1-25-14.1-34zM332.1 128H256V51.9l76.1 76.1zM48 464V48h160v104c0 13.3 10.7 24 24 24h104v288H48zm32-48h224V288l-23.5-23.5c-4.7-4.7-12.3-4.7-17 0L176 352l-39.5-39.5c-4.7-4.7-12.3-4.7-17 0L80 352v64zm48-240c-26.5 0-48 21.5-48 48s21.5 48 48 48 48-21.5 48-48-21.5-48-48-48z",
  { width: 384, height: 512 }
);
var GroupIcon = import_react3.default.memo(
  ({ theme }) => createIcon(
    /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M25 26H111V111H25", fill: iconFillColor(theme) }),
      /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
        "path",
        {
          d: "M25 111C25 80.2068 25 49.4135 25 26M25 26C48.6174 26 72.2348 26 111 26H25ZM25 26C53.3671 26 81.7343 26 111 26H25ZM111 26C111 52.303 111 78.606 111 111V26ZM111 26C111 51.2947 111 76.5893 111 111V26ZM111 111C87.0792 111 63.1585 111 25 111H111ZM111 111C87.4646 111 63.9293 111 25 111H111ZM25 111C25 81.1514 25 51.3028 25 26V111Z",
          stroke: iconFillColor(theme),
          strokeWidth: "2"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M100 100H160V160H100", fill: iconFillColor(theme) }),
      /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
        "path",
        {
          d: "M100 160C100 144.106 100 128.211 100 100M100 100C117.706 100 135.412 100 160 100H100ZM100 100C114.214 100 128.428 100 160 100H100ZM160 100C160 120.184 160 140.369 160 160V100ZM160 100C160 113.219 160 126.437 160 160V100ZM160 160C145.534 160 131.068 160 100 160H160ZM160 160C143.467 160 126.934 160 100 160H160ZM100 160C100 143.661 100 127.321 100 100V160Z",
          stroke: iconFillColor(theme),
          strokeWidth: "2"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(
        "g",
        {
          fill: handlerColor(theme),
          stroke: iconFillColor(theme),
          strokeWidth: "6",
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime.jsx)("rect", { x: "2.5", y: "2.5", width: "30", height: "30" }),
            /* @__PURE__ */ (0, import_jsx_runtime.jsx)("rect", { x: "2.5", y: "149.5", width: "30", height: "30" }),
            /* @__PURE__ */ (0, import_jsx_runtime.jsx)("rect", { x: "147.5", y: "149.5", width: "30", height: "30" }),
            /* @__PURE__ */ (0, import_jsx_runtime.jsx)("rect", { x: "147.5", y: "2.5", width: "30", height: "30" })
          ]
        }
      )
    ] }),
    { width: 182, height: 182, mirror: true }
  )
);
var UngroupIcon = import_react3.default.memo(
  ({ theme }) => createIcon(
    /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M25 26H111V111H25", fill: iconFillColor(theme) }),
      /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
        "path",
        {
          d: "M25 111C25 80.2068 25 49.4135 25 26M25 26C48.6174 26 72.2348 26 111 26H25ZM25 26C53.3671 26 81.7343 26 111 26H25ZM111 26C111 52.303 111 78.606 111 111V26ZM111 26C111 51.2947 111 76.5893 111 111V26ZM111 111C87.0792 111 63.1585 111 25 111H111ZM111 111C87.4646 111 63.9293 111 25 111H111ZM25 111C25 81.1514 25 51.3028 25 26V111Z",
          stroke: iconFillColor(theme),
          strokeWidth: "2"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M100 100H160V160H100", fill: iconFillColor(theme) }),
      /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
        "path",
        {
          d: "M100 160C100 144.106 100 128.211 100 100M100 100C117.706 100 135.412 100 160 100H100ZM100 100C114.214 100 128.428 100 160 100H100ZM160 100C160 120.184 160 140.369 160 160V100ZM160 100C160 113.219 160 126.437 160 160V100ZM160 160C145.534 160 131.068 160 100 160H160ZM160 160C143.467 160 126.934 160 100 160H160ZM100 160C100 143.661 100 127.321 100 100V160Z",
          stroke: iconFillColor(theme),
          strokeWidth: "2"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(
        "g",
        {
          fill: handlerColor(theme),
          stroke: iconFillColor(theme),
          strokeWidth: "6",
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime.jsx)("rect", { x: "2.5", y: "2.5", width: "30", height: "30" }),
            /* @__PURE__ */ (0, import_jsx_runtime.jsx)("rect", { x: "78.5", y: "149.5", width: "30", height: "30" }),
            /* @__PURE__ */ (0, import_jsx_runtime.jsx)("rect", { x: "147.5", y: "149.5", width: "30", height: "30" }),
            /* @__PURE__ */ (0, import_jsx_runtime.jsx)("rect", { x: "147.5", y: "78.5", width: "30", height: "30" }),
            /* @__PURE__ */ (0, import_jsx_runtime.jsx)("rect", { x: "105.5", y: "2.5", width: "30", height: "30" }),
            /* @__PURE__ */ (0, import_jsx_runtime.jsx)("rect", { x: "2.5", y: "102.5", width: "30", height: "30" })
          ]
        }
      )
    ] }),
    { width: 182, height: 182, mirror: true }
  )
);
var FillZigZagIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsx)("g", { strokeWidth: 1.25, children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M5.879 2.625h8.242a3.27 3.27 0 0 1 3.254 3.254v8.242a3.27 3.27 0 0 1-3.254 3.254H5.88a3.27 3.27 0 0 1-3.254-3.254V5.88A3.27 3.27 0 0 1 5.88 2.626l-.001-.001ZM4.518 16.118l7.608-12.83m.198 13.934 5.051-9.897M2.778 9.675l9.348-6.387m-7.608 12.83 12.857-8.793" }) }),
  modifiedTablerIconProps
);
var FillHachureIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      "path",
      {
        d: "M5.879 2.625h8.242a3.254 3.254 0 0 1 3.254 3.254v8.242a3.254 3.254 0 0 1-3.254 3.254H5.88a3.254 3.254 0 0 1-3.254-3.254V5.88a3.254 3.254 0 0 1 3.254-3.254Z",
        stroke: "currentColor",
        strokeWidth: "1.25"
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      "mask",
      {
        id: "FillHachureIcon",
        style: { maskType: "alpha" },
        maskUnits: "userSpaceOnUse",
        x: 2,
        y: 2,
        width: 16,
        height: 16,
        children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
          "path",
          {
            d: "M5.879 2.625h8.242a3.254 3.254 0 0 1 3.254 3.254v8.242a3.254 3.254 0 0 1-3.254 3.254H5.88a3.254 3.254 0 0 1-3.254-3.254V5.88a3.254 3.254 0 0 1 3.254-3.254Z",
            fill: "currentColor",
            stroke: "currentColor",
            strokeWidth: "1.25"
          }
        )
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("g", { mask: "url(#FillHachureIcon)", children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      "path",
      {
        d: "M2.258 15.156 15.156 2.258M7.324 20.222 20.222 7.325m-20.444 5.35L12.675-.222m-8.157 18.34L17.416 5.22",
        stroke: "currentColor",
        strokeWidth: "1.25",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }
    ) })
  ] }),
  modifiedTablerIconProps
);
var FillCrossHatchIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("g", { clipPath: "url(#a)", children: [
      /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
        "path",
        {
          d: "M5.879 2.625h8.242a3.254 3.254 0 0 1 3.254 3.254v8.242a3.254 3.254 0 0 1-3.254 3.254H5.88a3.254 3.254 0 0 1-3.254-3.254V5.88a3.254 3.254 0 0 1 3.254-3.254Z",
          stroke: "currentColor",
          strokeWidth: "1.25"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
        "mask",
        {
          id: "FillCrossHatchIcon",
          style: { maskType: "alpha" },
          maskUnits: "userSpaceOnUse",
          x: -1,
          y: -1,
          width: 22,
          height: 22,
          children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
            "path",
            {
              d: "M2.426 15.044 15.044 2.426M7.383 20 20 7.383M0 12.617 12.617 0m-7.98 17.941L17.256 5.324m-2.211 12.25L2.426 4.956M20 12.617 7.383 0m5.234 20L0 7.383m17.941 7.98L5.324 2.745",
              stroke: "currentColor",
              strokeWidth: "1.25",
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          )
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime.jsx)("g", { mask: "url(#FillCrossHatchIcon)", children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
        "path",
        {
          d: "M14.121 2H5.88A3.879 3.879 0 0 0 2 5.879v8.242A3.879 3.879 0 0 0 5.879 18h8.242A3.879 3.879 0 0 0 18 14.121V5.88A3.879 3.879 0 0 0 14.121 2Z",
          fill: "currentColor"
        }
      ) })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("defs", { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("clipPath", { id: "a", children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
  ] }),
  modifiedTablerIconProps
);
var FillSolidIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("g", { clipPath: "url(#a)", children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      "path",
      {
        d: "M4.91 2.625h10.18a2.284 2.284 0 0 1 2.285 2.284v10.182a2.284 2.284 0 0 1-2.284 2.284H4.909a2.284 2.284 0 0 1-2.284-2.284V4.909a2.284 2.284 0 0 1 2.284-2.284Z",
        stroke: "currentColor",
        strokeWidth: "1.25"
      }
    ) }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("defs", { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("clipPath", { id: "a", children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
  ] }),
  { ...modifiedTablerIconProps, fill: "currentColor" }
);
var StrokeWidthBaseIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    "path",
    {
      d: "M4.167 10h11.666",
      stroke: "currentColor",
      strokeWidth: "1.25",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }
  ) }),
  modifiedTablerIconProps
);
var StrokeWidthBoldIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    "path",
    {
      d: "M5 10h10",
      stroke: "currentColor",
      strokeWidth: "2.5",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }
  ),
  modifiedTablerIconProps
);
var StrokeWidthExtraBoldIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    "path",
    {
      d: "M5 10h10",
      stroke: "currentColor",
      strokeWidth: "3.75",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }
  ),
  modifiedTablerIconProps
);
var StrokeStyleSolidIcon = import_react3.default.memo(
  ({ theme }) => createIcon(
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      "path",
      {
        d: "M6 10H34",
        stroke: iconFillColor(theme),
        strokeWidth: 2,
        fill: "none",
        strokeLinecap: "round"
      }
    ),
    {
      width: 40,
      height: 20
    }
  )
);
var StrokeStyleDashedIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("g", { strokeWidth: "2", children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M5 12h2" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M17 12h2" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M11 12h2" })
  ] }),
  tablerIconProps
);
var StrokeStyleDottedIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("g", { strokeWidth: "2", children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M4 12v.01" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M8 12v.01" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M12 12v.01" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M16 12v.01" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M20 12v.01" })
  ] }),
  tablerIconProps
);
var SloppinessArchitectIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    "path",
    {
      d: "M2.5 12.038c1.655-.885 5.9-3.292 8.568-4.354 2.668-1.063.101 2.821 1.32 3.104 1.218.283 5.112-1.814 5.112-1.814",
      strokeWidth: "1.25"
    }
  ),
  modifiedTablerIconProps
);
var SloppinessArtistIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    "path",
    {
      d: "M2.5 12.563c1.655-.886 5.9-3.293 8.568-4.355 2.668-1.062.101 2.822 1.32 3.105 1.218.283 5.112-1.814 5.112-1.814m-13.469 2.23c2.963-1.586 6.13-5.62 7.468-4.998 1.338.623-1.153 4.11-.132 5.595 1.02 1.487 6.133-1.43 6.133-1.43",
      strokeWidth: "1.25"
    }
  ),
  modifiedTablerIconProps
);
var SloppinessCartoonistIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    "path",
    {
      d: "M2.5 11.936c1.737-.879 8.627-5.346 10.42-5.268 1.795.078-.418 5.138.345 5.736.763.598 3.53-1.789 4.235-2.147M2.929 9.788c1.164-.519 5.47-3.28 6.987-3.114 1.519.165 1 3.827 2.121 4.109 1.122.281 3.839-2.016 4.606-2.42",
      strokeWidth: "1.25"
    }
  ),
  modifiedTablerIconProps
);
var EdgeSharpIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("svg", { strokeWidth: "1.5", children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M3.33334 9.99998V6.66665C3.33334 6.04326 3.33403 4.9332 3.33539 3.33646C4.95233 3.33436 6.06276 3.33331 6.66668 3.33331H10" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M13.3333 3.33331V3.34331" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M16.6667 3.33331V3.34331" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M16.6667 6.66669V6.67669" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M16.6667 10V10.01" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M3.33334 13.3333V13.3433" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M16.6667 13.3333V13.3433" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M3.33334 16.6667V16.6767" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M6.66666 16.6667V16.6767" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M10 16.6667V16.6767" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M13.3333 16.6667V16.6767" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M16.6667 16.6667V16.6767" })
  ] }),
  modifiedTablerIconProps
);
var EdgeRoundIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(
    "g",
    {
      strokeWidth: "1.5",
      stroke: "currentColor",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M4 12v-4a4 4 0 0 1 4 -4h4" }),
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)("line", { x1: "16", y1: "4", x2: "16", y2: "4.01" }),
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)("line", { x1: "20", y1: "4", x2: "20", y2: "4.01" }),
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)("line", { x1: "20", y1: "8", x2: "20", y2: "8.01" }),
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)("line", { x1: "20", y1: "12", x2: "20", y2: "12.01" }),
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)("line", { x1: "4", y1: "16", x2: "4", y2: "16.01" }),
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)("line", { x1: "20", y1: "16", x2: "20", y2: "16.01" }),
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)("line", { x1: "4", y1: "20", x2: "4", y2: "20.01" }),
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)("line", { x1: "8", y1: "20", x2: "8", y2: "20.01" }),
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)("line", { x1: "12", y1: "20", x2: "12", y2: "20.01" }),
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)("line", { x1: "16", y1: "20", x2: "16", y2: "20.01" }),
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)("line", { x1: "20", y1: "20", x2: "20", y2: "20.01" })
      ]
    }
  ),
  tablerIconProps
);
var ArrowheadNoneIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M6 10H34", stroke: "currentColor", strokeWidth: 2, fill: "none" }),
  {
    width: 40,
    height: 20
  }
);
var ArrowheadArrowIcon = import_react3.default.memo(
  ({ flip = false }) => createIcon(
    /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(
      "g",
      {
        transform: flip ? "translate(40, 0) scale(-1, 1)" : "",
        stroke: "currentColor",
        strokeWidth: 2,
        fill: "none",
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M34 10H6M34 10L27 5M34 10L27 15" }),
          /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M27.5 5L34.5 10L27.5 15" })
        ]
      }
    ),
    { width: 40, height: 20 }
  )
);
var ArrowheadCircleIcon = import_react3.default.memo(
  ({ flip = false }) => createIcon(
    /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(
      "g",
      {
        stroke: "currentColor",
        fill: "currentColor",
        transform: flip ? "translate(40, 0) scale(-1, 1)" : "",
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M32 10L6 10", strokeWidth: 2 }),
          /* @__PURE__ */ (0, import_jsx_runtime.jsx)("circle", { r: "4", transform: "matrix(-1 0 0 1 30 10)" })
        ]
      }
    ),
    { width: 40, height: 20 }
  )
);
var ArrowheadCircleOutlineIcon = import_react3.default.memo(
  ({ flip = false }) => createIcon(
    /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(
      "g",
      {
        stroke: "currentColor",
        fill: "none",
        transform: flip ? "translate(40, 0) scale(-1, 1)" : "",
        strokeWidth: 2,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M26 10L6 10" }),
          /* @__PURE__ */ (0, import_jsx_runtime.jsx)("circle", { r: "4", transform: "matrix(-1 0 0 1 30 10)" })
        ]
      }
    ),
    { width: 40, height: 20 }
  )
);
var ArrowheadBarIcon = import_react3.default.memo(
  ({ flip = false }) => createIcon(
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("g", { transform: flip ? "translate(40, 0) scale(-1, 1)" : "", children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      "path",
      {
        d: "M34 10H5.99996M34 10L34 5M34 10L34 15",
        stroke: "currentColor",
        strokeWidth: 2,
        fill: "none"
      }
    ) }),
    { width: 40, height: 20 }
  )
);
var ArrowheadTriangleIcon = import_react3.default.memo(
  ({ flip = false }) => createIcon(
    /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(
      "g",
      {
        stroke: "currentColor",
        fill: "currentColor",
        transform: flip ? "translate(40, 0) scale(-1, 1)" : "",
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M32 10L6 10", strokeWidth: 2 }),
          /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M27.5 5.5L34.5 10L27.5 14.5L27.5 5.5" })
        ]
      }
    ),
    { width: 40, height: 20 }
  )
);
var ArrowheadTriangleOutlineIcon = import_react3.default.memo(
  ({ flip = false }) => createIcon(
    /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(
      "g",
      {
        stroke: "currentColor",
        fill: "none",
        transform: flip ? "translate(40, 0) scale(-1, 1)" : "",
        strokeWidth: 2,
        strokeLinejoin: "round",
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M6,9.5H27" }),
          /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M27,5L34,10L27,14Z", fill: "none" })
        ]
      }
    ),
    { width: 40, height: 20 }
  )
);
var ArrowheadDiamondIcon = import_react3.default.memo(
  ({ flip = false }) => createIcon(
    /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(
      "g",
      {
        stroke: "currentColor",
        fill: "currentColor",
        transform: flip ? "translate(40, 0) scale(-1, 1)" : "",
        strokeLinejoin: "round",
        strokeWidth: 2,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M6,9.5H20" }),
          /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M27,5L34,10L27,14L20,9.5Z" })
        ]
      }
    ),
    { width: 40, height: 20 }
  )
);
var ArrowheadDiamondOutlineIcon = import_react3.default.memo(
  ({ flip = false }) => createIcon(
    /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(
      "g",
      {
        stroke: "currentColor",
        fill: "none",
        transform: flip ? "translate(40, 0) scale(-1, 1)" : "",
        strokeLinejoin: "round",
        strokeWidth: 2,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M6,9.5H20" }),
          /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M27,5L34,10L27,14L20,9.5Z" })
        ]
      }
    ),
    { width: 40, height: 20 }
  )
);
var FontSizeSmallIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("g", { clipPath: "url(#a)", children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      "path",
      {
        d: "M14.167 6.667a3.333 3.333 0 0 0-3.334-3.334H9.167a3.333 3.333 0 0 0 0 6.667h1.666a3.333 3.333 0 0 1 0 6.667H9.167a3.333 3.333 0 0 1-3.334-3.334",
        stroke: "currentColor",
        strokeWidth: "1.25",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }
    ) }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("defs", { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("clipPath", { id: "a", children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
  ] }),
  modifiedTablerIconProps
);
var FontSizeMediumIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("g", { clipPath: "url(#a)", children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      "path",
      {
        d: "M5 16.667V3.333L10 15l5-11.667v13.334",
        stroke: "currentColor",
        strokeWidth: "1.25",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }
    ) }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("defs", { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("clipPath", { id: "a", children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
  ] }),
  modifiedTablerIconProps
);
var FontSizeLargeIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("g", { clipPath: "url(#a)", children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      "path",
      {
        d: "M5.833 3.333v13.334h8.334",
        stroke: "currentColor",
        strokeWidth: "1.25",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }
    ) }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("defs", { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("clipPath", { id: "a", children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
  ] }),
  modifiedTablerIconProps
);
var FontSizeExtraLargeIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    "path",
    {
      d: "m1.667 3.333 6.666 13.334M8.333 3.333 1.667 16.667M11.667 3.333v13.334h6.666",
      stroke: "currentColor",
      strokeWidth: "1.25",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }
  ) }),
  modifiedTablerIconProps
);
var FontFamilyNormalIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    "g",
    {
      stroke: "currentColor",
      strokeWidth: "1.25",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M5.833 16.667v-10a3.333 3.333 0 0 1 3.334-3.334h1.666a3.333 3.333 0 0 1 3.334 3.334v10M5.833 10.833h8.334" })
    }
  ) }),
  modifiedTablerIconProps
);
var FontFamilyCodeIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      "g",
      {
        clipPath: "url(#a)",
        stroke: "currentColor",
        strokeWidth: "1.25",
        strokeLinecap: "round",
        strokeLinejoin: "round",
        children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M5.833 6.667 2.5 10l3.333 3.333M14.167 6.667 17.5 10l-3.333 3.333M11.667 3.333 8.333 16.667" })
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("defs", { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("clipPath", { id: "a", children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
  ] }),
  modifiedTablerIconProps
);
var TextAlignLeftIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(
    "g",
    {
      stroke: "currentColor",
      fill: "none",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      strokeWidth: 2,
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)("line", { x1: "4", y1: "8", x2: "20", y2: "8" }),
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)("line", { x1: "4", y1: "12", x2: "12", y2: "12" }),
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)("line", { x1: "4", y1: "16", x2: "16", y2: "16" })
      ]
    }
  ),
  tablerIconProps
);
var TextAlignCenterIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(
    "g",
    {
      stroke: "currentColor",
      fill: "none",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)("line", { x1: "4", y1: "8", x2: "20", y2: "8" }),
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)("line", { x1: "8", y1: "12", x2: "16", y2: "12" }),
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)("line", { x1: "6", y1: "16", x2: "18", y2: "16" })
      ]
    }
  ),
  tablerIconProps
);
var TextAlignRightIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(
    "g",
    {
      stroke: "currentColor",
      fill: "none",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)("line", { x1: "4", y1: "8", x2: "20", y2: "8" }),
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)("line", { x1: "10", y1: "12", x2: "20", y2: "12" }),
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)("line", { x1: "8", y1: "16", x2: "20", y2: "16" })
      ]
    }
  ),
  tablerIconProps
);
var TextAlignTopIcon = import_react3.default.memo(
  ({ theme }) => createIcon(
    /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(
      "g",
      {
        strokeWidth: "1.5",
        stroke: "currentColor",
        fill: "none",
        strokeLinecap: "round",
        strokeLinejoin: "round",
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
          /* @__PURE__ */ (0, import_jsx_runtime.jsx)("line", { x1: "4", y1: "4", x2: "20", y2: "4" }),
          /* @__PURE__ */ (0, import_jsx_runtime.jsx)("rect", { x: "9", y: "8", width: "6", height: "12", rx: "2" })
        ]
      }
    ),
    tablerIconProps
  )
);
var TextAlignBottomIcon = import_react3.default.memo(
  ({ theme }) => createIcon(
    /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(
      "g",
      {
        strokeWidth: "2",
        stroke: "currentColor",
        fill: "none",
        strokeLinecap: "round",
        strokeLinejoin: "round",
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
          /* @__PURE__ */ (0, import_jsx_runtime.jsx)("line", { x1: "4", y1: "20", x2: "20", y2: "20" }),
          /* @__PURE__ */ (0, import_jsx_runtime.jsx)("rect", { x: "9", y: "4", width: "6", height: "12", rx: "2" })
        ]
      }
    ),
    tablerIconProps
  )
);
var TextAlignMiddleIcon = import_react3.default.memo(
  ({ theme }) => createIcon(
    /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(
      "g",
      {
        strokeWidth: "1.5",
        stroke: "currentColor",
        fill: "none",
        strokeLinecap: "round",
        strokeLinejoin: "round",
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
          /* @__PURE__ */ (0, import_jsx_runtime.jsx)("line", { x1: "4", y1: "12", x2: "9", y2: "12" }),
          /* @__PURE__ */ (0, import_jsx_runtime.jsx)("line", { x1: "15", y1: "12", x2: "20", y2: "12" }),
          /* @__PURE__ */ (0, import_jsx_runtime.jsx)("rect", { x: "9", y: "6", width: "6", height: "12", rx: "2" })
        ]
      }
    ),
    tablerIconProps
  )
);
var publishIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    "path",
    {
      d: "M537.6 226.6c4.1-10.7 6.4-22.4 6.4-34.6 0-53-43-96-96-96-19.7 0-38.1 6-53.3 16.2C367 64.2 315.3 32 256 32c-88.4 0-160 71.6-160 160 0 2.7.1 5.4.2 8.1C40.2 219.8 0 273.2 0 336c0 79.5 64.5 144 144 144h368c70.7 0 128-57.3 128-128 0-61.9-44-113.6-102.4-125.4zM393.4 288H328v112c0 8.8-7.2 16-16 16h-48c-8.8 0-16-7.2-16-16V288h-65.4c-14.3 0-21.4-17.2-11.3-27.3l105.4-105.4c6.2-6.2 16.4-6.2 22.6 0l105.4 105.4c10.1 10.1 2.9 27.3-11.3 27.3z",
      fill: "currentColor"
    }
  ),
  { width: 640, height: 512 }
);
var eraser = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M480 416C497.7 416 512 430.3 512 448C512 465.7 497.7 480 480 480H150.6C133.7 480 117.4 473.3 105.4 461.3L25.37 381.3C.3786 356.3 .3786 315.7 25.37 290.7L258.7 57.37C283.7 32.38 324.3 32.38 349.3 57.37L486.6 194.7C511.6 219.7 511.6 260.3 486.6 285.3L355.9 416H480zM265.4 416L332.7 348.7L195.3 211.3L70.63 336L150.6 416L265.4 416z" })
);
var handIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("g", { strokeWidth: 1.25, children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M8 13v-7.5a1.5 1.5 0 0 1 3 0v6.5" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M11 5.5v-2a1.5 1.5 0 1 1 3 0v8.5" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M14 5.5a1.5 1.5 0 0 1 3 0v6.5" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M17 7.5a1.5 1.5 0 0 1 3 0v8.5a6 6 0 0 1 -6 6h-2h.208a6 6 0 0 1 -5.012 -2.7a69.74 69.74 0 0 1 -.196 -.3c-.312 -.479 -1.407 -2.388 -3.286 -5.728a1.5 1.5 0 0 1 .536 -2.022a1.867 1.867 0 0 1 2.28 .28l1.47 1.47" })
  ] }),
  tablerIconProps
);
var downloadIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M4 17v2a2 2 0 0 0 2 2h12a2 2 0 0 0 2 -2v-2" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M7 11l5 5l5 -5" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M12 4l0 12" })
  ] }),
  tablerIconProps
);
var copyIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2" })
  ] }),
  tablerIconProps
);
var helpIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M12 12m-9 0a9 9 0 1 0 18 0a9 9 0 1 0 -18 0" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M12 17l0 .01" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M12 13.5a1.5 1.5 0 0 1 1 -1.5a2.6 2.6 0 1 0 -3 -4" })
  ] }),
  tablerIconProps
);
var playerPlayIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M7 4v16l13 -8z" })
  ] }),
  tablerIconProps
);
var playerStopFilledIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      "path",
      {
        d: "M17 4h-10a3 3 0 0 0 -3 3v10a3 3 0 0 0 3 3h10a3 3 0 0 0 3 -3v-10a3 3 0 0 0 -3 -3z",
        strokeWidth: "0",
        fill: "currentColor"
      }
    )
  ] }),
  tablerIconProps
);
var tablerCheckIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M5 12l5 5l10 -10" })
  ] }),
  tablerIconProps
);
var alertTriangleIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M10.24 3.957l-8.422 14.06a1.989 1.989 0 0 0 1.7 2.983h16.845a1.989 1.989 0 0 0 1.7 -2.983l-8.423 -14.06a1.989 1.989 0 0 0 -3.4 0z" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M12 9v4" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M12 17h.01" })
  ] }),
  tablerIconProps
);
var eyeDropperIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("g", { strokeWidth: 1.25, children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M11 7l6 6" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M4 16l11.7 -11.7a1 1 0 0 1 1.4 0l2.6 2.6a1 1 0 0 1 0 1.4l-11.7 11.7h-4v-4z" })
  ] }),
  tablerIconProps
);
var extraToolsIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("g", { strokeWidth: 1.5, children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M12 3l-4 7h8z" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M17 17m-3 0a3 3 0 1 0 6 0a3 3 0 1 0 -6 0" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M4 14m0 1a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v4a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1z" })
  ] }),
  tablerIconProps
);
var frameToolIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("g", { strokeWidth: 1.5, children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M4 7l16 0" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M4 17l16 0" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M7 4l0 16" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M17 4l0 16" })
  ] }),
  tablerIconProps
);
var mermaidLogoIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    "path",
    {
      fill: "currentColor",
      d: "M407.48,111.18C335.587,108.103 269.573,152.338 245.08,220C220.587,152.338 154.573,108.103 82.68,111.18C80.285,168.229 107.577,222.632 154.74,254.82C178.908,271.419 193.35,298.951 193.27,328.27L193.27,379.13L296.9,379.13L296.9,328.27C296.816,298.953 311.255,271.42 335.42,254.82C382.596,222.644 409.892,168.233 407.48,111.18Z"
    }
  )
);
var ArrowRightIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("g", { strokeWidth: "1.25", children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M4.16602 10H15.8327" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M12.5 13.3333L15.8333 10" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M12.5 6.66666L15.8333 9.99999" })
  ] }),
  modifiedTablerIconProps
);
var laserPointerToolIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(
    "g",
    {
      fill: "none",
      stroke: "currentColor",
      strokeWidth: "1.25",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      transform: "rotate(90 10 10)",
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
          "path",
          {
            clipRule: "evenodd",
            d: "m9.644 13.69 7.774-7.773a2.357 2.357 0 0 0-3.334-3.334l-7.773 7.774L8 12l1.643 1.69Z"
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "m13.25 3.417 3.333 3.333M10 10l2-2M5 15l3-3M2.156 17.894l1-1M5.453 19.029l-.144-1.407M2.377 11.887l.866 1.118M8.354 17.273l-1.194-.758M.953 14.652l1.408.13" })
      ]
    }
  ),
  20
);
var MagicIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("g", { stroke: "currentColor", fill: "none", children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { stroke: "none", d: "M0 0h24v24H0z" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M6 21l15 -15l-3 -3l-15 15l3 3" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M15 6l3 3" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M9 3a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M19 13a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2" })
  ] }),
  tablerIconProps
);
var OpenAIIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("g", { stroke: "currentColor", fill: "none", children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M11.217 19.384a3.501 3.501 0 0 0 6.783 -1.217v-5.167l-6 -3.35" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M5.214 15.014a3.501 3.501 0 0 0 4.446 5.266l4.34 -2.534v-6.946" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M6 7.63c-1.391 -.236 -2.787 .395 -3.534 1.689a3.474 3.474 0 0 0 1.271 4.745l4.263 2.514l6 -3.348" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M12.783 4.616a3.501 3.501 0 0 0 -6.783 1.217v5.067l6 3.45" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M18.786 8.986a3.501 3.501 0 0 0 -4.446 -5.266l-4.34 2.534v6.946" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M18 16.302c1.391 .236 2.787 -.395 3.534 -1.689a3.474 3.474 0 0 0 -1.271 -4.745l-4.308 -2.514l-5.955 3.42" })
  ] }),
  tablerIconProps
);
var fullscreenIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("g", { stroke: "currentColor", fill: "none", children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M4 8v-2a2 2 0 0 1 2 -2h2" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M4 16v2a2 2 0 0 0 2 2h2" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M16 4h2a2 2 0 0 1 2 2v2" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M16 20h2a2 2 0 0 0 2 -2v-2" })
  ] }),
  tablerIconProps
);
var eyeIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("g", { stroke: "currentColor", fill: "none", children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M21 12c-2.4 4 -5.4 6 -9 6c-3.6 0 -6.6 -2 -9 -6c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6" })
  ] }),
  tablerIconProps
);
var eyeClosedIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("g", { stroke: "currentColor", fill: "none", children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M10.585 10.587a2 2 0 0 0 2.829 2.828" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M16.681 16.673a8.717 8.717 0 0 1 -4.681 1.327c-3.6 0 -6.6 -2 -9 -6c1.272 -2.12 2.712 -3.678 4.32 -4.674m2.86 -1.146a9.055 9.055 0 0 1 1.82 -.18c3.6 0 6.6 2 9 6c-.666 1.11 -1.379 2.067 -2.138 2.87" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M3 3l18 18" })
  ] }),
  tablerIconProps
);
var brainIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("g", { stroke: "currentColor", fill: "none", children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M15.5 13a3.5 3.5 0 0 0 -3.5 3.5v1a3.5 3.5 0 0 0 7 0v-1.8" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M8.5 13a3.5 3.5 0 0 1 3.5 3.5v1a3.5 3.5 0 0 1 -7 0v-1.8" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M17.5 16a3.5 3.5 0 0 0 0 -7h-.5" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M19 9.3v-2.8a3.5 3.5 0 0 0 -7 0" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M6.5 16a3.5 3.5 0 0 1 0 -7h.5" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M5 9.3v-2.8a3.5 3.5 0 0 1 7 0v10" })
  ] }),
  tablerIconProps
);
var searchIcon = createIcon(
  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("g", { strokeWidth: 1.5, children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M10 10m-7 0a7 7 0 1 0 14 0a7 7 0 1 0 -14 0" }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M21 21l-6 -6" })
  ] }),
  tablerIconProps
);

// actions/actionDeleteSelected.tsx
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var deleteSelectedElements = (elements, appState) => {
  const framesToBeDeleted = new Set(
    getSelectedElements(
      elements.filter((el) => isFrameLikeElement(el)),
      appState
    ).map((el) => el.id)
  );
  return {
    elements: elements.map((el) => {
      if (appState.selectedElementIds[el.id]) {
        return newElementWith(el, { isDeleted: true });
      }
      if (el.frameId && framesToBeDeleted.has(el.frameId)) {
        return newElementWith(el, { isDeleted: true });
      }
      if (isBoundToContainer(el) && appState.selectedElementIds[el.containerId]) {
        return newElementWith(el, { isDeleted: true });
      }
      return el;
    }),
    appState: {
      ...appState,
      selectedElementIds: {},
      selectedGroupIds: {}
    }
  };
};
var handleGroupEditingState = (appState, elements) => {
  if (appState.editingGroupId) {
    const siblingElements = getElementsInGroup(
      getNonDeletedElements2(elements),
      appState.editingGroupId
    );
    if (siblingElements.length) {
      return {
        ...appState,
        selectedElementIds: { [siblingElements[0].id]: true }
      };
    }
  }
  return appState;
};
var actionDeleteSelected = register({
  name: "deleteSelectedElements",
  trackEvent: { category: "element", action: "delete" },
  perform: (elements, appState, formData, app) => {
    if (appState.editingLinearElement) {
      const {
        elementId,
        selectedPointsIndices,
        startBindingElement,
        endBindingElement
      } = appState.editingLinearElement;
      const elementsMap = app.scene.getNonDeletedElementsMap();
      const element = LinearElementEditor.getElement(elementId, elementsMap);
      if (!element) {
        return false;
      }
      if (selectedPointsIndices == null) {
        return false;
      }
      if (element.points.length < 2) {
        const nextElements2 = elements.map((el) => {
          if (el.id === element.id) {
            return newElementWith(el, { isDeleted: true });
          }
          return el;
        });
        const nextAppState2 = handleGroupEditingState(appState, nextElements2);
        return {
          elements: nextElements2,
          appState: {
            ...nextAppState2,
            editingLinearElement: null
          },
          commitToHistory: false
        };
      }
      const binding = {
        startBindingElement: selectedPointsIndices?.includes(0) ? null : startBindingElement,
        endBindingElement: selectedPointsIndices?.includes(
          element.points.length - 1
        ) ? null : endBindingElement
      };
      LinearElementEditor.deletePoints(element, selectedPointsIndices);
      return {
        elements,
        appState: {
          ...appState,
          editingLinearElement: {
            ...appState.editingLinearElement,
            ...binding,
            selectedPointsIndices: selectedPointsIndices?.[0] > 0 ? [selectedPointsIndices[0] - 1] : [0]
          }
        },
        commitToHistory: true
      };
    }
    let { elements: nextElements, appState: nextAppState } = deleteSelectedElements(elements, appState);
    fixBindingsAfterDeletion(
      nextElements,
      elements.filter(({ id }) => appState.selectedElementIds[id])
    );
    nextAppState = handleGroupEditingState(nextAppState, nextElements);
    return {
      elements: nextElements,
      appState: {
        ...nextAppState,
        activeTool: updateActiveTool(appState, { type: "selection" }),
        multiElement: null,
        activeEmbeddable: null
      },
      commitToHistory: isSomeElementSelected(
        getNonDeletedElements2(elements),
        appState
      )
    };
  },
  contextItemLabel: "labels.delete",
  keyTest: (event, appState, elements) => (event.key === KEYS.BACKSPACE || event.key === KEYS.DELETE) && !event[KEYS.CTRL_OR_CMD],
  PanelComponent: ({ elements, appState, updateData }) => /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
    ToolButton,
    {
      type: "button",
      icon: TrashIcon,
      title: t("labels.delete"),
      "aria-label": t("labels.delete"),
      onClick: () => updateData(null),
      visible: isSomeElementSelected(getNonDeletedElements2(elements), appState)
    }
  )
});

// actions/actionZindex.tsx
init_define_import_meta_env();

// zindex.ts
init_define_import_meta_env();
var isOfTargetFrame = (element, frameId) => {
  return element.frameId === frameId || element.id === frameId;
};
var getIndicesToMove = (elements, appState, elementsToBeMoved) => {
  let selectedIndices = [];
  let deletedIndices = [];
  let includeDeletedIndex = null;
  let index2 = -1;
  const selectedElementIds = arrayToMap(
    elementsToBeMoved ? elementsToBeMoved : getSelectedElements(elements, appState, {
      includeBoundTextElement: true,
      includeElementsInFrames: true
    })
  );
  while (++index2 < elements.length) {
    const element = elements[index2];
    if (selectedElementIds.get(element.id)) {
      if (deletedIndices.length) {
        selectedIndices = selectedIndices.concat(deletedIndices);
        deletedIndices = [];
      }
      selectedIndices.push(index2);
      includeDeletedIndex = index2 + 1;
    } else if (element.isDeleted && includeDeletedIndex === index2) {
      includeDeletedIndex = index2 + 1;
      deletedIndices.push(index2);
    } else {
      deletedIndices = [];
    }
  }
  return selectedIndices;
};
var toContiguousGroups = (array) => {
  let cursor = 0;
  return array.reduce((acc, value, index2) => {
    if (index2 > 0 && array[index2 - 1] !== value - 1) {
      cursor = ++cursor;
    }
    (acc[cursor] || (acc[cursor] = [])).push(value);
    return acc;
  }, []);
};
var getTargetIndexAccountingForBinding = (nextElement, elements, direction) => {
  if ("containerId" in nextElement && nextElement.containerId) {
    if (direction === "left") {
      const containerElement = Scene_default.getScene(nextElement).getElement(
        nextElement.containerId
      );
      if (containerElement) {
        return elements.indexOf(containerElement);
      }
    } else {
      return elements.indexOf(nextElement);
    }
  } else {
    const boundElementId = nextElement.boundElements?.find(
      (binding) => binding.type !== "arrow"
    )?.id;
    if (boundElementId) {
      if (direction === "left") {
        return elements.indexOf(nextElement);
      }
      const boundTextElement = Scene_default.getScene(nextElement).getElement(boundElementId);
      if (boundTextElement) {
        return elements.indexOf(boundTextElement);
      }
    }
  }
};
var getContiguousFrameRangeElements = (allElements, frameId) => {
  let rangeStart = -1;
  let rangeEnd = -1;
  allElements.forEach((element, index2) => {
    if (isOfTargetFrame(element, frameId)) {
      if (rangeStart === -1) {
        rangeStart = index2;
      }
      rangeEnd = index2;
    }
  });
  if (rangeStart === -1) {
    return [];
  }
  return allElements.slice(rangeStart, rangeEnd + 1);
};
var getTargetIndex = (appState, elements, boundaryIndex, direction, containingFrame) => {
  const sourceElement = elements[boundaryIndex];
  const indexFilter = (element) => {
    if (element.isDeleted) {
      return false;
    }
    if (containingFrame) {
      return element.frameId === containingFrame;
    }
    if (appState.editingGroupId) {
      return element.groupIds.includes(appState.editingGroupId);
    }
    return true;
  };
  const candidateIndex = direction === "left" ? findLastIndex(
    elements,
    (el) => indexFilter(el),
    Math.max(0, boundaryIndex - 1)
  ) : findIndex(elements, (el) => indexFilter(el), boundaryIndex + 1);
  const nextElement = elements[candidateIndex];
  if (!nextElement) {
    return -1;
  }
  if (appState.editingGroupId) {
    if (
      // candidate element is a sibling in current editing group  return
      sourceElement?.groupIds.join("") === nextElement?.groupIds.join("")
    ) {
      return getTargetIndexAccountingForBinding(nextElement, elements, direction) ?? candidateIndex;
    } else if (!nextElement?.groupIds.includes(appState.editingGroupId)) {
      return -1;
    }
  }
  if (!containingFrame && (nextElement.frameId || isFrameLikeElement(nextElement))) {
    const frameElements = getContiguousFrameRangeElements(
      elements,
      nextElement.frameId || nextElement.id
    );
    return direction === "left" ? elements.indexOf(frameElements[0]) : elements.indexOf(frameElements[frameElements.length - 1]);
  }
  if (!nextElement.groupIds.length) {
    return getTargetIndexAccountingForBinding(nextElement, elements, direction) ?? candidateIndex;
  }
  const siblingGroupId = appState.editingGroupId ? nextElement.groupIds[nextElement.groupIds.indexOf(appState.editingGroupId) - 1] : nextElement.groupIds[nextElement.groupIds.length - 1];
  const elementsInSiblingGroup = getElementsInGroup(elements, siblingGroupId);
  if (elementsInSiblingGroup.length) {
    return direction === "left" ? elements.indexOf(elementsInSiblingGroup[0]) : elements.indexOf(
      elementsInSiblingGroup[elementsInSiblingGroup.length - 1]
    );
  }
  return candidateIndex;
};
var getTargetElementsMap = (elements, indices) => {
  return indices.reduce((acc, index2) => {
    const element = elements[index2];
    acc[element.id] = element;
    return acc;
  }, {});
};
var shiftElementsByOne = (elements, appState, direction) => {
  const indicesToMove = getIndicesToMove(elements, appState);
  const targetElementsMap = getTargetElementsMap(elements, indicesToMove);
  let groupedIndices = toContiguousGroups(indicesToMove);
  if (direction === "right") {
    groupedIndices = groupedIndices.reverse();
  }
  const selectedFrames = new Set(
    indicesToMove.filter((idx) => isFrameLikeElement(elements[idx])).map((idx) => elements[idx].id)
  );
  groupedIndices.forEach((indices, i4) => {
    const leadingIndex = indices[0];
    const trailingIndex = indices[indices.length - 1];
    const boundaryIndex = direction === "left" ? leadingIndex : trailingIndex;
    const containingFrame = indices.some((idx) => {
      const el = elements[idx];
      return el.frameId && selectedFrames.has(el.frameId);
    }) ? null : elements[boundaryIndex]?.frameId;
    const targetIndex = getTargetIndex(
      appState,
      elements,
      boundaryIndex,
      direction,
      containingFrame
    );
    if (targetIndex === -1 || boundaryIndex === targetIndex) {
      return;
    }
    const leadingElements = direction === "left" ? elements.slice(0, targetIndex) : elements.slice(0, leadingIndex);
    const targetElements = elements.slice(leadingIndex, trailingIndex + 1);
    const displacedElements = direction === "left" ? elements.slice(targetIndex, leadingIndex) : elements.slice(trailingIndex + 1, targetIndex + 1);
    const trailingElements = direction === "left" ? elements.slice(trailingIndex + 1) : elements.slice(targetIndex + 1);
    elements = direction === "left" ? [
      ...leadingElements,
      ...targetElements,
      ...displacedElements,
      ...trailingElements
    ] : [
      ...leadingElements,
      ...displacedElements,
      ...targetElements,
      ...trailingElements
    ];
  });
  return elements.map((element) => {
    if (targetElementsMap[element.id]) {
      return bumpVersion(element);
    }
    return element;
  });
};
var shiftElementsToEnd = (elements, appState, direction, containingFrame, elementsToBeMoved) => {
  const indicesToMove = getIndicesToMove(elements, appState, elementsToBeMoved);
  const targetElementsMap = getTargetElementsMap(elements, indicesToMove);
  const displacedElements = [];
  let leadingIndex;
  let trailingIndex;
  if (direction === "left") {
    if (containingFrame) {
      leadingIndex = findIndex(
        elements,
        (el) => isOfTargetFrame(el, containingFrame)
      );
    } else if (appState.editingGroupId) {
      const groupElements = getElementsInGroup(
        elements,
        appState.editingGroupId
      );
      if (!groupElements.length) {
        return elements;
      }
      leadingIndex = elements.indexOf(groupElements[0]);
    } else {
      leadingIndex = 0;
    }
    trailingIndex = indicesToMove[indicesToMove.length - 1];
  } else {
    if (containingFrame) {
      trailingIndex = findLastIndex(
        elements,
        (el) => isOfTargetFrame(el, containingFrame)
      );
    } else if (appState.editingGroupId) {
      const groupElements = getElementsInGroup(
        elements,
        appState.editingGroupId
      );
      if (!groupElements.length) {
        return elements;
      }
      trailingIndex = elements.indexOf(groupElements[groupElements.length - 1]);
    } else {
      trailingIndex = elements.length - 1;
    }
    leadingIndex = indicesToMove[0];
  }
  if (leadingIndex === -1) {
    leadingIndex = 0;
  }
  for (let index2 = leadingIndex; index2 < trailingIndex + 1; index2++) {
    if (!indicesToMove.includes(index2)) {
      displacedElements.push(elements[index2]);
    }
  }
  const targetElements = Object.values(targetElementsMap).map((element) => {
    return bumpVersion(element);
  });
  const leadingElements = elements.slice(0, leadingIndex);
  const trailingElements = elements.slice(trailingIndex + 1);
  return direction === "left" ? [
    ...leadingElements,
    ...targetElements,
    ...displacedElements,
    ...trailingElements
  ] : [
    ...leadingElements,
    ...displacedElements,
    ...targetElements,
    ...trailingElements
  ];
};
function shiftElementsAccountingForFrames(allElements, appState, direction, shiftFunction) {
  const elementsToMove = arrayToMap(
    getSelectedElements(allElements, appState, {
      includeBoundTextElement: true,
      includeElementsInFrames: true
    })
  );
  const frameAwareContiguousElementsToMove = { regularElements: [], frameChildren: /* @__PURE__ */ new Map() };
  const fullySelectedFrames = /* @__PURE__ */ new Set();
  for (const element of allElements) {
    if (elementsToMove.has(element.id) && isFrameLikeElement(element)) {
      fullySelectedFrames.add(element.id);
    }
  }
  for (const element of allElements) {
    if (elementsToMove.has(element.id)) {
      if (isFrameLikeElement(element) || element.frameId && fullySelectedFrames.has(element.frameId)) {
        frameAwareContiguousElementsToMove.regularElements.push(element);
      } else if (!element.frameId) {
        frameAwareContiguousElementsToMove.regularElements.push(element);
      } else {
        const frameChildren = frameAwareContiguousElementsToMove.frameChildren.get(
          element.frameId
        ) || [];
        frameChildren.push(element);
        frameAwareContiguousElementsToMove.frameChildren.set(
          element.frameId,
          frameChildren
        );
      }
    }
  }
  let nextElements = allElements;
  const frameChildrenSets = Array.from(
    frameAwareContiguousElementsToMove.frameChildren.entries()
  );
  for (const [frameId, children] of frameChildrenSets) {
    nextElements = shiftFunction(
      allElements,
      appState,
      direction,
      frameId,
      children
    );
  }
  return shiftFunction(
    nextElements,
    appState,
    direction,
    null,
    frameAwareContiguousElementsToMove.regularElements
  );
}
var moveOneLeft = (allElements, appState) => {
  return shiftElementsByOne(allElements, appState, "left");
};
var moveOneRight = (allElements, appState) => {
  return shiftElementsByOne(allElements, appState, "right");
};
var moveAllLeft = (allElements, appState) => {
  return shiftElementsAccountingForFrames(
    allElements,
    appState,
    "left",
    shiftElementsToEnd
  );
};
var moveAllRight = (allElements, appState) => {
  return shiftElementsAccountingForFrames(
    allElements,
    appState,
    "right",
    shiftElementsToEnd
  );
};

// actions/actionZindex.tsx
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var actionSendBackward = register({
  name: "sendBackward",
  trackEvent: { category: "element" },
  perform: (elements, appState) => {
    return {
      elements: moveOneLeft(elements, appState),
      appState,
      commitToHistory: true
    };
  },
  contextItemLabel: "labels.sendBackward",
  keyPriority: 40,
  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && !event.shiftKey && event.code === CODES.BRACKET_LEFT,
  PanelComponent: ({ updateData, appState }) => /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
    "button",
    {
      type: "button",
      className: "zIndexButton",
      onClick: () => updateData(null),
      title: `${t("labels.sendBackward")} \u2014 ${getShortcutKey("CtrlOrCmd+[")}`,
      children: SendBackwardIcon
    }
  )
});
var actionBringForward = register({
  name: "bringForward",
  trackEvent: { category: "element" },
  perform: (elements, appState) => {
    return {
      elements: moveOneRight(elements, appState),
      appState,
      commitToHistory: true
    };
  },
  contextItemLabel: "labels.bringForward",
  keyPriority: 40,
  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && !event.shiftKey && event.code === CODES.BRACKET_RIGHT,
  PanelComponent: ({ updateData, appState }) => /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
    "button",
    {
      type: "button",
      className: "zIndexButton",
      onClick: () => updateData(null),
      title: `${t("labels.bringForward")} \u2014 ${getShortcutKey("CtrlOrCmd+]")}`,
      children: BringForwardIcon
    }
  )
});
var actionSendToBack = register({
  name: "sendToBack",
  trackEvent: { category: "element" },
  perform: (elements, appState) => {
    return {
      elements: moveAllLeft(elements, appState),
      appState,
      commitToHistory: true
    };
  },
  contextItemLabel: "labels.sendToBack",
  keyTest: (event) => isDarwin ? event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.BRACKET_LEFT : event[KEYS.CTRL_OR_CMD] && event.shiftKey && event.code === CODES.BRACKET_LEFT,
  PanelComponent: ({ updateData, appState }) => /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
    "button",
    {
      type: "button",
      className: "zIndexButton",
      onClick: () => updateData(null),
      title: `${t("labels.sendToBack")} \u2014 ${isDarwin ? getShortcutKey("CtrlOrCmd+Alt+[") : getShortcutKey("CtrlOrCmd+Shift+[")}`,
      children: SendToBackIcon
    }
  )
});
var actionBringToFront = register({
  name: "bringToFront",
  trackEvent: { category: "element" },
  perform: (elements, appState) => {
    return {
      elements: moveAllRight(elements, appState),
      appState,
      commitToHistory: true
    };
  },
  contextItemLabel: "labels.bringToFront",
  keyTest: (event) => isDarwin ? event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.BRACKET_RIGHT : event[KEYS.CTRL_OR_CMD] && event.shiftKey && event.code === CODES.BRACKET_RIGHT,
  PanelComponent: ({ updateData, appState }) => /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
    "button",
    {
      type: "button",
      className: "zIndexButton",
      onClick: (event) => updateData(null),
      title: `${t("labels.bringToFront")} \u2014 ${isDarwin ? getShortcutKey("CtrlOrCmd+Alt+]") : getShortcutKey("CtrlOrCmd+Shift+]")}`,
      children: BringToFrontIcon
    }
  )
});

// actions/actionSelectAll.ts
init_define_import_meta_env();
var actionSelectAll = register({
  name: "selectAll",
  trackEvent: { category: "canvas" },
  perform: (elements, appState, value, app) => {
    if (appState.editingLinearElement) {
      return false;
    }
    const selectedElementIds = excludeElementsInFramesFromSelection(
      elements.filter(
        (element) => !element.isDeleted && !(isTextElement(element) && element.containerId) && !element.locked
      )
    ).reduce((map, element) => {
      map[element.id] = true;
      return map;
    }, {});
    return {
      appState: {
        ...appState,
        ...selectGroupsForSelectedElements(
          {
            editingGroupId: null,
            selectedElementIds
          },
          getNonDeletedElements2(elements),
          appState,
          app
        ),
        selectedLinearElement: (
          // single linear element selected
          Object.keys(selectedElementIds).length === 1 && isLinearElement(elements[0]) ? new LinearElementEditor(elements[0]) : null
        )
      },
      commitToHistory: true
    };
  },
  contextItemLabel: "labels.selectAll",
  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.key === KEYS.A
});

// actions/actionDuplicateSelection.tsx
init_define_import_meta_env();

// element/sortElements.ts
init_define_import_meta_env();
var normalizeGroupElementOrder = (elements) => {
  const origElements = elements.slice();
  const sortedElements = /* @__PURE__ */ new Set();
  const orderInnerGroups = (elements2) => {
    const firstGroupSig = elements2[0]?.groupIds?.join("");
    const aGroup = [elements2[0]];
    const bGroup = [];
    for (const element of elements2.slice(1)) {
      if (element.groupIds?.join("") === firstGroupSig) {
        aGroup.push(element);
      } else {
        bGroup.push(element);
      }
    }
    return bGroup.length ? [...aGroup, ...orderInnerGroups(bGroup)] : aGroup;
  };
  const groupHandledElements = /* @__PURE__ */ new Map();
  origElements.forEach((element, idx) => {
    if (groupHandledElements.has(element.id)) {
      return;
    }
    if (element.groupIds?.length) {
      const topGroup = element.groupIds[element.groupIds.length - 1];
      const groupElements = origElements.slice(idx).filter((element2) => {
        const ret = element2?.groupIds?.some((id) => id === topGroup);
        if (ret) {
          groupHandledElements.set(element2.id, true);
        }
        return ret;
      });
      for (const elem of orderInnerGroups(groupElements)) {
        sortedElements.add(elem);
      }
    } else {
      sortedElements.add(element);
    }
  });
  if (sortedElements.size !== elements.length) {
    console.error("normalizeGroupElementOrder: lost some elements... bailing!");
    return elements;
  }
  return [...sortedElements];
};
var normalizeBoundElementsOrder = (elements) => {
  const elementsMap = arrayToMapWithIndex(elements);
  const origElements = elements.slice();
  const sortedElements = /* @__PURE__ */ new Set();
  origElements.forEach((element, idx) => {
    if (!element) {
      return;
    }
    if (element.boundElements?.length) {
      sortedElements.add(element);
      origElements[idx] = null;
      element.boundElements.forEach((boundElement) => {
        const child = elementsMap.get(boundElement.id);
        if (child && boundElement.type === "text") {
          sortedElements.add(child[0]);
          origElements[child[1]] = null;
        }
      });
    } else if (element.type === "text" && element.containerId) {
      const parent = elementsMap.get(element.containerId);
      if (!parent?.[0].boundElements?.find((x3) => x3.id === element.id)) {
        sortedElements.add(element);
        origElements[idx] = null;
      }
    } else {
      sortedElements.add(element);
      origElements[idx] = null;
    }
  });
  if (sortedElements.size !== elements.length) {
    console.error(
      "normalizeBoundElementsOrder: lost some elements... bailing!"
    );
    return elements;
  }
  return [...sortedElements];
};
var normalizeElementOrder = (elements) => {
  const ret = normalizeBoundElementsOrder(normalizeGroupElementOrder(elements));
  return ret;
};

// actions/actionDuplicateSelection.tsx
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var actionDuplicateSelection = register({
  name: "duplicateSelection",
  trackEvent: { category: "element" },
  perform: (elements, appState, formData, app) => {
    const elementsMap = app.scene.getNonDeletedElementsMap();
    if (appState.editingLinearElement) {
      const ret = LinearElementEditor.duplicateSelectedPoints(
        appState,
        elementsMap
      );
      if (!ret) {
        return false;
      }
      return {
        elements,
        appState: ret.appState,
        commitToHistory: true
      };
    }
    return {
      ...duplicateElements2(elements, appState),
      commitToHistory: true
    };
  },
  contextItemLabel: "labels.duplicateSelection",
  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.key === KEYS.D,
  PanelComponent: ({ elements, appState, updateData }) => /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
    ToolButton,
    {
      type: "button",
      icon: DuplicateIcon,
      title: `${t("labels.duplicateSelection")} \u2014 ${getShortcutKey(
        "CtrlOrCmd+D"
      )}`,
      "aria-label": t("labels.duplicateSelection"),
      onClick: () => updateData(null),
      visible: isSomeElementSelected(getNonDeletedElements2(elements), appState)
    }
  )
});
var duplicateElements2 = (elements, appState) => {
  const sortedElements = normalizeElementOrder(elements);
  const groupIdMap = /* @__PURE__ */ new Map();
  const newElements = [];
  const oldElements = [];
  const oldIdToDuplicatedId = /* @__PURE__ */ new Map();
  const duplicateAndOffsetElement = (element) => {
    const newElement2 = duplicateElement(
      appState.editingGroupId,
      groupIdMap,
      element,
      {
        x: element.x + GRID_SIZE / 2,
        y: element.y + GRID_SIZE / 2
      }
    );
    oldIdToDuplicatedId.set(element.id, newElement2.id);
    oldElements.push(element);
    newElements.push(newElement2);
    return newElement2;
  };
  const idsOfElementsToDuplicate = arrayToMap(
    getSelectedElements(sortedElements, appState, {
      includeBoundTextElement: true,
      includeElementsInFrames: true
    })
  );
  const processedIds = /* @__PURE__ */ new Map();
  const markAsProcessed = (elements2) => {
    for (const element of elements2) {
      processedIds.set(element.id, true);
    }
    return elements2;
  };
  const elementsWithClones = [];
  let index2 = -1;
  while (++index2 < sortedElements.length) {
    const element = sortedElements[index2];
    if (processedIds.get(element.id)) {
      continue;
    }
    const boundTextElement = getBoundTextElement(element, arrayToMap(elements));
    const isElementAFrameLike = isFrameLikeElement(element);
    if (idsOfElementsToDuplicate.get(element.id)) {
      if (element.groupIds.length || boundTextElement || isElementAFrameLike) {
        const groupId = getSelectedGroupForElement(appState, element);
        if (groupId) {
          const groupElements = getElementsInGroup(
            sortedElements,
            groupId
          ).flatMap(
            (element2) => isFrameLikeElement(element2) ? [...getFrameChildren(elements, element2.id), element2] : [element2]
          );
          elementsWithClones.push(
            ...markAsProcessed([
              ...groupElements,
              ...groupElements.map(
                (element2) => duplicateAndOffsetElement(element2)
              )
            ])
          );
          continue;
        }
        if (boundTextElement) {
          elementsWithClones.push(
            ...markAsProcessed([
              element,
              boundTextElement,
              duplicateAndOffsetElement(element),
              duplicateAndOffsetElement(boundTextElement)
            ])
          );
          continue;
        }
        if (isElementAFrameLike) {
          const elementsInFrame = getFrameChildren(sortedElements, element.id);
          elementsWithClones.push(
            ...markAsProcessed([
              ...elementsInFrame,
              element,
              ...elementsInFrame.map((e3) => duplicateAndOffsetElement(e3)),
              duplicateAndOffsetElement(element)
            ])
          );
          continue;
        }
      }
      if (!element.frameId || !idsOfElementsToDuplicate.has(element.frameId)) {
        elementsWithClones.push(
          ...markAsProcessed([element, duplicateAndOffsetElement(element)])
        );
      }
    } else {
      elementsWithClones.push(...markAsProcessed([element]));
    }
  }
  const finalElementsReversed = [];
  const finalElementIds = /* @__PURE__ */ new Map();
  index2 = elementsWithClones.length;
  while (--index2 >= 0) {
    const element = elementsWithClones[index2];
    if (!finalElementIds.get(element.id)) {
      finalElementIds.set(element.id, true);
      finalElementsReversed.push(element);
    }
  }
  const finalElements = finalElementsReversed.reverse();
  bindTextToShapeAfterDuplication(
    elementsWithClones,
    oldElements,
    oldIdToDuplicatedId
  );
  fixBindingsAfterDuplication(
    elementsWithClones,
    oldElements,
    oldIdToDuplicatedId
  );
  bindElementsToFramesAfterDuplication(
    finalElements,
    oldElements,
    oldIdToDuplicatedId
  );
  const nextElementsToSelect = excludeElementsInFramesFromSelection(newElements);
  return {
    elements: finalElements,
    appState: {
      ...appState,
      ...selectGroupsForSelectedElements(
        {
          editingGroupId: appState.editingGroupId,
          selectedElementIds: nextElementsToSelect.reduce(
            (acc, element) => {
              if (!isBoundToContainer(element)) {
                acc[element.id] = true;
              }
              return acc;
            },
            {}
          )
        },
        getNonDeletedElements2(finalElements),
        appState,
        null
      )
    }
  };
};

// actions/actionProperties.tsx
init_define_import_meta_env();

// analytics.ts
init_define_import_meta_env();
var ALLOWED_CATEGORIES_TO_TRACK = ["ai"];
var trackEvent = (category, action, label, value) => {
  try {
    if (typeof window === "undefined" || define_import_meta_env_default.VITE_WORKER_ID || define_import_meta_env_default.PROD) {
      return;
    }
    if (!ALLOWED_CATEGORIES_TO_TRACK.includes(category)) {
      return;
    }
    if (!define_import_meta_env_default.PROD) {
      console.info("trackEvent", { category, action, label, value });
    }
    if (window.sa_event) {
      window.sa_event(action, {
        category,
        label,
        value
      });
    }
  } catch (error) {
    console.error("error during analytics", error);
  }
};

// components/ButtonIconSelect.tsx
init_define_import_meta_env();
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var ButtonIconSelect = (props) => /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { className: "buttonList buttonListIcon", children: props.options.map(
  (option) => props.type === "button" ? /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
    "button",
    {
      onClick: (event) => props.onClick(option.value, event),
      className: clsx_m_default({
        active: option.active ?? props.value === option.value
      }),
      "data-testid": option.testId,
      title: option.text,
      children: option.icon
    },
    option.text
  ) : /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(
    "label",
    {
      className: clsx_m_default({ active: props.value === option.value }),
      title: option.text,
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
          "input",
          {
            type: "radio",
            name: props.group,
            onChange: () => props.onChange(option.value),
            checked: props.value === option.value,
            "data-testid": option.testId
          }
        ),
        option.icon
      ]
    },
    option.text
  )
) });

// components/ColorPicker/ColorPicker.tsx
init_define_import_meta_env();

// components/ColorPicker/TopPicks.tsx
init_define_import_meta_env();
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var TopPicks = ({
  onChange,
  type,
  activeColor,
  topPicks
}) => {
  let colors;
  if (type === "elementStroke") {
    colors = DEFAULT_ELEMENT_STROKE_PICKS;
  }
  if (type === "elementBackground") {
    colors = DEFAULT_ELEMENT_BACKGROUND_PICKS;
  }
  if (type === "canvasBackground") {
    colors = DEFAULT_CANVAS_BACKGROUND_PICKS;
  }
  if (topPicks) {
    colors = topPicks;
  }
  if (!colors) {
    console.error("Invalid type for TopPicks");
    return null;
  }
  return /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("div", { className: "color-picker__top-picks", children: colors.map((color) => /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
    "button",
    {
      className: clsx_m_default("color-picker__button", {
        active: color === activeColor,
        "is-transparent": color === "transparent" || !color
      }),
      style: { "--swatch-color": color },
      type: "button",
      title: color,
      onClick: () => onChange(color),
      "data-testid": `color-top-pick-${color}`,
      children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("div", { className: "color-picker__button-outline" })
    },
    color
  )) });
};

// components/ColorPicker/Picker.tsx
init_define_import_meta_env();
var import_react7 = __toESM(require_react(), 1);

// components/ColorPicker/ShadeList.tsx
init_define_import_meta_env();
var import_react4 = __toESM(require_react(), 1);

// components/ColorPicker/colorPickerUtils.ts
init_define_import_meta_env();
var getColorNameAndShadeFromColor = ({
  palette: palette2,
  color
}) => {
  for (const [colorName, colorVal] of Object.entries(palette2)) {
    if (Array.isArray(colorVal)) {
      const shade = colorVal.indexOf(color);
      if (shade > -1) {
        return { colorName, shade };
      }
    } else if (colorVal === color) {
      return { colorName, shade: null };
    }
  }
  return null;
};
var colorPickerHotkeyBindings = [
  ["q", "w", "e", "r", "t"],
  ["a", "s", "d", "f", "g"],
  ["z", "x", "c", "v", "b"]
].flat();
var isCustomColor = ({
  color,
  palette: palette2
}) => {
  const paletteValues = Object.values(palette2).flat();
  return !paletteValues.includes(color);
};
var getMostUsedCustomColors = (elements, type, palette2) => {
  const elementColorTypeMap = {
    elementBackground: "backgroundColor",
    elementStroke: "strokeColor"
  };
  const colors = elements.filter((element) => {
    if (element.isDeleted) {
      return false;
    }
    const color = element[elementColorTypeMap[type]];
    return isCustomColor({ color, palette: palette2 });
  });
  const colorCountMap = /* @__PURE__ */ new Map();
  colors.forEach((element) => {
    const color = element[elementColorTypeMap[type]];
    if (colorCountMap.has(color)) {
      colorCountMap.set(color, colorCountMap.get(color) + 1);
    } else {
      colorCountMap.set(color, 1);
    }
  });
  return [...colorCountMap.entries()].sort((a4, b4) => b4[1] - a4[1]).map((c3) => c3[0]).slice(0, MAX_CUSTOM_COLORS_USED_IN_CANVAS);
};
var activeColorPickerSectionAtom = atom2(null);
var calculateContrast = (r3, g3, b4) => {
  const yiq = (r3 * 299 + g3 * 587 + b4 * 114) / 1e3;
  return yiq >= 160 ? "black" : "white";
};
var getContrastYIQ = (bgHex, isCustomColor2) => {
  if (isCustomColor2) {
    const style = new Option().style;
    style.color = bgHex;
    if (style.color) {
      const rgb = style.color.replace(/^(rgb|rgba)\(/, "").replace(/\)$/, "").replace(/\s/g, "").split(",");
      const r4 = parseInt(rgb[0]);
      const g4 = parseInt(rgb[1]);
      const b5 = parseInt(rgb[2]);
      return calculateContrast(r4, g4, b5);
    }
  }
  if (bgHex === "transparent") {
    return "black";
  }
  const r3 = parseInt(bgHex.substring(1, 3), 16);
  const g3 = parseInt(bgHex.substring(3, 5), 16);
  const b4 = parseInt(bgHex.substring(5, 7), 16);
  return calculateContrast(r3, g3, b4);
};

// components/ColorPicker/HotkeyLabel.tsx
init_define_import_meta_env();
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var HotkeyLabel = ({
  color,
  keyLabel,
  isCustomColor: isCustomColor2 = false,
  isShade = false
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(
    "div",
    {
      className: "color-picker__button__hotkey-label",
      style: {
        color: getContrastYIQ(color, isCustomColor2)
      },
      children: [
        isShade && "\u21E7",
        keyLabel
      ]
    }
  );
};
var HotkeyLabel_default = HotkeyLabel;

// components/ColorPicker/ShadeList.tsx
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var ShadeList = ({ hex, onChange, palette: palette2 }) => {
  const colorObj = getColorNameAndShadeFromColor({
    color: hex || "transparent",
    palette: palette2
  });
  const [activeColorPickerSection, setActiveColorPickerSection] = useAtom(
    activeColorPickerSectionAtom
  );
  const btnRef = (0, import_react4.useRef)(null);
  (0, import_react4.useEffect)(() => {
    if (btnRef.current && activeColorPickerSection === "shades") {
      btnRef.current.focus();
    }
  }, [colorObj, activeColorPickerSection]);
  if (colorObj) {
    const { colorName, shade } = colorObj;
    const shades = palette2[colorName];
    if (Array.isArray(shades)) {
      return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: "color-picker-content--default shades", children: shades.map((color, i4) => /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(
        "button",
        {
          ref: i4 === shade && activeColorPickerSection === "shades" ? btnRef : void 0,
          tabIndex: -1,
          type: "button",
          className: clsx_m_default(
            "color-picker__button color-picker__button--large",
            { active: i4 === shade }
          ),
          "aria-label": "Shade",
          title: `${colorName} - ${i4 + 1}`,
          style: color ? { "--swatch-color": color } : void 0,
          onClick: () => {
            onChange(color);
            setActiveColorPickerSection("shades");
          },
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: "color-picker__button-outline" }),
            /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(HotkeyLabel_default, { color, keyLabel: i4 + 1, isShade: true })
          ]
        },
        i4
      )) });
    }
  }
  return /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(
    "div",
    {
      className: "color-picker-content--default",
      style: { position: "relative" },
      tabIndex: -1,
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
          "button",
          {
            type: "button",
            tabIndex: -1,
            className: "color-picker__button color-picker__button--large color-picker__button--no-focus-visible"
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
          "div",
          {
            tabIndex: -1,
            style: {
              position: "absolute",
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              textAlign: "center",
              fontSize: "0.75rem"
            },
            children: t("colorPicker.noShades")
          }
        )
      ]
    }
  );
};

// components/ColorPicker/PickerColorList.tsx
init_define_import_meta_env();
var import_react5 = __toESM(require_react(), 1);
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var PickerColorList = ({
  palette: palette2,
  color,
  onChange,
  label,
  activeShade
}) => {
  const colorObj = getColorNameAndShadeFromColor({
    color: color || "transparent",
    palette: palette2
  });
  const [activeColorPickerSection, setActiveColorPickerSection] = useAtom(
    activeColorPickerSectionAtom
  );
  const btnRef = (0, import_react5.useRef)(null);
  (0, import_react5.useEffect)(() => {
    if (btnRef.current && activeColorPickerSection === "baseColors") {
      btnRef.current.focus();
    }
  }, [colorObj?.colorName, activeColorPickerSection]);
  return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { className: "color-picker-content--default", children: Object.entries(palette2).map(([key, value], index2) => {
    const color2 = (Array.isArray(value) ? value[activeShade] : value) || "transparent";
    const keybinding = colorPickerHotkeyBindings[index2];
    const label2 = t(
      `colors.${key.replace(/\d+/, "")}`,
      null,
      ""
    );
    return /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)(
      "button",
      {
        ref: colorObj?.colorName === key ? btnRef : void 0,
        tabIndex: -1,
        type: "button",
        className: clsx_m_default(
          "color-picker__button color-picker__button--large",
          {
            active: colorObj?.colorName === key,
            "is-transparent": color2 === "transparent" || !color2
          }
        ),
        onClick: () => {
          onChange(color2);
          setActiveColorPickerSection("baseColors");
        },
        title: `${label2}${color2.startsWith("#") ? ` ${color2}` : ""} \u2014 ${keybinding}`,
        "aria-label": `${label2} \u2014 ${keybinding}`,
        style: color2 ? { "--swatch-color": color2 } : void 0,
        "data-testid": `color-${key}`,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { className: "color-picker__button-outline" }),
          /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(HotkeyLabel_default, { color: color2, keyLabel: keybinding })
        ]
      },
      key
    );
  }) });
};
var PickerColorList_default = PickerColorList;

// components/ColorPicker/CustomColorList.tsx
init_define_import_meta_env();
var import_react6 = __toESM(require_react(), 1);
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var CustomColorList = ({
  colors,
  color,
  onChange,
  label
}) => {
  const [activeColorPickerSection, setActiveColorPickerSection] = useAtom(
    activeColorPickerSectionAtom
  );
  const btnRef = (0, import_react6.useRef)(null);
  (0, import_react6.useEffect)(() => {
    if (btnRef.current) {
      btnRef.current.focus();
    }
  }, [color, activeColorPickerSection]);
  return /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("div", { className: "color-picker-content--default", children: colors.map((c3, i4) => {
    return /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)(
      "button",
      {
        ref: color === c3 ? btnRef : void 0,
        tabIndex: -1,
        type: "button",
        className: clsx_m_default(
          "color-picker__button color-picker__button--large",
          {
            active: color === c3,
            "is-transparent": c3 === "transparent" || !c3
          }
        ),
        onClick: () => {
          onChange(c3);
          setActiveColorPickerSection("custom");
        },
        title: c3,
        "aria-label": label,
        style: { "--swatch-color": c3 },
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("div", { className: "color-picker__button-outline" }),
          /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(HotkeyLabel_default, { color: c3, keyLabel: i4 + 1, isCustomColor: true })
        ]
      },
      i4
    );
  }) });
};

// components/ColorPicker/keyboardNavHandlers.ts
init_define_import_meta_env();
var arrowHandler = (eventKey, currentIndex, length) => {
  const rows = Math.ceil(length / COLORS_PER_ROW);
  currentIndex = currentIndex ?? -1;
  switch (eventKey) {
    case "ArrowLeft": {
      const prevIndex = currentIndex - 1;
      return prevIndex < 0 ? length - 1 : prevIndex;
    }
    case "ArrowRight": {
      return (currentIndex + 1) % length;
    }
    case "ArrowDown": {
      const nextIndex = currentIndex + COLORS_PER_ROW;
      return nextIndex >= length ? currentIndex % COLORS_PER_ROW : nextIndex;
    }
    case "ArrowUp": {
      const prevIndex = currentIndex - COLORS_PER_ROW;
      const newIndex = prevIndex < 0 ? COLORS_PER_ROW * rows + prevIndex : prevIndex;
      return newIndex >= length ? void 0 : newIndex;
    }
  }
};
var hotkeyHandler = ({
  e: e3,
  colorObj,
  onChange,
  palette: palette2,
  customColors,
  setActiveColorPickerSection,
  activeShade
}) => {
  if (colorObj?.shade != null) {
    if (["Digit1", "Digit2", "Digit3", "Digit4", "Digit5"].includes(e3.code) && e3.shiftKey) {
      const newShade = Number(e3.code.slice(-1)) - 1;
      onChange(palette2[colorObj.colorName][newShade]);
      setActiveColorPickerSection("shades");
      return true;
    }
  }
  if (["1", "2", "3", "4", "5"].includes(e3.key)) {
    const c3 = customColors[Number(e3.key) - 1];
    if (c3) {
      onChange(customColors[Number(e3.key) - 1]);
      setActiveColorPickerSection("custom");
      return true;
    }
  }
  if (colorPickerHotkeyBindings.includes(e3.key)) {
    const index2 = colorPickerHotkeyBindings.indexOf(e3.key);
    const paletteKey = Object.keys(palette2)[index2];
    const paletteValue = palette2[paletteKey];
    const r3 = Array.isArray(paletteValue) ? paletteValue[activeShade] : paletteValue;
    onChange(r3);
    setActiveColorPickerSection("baseColors");
    return true;
  }
  return false;
};
var colorPickerKeyNavHandler = ({
  event,
  activeColorPickerSection,
  palette: palette2,
  color,
  onChange,
  customColors,
  setActiveColorPickerSection,
  updateData,
  activeShade,
  onEyeDropperToggle,
  onEscape
}) => {
  if (event[KEYS.CTRL_OR_CMD]) {
    return false;
  }
  if (event.key === KEYS.ESCAPE) {
    onEscape(event);
    return true;
  }
  if (event.key === KEYS.ALT) {
    onEyeDropperToggle(true);
    return true;
  }
  if (event.key === KEYS.I) {
    onEyeDropperToggle();
    return true;
  }
  const colorObj = getColorNameAndShadeFromColor({ color, palette: palette2 });
  if (event.key === KEYS.TAB) {
    const sectionsMap = {
      custom: !!customColors.length,
      baseColors: true,
      shades: colorObj?.shade != null,
      hex: true
    };
    const sections = Object.entries(sectionsMap).reduce((acc, [key, value]) => {
      if (value) {
        acc.push(key);
      }
      return acc;
    }, []);
    const activeSectionIndex = sections.indexOf(activeColorPickerSection);
    const indexOffset = event.shiftKey ? -1 : 1;
    const nextSectionIndex = activeSectionIndex + indexOffset > sections.length - 1 ? 0 : activeSectionIndex + indexOffset < 0 ? sections.length - 1 : activeSectionIndex + indexOffset;
    const nextSection = sections[nextSectionIndex];
    if (nextSection) {
      setActiveColorPickerSection(nextSection);
    }
    if (nextSection === "custom") {
      onChange(customColors[0]);
    } else if (nextSection === "baseColors") {
      const baseColorName = Object.entries(palette2).find(([name, shades]) => {
        if (Array.isArray(shades)) {
          return shades.includes(color);
        } else if (shades === color) {
          return name;
        }
        return null;
      });
      if (!baseColorName) {
        onChange(COLOR_PALETTE.black);
      }
    }
    event.preventDefault();
    event.stopPropagation();
    return true;
  }
  if (hotkeyHandler({
    e: event,
    colorObj,
    onChange,
    palette: palette2,
    customColors,
    setActiveColorPickerSection,
    activeShade
  })) {
    return true;
  }
  if (activeColorPickerSection === "shades") {
    if (colorObj) {
      const { shade } = colorObj;
      const newShade = arrowHandler(event.key, shade, COLORS_PER_ROW);
      if (newShade !== void 0) {
        onChange(palette2[colorObj.colorName][newShade]);
        return true;
      }
    }
  }
  if (activeColorPickerSection === "baseColors") {
    if (colorObj) {
      const { colorName } = colorObj;
      const colorNames = Object.keys(palette2);
      const indexOfColorName = colorNames.indexOf(colorName);
      const newColorIndex = arrowHandler(
        event.key,
        indexOfColorName,
        colorNames.length
      );
      if (newColorIndex !== void 0) {
        const newColorName = colorNames[newColorIndex];
        const newColorNameValue = palette2[newColorName];
        onChange(
          Array.isArray(newColorNameValue) ? newColorNameValue[activeShade] : newColorNameValue
        );
        return true;
      }
    }
  }
  if (activeColorPickerSection === "custom") {
    const indexOfColor = customColors.indexOf(color);
    const newColorIndex = arrowHandler(
      event.key,
      indexOfColor,
      customColors.length
    );
    if (newColorIndex !== void 0) {
      const newColor = customColors[newColorIndex];
      onChange(newColor);
      return true;
    }
  }
  return false;
};

// components/ColorPicker/PickerHeading.tsx
init_define_import_meta_env();
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
var PickerHeading = ({ children }) => /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("div", { className: "color-picker__heading", children });
var PickerHeading_default = PickerHeading;

// components/ColorPicker/Picker.tsx
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
var Picker = ({
  color,
  onChange,
  label,
  type,
  elements,
  palette: palette2,
  updateData,
  children,
  onEyeDropperToggle,
  onEscape
}) => {
  const [customColors] = import_react7.default.useState(() => {
    if (type === "canvasBackground") {
      return [];
    }
    return getMostUsedCustomColors(elements, type, palette2);
  });
  const [activeColorPickerSection, setActiveColorPickerSection] = useAtom(
    activeColorPickerSectionAtom
  );
  const colorObj = getColorNameAndShadeFromColor({
    color,
    palette: palette2
  });
  (0, import_react7.useEffect)(() => {
    if (!activeColorPickerSection) {
      const isCustom = isCustomColor({ color, palette: palette2 });
      const isCustomButNotInList = isCustom && !customColors.includes(color);
      setActiveColorPickerSection(
        isCustomButNotInList ? "hex" : isCustom ? "custom" : colorObj?.shade != null ? "shades" : "baseColors"
      );
    }
  }, [
    activeColorPickerSection,
    color,
    palette2,
    setActiveColorPickerSection,
    colorObj,
    customColors
  ]);
  const [activeShade, setActiveShade] = (0, import_react7.useState)(
    colorObj?.shade ?? (type === "elementBackground" ? DEFAULT_ELEMENT_BACKGROUND_COLOR_INDEX : DEFAULT_ELEMENT_STROKE_COLOR_INDEX)
  );
  (0, import_react7.useEffect)(() => {
    if (colorObj?.shade != null) {
      setActiveShade(colorObj.shade);
    }
    const keyup = (event) => {
      if (event.key === KEYS.ALT) {
        onEyeDropperToggle(false);
      }
    };
    document.addEventListener("keyup" /* KEYUP */, keyup, { capture: true });
    return () => {
      document.removeEventListener("keyup" /* KEYUP */, keyup, { capture: true });
    };
  }, [colorObj, onEyeDropperToggle]);
  const pickerRef = import_react7.default.useRef(null);
  return /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("div", { role: "dialog", "aria-modal": "true", "aria-label": t("labels.colorPicker"), children: /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)(
    "div",
    {
      ref: pickerRef,
      onKeyDown: (event) => {
        const handled = colorPickerKeyNavHandler({
          event,
          activeColorPickerSection,
          palette: palette2,
          color,
          onChange,
          onEyeDropperToggle,
          customColors,
          setActiveColorPickerSection,
          updateData,
          activeShade,
          onEscape
        });
        if (handled) {
          event.preventDefault();
          event.stopPropagation();
        }
      },
      className: "color-picker-content",
      tabIndex: -1,
      children: [
        !!customColors.length && /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)("div", { children: [
          /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(PickerHeading_default, { children: t("colorPicker.mostUsedCustomColors") }),
          /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(
            CustomColorList,
            {
              colors: customColors,
              color,
              label: t("colorPicker.mostUsedCustomColors"),
              onChange
            }
          )
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)("div", { children: [
          /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(PickerHeading_default, { children: t("colorPicker.colors") }),
          /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(
            PickerColorList_default,
            {
              color,
              label,
              palette: palette2,
              onChange,
              activeShade
            }
          )
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)("div", { children: [
          /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(PickerHeading_default, { children: t("colorPicker.shades") }),
          /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(ShadeList, { hex: color, onChange, palette: palette2 })
        ] }),
        children
      ]
    }
  ) });
};

// ../../node_modules/@radix-ui/react-popover/dist/index.module.js
init_define_import_meta_env();

// ../../node_modules/@babel/runtime/helpers/esm/extends.js
init_define_import_meta_env();
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i4 = 1; i4 < arguments.length; i4++) {
      var source = arguments[i4];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

// ../../node_modules/@radix-ui/react-popover/dist/index.module.js
var import_react26 = __toESM(require_react());

// ../../node_modules/@radix-ui/primitive/dist/index.module.js
init_define_import_meta_env();
function $e42e1063c40fb3ef$export$b9ecd428b558ff10(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler === null || originalEventHandler === void 0 || originalEventHandler(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented)
      return ourEventHandler === null || ourEventHandler === void 0 ? void 0 : ourEventHandler(event);
  };
}

// ../../node_modules/@radix-ui/react-compose-refs/dist/index.module.js
init_define_import_meta_env();
var import_react8 = __toESM(require_react());
function $6ed0406888f73fc4$var$setRef(ref, value) {
  if (typeof ref === "function")
    ref(value);
  else if (ref !== null && ref !== void 0)
    ref.current = value;
}
function $6ed0406888f73fc4$export$43e446d32b3d21af(...refs) {
  return (node) => refs.forEach(
    (ref) => $6ed0406888f73fc4$var$setRef(ref, node)
  );
}
function $6ed0406888f73fc4$export$c7b2cbe3552a0d05(...refs) {
  return (0, import_react8.useCallback)($6ed0406888f73fc4$export$43e446d32b3d21af(...refs), refs);
}

// ../../node_modules/@radix-ui/react-context/dist/index.module.js
init_define_import_meta_env();
var import_react9 = __toESM(require_react());
function $c512c27ab02ef895$export$50c7b4e9d9f19c1(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function $c512c27ab02ef895$export$fd42f52fd3ae1109(rootComponentName, defaultContext) {
    const BaseContext = /* @__PURE__ */ (0, import_react9.createContext)(defaultContext);
    const index2 = defaultContexts.length;
    defaultContexts = [
      ...defaultContexts,
      defaultContext
    ];
    function Provider2(props) {
      const { scope, children, ...context } = props;
      const Context = (scope === null || scope === void 0 ? void 0 : scope[scopeName][index2]) || BaseContext;
      const value = (0, import_react9.useMemo)(
        () => context,
        Object.values(context)
      );
      return /* @__PURE__ */ (0, import_react9.createElement)(Context.Provider, {
        value
      }, children);
    }
    function useContext5(consumerName, scope) {
      const Context = (scope === null || scope === void 0 ? void 0 : scope[scopeName][index2]) || BaseContext;
      const context = (0, import_react9.useContext)(Context);
      if (context)
        return context;
      if (defaultContext !== void 0)
        return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    Provider2.displayName = rootComponentName + "Provider";
    return [
      Provider2,
      useContext5
    ];
  }
  const createScope = () => {
    const scopeContexts = defaultContexts.map((defaultContext) => {
      return /* @__PURE__ */ (0, import_react9.createContext)(defaultContext);
    });
    return function useScope(scope) {
      const contexts = (scope === null || scope === void 0 ? void 0 : scope[scopeName]) || scopeContexts;
      return (0, import_react9.useMemo)(
        () => ({
          [`__scope${scopeName}`]: {
            ...scope,
            [scopeName]: contexts
          }
        }),
        [
          scope,
          contexts
        ]
      );
    };
  };
  createScope.scopeName = scopeName;
  return [
    $c512c27ab02ef895$export$fd42f52fd3ae1109,
    $c512c27ab02ef895$var$composeContextScopes(createScope, ...createContextScopeDeps)
  ];
}
function $c512c27ab02ef895$var$composeContextScopes(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1)
    return baseScope;
  const createScope1 = () => {
    const scopeHooks = scopes.map(
      (createScope) => ({
        useScope: createScope(),
        scopeName: createScope.scopeName
      })
    );
    return function useComposedScopes(overrideScopes) {
      const nextScopes1 = scopeHooks.reduce((nextScopes, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return {
          ...nextScopes,
          ...currentScope
        };
      }, {});
      return (0, import_react9.useMemo)(
        () => ({
          [`__scope${baseScope.scopeName}`]: nextScopes1
        }),
        [
          nextScopes1
        ]
      );
    };
  };
  createScope1.scopeName = baseScope.scopeName;
  return createScope1;
}

// ../../node_modules/@radix-ui/react-dismissable-layer/dist/index.module.js
init_define_import_meta_env();
var import_react14 = __toESM(require_react());

// ../../node_modules/@radix-ui/react-primitive/dist/index.module.js
init_define_import_meta_env();
var import_react11 = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());

// ../../node_modules/@radix-ui/react-slot/dist/index.module.js
init_define_import_meta_env();
var import_react10 = __toESM(require_react());
var $5e63c961fc1ce211$export$8c6ed5c666ac1360 = /* @__PURE__ */ (0, import_react10.forwardRef)((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  const childrenArray = import_react10.Children.toArray(children);
  const slottable = childrenArray.find($5e63c961fc1ce211$var$isSlottable);
  if (slottable) {
    const newElement2 = slottable.props.children;
    const newChildren = childrenArray.map((child) => {
      if (child === slottable) {
        if (import_react10.Children.count(newElement2) > 1)
          return import_react10.Children.only(null);
        return /* @__PURE__ */ (0, import_react10.isValidElement)(newElement2) ? newElement2.props.children : null;
      } else
        return child;
    });
    return /* @__PURE__ */ (0, import_react10.createElement)($5e63c961fc1ce211$var$SlotClone, _extends({}, slotProps, {
      ref: forwardedRef
    }), /* @__PURE__ */ (0, import_react10.isValidElement)(newElement2) ? /* @__PURE__ */ (0, import_react10.cloneElement)(newElement2, void 0, newChildren) : null);
  }
  return /* @__PURE__ */ (0, import_react10.createElement)($5e63c961fc1ce211$var$SlotClone, _extends({}, slotProps, {
    ref: forwardedRef
  }), children);
});
$5e63c961fc1ce211$export$8c6ed5c666ac1360.displayName = "Slot";
var $5e63c961fc1ce211$var$SlotClone = /* @__PURE__ */ (0, import_react10.forwardRef)((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  if (/* @__PURE__ */ (0, import_react10.isValidElement)(children))
    return /* @__PURE__ */ (0, import_react10.cloneElement)(children, {
      ...$5e63c961fc1ce211$var$mergeProps(slotProps, children.props),
      ref: $6ed0406888f73fc4$export$43e446d32b3d21af(forwardedRef, children.ref)
    });
  return import_react10.Children.count(children) > 1 ? import_react10.Children.only(null) : null;
});
$5e63c961fc1ce211$var$SlotClone.displayName = "SlotClone";
var $5e63c961fc1ce211$export$d9f1ccf0bdb05d45 = ({ children }) => {
  return /* @__PURE__ */ (0, import_react10.createElement)(import_react10.Fragment, null, children);
};
function $5e63c961fc1ce211$var$isSlottable(child) {
  return /* @__PURE__ */ (0, import_react10.isValidElement)(child) && child.type === $5e63c961fc1ce211$export$d9f1ccf0bdb05d45;
}
function $5e63c961fc1ce211$var$mergeProps(slotProps, childProps) {
  const overrideProps = {
    ...childProps
  };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue)
        overrideProps[propName] = (...args) => {
          childPropValue(...args);
          slotPropValue(...args);
        };
      else if (slotPropValue)
        overrideProps[propName] = slotPropValue;
    } else if (propName === "style")
      overrideProps[propName] = {
        ...slotPropValue,
        ...childPropValue
      };
    else if (propName === "className")
      overrideProps[propName] = [
        slotPropValue,
        childPropValue
      ].filter(Boolean).join(" ");
  }
  return {
    ...slotProps,
    ...overrideProps
  };
}

// ../../node_modules/@radix-ui/react-primitive/dist/index.module.js
var $8927f6f2acc4f386$var$NODES = [
  "a",
  "button",
  "div",
  "h2",
  "h3",
  "img",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
];
var $8927f6f2acc4f386$export$250ffa63cdc0d034 = $8927f6f2acc4f386$var$NODES.reduce((primitive, node) => {
  const Node = /* @__PURE__ */ (0, import_react11.forwardRef)((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? $5e63c961fc1ce211$export$8c6ed5c666ac1360 : node;
    (0, import_react11.useEffect)(() => {
      window[Symbol.for("radix-ui")] = true;
    }, []);
    return /* @__PURE__ */ (0, import_react11.createElement)(Comp, _extends({}, primitiveProps, {
      ref: forwardedRef
    }));
  });
  Node.displayName = `Primitive.${node}`;
  return {
    ...primitive,
    [node]: Node
  };
}, {});
function $8927f6f2acc4f386$export$6d1a0317bde7de7f(target, event) {
  if (target)
    (0, import_react_dom.flushSync)(
      () => target.dispatchEvent(event)
    );
}

// ../../node_modules/@radix-ui/react-use-callback-ref/dist/index.module.js
init_define_import_meta_env();
var import_react12 = __toESM(require_react());
function $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(callback) {
  const callbackRef = (0, import_react12.useRef)(callback);
  (0, import_react12.useEffect)(() => {
    callbackRef.current = callback;
  });
  return (0, import_react12.useMemo)(
    () => (...args) => {
      var _callbackRef$current;
      return (_callbackRef$current = callbackRef.current) === null || _callbackRef$current === void 0 ? void 0 : _callbackRef$current.call(callbackRef, ...args);
    },
    []
  );
}

// ../../node_modules/@radix-ui/react-use-escape-keydown/dist/index.module.js
init_define_import_meta_env();
var import_react13 = __toESM(require_react());
function $addc16e1bbe58fd0$export$3a72a57244d6e765(onEscapeKeyDownProp, ownerDocument = globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) {
  const onEscapeKeyDown = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onEscapeKeyDownProp);
  (0, import_react13.useEffect)(() => {
    const handleKeyDown = (event) => {
      if (event.key === "Escape")
        onEscapeKeyDown(event);
    };
    ownerDocument.addEventListener("keydown", handleKeyDown);
    return () => ownerDocument.removeEventListener("keydown", handleKeyDown);
  }, [
    onEscapeKeyDown,
    ownerDocument
  ]);
}

// ../../node_modules/@radix-ui/react-dismissable-layer/dist/index.module.js
var $5cb92bef7577960e$var$CONTEXT_UPDATE = "dismissableLayer.update";
var $5cb92bef7577960e$var$POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
var $5cb92bef7577960e$var$FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
var $5cb92bef7577960e$var$originalBodyPointerEvents;
var $5cb92bef7577960e$var$DismissableLayerContext = /* @__PURE__ */ (0, import_react14.createContext)({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
var $5cb92bef7577960e$export$177fb62ff3ec1f22 = /* @__PURE__ */ (0, import_react14.forwardRef)((props, forwardedRef) => {
  var _node$ownerDocument;
  const { disableOutsidePointerEvents = false, onEscapeKeyDown, onPointerDownOutside, onFocusOutside, onInteractOutside, onDismiss, ...layerProps } = props;
  const context = (0, import_react14.useContext)($5cb92bef7577960e$var$DismissableLayerContext);
  const [node1, setNode] = (0, import_react14.useState)(null);
  const ownerDocument = (_node$ownerDocument = node1 === null || node1 === void 0 ? void 0 : node1.ownerDocument) !== null && _node$ownerDocument !== void 0 ? _node$ownerDocument : globalThis === null || globalThis === void 0 ? void 0 : globalThis.document;
  const [, force] = (0, import_react14.useState)({});
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(
    forwardedRef,
    (node) => setNode(node)
  );
  const layers = Array.from(context.layers);
  const [highestLayerWithOutsidePointerEventsDisabled] = [
    ...context.layersWithOutsidePointerEventsDisabled
  ].slice(-1);
  const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
  const index2 = node1 ? layers.indexOf(node1) : -1;
  const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
  const isPointerEventsEnabled = index2 >= highestLayerWithOutsidePointerEventsDisabledIndex;
  const pointerDownOutside = $5cb92bef7577960e$var$usePointerDownOutside((event) => {
    const target = event.target;
    const isPointerDownOnBranch = [
      ...context.branches
    ].some(
      (branch) => branch.contains(target)
    );
    if (!isPointerEventsEnabled || isPointerDownOnBranch)
      return;
    onPointerDownOutside === null || onPointerDownOutside === void 0 || onPointerDownOutside(event);
    onInteractOutside === null || onInteractOutside === void 0 || onInteractOutside(event);
    if (!event.defaultPrevented)
      onDismiss === null || onDismiss === void 0 || onDismiss();
  }, ownerDocument);
  const focusOutside = $5cb92bef7577960e$var$useFocusOutside((event) => {
    const target = event.target;
    const isFocusInBranch = [
      ...context.branches
    ].some(
      (branch) => branch.contains(target)
    );
    if (isFocusInBranch)
      return;
    onFocusOutside === null || onFocusOutside === void 0 || onFocusOutside(event);
    onInteractOutside === null || onInteractOutside === void 0 || onInteractOutside(event);
    if (!event.defaultPrevented)
      onDismiss === null || onDismiss === void 0 || onDismiss();
  }, ownerDocument);
  $addc16e1bbe58fd0$export$3a72a57244d6e765((event) => {
    const isHighestLayer = index2 === context.layers.size - 1;
    if (!isHighestLayer)
      return;
    onEscapeKeyDown === null || onEscapeKeyDown === void 0 || onEscapeKeyDown(event);
    if (!event.defaultPrevented && onDismiss) {
      event.preventDefault();
      onDismiss();
    }
  }, ownerDocument);
  (0, import_react14.useEffect)(() => {
    if (!node1)
      return;
    if (disableOutsidePointerEvents) {
      if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
        $5cb92bef7577960e$var$originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;
        ownerDocument.body.style.pointerEvents = "none";
      }
      context.layersWithOutsidePointerEventsDisabled.add(node1);
    }
    context.layers.add(node1);
    $5cb92bef7577960e$var$dispatchUpdate();
    return () => {
      if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1)
        ownerDocument.body.style.pointerEvents = $5cb92bef7577960e$var$originalBodyPointerEvents;
    };
  }, [
    node1,
    ownerDocument,
    disableOutsidePointerEvents,
    context
  ]);
  (0, import_react14.useEffect)(() => {
    return () => {
      if (!node1)
        return;
      context.layers.delete(node1);
      context.layersWithOutsidePointerEventsDisabled.delete(node1);
      $5cb92bef7577960e$var$dispatchUpdate();
    };
  }, [
    node1,
    context
  ]);
  (0, import_react14.useEffect)(() => {
    const handleUpdate = () => force({});
    document.addEventListener($5cb92bef7577960e$var$CONTEXT_UPDATE, handleUpdate);
    return () => document.removeEventListener($5cb92bef7577960e$var$CONTEXT_UPDATE, handleUpdate);
  }, []);
  return /* @__PURE__ */ (0, import_react14.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({}, layerProps, {
    ref: composedRefs,
    style: {
      pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0,
      ...props.style
    },
    onFocusCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onFocusCapture, focusOutside.onFocusCapture),
    onBlurCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onBlurCapture, focusOutside.onBlurCapture),
    onPointerDownCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerDownCapture, pointerDownOutside.onPointerDownCapture)
  }));
});
function $5cb92bef7577960e$var$usePointerDownOutside(onPointerDownOutside, ownerDocument = globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) {
  const handlePointerDownOutside = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onPointerDownOutside);
  const isPointerInsideReactTreeRef = (0, import_react14.useRef)(false);
  const handleClickRef = (0, import_react14.useRef)(() => {
  });
  (0, import_react14.useEffect)(() => {
    const handlePointerDown = (event) => {
      if (event.target && !isPointerInsideReactTreeRef.current) {
        let handleAndDispatchPointerDownOutsideEvent = function() {
          $5cb92bef7577960e$var$handleAndDispatchCustomEvent($5cb92bef7577960e$var$POINTER_DOWN_OUTSIDE, handlePointerDownOutside, eventDetail, {
            discrete: true
          });
        };
        const eventDetail = {
          originalEvent: event
        };
        if (event.pointerType === "touch") {
          ownerDocument.removeEventListener("click", handleClickRef.current);
          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent;
          ownerDocument.addEventListener("click", handleClickRef.current, {
            once: true
          });
        } else
          handleAndDispatchPointerDownOutsideEvent();
      }
      isPointerInsideReactTreeRef.current = false;
    };
    const timerId = window.setTimeout(() => {
      ownerDocument.addEventListener("pointerdown", handlePointerDown);
    }, 0);
    return () => {
      window.clearTimeout(timerId);
      ownerDocument.removeEventListener("pointerdown", handlePointerDown);
      ownerDocument.removeEventListener("click", handleClickRef.current);
    };
  }, [
    ownerDocument,
    handlePointerDownOutside
  ]);
  return {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
  };
}
function $5cb92bef7577960e$var$useFocusOutside(onFocusOutside, ownerDocument = globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) {
  const handleFocusOutside = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onFocusOutside);
  const isFocusInsideReactTreeRef = (0, import_react14.useRef)(false);
  (0, import_react14.useEffect)(() => {
    const handleFocus = (event) => {
      if (event.target && !isFocusInsideReactTreeRef.current) {
        const eventDetail = {
          originalEvent: event
        };
        $5cb92bef7577960e$var$handleAndDispatchCustomEvent($5cb92bef7577960e$var$FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {
          discrete: false
        });
      }
    };
    ownerDocument.addEventListener("focusin", handleFocus);
    return () => ownerDocument.removeEventListener("focusin", handleFocus);
  }, [
    ownerDocument,
    handleFocusOutside
  ]);
  return {
    onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
    onBlurCapture: () => isFocusInsideReactTreeRef.current = false
  };
}
function $5cb92bef7577960e$var$dispatchUpdate() {
  const event = new CustomEvent($5cb92bef7577960e$var$CONTEXT_UPDATE);
  document.dispatchEvent(event);
}
function $5cb92bef7577960e$var$handleAndDispatchCustomEvent(name, handler, detail, { discrete }) {
  const target = detail.originalEvent.target;
  const event = new CustomEvent(name, {
    bubbles: false,
    cancelable: true,
    detail
  });
  if (handler)
    target.addEventListener(name, handler, {
      once: true
    });
  if (discrete)
    $8927f6f2acc4f386$export$6d1a0317bde7de7f(target, event);
  else
    target.dispatchEvent(event);
}

// ../../node_modules/@radix-ui/react-focus-guards/dist/index.module.js
init_define_import_meta_env();
var import_react15 = __toESM(require_react());
var $3db38b7d1fb3fe6a$var$count = 0;
function $3db38b7d1fb3fe6a$export$b7ece24a22aeda8c() {
  (0, import_react15.useEffect)(() => {
    var _edgeGuards$, _edgeGuards$2;
    const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", (_edgeGuards$ = edgeGuards[0]) !== null && _edgeGuards$ !== void 0 ? _edgeGuards$ : $3db38b7d1fb3fe6a$var$createFocusGuard());
    document.body.insertAdjacentElement("beforeend", (_edgeGuards$2 = edgeGuards[1]) !== null && _edgeGuards$2 !== void 0 ? _edgeGuards$2 : $3db38b7d1fb3fe6a$var$createFocusGuard());
    $3db38b7d1fb3fe6a$var$count++;
    return () => {
      if ($3db38b7d1fb3fe6a$var$count === 1)
        document.querySelectorAll("[data-radix-focus-guard]").forEach(
          (node) => node.remove()
        );
      $3db38b7d1fb3fe6a$var$count--;
    };
  }, []);
}
function $3db38b7d1fb3fe6a$var$createFocusGuard() {
  const element = document.createElement("span");
  element.setAttribute("data-radix-focus-guard", "");
  element.tabIndex = 0;
  element.style.cssText = "outline: none; opacity: 0; position: fixed; pointer-events: none";
  return element;
}

// ../../node_modules/@radix-ui/react-focus-scope/dist/index.module.js
init_define_import_meta_env();
var import_react16 = __toESM(require_react());
var $d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
var $d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
var $d3863c46a17e8a28$var$EVENT_OPTIONS = {
  bubbles: false,
  cancelable: true
};
var $d3863c46a17e8a28$export$20e40289641fbbb6 = /* @__PURE__ */ (0, import_react16.forwardRef)((props, forwardedRef) => {
  const { loop = false, trapped = false, onMountAutoFocus: onMountAutoFocusProp, onUnmountAutoFocus: onUnmountAutoFocusProp, ...scopeProps } = props;
  const [container1, setContainer] = (0, import_react16.useState)(null);
  const onMountAutoFocus = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onMountAutoFocusProp);
  const onUnmountAutoFocus = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onUnmountAutoFocusProp);
  const lastFocusedElementRef = (0, import_react16.useRef)(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(
    forwardedRef,
    (node) => setContainer(node)
  );
  const focusScope = (0, import_react16.useRef)({
    paused: false,
    pause() {
      this.paused = true;
    },
    resume() {
      this.paused = false;
    }
  }).current;
  (0, import_react16.useEffect)(() => {
    if (trapped) {
      let handleFocusIn = function(event) {
        if (focusScope.paused || !container1)
          return;
        const target = event.target;
        if (container1.contains(target))
          lastFocusedElementRef.current = target;
        else
          $d3863c46a17e8a28$var$focus(lastFocusedElementRef.current, {
            select: true
          });
      }, handleFocusOut = function(event) {
        if (focusScope.paused || !container1)
          return;
        if (!container1.contains(event.relatedTarget))
          $d3863c46a17e8a28$var$focus(lastFocusedElementRef.current, {
            select: true
          });
      };
      document.addEventListener("focusin", handleFocusIn);
      document.addEventListener("focusout", handleFocusOut);
      return () => {
        document.removeEventListener("focusin", handleFocusIn);
        document.removeEventListener("focusout", handleFocusOut);
      };
    }
  }, [
    trapped,
    container1,
    focusScope.paused
  ]);
  (0, import_react16.useEffect)(() => {
    if (container1) {
      $d3863c46a17e8a28$var$focusScopesStack.add(focusScope);
      const previouslyFocusedElement = document.activeElement;
      const hasFocusedCandidate = container1.contains(previouslyFocusedElement);
      if (!hasFocusedCandidate) {
        const mountEvent = new CustomEvent($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, $d3863c46a17e8a28$var$EVENT_OPTIONS);
        container1.addEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        container1.dispatchEvent(mountEvent);
        if (!mountEvent.defaultPrevented) {
          $d3863c46a17e8a28$var$focusFirst($d3863c46a17e8a28$var$removeLinks($d3863c46a17e8a28$var$getTabbableCandidates(container1)), {
            select: true
          });
          if (document.activeElement === previouslyFocusedElement)
            $d3863c46a17e8a28$var$focus(container1);
        }
      }
      return () => {
        container1.removeEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        setTimeout(() => {
          const unmountEvent = new CustomEvent($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, $d3863c46a17e8a28$var$EVENT_OPTIONS);
          container1.addEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          container1.dispatchEvent(unmountEvent);
          if (!unmountEvent.defaultPrevented)
            $d3863c46a17e8a28$var$focus(previouslyFocusedElement !== null && previouslyFocusedElement !== void 0 ? previouslyFocusedElement : document.body, {
              select: true
            });
          container1.removeEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          $d3863c46a17e8a28$var$focusScopesStack.remove(focusScope);
        }, 0);
      };
    }
  }, [
    container1,
    onMountAutoFocus,
    onUnmountAutoFocus,
    focusScope
  ]);
  const handleKeyDown = (0, import_react16.useCallback)((event) => {
    if (!loop && !trapped)
      return;
    if (focusScope.paused)
      return;
    const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
    const focusedElement = document.activeElement;
    if (isTabKey && focusedElement) {
      const container = event.currentTarget;
      const [first, last] = $d3863c46a17e8a28$var$getTabbableEdges(container);
      const hasTabbableElementsInside = first && last;
      if (!hasTabbableElementsInside) {
        if (focusedElement === container)
          event.preventDefault();
      } else {
        if (!event.shiftKey && focusedElement === last) {
          event.preventDefault();
          if (loop)
            $d3863c46a17e8a28$var$focus(first, {
              select: true
            });
        } else if (event.shiftKey && focusedElement === first) {
          event.preventDefault();
          if (loop)
            $d3863c46a17e8a28$var$focus(last, {
              select: true
            });
        }
      }
    }
  }, [
    loop,
    trapped,
    focusScope.paused
  ]);
  return /* @__PURE__ */ (0, import_react16.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
    tabIndex: -1
  }, scopeProps, {
    ref: composedRefs,
    onKeyDown: handleKeyDown
  }));
});
function $d3863c46a17e8a28$var$focusFirst(candidates, { select = false } = {}) {
  const previouslyFocusedElement = document.activeElement;
  for (const candidate of candidates) {
    $d3863c46a17e8a28$var$focus(candidate, {
      select
    });
    if (document.activeElement !== previouslyFocusedElement)
      return;
  }
}
function $d3863c46a17e8a28$var$getTabbableEdges(container) {
  const candidates = $d3863c46a17e8a28$var$getTabbableCandidates(container);
  const first = $d3863c46a17e8a28$var$findVisible(candidates, container);
  const last = $d3863c46a17e8a28$var$findVisible(candidates.reverse(), container);
  return [
    first,
    last
  ];
}
function $d3863c46a17e8a28$var$getTabbableCandidates(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput)
        return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode())
    nodes.push(walker.currentNode);
  return nodes;
}
function $d3863c46a17e8a28$var$findVisible(elements, container) {
  for (const element of elements) {
    if (!$d3863c46a17e8a28$var$isHidden(element, {
      upTo: container
    }))
      return element;
  }
}
function $d3863c46a17e8a28$var$isHidden(node, { upTo }) {
  if (getComputedStyle(node).visibility === "hidden")
    return true;
  while (node) {
    if (upTo !== void 0 && node === upTo)
      return false;
    if (getComputedStyle(node).display === "none")
      return true;
    node = node.parentElement;
  }
  return false;
}
function $d3863c46a17e8a28$var$isSelectableInput(element) {
  return element instanceof HTMLInputElement && "select" in element;
}
function $d3863c46a17e8a28$var$focus(element, { select = false } = {}) {
  if (element && element.focus) {
    const previouslyFocusedElement = document.activeElement;
    element.focus({
      preventScroll: true
    });
    if (element !== previouslyFocusedElement && $d3863c46a17e8a28$var$isSelectableInput(element) && select)
      element.select();
  }
}
var $d3863c46a17e8a28$var$focusScopesStack = $d3863c46a17e8a28$var$createFocusScopesStack();
function $d3863c46a17e8a28$var$createFocusScopesStack() {
  let stack = [];
  return {
    add(focusScope) {
      const activeFocusScope = stack[0];
      if (focusScope !== activeFocusScope)
        activeFocusScope === null || activeFocusScope === void 0 || activeFocusScope.pause();
      stack = $d3863c46a17e8a28$var$arrayRemove(stack, focusScope);
      stack.unshift(focusScope);
    },
    remove(focusScope) {
      var _stack$;
      stack = $d3863c46a17e8a28$var$arrayRemove(stack, focusScope);
      (_stack$ = stack[0]) === null || _stack$ === void 0 || _stack$.resume();
    }
  };
}
function $d3863c46a17e8a28$var$arrayRemove(array, item) {
  const updatedArray = [
    ...array
  ];
  const index2 = updatedArray.indexOf(item);
  if (index2 !== -1)
    updatedArray.splice(index2, 1);
  return updatedArray;
}
function $d3863c46a17e8a28$var$removeLinks(items) {
  return items.filter(
    (item) => item.tagName !== "A"
  );
}

// ../../node_modules/@radix-ui/react-id/dist/index.module.js
init_define_import_meta_env();
var $2AODx$react = __toESM(require_react());

// ../../node_modules/@radix-ui/react-use-layout-effect/dist/index.module.js
init_define_import_meta_env();
var import_react17 = __toESM(require_react());
var $9f79659886946c16$export$e5c5a5f917a5871c = Boolean(globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) ? import_react17.useLayoutEffect : () => {
};

// ../../node_modules/@radix-ui/react-id/dist/index.module.js
var $1746a345f3d73bb7$var$useReactId = $2AODx$react["useId".toString()] || (() => void 0);
var $1746a345f3d73bb7$var$count = 0;
function $1746a345f3d73bb7$export$f680877a34711e37(deterministicId) {
  const [id, setId] = $2AODx$react.useState($1746a345f3d73bb7$var$useReactId());
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    if (!deterministicId)
      setId(
        (reactId) => reactId !== null && reactId !== void 0 ? reactId : String($1746a345f3d73bb7$var$count++)
      );
  }, [
    deterministicId
  ]);
  return deterministicId || (id ? `radix-${id}` : "");
}

// ../../node_modules/@radix-ui/react-popper/dist/index.module.js
init_define_import_meta_env();
var import_react21 = __toESM(require_react());

// ../../node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.esm.js
init_define_import_meta_env();

// ../../node_modules/@floating-ui/dom/dist/floating-ui.dom.browser.min.mjs
init_define_import_meta_env();

// ../../node_modules/@floating-ui/core/dist/floating-ui.core.browser.min.mjs
init_define_import_meta_env();
function t2(t4) {
  return t4.split("-")[0];
}
function e(t4) {
  return t4.split("-")[1];
}
function n(e3) {
  return ["top", "bottom"].includes(t2(e3)) ? "x" : "y";
}
function r(t4) {
  return "y" === t4 ? "height" : "width";
}
function i(i4, o4, a4) {
  let { reference: l4, floating: s4 } = i4;
  const c3 = l4.x + l4.width / 2 - s4.width / 2, f3 = l4.y + l4.height / 2 - s4.height / 2, u3 = n(o4), m3 = r(u3), g3 = l4[m3] / 2 - s4[m3] / 2, d3 = "x" === u3;
  let p3;
  switch (t2(o4)) {
    case "top":
      p3 = { x: c3, y: l4.y - s4.height };
      break;
    case "bottom":
      p3 = { x: c3, y: l4.y + l4.height };
      break;
    case "right":
      p3 = { x: l4.x + l4.width, y: f3 };
      break;
    case "left":
      p3 = { x: l4.x - s4.width, y: f3 };
      break;
    default:
      p3 = { x: l4.x, y: l4.y };
  }
  switch (e(o4)) {
    case "start":
      p3[u3] -= g3 * (a4 && d3 ? -1 : 1);
      break;
    case "end":
      p3[u3] += g3 * (a4 && d3 ? -1 : 1);
  }
  return p3;
}
var o = async (t4, e3, n4) => {
  const { placement: r3 = "bottom", strategy: o4 = "absolute", middleware: a4 = [], platform: l4 } = n4, s4 = await (null == l4.isRTL ? void 0 : l4.isRTL(e3));
  let c3 = await l4.getElementRects({ reference: t4, floating: e3, strategy: o4 }), { x: f3, y: u3 } = i(c3, r3, s4), m3 = r3, g3 = {}, d3 = 0;
  for (let n5 = 0; n5 < a4.length; n5++) {
    const { name: p3, fn: h3 } = a4[n5], { x: y3, y: x3, data: w3, reset: v3 } = await h3({ x: f3, y: u3, initialPlacement: r3, placement: m3, strategy: o4, middlewareData: g3, rects: c3, platform: l4, elements: { reference: t4, floating: e3 } });
    f3 = null != y3 ? y3 : f3, u3 = null != x3 ? x3 : u3, g3 = { ...g3, [p3]: { ...g3[p3], ...w3 } }, v3 && d3 <= 50 && (d3++, "object" == typeof v3 && (v3.placement && (m3 = v3.placement), v3.rects && (c3 = true === v3.rects ? await l4.getElementRects({ reference: t4, floating: e3, strategy: o4 }) : v3.rects), { x: f3, y: u3 } = i(c3, m3, s4)), n5 = -1);
  }
  return { x: f3, y: u3, placement: m3, strategy: o4, middlewareData: g3 };
};
function a2(t4) {
  return "number" != typeof t4 ? function(t5) {
    return { top: 0, right: 0, bottom: 0, left: 0, ...t5 };
  }(t4) : { top: t4, right: t4, bottom: t4, left: t4 };
}
function l2(t4) {
  return { ...t4, top: t4.y, left: t4.x, right: t4.x + t4.width, bottom: t4.y + t4.height };
}
async function s(t4, e3) {
  var n4;
  void 0 === e3 && (e3 = {});
  const { x: r3, y: i4, platform: o4, rects: s4, elements: c3, strategy: f3 } = t4, { boundary: u3 = "clippingAncestors", rootBoundary: m3 = "viewport", elementContext: g3 = "floating", altBoundary: d3 = false, padding: p3 = 0 } = e3, h3 = a2(p3), y3 = c3[d3 ? "floating" === g3 ? "reference" : "floating" : g3], x3 = l2(await o4.getClippingRect({ element: null == (n4 = await (null == o4.isElement ? void 0 : o4.isElement(y3))) || n4 ? y3 : y3.contextElement || await (null == o4.getDocumentElement ? void 0 : o4.getDocumentElement(c3.floating)), boundary: u3, rootBoundary: m3, strategy: f3 })), w3 = l2(o4.convertOffsetParentRelativeRectToViewportRelativeRect ? await o4.convertOffsetParentRelativeRectToViewportRelativeRect({ rect: "floating" === g3 ? { ...s4.floating, x: r3, y: i4 } : s4.reference, offsetParent: await (null == o4.getOffsetParent ? void 0 : o4.getOffsetParent(c3.floating)), strategy: f3 }) : s4[g3]);
  return { top: x3.top - w3.top + h3.top, bottom: w3.bottom - x3.bottom + h3.bottom, left: x3.left - w3.left + h3.left, right: w3.right - x3.right + h3.right };
}
var c = Math.min;
var f = Math.max;
function u(t4, e3, n4) {
  return f(t4, c(e3, n4));
}
var m = (t4) => ({ name: "arrow", options: t4, async fn(i4) {
  const { element: o4, padding: l4 = 0 } = null != t4 ? t4 : {}, { x: s4, y: c3, placement: f3, rects: m3, platform: g3 } = i4;
  if (null == o4)
    return {};
  const d3 = a2(l4), p3 = { x: s4, y: c3 }, h3 = n(f3), y3 = e(f3), x3 = r(h3), w3 = await g3.getDimensions(o4), v3 = "y" === h3 ? "top" : "left", b4 = "y" === h3 ? "bottom" : "right", R4 = m3.reference[x3] + m3.reference[h3] - p3[h3] - m3.floating[x3], A3 = p3[h3] - m3.reference[h3], P2 = await (null == g3.getOffsetParent ? void 0 : g3.getOffsetParent(o4));
  let T3 = P2 ? "y" === h3 ? P2.clientHeight || 0 : P2.clientWidth || 0 : 0;
  0 === T3 && (T3 = m3.floating[x3]);
  const O2 = R4 / 2 - A3 / 2, D3 = d3[v3], L4 = T3 - w3[x3] - d3[b4], k2 = T3 / 2 - w3[x3] / 2 + O2, E4 = u(D3, k2, L4), C3 = ("start" === y3 ? d3[v3] : d3[b4]) > 0 && k2 !== E4 && m3.reference[x3] <= m3.floating[x3];
  return { [h3]: p3[h3] - (C3 ? k2 < D3 ? D3 - k2 : L4 - k2 : 0), data: { [h3]: E4, centerOffset: k2 - E4 } };
} });
var g = { left: "right", right: "left", bottom: "top", top: "bottom" };
function d(t4) {
  return t4.replace(/left|right|bottom|top/g, (t5) => g[t5]);
}
function p(t4, i4, o4) {
  void 0 === o4 && (o4 = false);
  const a4 = e(t4), l4 = n(t4), s4 = r(l4);
  let c3 = "x" === l4 ? a4 === (o4 ? "end" : "start") ? "right" : "left" : "start" === a4 ? "bottom" : "top";
  return i4.reference[s4] > i4.floating[s4] && (c3 = d(c3)), { main: c3, cross: d(c3) };
}
var h = { start: "end", end: "start" };
function y(t4) {
  return t4.replace(/start|end/g, (t5) => h[t5]);
}
var x = ["top", "right", "bottom", "left"];
var w = x.reduce((t4, e3) => t4.concat(e3, e3 + "-start", e3 + "-end"), []);
var b2 = function(e3) {
  return void 0 === e3 && (e3 = {}), { name: "flip", options: e3, async fn(n4) {
    var r3;
    const { placement: i4, middlewareData: o4, rects: a4, initialPlacement: l4, platform: c3, elements: f3 } = n4, { mainAxis: u3 = true, crossAxis: m3 = true, fallbackPlacements: g3, fallbackStrategy: h3 = "bestFit", flipAlignment: x3 = true, ...w3 } = e3, v3 = t2(i4), b4 = g3 || (v3 === l4 || !x3 ? [d(l4)] : function(t4) {
      const e4 = d(t4);
      return [y(t4), e4, y(e4)];
    }(l4)), R4 = [l4, ...b4], A3 = await s(n4, w3), P2 = [];
    let T3 = (null == (r3 = o4.flip) ? void 0 : r3.overflows) || [];
    if (u3 && P2.push(A3[v3]), m3) {
      const { main: t4, cross: e4 } = p(i4, a4, await (null == c3.isRTL ? void 0 : c3.isRTL(f3.floating)));
      P2.push(A3[t4], A3[e4]);
    }
    if (T3 = [...T3, { placement: i4, overflows: P2 }], !P2.every((t4) => t4 <= 0)) {
      var O2, D3;
      const t4 = (null != (O2 = null == (D3 = o4.flip) ? void 0 : D3.index) ? O2 : 0) + 1, e4 = R4[t4];
      if (e4)
        return { data: { index: t4, overflows: T3 }, reset: { placement: e4 } };
      let n5 = "bottom";
      switch (h3) {
        case "bestFit": {
          var L4;
          const t5 = null == (L4 = T3.map((t6) => [t6, t6.overflows.filter((t7) => t7 > 0).reduce((t7, e5) => t7 + e5, 0)]).sort((t6, e5) => t6[1] - e5[1])[0]) ? void 0 : L4[0].placement;
          t5 && (n5 = t5);
          break;
        }
        case "initialPlacement":
          n5 = l4;
      }
      if (i4 !== n5)
        return { reset: { placement: n5 } };
    }
    return {};
  } };
};
function R2(t4, e3) {
  return { top: t4.top - e3.height, right: t4.right - e3.width, bottom: t4.bottom - e3.height, left: t4.left - e3.width };
}
function A2(t4) {
  return x.some((e3) => t4[e3] >= 0);
}
var P = function(t4) {
  let { strategy: e3 = "referenceHidden", ...n4 } = void 0 === t4 ? {} : t4;
  return { name: "hide", async fn(t5) {
    const { rects: r3 } = t5;
    switch (e3) {
      case "referenceHidden": {
        const e4 = R2(await s(t5, { ...n4, elementContext: "reference" }), r3.reference);
        return { data: { referenceHiddenOffsets: e4, referenceHidden: A2(e4) } };
      }
      case "escaped": {
        const e4 = R2(await s(t5, { ...n4, altBoundary: true }), r3.floating);
        return { data: { escapedOffsets: e4, escaped: A2(e4) } };
      }
      default:
        return {};
    }
  } };
};
var T = function(r3) {
  return void 0 === r3 && (r3 = 0), { name: "offset", options: r3, async fn(i4) {
    const { x: o4, y: a4 } = i4, l4 = await async function(r4, i5) {
      const { placement: o5, platform: a5, elements: l5 } = r4, s4 = await (null == a5.isRTL ? void 0 : a5.isRTL(l5.floating)), c3 = t2(o5), f3 = e(o5), u3 = "x" === n(o5), m3 = ["left", "top"].includes(c3) ? -1 : 1, g3 = s4 && u3 ? -1 : 1, d3 = "function" == typeof i5 ? i5(r4) : i5;
      let { mainAxis: p3, crossAxis: h3, alignmentAxis: y3 } = "number" == typeof d3 ? { mainAxis: d3, crossAxis: 0, alignmentAxis: null } : { mainAxis: 0, crossAxis: 0, alignmentAxis: null, ...d3 };
      return f3 && "number" == typeof y3 && (h3 = "end" === f3 ? -1 * y3 : y3), u3 ? { x: h3 * g3, y: p3 * m3 } : { x: p3 * m3, y: h3 * g3 };
    }(i4, r3);
    return { x: o4 + l4.x, y: a4 + l4.y, data: l4 };
  } };
};
function O(t4) {
  return "x" === t4 ? "y" : "x";
}
var D = function(e3) {
  return void 0 === e3 && (e3 = {}), { name: "shift", options: e3, async fn(r3) {
    const { x: i4, y: o4, placement: a4 } = r3, { mainAxis: l4 = true, crossAxis: c3 = false, limiter: f3 = { fn: (t4) => {
      let { x: e4, y: n4 } = t4;
      return { x: e4, y: n4 };
    } }, ...m3 } = e3, g3 = { x: i4, y: o4 }, d3 = await s(r3, m3), p3 = n(t2(a4)), h3 = O(p3);
    let y3 = g3[p3], x3 = g3[h3];
    if (l4) {
      const t4 = "y" === p3 ? "bottom" : "right";
      y3 = u(y3 + d3["y" === p3 ? "top" : "left"], y3, y3 - d3[t4]);
    }
    if (c3) {
      const t4 = "y" === h3 ? "bottom" : "right";
      x3 = u(x3 + d3["y" === h3 ? "top" : "left"], x3, x3 - d3[t4]);
    }
    const w3 = f3.fn({ ...r3, [p3]: y3, [h3]: x3 });
    return { ...w3, data: { x: w3.x - i4, y: w3.y - o4 } };
  } };
};
var L2 = function(e3) {
  return void 0 === e3 && (e3 = {}), { options: e3, fn(r3) {
    const { x: i4, y: o4, placement: a4, rects: l4, middlewareData: s4 } = r3, { offset: c3 = 0, mainAxis: f3 = true, crossAxis: u3 = true } = e3, m3 = { x: i4, y: o4 }, g3 = n(a4), d3 = O(g3);
    let p3 = m3[g3], h3 = m3[d3];
    const y3 = "function" == typeof c3 ? c3({ ...l4, placement: a4 }) : c3, x3 = "number" == typeof y3 ? { mainAxis: y3, crossAxis: 0 } : { mainAxis: 0, crossAxis: 0, ...y3 };
    if (f3) {
      const t4 = "y" === g3 ? "height" : "width", e4 = l4.reference[g3] - l4.floating[t4] + x3.mainAxis, n4 = l4.reference[g3] + l4.reference[t4] - x3.mainAxis;
      p3 < e4 ? p3 = e4 : p3 > n4 && (p3 = n4);
    }
    if (u3) {
      var w3, v3, b4, R4;
      const e4 = "y" === g3 ? "width" : "height", n4 = ["top", "left"].includes(t2(a4)), r4 = l4.reference[d3] - l4.floating[e4] + (n4 && null != (w3 = null == (v3 = s4.offset) ? void 0 : v3[d3]) ? w3 : 0) + (n4 ? 0 : x3.crossAxis), i5 = l4.reference[d3] + l4.reference[e4] + (n4 ? 0 : null != (b4 = null == (R4 = s4.offset) ? void 0 : R4[d3]) ? b4 : 0) - (n4 ? x3.crossAxis : 0);
      h3 < r4 ? h3 = r4 : h3 > i5 && (h3 = i5);
    }
    return { [g3]: p3, [d3]: h3 };
  } };
};
var k = function(n4) {
  return void 0 === n4 && (n4 = {}), { name: "size", options: n4, async fn(r3) {
    const { placement: i4, rects: o4, platform: a4, elements: l4 } = r3, { apply: c3, ...u3 } = n4, m3 = await s(r3, u3), g3 = t2(i4), d3 = e(i4);
    let p3, h3;
    "top" === g3 || "bottom" === g3 ? (p3 = g3, h3 = d3 === (await (null == a4.isRTL ? void 0 : a4.isRTL(l4.floating)) ? "start" : "end") ? "left" : "right") : (h3 = g3, p3 = "end" === d3 ? "top" : "bottom");
    const y3 = f(m3.left, 0), x3 = f(m3.right, 0), w3 = f(m3.top, 0), v3 = f(m3.bottom, 0), b4 = { availableHeight: o4.floating.height - (["left", "right"].includes(i4) ? 2 * (0 !== w3 || 0 !== v3 ? w3 + v3 : f(m3.top, m3.bottom)) : m3[p3]), availableWidth: o4.floating.width - (["top", "bottom"].includes(i4) ? 2 * (0 !== y3 || 0 !== x3 ? y3 + x3 : f(m3.left, m3.right)) : m3[h3]) }, R4 = await a4.getDimensions(l4.floating);
    null == c3 || c3({ ...r3, ...b4 });
    const A3 = await a4.getDimensions(l4.floating);
    return R4.width !== A3.width || R4.height !== A3.height ? { reset: { rects: true } } : {};
  } };
};

// ../../node_modules/@floating-ui/dom/dist/floating-ui.dom.browser.min.mjs
function n2(t4) {
  return t4 && t4.document && t4.location && t4.alert && t4.setInterval;
}
function o2(t4) {
  if (null == t4)
    return window;
  if (!n2(t4)) {
    const e3 = t4.ownerDocument;
    return e3 && e3.defaultView || window;
  }
  return t4;
}
function i2(t4) {
  return o2(t4).getComputedStyle(t4);
}
function r2(t4) {
  return n2(t4) ? "" : t4 ? (t4.nodeName || "").toLowerCase() : "";
}
function l3() {
  const t4 = navigator.userAgentData;
  return null != t4 && t4.brands ? t4.brands.map((t5) => t5.brand + "/" + t5.version).join(" ") : navigator.userAgent;
}
function c2(t4) {
  return t4 instanceof o2(t4).HTMLElement;
}
function f2(t4) {
  return t4 instanceof o2(t4).Element;
}
function s2(t4) {
  if ("undefined" == typeof ShadowRoot)
    return false;
  return t4 instanceof o2(t4).ShadowRoot || t4 instanceof ShadowRoot;
}
function u2(t4) {
  const { overflow: e3, overflowX: n4, overflowY: o4 } = i2(t4);
  return /auto|scroll|overlay|hidden/.test(e3 + o4 + n4);
}
function d2(t4) {
  return ["table", "td", "th"].includes(r2(t4));
}
function h2(t4) {
  const e3 = /firefox/i.test(l3()), n4 = i2(t4);
  return "none" !== n4.transform || "none" !== n4.perspective || "paint" === n4.contain || ["transform", "perspective"].includes(n4.willChange) || e3 && "filter" === n4.willChange || e3 && !!n4.filter && "none" !== n4.filter;
}
function a3() {
  return !/^((?!chrome|android).)*safari/i.test(l3());
}
var g2 = Math.min;
var p2 = Math.max;
var m2 = Math.round;
function w2(t4, e3, n4) {
  var i4, r3, l4, s4;
  void 0 === e3 && (e3 = false), void 0 === n4 && (n4 = false);
  const u3 = t4.getBoundingClientRect();
  let d3 = 1, h3 = 1;
  e3 && c2(t4) && (d3 = t4.offsetWidth > 0 && m2(u3.width) / t4.offsetWidth || 1, h3 = t4.offsetHeight > 0 && m2(u3.height) / t4.offsetHeight || 1);
  const g3 = f2(t4) ? o2(t4) : window, p3 = !a3() && n4, w3 = (u3.left + (p3 && null != (i4 = null == (r3 = g3.visualViewport) ? void 0 : r3.offsetLeft) ? i4 : 0)) / d3, v3 = (u3.top + (p3 && null != (l4 = null == (s4 = g3.visualViewport) ? void 0 : s4.offsetTop) ? l4 : 0)) / h3, y3 = u3.width / d3, x3 = u3.height / h3;
  return { width: y3, height: x3, top: v3, right: w3 + y3, bottom: v3 + x3, left: w3, x: w3, y: v3 };
}
function v2(t4) {
  return (e3 = t4, (e3 instanceof o2(e3).Node ? t4.ownerDocument : t4.document) || window.document).documentElement;
  var e3;
}
function y2(t4) {
  return f2(t4) ? { scrollLeft: t4.scrollLeft, scrollTop: t4.scrollTop } : { scrollLeft: t4.pageXOffset, scrollTop: t4.pageYOffset };
}
function x2(t4) {
  return w2(v2(t4)).left + y2(t4).scrollLeft;
}
function b3(t4, e3, n4) {
  const o4 = c2(e3), i4 = v2(e3), l4 = w2(t4, o4 && function(t5) {
    const e4 = w2(t5);
    return m2(e4.width) !== t5.offsetWidth || m2(e4.height) !== t5.offsetHeight;
  }(e3), "fixed" === n4);
  let f3 = { scrollLeft: 0, scrollTop: 0 };
  const s4 = { x: 0, y: 0 };
  if (o4 || !o4 && "fixed" !== n4)
    if (("body" !== r2(e3) || u2(i4)) && (f3 = y2(e3)), c2(e3)) {
      const t5 = w2(e3, true);
      s4.x = t5.x + e3.clientLeft, s4.y = t5.y + e3.clientTop;
    } else
      i4 && (s4.x = x2(i4));
  return { x: l4.left + f3.scrollLeft - s4.x, y: l4.top + f3.scrollTop - s4.y, width: l4.width, height: l4.height };
}
function L3(t4) {
  return "html" === r2(t4) ? t4 : t4.assignedSlot || t4.parentNode || (s2(t4) ? t4.host : null) || v2(t4);
}
function R3(t4) {
  return c2(t4) && "fixed" !== getComputedStyle(t4).position ? t4.offsetParent : null;
}
function T2(t4) {
  const e3 = o2(t4);
  let n4 = R3(t4);
  for (; n4 && d2(n4) && "static" === getComputedStyle(n4).position; )
    n4 = R3(n4);
  return n4 && ("html" === r2(n4) || "body" === r2(n4) && "static" === getComputedStyle(n4).position && !h2(n4)) ? e3 : n4 || function(t5) {
    let e4 = L3(t5);
    for (s2(e4) && (e4 = e4.host); c2(e4) && !["html", "body"].includes(r2(e4)); ) {
      if (h2(e4))
        return e4;
      e4 = e4.parentNode;
    }
    return null;
  }(t4) || e3;
}
function W(t4) {
  if (c2(t4))
    return { width: t4.offsetWidth, height: t4.offsetHeight };
  const e3 = w2(t4);
  return { width: e3.width, height: e3.height };
}
function E3(t4) {
  const e3 = L3(t4);
  return ["html", "body", "#document"].includes(r2(e3)) ? t4.ownerDocument.body : c2(e3) && u2(e3) ? e3 : E3(e3);
}
function H(t4, e3) {
  var n4;
  void 0 === e3 && (e3 = []);
  const i4 = E3(t4), r3 = i4 === (null == (n4 = t4.ownerDocument) ? void 0 : n4.body), l4 = o2(i4), c3 = r3 ? [l4].concat(l4.visualViewport || [], u2(i4) ? i4 : []) : i4, f3 = e3.concat(c3);
  return r3 ? f3 : f3.concat(H(c3));
}
function C2(e3, n4, r3) {
  return "viewport" === n4 ? l2(function(t4, e4) {
    const n5 = o2(t4), i4 = v2(t4), r4 = n5.visualViewport;
    let l4 = i4.clientWidth, c3 = i4.clientHeight, f3 = 0, s4 = 0;
    if (r4) {
      l4 = r4.width, c3 = r4.height;
      const t5 = a3();
      (t5 || !t5 && "fixed" === e4) && (f3 = r4.offsetLeft, s4 = r4.offsetTop);
    }
    return { width: l4, height: c3, x: f3, y: s4 };
  }(e3, r3)) : f2(n4) ? function(t4, e4) {
    const n5 = w2(t4, false, "fixed" === e4), o4 = n5.top + t4.clientTop, i4 = n5.left + t4.clientLeft;
    return { top: o4, left: i4, x: i4, y: o4, right: i4 + t4.clientWidth, bottom: o4 + t4.clientHeight, width: t4.clientWidth, height: t4.clientHeight };
  }(n4, r3) : l2(function(t4) {
    var e4;
    const n5 = v2(t4), o4 = y2(t4), r4 = null == (e4 = t4.ownerDocument) ? void 0 : e4.body, l4 = p2(n5.scrollWidth, n5.clientWidth, r4 ? r4.scrollWidth : 0, r4 ? r4.clientWidth : 0), c3 = p2(n5.scrollHeight, n5.clientHeight, r4 ? r4.scrollHeight : 0, r4 ? r4.clientHeight : 0);
    let f3 = -o4.scrollLeft + x2(t4);
    const s4 = -o4.scrollTop;
    return "rtl" === i2(r4 || n5).direction && (f3 += p2(n5.clientWidth, r4 ? r4.clientWidth : 0) - l4), { width: l4, height: c3, x: f3, y: s4 };
  }(v2(e3)));
}
function S(t4) {
  const e3 = H(t4), n4 = ["absolute", "fixed"].includes(i2(t4).position) && c2(t4) ? T2(t4) : t4;
  return f2(n4) ? e3.filter((t5) => f2(t5) && function(t6, e4) {
    const n5 = null == e4.getRootNode ? void 0 : e4.getRootNode();
    if (t6.contains(e4))
      return true;
    if (n5 && s2(n5)) {
      let n6 = e4;
      do {
        if (n6 && t6 === n6)
          return true;
        n6 = n6.parentNode || n6.host;
      } while (n6);
    }
    return false;
  }(t5, n4) && "body" !== r2(t5)) : [];
}
var D2 = { getClippingRect: function(t4) {
  let { element: e3, boundary: n4, rootBoundary: o4, strategy: i4 } = t4;
  const r3 = [..."clippingAncestors" === n4 ? S(e3) : [].concat(n4), o4], l4 = r3[0], c3 = r3.reduce((t5, n5) => {
    const o5 = C2(e3, n5, i4);
    return t5.top = p2(o5.top, t5.top), t5.right = g2(o5.right, t5.right), t5.bottom = g2(o5.bottom, t5.bottom), t5.left = p2(o5.left, t5.left), t5;
  }, C2(e3, l4, i4));
  return { width: c3.right - c3.left, height: c3.bottom - c3.top, x: c3.left, y: c3.top };
}, convertOffsetParentRelativeRectToViewportRelativeRect: function(t4) {
  let { rect: e3, offsetParent: n4, strategy: o4 } = t4;
  const i4 = c2(n4), l4 = v2(n4);
  if (n4 === l4)
    return e3;
  let f3 = { scrollLeft: 0, scrollTop: 0 };
  const s4 = { x: 0, y: 0 };
  if ((i4 || !i4 && "fixed" !== o4) && (("body" !== r2(n4) || u2(l4)) && (f3 = y2(n4)), c2(n4))) {
    const t5 = w2(n4, true);
    s4.x = t5.x + n4.clientLeft, s4.y = t5.y + n4.clientTop;
  }
  return { ...e3, x: e3.x - f3.scrollLeft + s4.x, y: e3.y - f3.scrollTop + s4.y };
}, isElement: f2, getDimensions: W, getOffsetParent: T2, getDocumentElement: v2, getElementRects: (t4) => {
  let { reference: e3, floating: n4, strategy: o4 } = t4;
  return { reference: b3(e3, T2(n4), o4), floating: { ...W(n4), x: 0, y: 0 } };
}, getClientRects: (t4) => Array.from(t4.getClientRects()), isRTL: (t4) => "rtl" === i2(t4).direction };
function N(t4, e3, n4, o4) {
  void 0 === o4 && (o4 = {});
  const { ancestorScroll: i4 = true, ancestorResize: r3 = true, elementResize: l4 = true, animationFrame: c3 = false } = o4, s4 = i4 && !c3, u3 = r3 && !c3, d3 = s4 || u3 ? [...f2(t4) ? H(t4) : [], ...H(e3)] : [];
  d3.forEach((t5) => {
    s4 && t5.addEventListener("scroll", n4, { passive: true }), u3 && t5.addEventListener("resize", n4);
  });
  let h3, a4 = null;
  if (l4) {
    let o5 = true;
    a4 = new ResizeObserver(() => {
      o5 || n4(), o5 = false;
    }), f2(t4) && !c3 && a4.observe(t4), a4.observe(e3);
  }
  let g3 = c3 ? w2(t4) : null;
  return c3 && function e4() {
    const o5 = w2(t4);
    !g3 || o5.x === g3.x && o5.y === g3.y && o5.width === g3.width && o5.height === g3.height || n4();
    g3 = o5, h3 = requestAnimationFrame(e4);
  }(), n4(), () => {
    var t5;
    d3.forEach((t6) => {
      s4 && t6.removeEventListener("scroll", n4), u3 && t6.removeEventListener("resize", n4);
    }), null == (t5 = a4) || t5.disconnect(), a4 = null, c3 && cancelAnimationFrame(h3);
  };
}
var z = (t4, n4, o4) => o(t4, n4, { platform: D2, ...o4 });

// ../../node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.esm.js
var React4 = __toESM(require_react());
var import_react18 = __toESM(require_react());
var ReactDOM2 = __toESM(require_react_dom());
var index = typeof document !== "undefined" ? import_react18.useLayoutEffect : import_react18.useEffect;
function deepEqual(a4, b4) {
  if (a4 === b4) {
    return true;
  }
  if (typeof a4 !== typeof b4) {
    return false;
  }
  if (typeof a4 === "function" && a4.toString() === b4.toString()) {
    return true;
  }
  let length, i4, keys;
  if (a4 && b4 && typeof a4 == "object") {
    if (Array.isArray(a4)) {
      length = a4.length;
      if (length != b4.length)
        return false;
      for (i4 = length; i4-- !== 0; ) {
        if (!deepEqual(a4[i4], b4[i4])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a4);
    length = keys.length;
    if (length !== Object.keys(b4).length) {
      return false;
    }
    for (i4 = length; i4-- !== 0; ) {
      if (!Object.prototype.hasOwnProperty.call(b4, keys[i4])) {
        return false;
      }
    }
    for (i4 = length; i4-- !== 0; ) {
      const key = keys[i4];
      if (key === "_owner" && a4.$$typeof) {
        continue;
      }
      if (!deepEqual(a4[key], b4[key])) {
        return false;
      }
    }
    return true;
  }
  return a4 !== a4 && b4 !== b4;
}
function useLatestRef(value) {
  const ref = React4.useRef(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating(_temp) {
  let {
    middleware,
    placement = "bottom",
    strategy = "absolute",
    whileElementsMounted
  } = _temp === void 0 ? {} : _temp;
  const reference = React4.useRef(null);
  const floating = React4.useRef(null);
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const cleanupRef = React4.useRef(null);
  const [data, setData] = React4.useState({
    // Setting these to `null` will allow the consumer to determine if
    // `computePosition()` has run yet
    x: null,
    y: null,
    strategy,
    placement,
    middlewareData: {}
  });
  const [latestMiddleware, setLatestMiddleware] = React4.useState(middleware);
  if (!deepEqual(latestMiddleware == null ? void 0 : latestMiddleware.map((_ref) => {
    let {
      options
    } = _ref;
    return options;
  }), middleware == null ? void 0 : middleware.map((_ref2) => {
    let {
      options
    } = _ref2;
    return options;
  }))) {
    setLatestMiddleware(middleware);
  }
  const update = React4.useCallback(() => {
    if (!reference.current || !floating.current) {
      return;
    }
    z(reference.current, floating.current, {
      middleware: latestMiddleware,
      placement,
      strategy
    }).then((data2) => {
      if (isMountedRef.current) {
        ReactDOM2.flushSync(() => {
          setData(data2);
        });
      }
    });
  }, [latestMiddleware, placement, strategy]);
  index(() => {
    if (isMountedRef.current) {
      update();
    }
  }, [update]);
  const isMountedRef = React4.useRef(false);
  index(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  const runElementMountCallback = React4.useCallback(() => {
    if (typeof cleanupRef.current === "function") {
      cleanupRef.current();
      cleanupRef.current = null;
    }
    if (reference.current && floating.current) {
      if (whileElementsMountedRef.current) {
        const cleanupFn = whileElementsMountedRef.current(reference.current, floating.current, update);
        cleanupRef.current = cleanupFn;
      } else {
        update();
      }
    }
  }, [update, whileElementsMountedRef]);
  const setReference = React4.useCallback((node) => {
    reference.current = node;
    runElementMountCallback();
  }, [runElementMountCallback]);
  const setFloating = React4.useCallback((node) => {
    floating.current = node;
    runElementMountCallback();
  }, [runElementMountCallback]);
  const refs = React4.useMemo(() => ({
    reference,
    floating
  }), []);
  return React4.useMemo(() => ({
    ...data,
    update,
    refs,
    reference: setReference,
    floating: setFloating
  }), [data, update, refs, setReference, setFloating]);
}
var arrow = (options) => {
  const {
    element,
    padding
  } = options;
  function isRef(value) {
    return Object.prototype.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(args) {
      if (isRef(element)) {
        if (element.current != null) {
          return m({
            element: element.current,
            padding
          }).fn(args);
        }
        return {};
      } else if (element) {
        return m({
          element,
          padding
        }).fn(args);
      }
      return {};
    }
  };
};

// ../../node_modules/@radix-ui/react-arrow/dist/index.module.js
init_define_import_meta_env();
var import_react19 = __toESM(require_react());
var $7e8f5cd07187803e$export$21b07c8f274aebd5 = /* @__PURE__ */ (0, import_react19.forwardRef)((props, forwardedRef) => {
  const { children, width = 10, height = 5, ...arrowProps } = props;
  return /* @__PURE__ */ (0, import_react19.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.svg, _extends({}, arrowProps, {
    ref: forwardedRef,
    width,
    height,
    viewBox: "0 0 30 10",
    preserveAspectRatio: "none"
  }), props.asChild ? children : /* @__PURE__ */ (0, import_react19.createElement)("polygon", {
    points: "0,0 30,0 15,10"
  }));
});
var $7e8f5cd07187803e$export$be92b6f5f03c0fe9 = $7e8f5cd07187803e$export$21b07c8f274aebd5;

// ../../node_modules/@radix-ui/react-use-size/dist/index.module.js
init_define_import_meta_env();
var import_react20 = __toESM(require_react());
function $db6c3485150b8e66$export$1ab7ae714698c4b8(element) {
  const [size, setSize] = (0, import_react20.useState)(void 0);
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    if (element) {
      setSize({
        width: element.offsetWidth,
        height: element.offsetHeight
      });
      const resizeObserver = new ResizeObserver((entries) => {
        if (!Array.isArray(entries))
          return;
        if (!entries.length)
          return;
        const entry = entries[0];
        let width;
        let height;
        if ("borderBoxSize" in entry) {
          const borderSizeEntry = entry["borderBoxSize"];
          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
          width = borderSize["inlineSize"];
          height = borderSize["blockSize"];
        } else {
          width = element.offsetWidth;
          height = element.offsetHeight;
        }
        setSize({
          width,
          height
        });
      });
      resizeObserver.observe(element, {
        box: "border-box"
      });
      return () => resizeObserver.unobserve(element);
    } else
      setSize(void 0);
  }, [
    element
  ]);
  return size;
}

// ../../node_modules/@radix-ui/react-popper/dist/index.module.js
var $cf1ac5d9fe0e8206$var$POPPER_NAME = "Popper";
var [$cf1ac5d9fe0e8206$var$createPopperContext, $cf1ac5d9fe0e8206$export$722aac194ae923] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($cf1ac5d9fe0e8206$var$POPPER_NAME);
var [$cf1ac5d9fe0e8206$var$PopperProvider, $cf1ac5d9fe0e8206$var$usePopperContext] = $cf1ac5d9fe0e8206$var$createPopperContext($cf1ac5d9fe0e8206$var$POPPER_NAME);
var $cf1ac5d9fe0e8206$export$badac9ada3a0bdf9 = (props) => {
  const { __scopePopper, children } = props;
  const [anchor, setAnchor] = (0, import_react21.useState)(null);
  return /* @__PURE__ */ (0, import_react21.createElement)($cf1ac5d9fe0e8206$var$PopperProvider, {
    scope: __scopePopper,
    anchor,
    onAnchorChange: setAnchor
  }, children);
};
var $cf1ac5d9fe0e8206$var$ANCHOR_NAME = "PopperAnchor";
var $cf1ac5d9fe0e8206$export$ecd4e1ccab6ed6d = /* @__PURE__ */ (0, import_react21.forwardRef)((props, forwardedRef) => {
  const { __scopePopper, virtualRef, ...anchorProps } = props;
  const context = $cf1ac5d9fe0e8206$var$usePopperContext($cf1ac5d9fe0e8206$var$ANCHOR_NAME, __scopePopper);
  const ref = (0, import_react21.useRef)(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
  (0, import_react21.useEffect)(() => {
    context.onAnchorChange((virtualRef === null || virtualRef === void 0 ? void 0 : virtualRef.current) || ref.current);
  });
  return virtualRef ? null : /* @__PURE__ */ (0, import_react21.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({}, anchorProps, {
    ref: composedRefs
  }));
});
var $cf1ac5d9fe0e8206$var$CONTENT_NAME = "PopperContent";
var [$cf1ac5d9fe0e8206$var$PopperContentProvider, $cf1ac5d9fe0e8206$var$useContentContext] = $cf1ac5d9fe0e8206$var$createPopperContext($cf1ac5d9fe0e8206$var$CONTENT_NAME);
var [$cf1ac5d9fe0e8206$var$PositionContextProvider, $cf1ac5d9fe0e8206$var$usePositionContext] = $cf1ac5d9fe0e8206$var$createPopperContext($cf1ac5d9fe0e8206$var$CONTENT_NAME, {
  hasParent: false,
  positionUpdateFns: /* @__PURE__ */ new Set()
});
var $cf1ac5d9fe0e8206$export$bc4ae5855d3c4fc = /* @__PURE__ */ (0, import_react21.forwardRef)((props, forwardedRef) => {
  var _arrowSize$width, _arrowSize$height, _middlewareData$arrow, _middlewareData$arrow2, _middlewareData$arrow3, _middlewareData$hide, _middlewareData$trans, _middlewareData$trans2;
  const { __scopePopper, side = "bottom", sideOffset = 0, align = "center", alignOffset = 0, arrowPadding = 0, collisionBoundary = [], collisionPadding: collisionPaddingProp = 0, sticky = "partial", hideWhenDetached = false, avoidCollisions = true, onPlaced, ...contentProps } = props;
  const context = $cf1ac5d9fe0e8206$var$usePopperContext($cf1ac5d9fe0e8206$var$CONTENT_NAME, __scopePopper);
  const [content, setContent] = (0, import_react21.useState)(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(
    forwardedRef,
    (node) => setContent(node)
  );
  const [arrow2, setArrow] = (0, import_react21.useState)(null);
  const arrowSize = $db6c3485150b8e66$export$1ab7ae714698c4b8(arrow2);
  const arrowWidth = (_arrowSize$width = arrowSize === null || arrowSize === void 0 ? void 0 : arrowSize.width) !== null && _arrowSize$width !== void 0 ? _arrowSize$width : 0;
  const arrowHeight = (_arrowSize$height = arrowSize === null || arrowSize === void 0 ? void 0 : arrowSize.height) !== null && _arrowSize$height !== void 0 ? _arrowSize$height : 0;
  const desiredPlacement = side + (align !== "center" ? "-" + align : "");
  const collisionPadding = typeof collisionPaddingProp === "number" ? collisionPaddingProp : {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...collisionPaddingProp
  };
  const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [
    collisionBoundary
  ];
  const hasExplicitBoundaries = boundary.length > 0;
  const detectOverflowOptions = {
    padding: collisionPadding,
    boundary: boundary.filter($cf1ac5d9fe0e8206$var$isNotNull),
    // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
    altBoundary: hasExplicitBoundaries
  };
  const { reference, floating, strategy, x: x3, y: y3, placement, middlewareData, update } = useFloating({
    // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
    strategy: "fixed",
    placement: desiredPlacement,
    whileElementsMounted: N,
    middleware: [
      $cf1ac5d9fe0e8206$var$anchorCssProperties(),
      T({
        mainAxis: sideOffset + arrowHeight,
        alignmentAxis: alignOffset
      }),
      avoidCollisions ? D({
        mainAxis: true,
        crossAxis: false,
        limiter: sticky === "partial" ? L2() : void 0,
        ...detectOverflowOptions
      }) : void 0,
      arrow2 ? arrow({
        element: arrow2,
        padding: arrowPadding
      }) : void 0,
      avoidCollisions ? b2({
        ...detectOverflowOptions
      }) : void 0,
      k({
        ...detectOverflowOptions,
        apply: ({ elements, availableWidth: width, availableHeight: height }) => {
          elements.floating.style.setProperty("--radix-popper-available-width", `${width}px`);
          elements.floating.style.setProperty("--radix-popper-available-height", `${height}px`);
        }
      }),
      $cf1ac5d9fe0e8206$var$transformOrigin({
        arrowWidth,
        arrowHeight
      }),
      hideWhenDetached ? P({
        strategy: "referenceHidden"
      }) : void 0
    ].filter($cf1ac5d9fe0e8206$var$isDefined)
  });
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    reference(context.anchor);
  }, [
    reference,
    context.anchor
  ]);
  const isPlaced = x3 !== null && y3 !== null;
  const [placedSide, placedAlign] = $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement(placement);
  const handlePlaced = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onPlaced);
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    if (isPlaced)
      handlePlaced === null || handlePlaced === void 0 || handlePlaced();
  }, [
    isPlaced,
    handlePlaced
  ]);
  const arrowX = (_middlewareData$arrow = middlewareData.arrow) === null || _middlewareData$arrow === void 0 ? void 0 : _middlewareData$arrow.x;
  const arrowY = (_middlewareData$arrow2 = middlewareData.arrow) === null || _middlewareData$arrow2 === void 0 ? void 0 : _middlewareData$arrow2.y;
  const cannotCenterArrow = ((_middlewareData$arrow3 = middlewareData.arrow) === null || _middlewareData$arrow3 === void 0 ? void 0 : _middlewareData$arrow3.centerOffset) !== 0;
  const [contentZIndex, setContentZIndex] = (0, import_react21.useState)();
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    if (content)
      setContentZIndex(window.getComputedStyle(content).zIndex);
  }, [
    content
  ]);
  const { hasParent, positionUpdateFns } = $cf1ac5d9fe0e8206$var$usePositionContext($cf1ac5d9fe0e8206$var$CONTENT_NAME, __scopePopper);
  const isRoot = !hasParent;
  (0, import_react21.useLayoutEffect)(() => {
    if (!isRoot) {
      positionUpdateFns.add(update);
      return () => {
        positionUpdateFns.delete(update);
      };
    }
  }, [
    isRoot,
    positionUpdateFns,
    update
  ]);
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    if (isRoot && isPlaced)
      Array.from(positionUpdateFns).reverse().forEach(
        (fn) => requestAnimationFrame(fn)
      );
  }, [
    isRoot,
    isPlaced,
    positionUpdateFns
  ]);
  const commonProps2 = {
    "data-side": placedSide,
    "data-align": placedAlign,
    ...contentProps,
    ref: composedRefs,
    style: {
      ...contentProps.style,
      // if the PopperContent hasn't been placed yet (not all measurements done)
      // we prevent animations so that users's animation don't kick in too early referring wrong sides
      animation: !isPlaced ? "none" : void 0,
      // hide the content if using the hide middleware and should be hidden
      opacity: (_middlewareData$hide = middlewareData.hide) !== null && _middlewareData$hide !== void 0 && _middlewareData$hide.referenceHidden ? 0 : void 0
    }
  };
  return /* @__PURE__ */ (0, import_react21.createElement)("div", {
    ref: floating,
    "data-radix-popper-content-wrapper": "",
    style: {
      position: strategy,
      left: 0,
      top: 0,
      transform: isPlaced ? `translate3d(${Math.round(x3)}px, ${Math.round(y3)}px, 0)` : "translate3d(0, -200%, 0)",
      // keep off the page when measuring
      minWidth: "max-content",
      zIndex: contentZIndex,
      ["--radix-popper-transform-origin"]: [
        (_middlewareData$trans = middlewareData.transformOrigin) === null || _middlewareData$trans === void 0 ? void 0 : _middlewareData$trans.x,
        (_middlewareData$trans2 = middlewareData.transformOrigin) === null || _middlewareData$trans2 === void 0 ? void 0 : _middlewareData$trans2.y
      ].join(" ")
    },
    dir: props.dir
  }, /* @__PURE__ */ (0, import_react21.createElement)($cf1ac5d9fe0e8206$var$PopperContentProvider, {
    scope: __scopePopper,
    placedSide,
    onArrowChange: setArrow,
    arrowX,
    arrowY,
    shouldHideArrow: cannotCenterArrow
  }, isRoot ? /* @__PURE__ */ (0, import_react21.createElement)($cf1ac5d9fe0e8206$var$PositionContextProvider, {
    scope: __scopePopper,
    hasParent: true,
    positionUpdateFns
  }, /* @__PURE__ */ (0, import_react21.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, commonProps2)) : /* @__PURE__ */ (0, import_react21.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, commonProps2)));
});
var $cf1ac5d9fe0e8206$var$ARROW_NAME = "PopperArrow";
var $cf1ac5d9fe0e8206$var$OPPOSITE_SIDE = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var $cf1ac5d9fe0e8206$export$79d62cd4e10a3fd0 = /* @__PURE__ */ (0, import_react21.forwardRef)(function $cf1ac5d9fe0e8206$export$79d62cd4e10a3fd02(props, forwardedRef) {
  const { __scopePopper, ...arrowProps } = props;
  const contentContext = $cf1ac5d9fe0e8206$var$useContentContext($cf1ac5d9fe0e8206$var$ARROW_NAME, __scopePopper);
  const baseSide = $cf1ac5d9fe0e8206$var$OPPOSITE_SIDE[contentContext.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ (0, import_react21.createElement)("span", {
      ref: contentContext.onArrowChange,
      style: {
        position: "absolute",
        left: contentContext.arrowX,
        top: contentContext.arrowY,
        [baseSide]: 0,
        transformOrigin: {
          top: "",
          right: "0 0",
          bottom: "center 0",
          left: "100% 0"
        }[contentContext.placedSide],
        transform: {
          top: "translateY(100%)",
          right: "translateY(50%) rotate(90deg) translateX(-50%)",
          bottom: `rotate(180deg)`,
          left: "translateY(50%) rotate(-90deg) translateX(50%)"
        }[contentContext.placedSide],
        visibility: contentContext.shouldHideArrow ? "hidden" : void 0
      }
    }, /* @__PURE__ */ (0, import_react21.createElement)($7e8f5cd07187803e$export$be92b6f5f03c0fe9, _extends({}, arrowProps, {
      ref: forwardedRef,
      style: {
        ...arrowProps.style,
        // ensures the element can be measured correctly (mostly for if SVG)
        display: "block"
      }
    })))
  );
});
function $cf1ac5d9fe0e8206$var$isDefined(value) {
  return value !== void 0;
}
function $cf1ac5d9fe0e8206$var$isNotNull(value) {
  return value !== null;
}
var $cf1ac5d9fe0e8206$var$anchorCssProperties = () => ({
  name: "anchorCssProperties",
  fn(data) {
    const { rects, elements } = data;
    const { width, height } = rects.reference;
    elements.floating.style.setProperty("--radix-popper-anchor-width", `${width}px`);
    elements.floating.style.setProperty("--radix-popper-anchor-height", `${height}px`);
    return {};
  }
});
var $cf1ac5d9fe0e8206$var$transformOrigin = (options) => ({
  name: "transformOrigin",
  options,
  fn(data) {
    var _middlewareData$arrow4, _middlewareData$arrow5, _middlewareData$arrow6, _middlewareData$arrow7, _middlewareData$arrow8;
    const { placement, rects, middlewareData } = data;
    const cannotCenterArrow = ((_middlewareData$arrow4 = middlewareData.arrow) === null || _middlewareData$arrow4 === void 0 ? void 0 : _middlewareData$arrow4.centerOffset) !== 0;
    const isArrowHidden = cannotCenterArrow;
    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
    const [placedSide, placedAlign] = $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement(placement);
    const noArrowAlign = {
      start: "0%",
      center: "50%",
      end: "100%"
    }[placedAlign];
    const arrowXCenter = ((_middlewareData$arrow5 = (_middlewareData$arrow6 = middlewareData.arrow) === null || _middlewareData$arrow6 === void 0 ? void 0 : _middlewareData$arrow6.x) !== null && _middlewareData$arrow5 !== void 0 ? _middlewareData$arrow5 : 0) + arrowWidth / 2;
    const arrowYCenter = ((_middlewareData$arrow7 = (_middlewareData$arrow8 = middlewareData.arrow) === null || _middlewareData$arrow8 === void 0 ? void 0 : _middlewareData$arrow8.y) !== null && _middlewareData$arrow7 !== void 0 ? _middlewareData$arrow7 : 0) + arrowHeight / 2;
    let x3 = "";
    let y3 = "";
    if (placedSide === "bottom") {
      x3 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y3 = `${-arrowHeight}px`;
    } else if (placedSide === "top") {
      x3 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y3 = `${rects.floating.height + arrowHeight}px`;
    } else if (placedSide === "right") {
      x3 = `${-arrowHeight}px`;
      y3 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    } else if (placedSide === "left") {
      x3 = `${rects.floating.width + arrowHeight}px`;
      y3 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    }
    return {
      data: {
        x: x3,
        y: y3
      }
    };
  }
});
function $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement(placement) {
  const [side, align = "center"] = placement.split("-");
  return [
    side,
    align
  ];
}
var $cf1ac5d9fe0e8206$export$be92b6f5f03c0fe9 = $cf1ac5d9fe0e8206$export$badac9ada3a0bdf9;
var $cf1ac5d9fe0e8206$export$b688253958b8dfe7 = $cf1ac5d9fe0e8206$export$ecd4e1ccab6ed6d;
var $cf1ac5d9fe0e8206$export$7c6e2c02157bb7d2 = $cf1ac5d9fe0e8206$export$bc4ae5855d3c4fc;
var $cf1ac5d9fe0e8206$export$21b07c8f274aebd5 = $cf1ac5d9fe0e8206$export$79d62cd4e10a3fd0;

// ../../node_modules/@radix-ui/react-portal/dist/index.module.js
init_define_import_meta_env();
var import_react22 = __toESM(require_react());
var import_react_dom3 = __toESM(require_react_dom());
var $f1701beae083dbae$export$602eac185826482c = /* @__PURE__ */ (0, import_react22.forwardRef)((props, forwardedRef) => {
  var _globalThis$document;
  const { container = globalThis === null || globalThis === void 0 ? void 0 : (_globalThis$document = globalThis.document) === null || _globalThis$document === void 0 ? void 0 : _globalThis$document.body, ...portalProps } = props;
  return container ? /* @__PURE__ */ import_react_dom3.default.createPortal(/* @__PURE__ */ (0, import_react22.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({}, portalProps, {
    ref: forwardedRef
  })), container) : null;
});

// ../../node_modules/@radix-ui/react-presence/dist/index.module.js
init_define_import_meta_env();
var import_react23 = __toESM(require_react());
var import_react_dom4 = __toESM(require_react_dom());
function $fe963b355347cc68$export$3e6543de14f8614f(initialState, machine) {
  return (0, import_react23.useReducer)((state, event) => {
    const nextState = machine[state][event];
    return nextState !== null && nextState !== void 0 ? nextState : state;
  }, initialState);
}
var $921a889cee6df7e8$export$99c2b779aa4e8b8b = (props) => {
  const { present, children } = props;
  const presence = $921a889cee6df7e8$var$usePresence(present);
  const child = typeof children === "function" ? children({
    present: presence.isPresent
  }) : import_react23.Children.only(children);
  const ref = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(presence.ref, child.ref);
  const forceMount = typeof children === "function";
  return forceMount || presence.isPresent ? /* @__PURE__ */ (0, import_react23.cloneElement)(child, {
    ref
  }) : null;
};
$921a889cee6df7e8$export$99c2b779aa4e8b8b.displayName = "Presence";
function $921a889cee6df7e8$var$usePresence(present) {
  const [node1, setNode] = (0, import_react23.useState)();
  const stylesRef = (0, import_react23.useRef)({});
  const prevPresentRef = (0, import_react23.useRef)(present);
  const prevAnimationNameRef = (0, import_react23.useRef)("none");
  const initialState = present ? "mounted" : "unmounted";
  const [state, send] = $fe963b355347cc68$export$3e6543de14f8614f(initialState, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  (0, import_react23.useEffect)(() => {
    const currentAnimationName = $921a889cee6df7e8$var$getAnimationName(stylesRef.current);
    prevAnimationNameRef.current = state === "mounted" ? currentAnimationName : "none";
  }, [
    state
  ]);
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    const styles = stylesRef.current;
    const wasPresent = prevPresentRef.current;
    const hasPresentChanged = wasPresent !== present;
    if (hasPresentChanged) {
      const prevAnimationName = prevAnimationNameRef.current;
      const currentAnimationName = $921a889cee6df7e8$var$getAnimationName(styles);
      if (present)
        send("MOUNT");
      else if (currentAnimationName === "none" || (styles === null || styles === void 0 ? void 0 : styles.display) === "none")
        send("UNMOUNT");
      else {
        const isAnimating = prevAnimationName !== currentAnimationName;
        if (wasPresent && isAnimating)
          send("ANIMATION_OUT");
        else
          send("UNMOUNT");
      }
      prevPresentRef.current = present;
    }
  }, [
    present,
    send
  ]);
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    if (node1) {
      const handleAnimationEnd = (event) => {
        const currentAnimationName = $921a889cee6df7e8$var$getAnimationName(stylesRef.current);
        const isCurrentAnimation = currentAnimationName.includes(event.animationName);
        if (event.target === node1 && isCurrentAnimation)
          (0, import_react_dom4.flushSync)(
            () => send("ANIMATION_END")
          );
      };
      const handleAnimationStart = (event) => {
        if (event.target === node1)
          prevAnimationNameRef.current = $921a889cee6df7e8$var$getAnimationName(stylesRef.current);
      };
      node1.addEventListener("animationstart", handleAnimationStart);
      node1.addEventListener("animationcancel", handleAnimationEnd);
      node1.addEventListener("animationend", handleAnimationEnd);
      return () => {
        node1.removeEventListener("animationstart", handleAnimationStart);
        node1.removeEventListener("animationcancel", handleAnimationEnd);
        node1.removeEventListener("animationend", handleAnimationEnd);
      };
    } else
      send("ANIMATION_END");
  }, [
    node1,
    send
  ]);
  return {
    isPresent: [
      "mounted",
      "unmountSuspended"
    ].includes(state),
    ref: (0, import_react23.useCallback)((node) => {
      if (node)
        stylesRef.current = getComputedStyle(node);
      setNode(node);
    }, [])
  };
}
function $921a889cee6df7e8$var$getAnimationName(styles) {
  return (styles === null || styles === void 0 ? void 0 : styles.animationName) || "none";
}

// ../../node_modules/@radix-ui/react-use-controllable-state/dist/index.module.js
init_define_import_meta_env();
var import_react24 = __toESM(require_react());
function $71cd76cc60e0454e$export$6f32135080cb4c3({ prop, defaultProp, onChange = () => {
} }) {
  const [uncontrolledProp, setUncontrolledProp] = $71cd76cc60e0454e$var$useUncontrolledState({
    defaultProp,
    onChange
  });
  const isControlled = prop !== void 0;
  const value1 = isControlled ? prop : uncontrolledProp;
  const handleChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onChange);
  const setValue = (0, import_react24.useCallback)((nextValue) => {
    if (isControlled) {
      const setter = nextValue;
      const value = typeof nextValue === "function" ? setter(prop) : nextValue;
      if (value !== prop)
        handleChange(value);
    } else
      setUncontrolledProp(nextValue);
  }, [
    isControlled,
    prop,
    setUncontrolledProp,
    handleChange
  ]);
  return [
    value1,
    setValue
  ];
}
function $71cd76cc60e0454e$var$useUncontrolledState({ defaultProp, onChange }) {
  const uncontrolledState = (0, import_react24.useState)(defaultProp);
  const [value] = uncontrolledState;
  const prevValueRef = (0, import_react24.useRef)(value);
  const handleChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onChange);
  (0, import_react24.useEffect)(() => {
    if (prevValueRef.current !== value) {
      handleChange(value);
      prevValueRef.current = value;
    }
  }, [
    value,
    prevValueRef,
    handleChange
  ]);
  return uncontrolledState;
}

// ../../node_modules/aria-hidden/dist/es2015/index.js
init_define_import_meta_env();
var getDefaultParent = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = function(node) {
  return node && (node.host || unwrapHost(node.parentNode));
};
var correctTargets = function(parent, targets) {
  return targets.map(function(target) {
    if (parent.contains(target)) {
      return target;
    }
    var correctedTarget = unwrapHost(target);
    if (correctedTarget && parent.contains(correctedTarget)) {
      return correctedTarget;
    }
    console.error("aria-hidden", target, "in not contained inside", parent, ". Doing nothing");
    return null;
  }).filter(function(x3) {
    return Boolean(x3);
  });
};
var applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
  var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  var markerCounter = markerMap[markerName];
  var hiddenNodes = [];
  var elementsToKeep = /* @__PURE__ */ new Set();
  var elementsToStop = new Set(targets);
  var keep = function(el) {
    if (!el || elementsToKeep.has(el)) {
      return;
    }
    elementsToKeep.add(el);
    keep(el.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, function(node) {
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        var attr = node.getAttribute(controlAttribute);
        var alreadyHidden = attr !== null && attr !== "false";
        var counterValue = (counterMap.get(node) || 0) + 1;
        var markerValue = (markerCounter.get(node) || 0) + 1;
        counterMap.set(node, counterValue);
        markerCounter.set(node, markerValue);
        hiddenNodes.push(node);
        if (counterValue === 1 && alreadyHidden) {
          uncontrolledNodes.set(node, true);
        }
        if (markerValue === 1) {
          node.setAttribute(markerName, "true");
        }
        if (!alreadyHidden) {
          node.setAttribute(controlAttribute, "true");
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return function() {
    hiddenNodes.forEach(function(node) {
      var counterValue = counterMap.get(node) - 1;
      var markerValue = markerCounter.get(node) - 1;
      counterMap.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node)) {
          node.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node);
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
var hideOthers = function(originalTarget, parentNode, markerName) {
  if (markerName === void 0) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  var activeParentNode = parentNode || getDefaultParent(originalTarget);
  if (!activeParentNode) {
    return function() {
      return null;
    };
  }
  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live]")));
  return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
};

// ../../node_modules/react-remove-scroll/dist/es2015/index.js
init_define_import_meta_env();

// ../../node_modules/react-remove-scroll/dist/es2015/Combination.js
init_define_import_meta_env();

// ../../node_modules/tslib/tslib.es6.js
init_define_import_meta_env();
var __assign = function() {
  __assign = Object.assign || function __assign3(t4) {
    for (var s4, i4 = 1, n4 = arguments.length; i4 < n4; i4++) {
      s4 = arguments[i4];
      for (var p3 in s4)
        if (Object.prototype.hasOwnProperty.call(s4, p3))
          t4[p3] = s4[p3];
    }
    return t4;
  };
  return __assign.apply(this, arguments);
};
function __rest(s4, e3) {
  var t4 = {};
  for (var p3 in s4)
    if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
      t4[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i4 = 0, p3 = Object.getOwnPropertySymbols(s4); i4 < p3.length; i4++) {
      if (e3.indexOf(p3[i4]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i4]))
        t4[p3[i4]] = s4[p3[i4]];
    }
  return t4;
}
function __spreadArray(to, from3, pack) {
  if (pack || arguments.length === 2)
    for (var i4 = 0, l4 = from3.length, ar; i4 < l4; i4++) {
      if (ar || !(i4 in from3)) {
        if (!ar)
          ar = Array.prototype.slice.call(from3, 0, i4);
        ar[i4] = from3[i4];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from3));
}

// ../../node_modules/react-remove-scroll/dist/es2015/Combination.js
var React10 = __toESM(require_react());

// ../../node_modules/react-remove-scroll/dist/es2015/UI.js
init_define_import_meta_env();
var React6 = __toESM(require_react());

// ../../node_modules/react-remove-scroll-bar/dist/es2015/constants.js
init_define_import_meta_env();
var zeroRightClassName = "right-scroll-bar-position";
var fullWidthClassName = "width-before-scroll-bar";
var noScrollbarsClassName = "with-scroll-bars-hidden";
var removedBarSizeVariable = "--removed-body-scroll-bar-size";

// ../../node_modules/use-callback-ref/dist/es2015/index.js
init_define_import_meta_env();

// ../../node_modules/use-callback-ref/dist/es2015/assignRef.js
init_define_import_meta_env();
function assignRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}

// ../../node_modules/use-callback-ref/dist/es2015/useRef.js
init_define_import_meta_env();
var import_react25 = __toESM(require_react());
function useCallbackRef(initialValue, callback) {
  var ref = (0, import_react25.useState)(function() {
    return {
      // value
      value: initialValue,
      // last callback
      callback,
      // "memoized" public interface
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last = ref.value;
          if (last !== value) {
            ref.value = value;
            ref.callback(value, last);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}

// ../../node_modules/use-callback-ref/dist/es2015/useMergeRef.js
init_define_import_meta_env();
function useMergeRefs(refs, defaultValue) {
  return useCallbackRef(defaultValue || null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef(ref, newValue);
    });
  });
}

// ../../node_modules/react-remove-scroll/dist/es2015/medium.js
init_define_import_meta_env();

// ../../node_modules/use-sidecar/dist/es2015/index.js
init_define_import_meta_env();

// ../../node_modules/use-sidecar/node_modules/tslib/tslib.es6.mjs
init_define_import_meta_env();
var __assign2 = function() {
  __assign2 = Object.assign || function __assign3(t4) {
    for (var s4, i4 = 1, n4 = arguments.length; i4 < n4; i4++) {
      s4 = arguments[i4];
      for (var p3 in s4)
        if (Object.prototype.hasOwnProperty.call(s4, p3))
          t4[p3] = s4[p3];
    }
    return t4;
  };
  return __assign2.apply(this, arguments);
};
function __rest2(s4, e3) {
  var t4 = {};
  for (var p3 in s4)
    if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
      t4[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i4 = 0, p3 = Object.getOwnPropertySymbols(s4); i4 < p3.length; i4++) {
      if (e3.indexOf(p3[i4]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i4]))
        t4[p3[i4]] = s4[p3[i4]];
    }
  return t4;
}

// ../../node_modules/use-sidecar/dist/es2015/medium.js
init_define_import_meta_env();
function ItoI(a4) {
  return a4;
}
function innerCreateMedium(defaults, middleware) {
  if (middleware === void 0) {
    middleware = ItoI;
  }
  var buffer = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer.length) {
        return buffer[buffer.length - 1];
      }
      return defaults;
    },
    useMedium: function(data) {
      var item = middleware(data, assigned);
      buffer.push(item);
      return function() {
        buffer = buffer.filter(function(x3) {
          return x3 !== item;
        });
      };
    },
    assignSyncMedium: function(cb) {
      assigned = true;
      while (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
      }
      buffer = {
        push: function(x3) {
          return cb(x3);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb) {
      assigned = true;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
        pendingQueue = buffer;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer = {
        push: function(x3) {
          pendingQueue.push(x3);
          cycle();
        },
        filter: function(filter) {
          pendingQueue = pendingQueue.filter(filter);
          return buffer;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium(options) {
  if (options === void 0) {
    options = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign2({ async: true, ssr: false }, options);
  return medium;
}

// ../../node_modules/use-sidecar/dist/es2015/exports.js
init_define_import_meta_env();
var React5 = __toESM(require_react());
var SideCar = function(_a) {
  var sideCar = _a.sideCar, rest = __rest2(_a, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return React5.createElement(Target, __assign2({}, rest));
};
SideCar.isSideCarExport = true;
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar;
}

// ../../node_modules/react-remove-scroll/dist/es2015/medium.js
var effectCar = createSidecarMedium();

// ../../node_modules/react-remove-scroll/dist/es2015/UI.js
var nothing = function() {
  return;
};
var RemoveScroll = React6.forwardRef(function(props, parentRef) {
  var ref = React6.useRef(null);
  var _a = React6.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a[0], setCallbacks = _a[1];
  var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container = _b === void 0 ? "div" : _b, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs([ref, parentRef]);
  var containerProps = __assign(__assign({}, rest), callbacks);
  return React6.createElement(
    React6.Fragment,
    null,
    enabled && React6.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref }),
    forwardProps ? React6.cloneElement(React6.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : React6.createElement(Container, __assign({}, containerProps, { className, ref: containerRef }), children)
  );
});
RemoveScroll.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};

// ../../node_modules/react-remove-scroll/dist/es2015/sidecar.js
init_define_import_meta_env();

// ../../node_modules/react-remove-scroll/dist/es2015/SideEffect.js
init_define_import_meta_env();
var React9 = __toESM(require_react());

// ../../node_modules/react-remove-scroll-bar/dist/es2015/index.js
init_define_import_meta_env();

// ../../node_modules/react-remove-scroll-bar/dist/es2015/component.js
init_define_import_meta_env();
var React8 = __toESM(require_react());

// ../../node_modules/react-style-singleton/dist/es2015/index.js
init_define_import_meta_env();

// ../../node_modules/react-style-singleton/dist/es2015/component.js
init_define_import_meta_env();

// ../../node_modules/react-style-singleton/dist/es2015/hook.js
init_define_import_meta_env();
var React7 = __toESM(require_react());

// ../../node_modules/react-style-singleton/dist/es2015/singleton.js
init_define_import_meta_env();

// ../../node_modules/get-nonce/dist/es2015/index.js
init_define_import_meta_env();
var currentNonce;
var getNonce = function() {
  if (currentNonce) {
    return currentNonce;
  }
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return void 0;
};

// ../../node_modules/react-style-singleton/dist/es2015/singleton.js
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce();
  if (nonce) {
    tag.setAttribute("nonce", nonce);
  }
  return tag;
}
function injectStyles(tag, css) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css;
  } else {
    tag.appendChild(document.createTextNode(css));
  }
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  var counter = 0;
  var stylesheet = null;
  return {
    add: function(style) {
      if (counter == 0) {
        if (stylesheet = makeStyleTag()) {
          injectStyles(stylesheet, style);
          insertStyleTag(stylesheet);
        }
      }
      counter++;
    },
    remove: function() {
      counter--;
      if (!counter && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};

// ../../node_modules/react-style-singleton/dist/es2015/hook.js
var styleHookSingleton = function() {
  var sheet = stylesheetSingleton();
  return function(styles, isDynamic) {
    React7.useEffect(function() {
      sheet.add(styles);
      return function() {
        sheet.remove();
      };
    }, [styles && isDynamic]);
  };
};

// ../../node_modules/react-style-singleton/dist/es2015/component.js
var styleSingleton = function() {
  var useStyle = styleHookSingleton();
  var Sheet = function(_a) {
    var styles = _a.styles, dynamic = _a.dynamic;
    useStyle(styles, dynamic);
    return null;
  };
  return Sheet;
};

// ../../node_modules/react-remove-scroll-bar/dist/es2015/utils.js
init_define_import_meta_env();
var zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse = function(x3) {
  return parseInt(x3 || "", 10) || 0;
};
var getOffset = function(gapMode) {
  var cs = window.getComputedStyle(document.body);
  var left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top2 = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse(left), parse(top2), parse(right)];
};
var getGapWidth = function(gapMode) {
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap;
  }
  var offsets = getOffset(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};

// ../../node_modules/react-remove-scroll-bar/dist/es2015/component.js
var Style = styleSingleton();
var getStyles = function(_a, allowRelative, gapMode, important) {
  var left = _a.left, top2 = _a.top, right = _a.right, gap = _a.gap;
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top2, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "),
    gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
  ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body {\n    ").concat(removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
};
var RemoveScrollBar = function(props) {
  var noRelative = props.noRelative, noImportant = props.noImportant, _a = props.gapMode, gapMode = _a === void 0 ? "margin" : _a;
  var gap = React8.useMemo(function() {
    return getGapWidth(gapMode);
  }, [gapMode]);
  return React8.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
};

// ../../node_modules/react-remove-scroll/dist/es2015/aggresiveCapture.js
init_define_import_meta_env();
var passiveSupported = false;
if (typeof window !== "undefined") {
  try {
    options = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported = true;
        return true;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (err) {
    passiveSupported = false;
  }
}
var options;
var nonPassive = passiveSupported ? { passive: false } : false;

// ../../node_modules/react-remove-scroll/dist/es2015/handleScroll.js
init_define_import_meta_env();
var alwaysContainsScroll = function(node) {
  return node.tagName === "TEXTAREA";
};
var elementCanBeScrolled = function(node, overflow) {
  var styles = window.getComputedStyle(node);
  return (
    // not-not-scrollable
    styles[overflow] !== "hidden" && // contains scroll inside self
    !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === "visible")
  );
};
var elementCouldBeVScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowY");
};
var elementCouldBeHScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowX");
};
var locationCouldBeScrolled = function(axis, node) {
  var current = node;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable = elementCouldBeScrolled(axis, current);
    if (isScrollable) {
      var _a = getScrollVariables(axis, current), s4 = _a[1], d3 = _a[2];
      if (s4 > d3) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== document.body);
  return false;
};
var getVScrollVariables = function(_a) {
  var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
};
var getHScrollVariables = function(_a) {
  var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
};
var elementCouldBeScrolled = function(axis, node) {
  return axis === "v" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
};
var getScrollVariables = function(axis, node) {
  return axis === "v" ? getVScrollVariables(node) : getHScrollVariables(node);
};
var getDirectionFactor = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
};
var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    var _a = getScrollVariables(axis, target), position = _a[0], scroll_1 = _a[1], capacity = _a[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position;
    if (position || elementScroll) {
      if (elementCouldBeScrolled(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position;
      }
    }
    target = target.parentNode;
  } while (
    // portaled content
    !targetInLock && target !== document.body || // self content
    targetInLock && (endTarget.contains(target) || endTarget === target)
  );
  if (isDeltaPositive && (noOverscroll && availableScroll === 0 || !noOverscroll && delta > availableScroll)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (noOverscroll && availableScrollTop === 0 || !noOverscroll && -delta > availableScrollTop)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};

// ../../node_modules/react-remove-scroll/dist/es2015/SideEffect.js
var getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare = function(x3, y3) {
  return x3[0] === y3[0] && x3[1] === y3[1];
};
var generateStyle = function(id) {
  return "\n  .block-interactivity-".concat(id, " {pointer-events: none;}\n  .allow-interactivity-").concat(id, " {pointer-events: all;}\n");
};
var idCounter = 0;
var lockStack = [];
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = React9.useRef([]);
  var touchStartRef = React9.useRef([0, 0]);
  var activeAxis = React9.useRef();
  var id = React9.useState(idCounter++)[0];
  var Style2 = React9.useState(function() {
    return styleSingleton();
  })[0];
  var lastProps = React9.useRef(props);
  React9.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  React9.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id));
      var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
      allow_1.forEach(function(el) {
        return el.classList.add("allow-interactivity-".concat(id));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id));
        allow_1.forEach(function(el) {
          return el.classList.remove("allow-interactivity-".concat(id));
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = React9.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY, true);
  }, []);
  var shouldPrevent = React9.useCallback(function(_event) {
    var event = _event;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e3) {
      return e3.name === event.type && e3.target === event.target && deltaCompare(e3.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node) {
        return node.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = React9.useCallback(function(name, delta, target, should) {
    var event = { name, delta, target, should };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e3) {
        return e3 !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = React9.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = React9.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = React9.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  React9.useEffect(function() {
    lockStack.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive);
    document.addEventListener("touchmove", shouldPrevent, nonPassive);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive);
    return function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return React9.createElement(
    React9.Fragment,
    null,
    inert ? React9.createElement(Style2, { styles: generateStyle(id) }) : null,
    removeScrollBar ? React9.createElement(RemoveScrollBar, { gapMode: "margin" }) : null
  );
}

// ../../node_modules/react-remove-scroll/dist/es2015/sidecar.js
var sidecar_default = exportSidecar(effectCar, RemoveScrollSideCar);

// ../../node_modules/react-remove-scroll/dist/es2015/Combination.js
var ReactRemoveScroll = React10.forwardRef(function(props, ref) {
  return React10.createElement(RemoveScroll, __assign({}, props, { ref, sideCar: sidecar_default }));
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
var Combination_default = ReactRemoveScroll;

// ../../node_modules/@radix-ui/react-popover/dist/index.module.js
var $cb5cc270b50c6fcd$var$POPOVER_NAME = "Popover";
var [$cb5cc270b50c6fcd$var$createPopoverContext, $cb5cc270b50c6fcd$export$c8393c9e73286932] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($cb5cc270b50c6fcd$var$POPOVER_NAME, [
  $cf1ac5d9fe0e8206$export$722aac194ae923
]);
var $cb5cc270b50c6fcd$var$usePopperScope = $cf1ac5d9fe0e8206$export$722aac194ae923();
var [$cb5cc270b50c6fcd$var$PopoverProvider, $cb5cc270b50c6fcd$var$usePopoverContext] = $cb5cc270b50c6fcd$var$createPopoverContext($cb5cc270b50c6fcd$var$POPOVER_NAME);
var $cb5cc270b50c6fcd$export$5b6b19405a83ff9d = (props) => {
  const { __scopePopover, children, open: openProp, defaultOpen, onOpenChange, modal = false } = props;
  const popperScope = $cb5cc270b50c6fcd$var$usePopperScope(__scopePopover);
  const triggerRef = (0, import_react26.useRef)(null);
  const [hasCustomAnchor, setHasCustomAnchor] = (0, import_react26.useState)(false);
  const [open = false, setOpen] = $71cd76cc60e0454e$export$6f32135080cb4c3({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  return /* @__PURE__ */ (0, import_react26.createElement)($cf1ac5d9fe0e8206$export$be92b6f5f03c0fe9, popperScope, /* @__PURE__ */ (0, import_react26.createElement)($cb5cc270b50c6fcd$var$PopoverProvider, {
    scope: __scopePopover,
    contentId: $1746a345f3d73bb7$export$f680877a34711e37(),
    triggerRef,
    open,
    onOpenChange: setOpen,
    onOpenToggle: (0, import_react26.useCallback)(
      () => setOpen(
        (prevOpen) => !prevOpen
      ),
      [
        setOpen
      ]
    ),
    hasCustomAnchor,
    onCustomAnchorAdd: (0, import_react26.useCallback)(
      () => setHasCustomAnchor(true),
      []
    ),
    onCustomAnchorRemove: (0, import_react26.useCallback)(
      () => setHasCustomAnchor(false),
      []
    ),
    modal
  }, children));
};
var $cb5cc270b50c6fcd$var$TRIGGER_NAME = "PopoverTrigger";
var $cb5cc270b50c6fcd$export$7dacb05d26466c3 = /* @__PURE__ */ (0, import_react26.forwardRef)((props, forwardedRef) => {
  const { __scopePopover, ...triggerProps } = props;
  const context = $cb5cc270b50c6fcd$var$usePopoverContext($cb5cc270b50c6fcd$var$TRIGGER_NAME, __scopePopover);
  const popperScope = $cb5cc270b50c6fcd$var$usePopperScope(__scopePopover);
  const composedTriggerRef = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, context.triggerRef);
  const trigger = /* @__PURE__ */ (0, import_react26.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.button, _extends({
    type: "button",
    "aria-haspopup": "dialog",
    "aria-expanded": context.open,
    "aria-controls": context.contentId,
    "data-state": $cb5cc270b50c6fcd$var$getState(context.open)
  }, triggerProps, {
    ref: composedTriggerRef,
    onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onClick, context.onOpenToggle)
  }));
  return context.hasCustomAnchor ? trigger : /* @__PURE__ */ (0, import_react26.createElement)($cf1ac5d9fe0e8206$export$b688253958b8dfe7, _extends({
    asChild: true
  }, popperScope), trigger);
});
var $cb5cc270b50c6fcd$var$PORTAL_NAME = "PopoverPortal";
var [$cb5cc270b50c6fcd$var$PortalProvider, $cb5cc270b50c6fcd$var$usePortalContext] = $cb5cc270b50c6fcd$var$createPopoverContext($cb5cc270b50c6fcd$var$PORTAL_NAME, {
  forceMount: void 0
});
var $cb5cc270b50c6fcd$export$dd679ffb4362d2d4 = (props) => {
  const { __scopePopover, forceMount, children, container } = props;
  const context = $cb5cc270b50c6fcd$var$usePopoverContext($cb5cc270b50c6fcd$var$PORTAL_NAME, __scopePopover);
  return /* @__PURE__ */ (0, import_react26.createElement)($cb5cc270b50c6fcd$var$PortalProvider, {
    scope: __scopePopover,
    forceMount
  }, /* @__PURE__ */ (0, import_react26.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
    present: forceMount || context.open
  }, /* @__PURE__ */ (0, import_react26.createElement)($f1701beae083dbae$export$602eac185826482c, {
    asChild: true,
    container
  }, children)));
};
var $cb5cc270b50c6fcd$var$CONTENT_NAME = "PopoverContent";
var $cb5cc270b50c6fcd$export$d7e1f420b25549ff = /* @__PURE__ */ (0, import_react26.forwardRef)((props, forwardedRef) => {
  const portalContext = $cb5cc270b50c6fcd$var$usePortalContext($cb5cc270b50c6fcd$var$CONTENT_NAME, props.__scopePopover);
  const { forceMount = portalContext.forceMount, ...contentProps } = props;
  const context = $cb5cc270b50c6fcd$var$usePopoverContext($cb5cc270b50c6fcd$var$CONTENT_NAME, props.__scopePopover);
  return /* @__PURE__ */ (0, import_react26.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
    present: forceMount || context.open
  }, context.modal ? /* @__PURE__ */ (0, import_react26.createElement)($cb5cc270b50c6fcd$var$PopoverContentModal, _extends({}, contentProps, {
    ref: forwardedRef
  })) : /* @__PURE__ */ (0, import_react26.createElement)($cb5cc270b50c6fcd$var$PopoverContentNonModal, _extends({}, contentProps, {
    ref: forwardedRef
  })));
});
var $cb5cc270b50c6fcd$var$PopoverContentModal = /* @__PURE__ */ (0, import_react26.forwardRef)((props, forwardedRef) => {
  const context = $cb5cc270b50c6fcd$var$usePopoverContext($cb5cc270b50c6fcd$var$CONTENT_NAME, props.__scopePopover);
  const contentRef = (0, import_react26.useRef)(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, contentRef);
  const isRightClickOutsideRef = (0, import_react26.useRef)(false);
  (0, import_react26.useEffect)(() => {
    const content = contentRef.current;
    if (content)
      return hideOthers(content);
  }, []);
  return /* @__PURE__ */ (0, import_react26.createElement)(Combination_default, {
    as: $5e63c961fc1ce211$export$8c6ed5c666ac1360,
    allowPinchZoom: true
  }, /* @__PURE__ */ (0, import_react26.createElement)($cb5cc270b50c6fcd$var$PopoverContentImpl, _extends({}, props, {
    ref: composedRefs,
    trapFocus: context.open,
    disableOutsidePointerEvents: true,
    onCloseAutoFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onCloseAutoFocus, (event) => {
      var _context$triggerRef$c;
      event.preventDefault();
      if (!isRightClickOutsideRef.current)
        (_context$triggerRef$c = context.triggerRef.current) === null || _context$triggerRef$c === void 0 || _context$triggerRef$c.focus();
    }),
    onPointerDownOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerDownOutside, (event) => {
      const originalEvent = event.detail.originalEvent;
      const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
      const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
      isRightClickOutsideRef.current = isRightClick;
    }, {
      checkForDefaultPrevented: false
    }),
    onFocusOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
      props.onFocusOutside,
      (event) => event.preventDefault(),
      {
        checkForDefaultPrevented: false
      }
    )
  })));
});
var $cb5cc270b50c6fcd$var$PopoverContentNonModal = /* @__PURE__ */ (0, import_react26.forwardRef)((props, forwardedRef) => {
  const context = $cb5cc270b50c6fcd$var$usePopoverContext($cb5cc270b50c6fcd$var$CONTENT_NAME, props.__scopePopover);
  const hasInteractedOutsideRef = (0, import_react26.useRef)(false);
  return /* @__PURE__ */ (0, import_react26.createElement)($cb5cc270b50c6fcd$var$PopoverContentImpl, _extends({}, props, {
    ref: forwardedRef,
    trapFocus: false,
    disableOutsidePointerEvents: false,
    onCloseAutoFocus: (event) => {
      var _props$onCloseAutoFoc;
      (_props$onCloseAutoFoc = props.onCloseAutoFocus) === null || _props$onCloseAutoFoc === void 0 || _props$onCloseAutoFoc.call(props, event);
      if (!event.defaultPrevented) {
        var _context$triggerRef$c2;
        if (!hasInteractedOutsideRef.current)
          (_context$triggerRef$c2 = context.triggerRef.current) === null || _context$triggerRef$c2 === void 0 || _context$triggerRef$c2.focus();
        event.preventDefault();
      }
      hasInteractedOutsideRef.current = false;
    },
    onInteractOutside: (event) => {
      var _props$onInteractOuts, _context$triggerRef$c3;
      (_props$onInteractOuts = props.onInteractOutside) === null || _props$onInteractOuts === void 0 || _props$onInteractOuts.call(props, event);
      if (!event.defaultPrevented)
        hasInteractedOutsideRef.current = true;
      const target = event.target;
      const targetIsTrigger = (_context$triggerRef$c3 = context.triggerRef.current) === null || _context$triggerRef$c3 === void 0 ? void 0 : _context$triggerRef$c3.contains(target);
      if (targetIsTrigger)
        event.preventDefault();
    }
  }));
});
var $cb5cc270b50c6fcd$var$PopoverContentImpl = /* @__PURE__ */ (0, import_react26.forwardRef)((props, forwardedRef) => {
  const { __scopePopover, trapFocus, onOpenAutoFocus, onCloseAutoFocus, disableOutsidePointerEvents, onEscapeKeyDown, onPointerDownOutside, onFocusOutside, onInteractOutside, ...contentProps } = props;
  const context = $cb5cc270b50c6fcd$var$usePopoverContext($cb5cc270b50c6fcd$var$CONTENT_NAME, __scopePopover);
  const popperScope = $cb5cc270b50c6fcd$var$usePopperScope(__scopePopover);
  $3db38b7d1fb3fe6a$export$b7ece24a22aeda8c();
  return /* @__PURE__ */ (0, import_react26.createElement)($d3863c46a17e8a28$export$20e40289641fbbb6, {
    asChild: true,
    loop: true,
    trapped: trapFocus,
    onMountAutoFocus: onOpenAutoFocus,
    onUnmountAutoFocus: onCloseAutoFocus
  }, /* @__PURE__ */ (0, import_react26.createElement)($5cb92bef7577960e$export$177fb62ff3ec1f22, {
    asChild: true,
    disableOutsidePointerEvents,
    onInteractOutside,
    onEscapeKeyDown,
    onPointerDownOutside,
    onFocusOutside,
    onDismiss: () => context.onOpenChange(false)
  }, /* @__PURE__ */ (0, import_react26.createElement)($cf1ac5d9fe0e8206$export$7c6e2c02157bb7d2, _extends({
    "data-state": $cb5cc270b50c6fcd$var$getState(context.open),
    role: "dialog",
    id: context.contentId
  }, popperScope, contentProps, {
    ref: forwardedRef,
    style: {
      ...contentProps.style,
      // re-namespace exposed content custom property
      ["--radix-popover-content-transform-origin"]: "var(--radix-popper-transform-origin)"
    }
  }))));
});
var $cb5cc270b50c6fcd$export$3152841115e061b2 = /* @__PURE__ */ (0, import_react26.forwardRef)((props, forwardedRef) => {
  const { __scopePopover, ...arrowProps } = props;
  const popperScope = $cb5cc270b50c6fcd$var$usePopperScope(__scopePopover);
  return /* @__PURE__ */ (0, import_react26.createElement)($cf1ac5d9fe0e8206$export$21b07c8f274aebd5, _extends({}, popperScope, arrowProps, {
    ref: forwardedRef
  }));
});
function $cb5cc270b50c6fcd$var$getState(open) {
  return open ? "open" : "closed";
}
var $cb5cc270b50c6fcd$export$be92b6f5f03c0fe9 = $cb5cc270b50c6fcd$export$5b6b19405a83ff9d;
var $cb5cc270b50c6fcd$export$41fb9f06171c75f4 = $cb5cc270b50c6fcd$export$7dacb05d26466c3;
var $cb5cc270b50c6fcd$export$602eac185826482c = $cb5cc270b50c6fcd$export$dd679ffb4362d2d4;
var $cb5cc270b50c6fcd$export$7c6e2c02157bb7d2 = $cb5cc270b50c6fcd$export$d7e1f420b25549ff;
var $cb5cc270b50c6fcd$export$21b07c8f274aebd5 = $cb5cc270b50c6fcd$export$3152841115e061b2;

// components/ColorPicker/ColorInput.tsx
init_define_import_meta_env();
var import_react32 = __toESM(require_react(), 1);

// components/EyeDropper.tsx
init_define_import_meta_env();
var import_react31 = __toESM(require_react(), 1);
var import_react_dom5 = __toESM(require_react_dom(), 1);

// context/ui-appState.ts
init_define_import_meta_env();
var import_react27 = __toESM(require_react(), 1);
var UIAppStateContext = import_react27.default.createContext(null);
var useUIAppState = () => import_react27.default.useContext(UIAppStateContext);

// hooks/useCreatePortalContainer.ts
init_define_import_meta_env();
var import_react28 = __toESM(require_react(), 1);
var useCreatePortalContainer = (opts) => {
  const [div, setDiv] = (0, import_react28.useState)(null);
  const device = useDevice();
  const { theme } = useUIAppState();
  const { container: excalidrawContainer } = useExcalidrawContainer();
  (0, import_react28.useLayoutEffect)(() => {
    if (div) {
      div.className = "";
      div.classList.add("excalidraw", ...opts?.className?.split(/\s+/) || []);
      div.classList.toggle("excalidraw--mobile", device.editor.isMobile);
      div.classList.toggle("theme--dark", theme === "dark");
    }
  }, [div, theme, device.editor.isMobile, opts?.className]);
  (0, import_react28.useLayoutEffect)(() => {
    const container = opts?.parentSelector ? excalidrawContainer?.querySelector(opts.parentSelector) : document.body;
    if (!container) {
      return;
    }
    const div2 = document.createElement("div");
    container.appendChild(div2);
    setDiv(div2);
    return () => {
      container.removeChild(div2);
    };
  }, [excalidrawContainer, opts?.parentSelector]);
  return div;
};

// hooks/useOutsideClick.ts
init_define_import_meta_env();
var import_react29 = __toESM(require_react(), 1);
function useOutsideClick(ref, callback, isInside) {
  (0, import_react29.useEffect)(() => {
    function onOutsideClick(event) {
      const _event = event;
      if (!ref.current) {
        return;
      }
      const isInsideOverride = isInside?.(_event, ref.current);
      if (isInsideOverride === true) {
        return;
      } else if (isInsideOverride === false) {
        return callback(_event);
      }
      if (ref.current.contains(_event.target) || // target is detached from DOM (happens when the element is removed
      // on a pointerup event fired *before* this handler's pointerup is
      // dispatched)
      !document.documentElement.contains(_event.target)) {
        return;
      }
      const isClickOnRadixPortal = _event.target.closest("[data-radix-portal]") || // when radix popup is in "modal" mode, it disables pointer events on
      // the `body` element, so the target element is going to be the `html`
      // (note: this won't work if we selectively re-enable pointer events on
      // specific elements as we do with navbar or excalidraw UI elements)
      _event.target === document.documentElement && document.body.style.pointerEvents === "none";
      if (isClickOnRadixPortal) {
        return;
      }
      if (_event.target.closest("[data-prevent-outside-click]")) {
        return;
      }
      callback(_event);
    }
    document.addEventListener("pointerdown" /* POINTER_DOWN */, onOutsideClick);
    document.addEventListener("touchstart" /* TOUCH_START */, onOutsideClick);
    return () => {
      document.removeEventListener("pointerdown" /* POINTER_DOWN */, onOutsideClick);
      document.removeEventListener("touchstart" /* TOUCH_START */, onOutsideClick);
    };
  }, [ref, callback, isInside]);
}

// hooks/useStable.ts
init_define_import_meta_env();
var import_react30 = __toESM(require_react(), 1);
var useStable = (value) => {
  const ref = (0, import_react30.useRef)(value);
  Object.assign(ref.current, value);
  return ref.current;
};

// components/EyeDropper.tsx
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
var activeEyeDropperAtom = atom2(null);
var EyeDropper = ({ onCancel, onChange, onSelect, colorPickerType }) => {
  const eyeDropperContainer = useCreatePortalContainer({
    className: "excalidraw-eye-dropper-backdrop",
    parentSelector: ".excalidraw-eye-dropper-container"
  });
  const appState = useUIAppState();
  const elements = useExcalidrawElements();
  const app = useApp();
  const selectedElements = getSelectedElements(elements, appState);
  const stableProps = useStable({
    app,
    onCancel,
    onChange,
    onSelect,
    selectedElements
  });
  const { container: excalidrawContainer } = useExcalidrawContainer();
  (0, import_react31.useEffect)(() => {
    const colorPreviewDiv = ref.current;
    if (!colorPreviewDiv || !app.canvas || !eyeDropperContainer) {
      return;
    }
    let isHoldingPointerDown = false;
    const ctx = app.canvas.getContext("2d");
    const getCurrentColor = ({
      clientX,
      clientY
    }) => {
      const pixel = ctx.getImageData(
        (clientX - appState.offsetLeft) * window.devicePixelRatio,
        (clientY - appState.offsetTop) * window.devicePixelRatio,
        1,
        1
      ).data;
      return rgbToHex(pixel[0], pixel[1], pixel[2]);
    };
    const mouseMoveListener = ({
      clientX,
      clientY,
      altKey
    }) => {
      colorPreviewDiv.style.top = `${clientY + 20}px`;
      colorPreviewDiv.style.left = `${clientX + 20}px`;
      const currentColor = getCurrentColor({ clientX, clientY });
      if (isHoldingPointerDown) {
        stableProps.onChange(
          colorPickerType,
          currentColor,
          stableProps.selectedElements,
          { altKey }
        );
      }
      colorPreviewDiv.style.background = currentColor;
    };
    const onCancel2 = () => {
      stableProps.onCancel();
    };
    const onSelect2 = (color, event) => {
      stableProps.onSelect(color, event);
    };
    const pointerDownListener = (event) => {
      isHoldingPointerDown = true;
      event.stopImmediatePropagation();
    };
    const pointerUpListener = (event) => {
      isHoldingPointerDown = false;
      excalidrawContainer?.focus();
      event.stopImmediatePropagation();
      event.preventDefault();
      onSelect2(getCurrentColor(event), event);
    };
    const keyDownListener = (event) => {
      if (event.key === KEYS.ESCAPE) {
        event.preventDefault();
        event.stopImmediatePropagation();
        onCancel2();
      }
    };
    eyeDropperContainer.tabIndex = -1;
    eyeDropperContainer.focus();
    mouseMoveListener({
      clientX: stableProps.app.lastViewportPosition.x,
      clientY: stableProps.app.lastViewportPosition.y,
      altKey: false
    });
    eyeDropperContainer.addEventListener("keydown" /* KEYDOWN */, keyDownListener);
    eyeDropperContainer.addEventListener(
      "pointerdown" /* POINTER_DOWN */,
      pointerDownListener
    );
    eyeDropperContainer.addEventListener("pointerup" /* POINTER_UP */, pointerUpListener);
    window.addEventListener("pointermove", mouseMoveListener, {
      passive: true
    });
    window.addEventListener("blur" /* BLUR */, onCancel2);
    return () => {
      isHoldingPointerDown = false;
      eyeDropperContainer.removeEventListener("keydown" /* KEYDOWN */, keyDownListener);
      eyeDropperContainer.removeEventListener(
        "pointerdown" /* POINTER_DOWN */,
        pointerDownListener
      );
      eyeDropperContainer.removeEventListener(
        "pointerup" /* POINTER_UP */,
        pointerUpListener
      );
      window.removeEventListener("pointermove", mouseMoveListener);
      window.removeEventListener("blur" /* BLUR */, onCancel2);
    };
  }, [
    stableProps,
    app.canvas,
    eyeDropperContainer,
    colorPickerType,
    excalidrawContainer,
    appState.offsetLeft,
    appState.offsetTop
  ]);
  const ref = (0, import_react31.useRef)(null);
  useOutsideClick(
    ref,
    () => {
      onCancel();
    },
    (event) => {
      if (event.target.closest(
        ".excalidraw-eye-dropper-trigger, .excalidraw-eye-dropper-backdrop"
      )) {
        return true;
      }
      return false;
    }
  );
  if (!eyeDropperContainer) {
    return null;
  }
  return (0, import_react_dom5.createPortal)(
    /* @__PURE__ */ (0, import_jsx_runtime13.jsx)("div", { ref, className: "excalidraw-eye-dropper-preview" }),
    eyeDropperContainer
  );
};

// components/ColorPicker/ColorInput.tsx
var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);
var ColorInput = ({
  color,
  onChange,
  label,
  colorPickerType
}) => {
  const device = useDevice();
  const [innerValue, setInnerValue] = (0, import_react32.useState)(color);
  const [activeSection, setActiveColorPickerSection] = useAtom(
    activeColorPickerSectionAtom
  );
  (0, import_react32.useEffect)(() => {
    setInnerValue(color);
  }, [color]);
  const changeColor = (0, import_react32.useCallback)(
    (inputValue) => {
      const value = inputValue.toLowerCase();
      const color2 = getColor(value);
      if (color2) {
        onChange(color2);
      }
      setInnerValue(value);
    },
    [onChange]
  );
  const inputRef = (0, import_react32.useRef)(null);
  const eyeDropperTriggerRef = (0, import_react32.useRef)(null);
  (0, import_react32.useEffect)(() => {
    if (inputRef.current) {
      inputRef.current.focus();
    }
  }, [activeSection]);
  const [eyeDropperState, setEyeDropperState] = useAtom(
    activeEyeDropperAtom,
    jotaiScope
  );
  (0, import_react32.useEffect)(() => {
    return () => {
      setEyeDropperState(null);
    };
  }, [setEyeDropperState]);
  return /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)("div", { className: "color-picker__input-label", children: [
    /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("div", { className: "color-picker__input-hash", children: "#" }),
    /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(
      "input",
      {
        ref: activeSection === "hex" ? inputRef : void 0,
        style: { border: 0, padding: 0 },
        spellCheck: false,
        className: "color-picker-input",
        "aria-label": label,
        onChange: (event) => {
          changeColor(event.target.value);
        },
        value: (innerValue || "").replace(/^#/, ""),
        onBlur: () => {
          setInnerValue(color);
        },
        tabIndex: -1,
        onFocus: () => setActiveColorPickerSection("hex"),
        onKeyDown: (event) => {
          if (event.key === KEYS.TAB) {
            return;
          } else if (event.key === KEYS.ESCAPE) {
            eyeDropperTriggerRef.current?.focus();
          }
          event.stopPropagation();
        }
      }
    ),
    !device.editor.isMobile && /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)(import_jsx_runtime14.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(
        "div",
        {
          style: {
            width: "1px",
            height: "1.25rem",
            backgroundColor: "var(--default-border-color)"
          }
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(
        "div",
        {
          ref: eyeDropperTriggerRef,
          className: clsx_m_default("excalidraw-eye-dropper-trigger", {
            selected: eyeDropperState
          }),
          onClick: () => setEyeDropperState(
            (s4) => s4 ? null : {
              keepOpenOnAlt: false,
              onSelect: (color2) => onChange(color2),
              colorPickerType
            }
          ),
          title: `${t(
            "labels.eyeDropper"
          )} \u2014 ${KEYS.I.toLocaleUpperCase()} or ${getShortcutKey("Alt")} `,
          children: eyeDropperIcon
        }
      )
    ] })
  ] });
};

// components/ColorPicker/ColorPicker.tsx
var import_react33 = __toESM(require_react(), 1);
var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);
var isValidColor = (color) => {
  const style = new Option().style;
  style.color = color;
  return !!style.color;
};
var getColor = (color) => {
  if (isTransparent(color)) {
    return color;
  }
  return isValidColor(`#${color}`) ? `#${color}` : isValidColor(color) ? color : null;
};
var ColorPickerPopupContent = ({
  type,
  color,
  onChange,
  label,
  elements,
  palette: palette2 = COLOR_PALETTE,
  updateData
}) => {
  const [, setActiveColorPickerSection] = useAtom(activeColorPickerSectionAtom);
  const [eyeDropperState, setEyeDropperState] = useAtom(
    activeEyeDropperAtom,
    jotaiScope
  );
  const { container } = useExcalidrawContainer();
  const device = useDevice();
  const colorInputJSX = /* @__PURE__ */ (0, import_jsx_runtime15.jsxs)("div", { children: [
    /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(PickerHeading_default, { children: t("colorPicker.hexCode") }),
    /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(
      ColorInput,
      {
        color,
        label,
        onChange: (color2) => {
          onChange(color2);
        },
        colorPickerType: type
      }
    )
  ] });
  const popoverRef = (0, import_react33.useRef)(null);
  const focusPickerContent = () => {
    popoverRef.current?.querySelector(".color-picker-content")?.focus();
  };
  return /* @__PURE__ */ (0, import_jsx_runtime15.jsx)($cb5cc270b50c6fcd$export$602eac185826482c, { container, children: /* @__PURE__ */ (0, import_jsx_runtime15.jsxs)(
    $cb5cc270b50c6fcd$export$7c6e2c02157bb7d2,
    {
      ref: popoverRef,
      className: "focus-visible-none",
      "data-prevent-outside-click": true,
      onFocusOutside: (event) => {
        focusPickerContent();
        event.preventDefault();
      },
      onPointerDownOutside: (event) => {
        if (eyeDropperState) {
          event.preventDefault();
        }
      },
      onCloseAutoFocus: (e3) => {
        e3.stopPropagation();
        e3.preventDefault();
        if (container && !isInteractive(document.activeElement)) {
          container.focus();
        }
        updateData({ openPopup: null });
        setActiveColorPickerSection(null);
      },
      side: device.editor.isMobile && !device.viewport.isLandscape ? "bottom" : "right",
      align: device.editor.isMobile && !device.viewport.isLandscape ? "center" : "start",
      alignOffset: -16,
      sideOffset: 20,
      style: {
        zIndex: "var(--zIndex-layerUI)",
        backgroundColor: "var(--popup-bg-color)",
        maxWidth: "208px",
        maxHeight: window.innerHeight,
        padding: "12px",
        borderRadius: "8px",
        boxSizing: "border-box",
        overflowY: "auto",
        boxShadow: "0px 7px 14px rgba(0, 0, 0, 0.05), 0px 0px 3.12708px rgba(0, 0, 0, 0.0798), 0px 0px 0.931014px rgba(0, 0, 0, 0.1702)"
      },
      children: [
        palette2 ? /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(
          Picker,
          {
            palette: palette2,
            color,
            onChange: (changedColor) => {
              onChange(changedColor);
            },
            onEyeDropperToggle: (force) => {
              setEyeDropperState((state) => {
                if (force) {
                  state = state || {
                    keepOpenOnAlt: true,
                    onSelect: onChange,
                    colorPickerType: type
                  };
                  state.keepOpenOnAlt = true;
                  return state;
                }
                return force === false || state ? null : {
                  keepOpenOnAlt: false,
                  onSelect: onChange,
                  colorPickerType: type
                };
              });
            },
            onEscape: (event) => {
              if (eyeDropperState) {
                setEyeDropperState(null);
              } else if (isWritableElement(event.target)) {
                focusPickerContent();
              } else {
                updateData({ openPopup: null });
              }
            },
            label,
            type,
            elements,
            updateData,
            children: colorInputJSX
          }
        ) : colorInputJSX,
        /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(
          $cb5cc270b50c6fcd$export$21b07c8f274aebd5,
          {
            width: 20,
            height: 10,
            style: {
              fill: "var(--popup-bg-color)",
              filter: "drop-shadow(rgba(0, 0, 0, 0.05) 0px 3px 2px)"
            }
          }
        )
      ]
    }
  ) });
};
var ColorPickerTrigger = ({
  label,
  color,
  type
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(
    $cb5cc270b50c6fcd$export$41fb9f06171c75f4,
    {
      type: "button",
      className: clsx_m_default("color-picker__button active-color", {
        "is-transparent": color === "transparent" || !color
      }),
      "aria-label": label,
      style: color ? { "--swatch-color": color } : void 0,
      title: type === "elementStroke" ? t("labels.showStroke") : t("labels.showBackground"),
      children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)("div", { className: "color-picker__button-outline" })
    }
  );
};
var ColorPicker = ({
  type,
  color,
  onChange,
  label,
  elements,
  palette: palette2 = COLOR_PALETTE,
  topPicks,
  updateData,
  appState
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime15.jsx)("div", { children: /* @__PURE__ */ (0, import_jsx_runtime15.jsxs)("div", { role: "dialog", "aria-modal": "true", className: "color-picker-container", children: [
    /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(
      TopPicks,
      {
        activeColor: color,
        onChange,
        type,
        topPicks
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(
      "div",
      {
        style: {
          width: 1,
          height: "100%",
          backgroundColor: "var(--default-border-color)",
          margin: "0 auto"
        }
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime15.jsxs)(
      $cb5cc270b50c6fcd$export$be92b6f5f03c0fe9,
      {
        open: appState.openPopup === type,
        onOpenChange: (open) => {
          updateData({ openPopup: open ? type : null });
        },
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(ColorPickerTrigger, { color, label, type }),
          appState.openPopup === type && /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(
            ColorPickerPopupContent,
            {
              type,
              color,
              onChange,
              label,
              elements,
              palette: palette2,
              updateData
            }
          )
        ]
      }
    )
  ] }) });
};

// components/IconPicker.tsx
init_define_import_meta_env();
var import_react35 = __toESM(require_react(), 1);

// components/Popover.tsx
init_define_import_meta_env();
var import_react34 = __toESM(require_react(), 1);
var import_react_dom6 = __toESM(require_react_dom(), 1);
var import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);
var Popover = ({
  children,
  left,
  top: top2,
  onCloseRequest,
  fitInViewport = false,
  offsetLeft = 0,
  offsetTop = 0,
  viewportWidth = window.innerWidth,
  viewportHeight = window.innerHeight
}) => {
  const popoverRef = (0, import_react34.useRef)(null);
  (0, import_react34.useEffect)(() => {
    const container = popoverRef.current;
    if (!container) {
      return;
    }
    if (!container.contains(document.activeElement)) {
      container.focus();
    }
    const handleKeyDown = (event) => {
      if (event.key === KEYS.TAB) {
        const focusableElements = queryFocusableElements(container);
        const { activeElement } = document;
        const currentIndex = focusableElements.findIndex(
          (element) => element === activeElement
        );
        if (activeElement === container) {
          if (event.shiftKey) {
            focusableElements[focusableElements.length - 1]?.focus();
          } else {
            focusableElements[0].focus();
          }
          event.preventDefault();
          event.stopImmediatePropagation();
        } else if (currentIndex === 0 && event.shiftKey) {
          focusableElements[focusableElements.length - 1]?.focus();
          event.preventDefault();
          event.stopImmediatePropagation();
        } else if (currentIndex === focusableElements.length - 1 && !event.shiftKey) {
          focusableElements[0]?.focus();
          event.preventDefault();
          event.stopImmediatePropagation();
        }
      }
    };
    container.addEventListener("keydown", handleKeyDown);
    return () => container.removeEventListener("keydown", handleKeyDown);
  }, []);
  const lastInitializedPosRef = (0, import_react34.useRef)(
    null
  );
  (0, import_react34.useLayoutEffect)(() => {
    if (fitInViewport && popoverRef.current && top2 != null && left != null) {
      const container = popoverRef.current;
      const { width, height } = container.getBoundingClientRect();
      if (lastInitializedPosRef.current?.top === top2 && lastInitializedPosRef.current?.left === left) {
        return;
      }
      lastInitializedPosRef.current = { top: top2, left };
      if (width >= viewportWidth) {
        container.style.width = `${viewportWidth}px`;
        container.style.left = "0px";
        container.style.overflowX = "scroll";
      } else if (left + width - offsetLeft > viewportWidth) {
        container.style.left = `${viewportWidth - width - 10}px`;
      } else {
        container.style.left = `${left}px`;
      }
      if (height >= viewportHeight) {
        container.style.height = `${viewportHeight - 20}px`;
        container.style.top = "10px";
        container.style.overflowY = "scroll";
      } else if (top2 + height - offsetTop > viewportHeight) {
        container.style.top = `${viewportHeight - height}px`;
      } else {
        container.style.top = `${top2}px`;
      }
    }
  }, [
    top2,
    left,
    fitInViewport,
    viewportWidth,
    viewportHeight,
    offsetLeft,
    offsetTop
  ]);
  (0, import_react34.useEffect)(() => {
    if (onCloseRequest) {
      const handler = (event) => {
        if (!popoverRef.current?.contains(event.target)) {
          (0, import_react_dom6.unstable_batchedUpdates)(() => onCloseRequest(event));
        }
      };
      document.addEventListener("pointerdown", handler, false);
      return () => document.removeEventListener("pointerdown", handler, false);
    }
  }, [onCloseRequest]);
  return /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("div", { className: "popover", ref: popoverRef, tabIndex: -1, children });
};

// components/IconPicker.tsx
var import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);
function Picker2({
  options,
  value,
  label,
  onChange,
  onClose
}) {
  const rFirstItem = import_react35.default.useRef();
  const rActiveItem = import_react35.default.useRef();
  const rGallery = import_react35.default.useRef(null);
  import_react35.default.useEffect(() => {
    if (rActiveItem.current) {
      rActiveItem.current.focus();
    } else if (rGallery.current) {
      rGallery.current.focus();
    }
  }, []);
  const handleKeyDown = (event) => {
    const pressedOption = options.find(
      (option) => option.keyBinding === event.key.toLowerCase()
    );
    if (!(event.metaKey || event.altKey || event.ctrlKey) && pressedOption) {
      const index2 = options.indexOf(pressedOption);
      rGallery.current.children[index2].focus();
      event.preventDefault();
    } else if (event.key === KEYS.TAB) {
      setTimeout(() => {
        const active = rActiveItem.current;
        const docActive = document.activeElement;
        if (active !== docActive) {
          onClose();
        }
      }, 0);
    } else if (isArrowKey(event.key)) {
      const { activeElement } = document;
      const isRTL2 = getLanguage().rtl;
      const index2 = Array.prototype.indexOf.call(
        rGallery.current.children,
        activeElement
      );
      if (index2 !== -1) {
        const length = options.length;
        let nextIndex = index2;
        switch (event.key) {
          case (isRTL2 ? KEYS.ARROW_LEFT : KEYS.ARROW_RIGHT):
          case KEYS.ARROW_DOWN: {
            nextIndex = (index2 + 1) % length;
            break;
          }
          case (isRTL2 ? KEYS.ARROW_RIGHT : KEYS.ARROW_LEFT):
          case KEYS.ARROW_UP: {
            nextIndex = (length + index2 - 1) % length;
            break;
          }
        }
        rGallery.current.children[nextIndex].focus();
      }
      event.preventDefault();
    } else if (event.key === KEYS.ESCAPE || event.key === KEYS.ENTER) {
      event.preventDefault();
      onClose();
    }
    event.nativeEvent.stopImmediatePropagation();
    event.stopPropagation();
  };
  return /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(
    "div",
    {
      className: `picker`,
      role: "dialog",
      "aria-modal": "true",
      "aria-label": label,
      onKeyDown: handleKeyDown,
      children: /* @__PURE__ */ (0, import_jsx_runtime17.jsx)("div", { className: "picker-content", ref: rGallery, children: options.map((option, i4) => /* @__PURE__ */ (0, import_jsx_runtime17.jsxs)(
        "button",
        {
          className: clsx_m_default("picker-option", {
            active: value === option.value
          }),
          onClick: (event) => {
            event.currentTarget.focus();
            onChange(option.value);
          },
          title: `${option.text} ${option.keyBinding && `\u2014 ${option.keyBinding.toUpperCase()}`}`,
          "aria-label": option.text || "none",
          "aria-keyshortcuts": option.keyBinding || void 0,
          ref: (el) => {
            if (el && i4 === 0) {
              rFirstItem.current = el;
            }
            if (el && option.value === value) {
              rActiveItem.current = el;
            }
          },
          onFocus: () => {
            onChange(option.value);
          },
          children: [
            option.icon,
            option.keyBinding && /* @__PURE__ */ (0, import_jsx_runtime17.jsx)("span", { className: "picker-keybinding", children: option.keyBinding })
          ]
        },
        option.text
      )) })
    }
  );
}
function IconPicker({
  value,
  label,
  options,
  onChange,
  group = ""
}) {
  const [isActive, setActive] = import_react35.default.useState(false);
  const rPickerButton = import_react35.default.useRef(null);
  const isRTL2 = getLanguage().rtl;
  return /* @__PURE__ */ (0, import_jsx_runtime17.jsxs)("div", { children: [
    /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(
      "button",
      {
        name: group,
        className: isActive ? "active" : "",
        "aria-label": label,
        onClick: () => setActive(!isActive),
        ref: rPickerButton,
        children: options.find((option) => option.value === value)?.icon
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(import_react35.default.Suspense, { fallback: "", children: isActive ? /* @__PURE__ */ (0, import_jsx_runtime17.jsxs)(import_jsx_runtime17.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(
        Popover,
        {
          onCloseRequest: (event) => event.target !== rPickerButton.current && setActive(false),
          ...isRTL2 ? { right: 5.5 } : { left: -5.5 },
          children: /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(
            Picker2,
            {
              options: options.filter((opt) => opt.showInPicker !== false),
              value,
              label,
              onChange,
              onClose: () => {
                setActive(false);
                rPickerButton.current?.focus();
              }
            }
          )
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime17.jsx)("div", { className: "picker-triangle" })
    ] }) : null })
  ] });
}

// actions/actionProperties.tsx
var import_jsx_runtime18 = __toESM(require_jsx_runtime(), 1);
var FONT_SIZE_RELATIVE_INCREASE_STEP = 0.1;
var changeProperty = (elements, appState, callback, includeBoundText = false) => {
  const selectedElementIds = arrayToMap(
    getSelectedElements(elements, appState, {
      includeBoundTextElement: includeBoundText
    })
  );
  return elements.map((element) => {
    if (selectedElementIds.get(element.id) || element.id === appState.editingElement?.id) {
      return callback(element);
    }
    return element;
  });
};
var getFormValue = function(elements, appState, getAttribute, isRelevantElement, defaultValue) {
  const editingElement = appState.editingElement;
  const nonDeletedElements = getNonDeletedElements2(elements);
  let ret = null;
  if (editingElement) {
    ret = getAttribute(editingElement);
  }
  if (!ret) {
    const hasSelection = isSomeElementSelected(nonDeletedElements, appState);
    if (hasSelection) {
      ret = getCommonAttributeOfSelectedElements(
        isRelevantElement === true ? nonDeletedElements : nonDeletedElements.filter((el) => isRelevantElement(el)),
        appState,
        getAttribute
      ) ?? (typeof defaultValue === "function" ? defaultValue(true) : defaultValue);
    } else {
      ret = typeof defaultValue === "function" ? defaultValue(false) : defaultValue;
    }
  }
  return ret;
};
var offsetElementAfterFontResize = (prevElement, nextElement) => {
  if (isBoundToContainer(nextElement)) {
    return nextElement;
  }
  return mutateElement(
    nextElement,
    {
      x: prevElement.textAlign === "left" ? prevElement.x : prevElement.x + (prevElement.width - nextElement.width) / (prevElement.textAlign === "center" ? 2 : 1),
      // centering vertically is non-standard, but for Excalidraw I think
      // it makes sense
      y: prevElement.y + (prevElement.height - nextElement.height) / 2
    },
    false
  );
};
var changeFontSize = (elements, appState, app, getNewFontSize, fallbackValue) => {
  const newFontSizes = /* @__PURE__ */ new Set();
  return {
    elements: changeProperty(
      elements,
      appState,
      (oldElement) => {
        if (isTextElement(oldElement)) {
          const newFontSize = getNewFontSize(oldElement);
          newFontSizes.add(newFontSize);
          let newElement2 = newElementWith(oldElement, {
            fontSize: newFontSize
          });
          redrawTextBoundingBox(
            newElement2,
            app.scene.getContainerElement(oldElement),
            app.scene.getNonDeletedElementsMap()
          );
          newElement2 = offsetElementAfterFontResize(oldElement, newElement2);
          return newElement2;
        }
        return oldElement;
      },
      true
    ),
    appState: {
      ...appState,
      // update state only if we've set all select text elements to
      // the same font size
      currentItemFontSize: newFontSizes.size === 1 ? [...newFontSizes][0] : fallbackValue ?? appState.currentItemFontSize
    },
    commitToHistory: true
  };
};
var actionChangeStrokeColor = register({
  name: "changeStrokeColor",
  trackEvent: false,
  perform: (elements, appState, value) => {
    return {
      ...value.currentItemStrokeColor && {
        elements: changeProperty(
          elements,
          appState,
          (el) => {
            return hasStrokeColor(el.type) ? newElementWith(el, {
              strokeColor: value.currentItemStrokeColor
            }) : el;
          },
          true
        )
      },
      appState: {
        ...appState,
        ...value
      },
      commitToHistory: !!value.currentItemStrokeColor
    };
  },
  PanelComponent: ({ elements, appState, updateData, appProps }) => /* @__PURE__ */ (0, import_jsx_runtime18.jsxs)(import_jsx_runtime18.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime18.jsx)("h3", { "aria-hidden": "true", children: t("labels.stroke") }),
    /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
      ColorPicker,
      {
        topPicks: DEFAULT_ELEMENT_STROKE_PICKS,
        palette: DEFAULT_ELEMENT_STROKE_COLOR_PALETTE,
        type: "elementStroke",
        label: t("labels.stroke"),
        color: getFormValue(
          elements,
          appState,
          (element) => element.strokeColor,
          true,
          appState.currentItemStrokeColor
        ),
        onChange: (color) => updateData({ currentItemStrokeColor: color }),
        elements,
        appState,
        updateData
      }
    )
  ] })
});
var actionChangeBackgroundColor = register({
  name: "changeBackgroundColor",
  trackEvent: false,
  perform: (elements, appState, value) => {
    return {
      ...value.currentItemBackgroundColor && {
        elements: changeProperty(
          elements,
          appState,
          (el) => newElementWith(el, {
            backgroundColor: value.currentItemBackgroundColor
          })
        )
      },
      appState: {
        ...appState,
        ...value
      },
      commitToHistory: !!value.currentItemBackgroundColor
    };
  },
  PanelComponent: ({ elements, appState, updateData, appProps }) => /* @__PURE__ */ (0, import_jsx_runtime18.jsxs)(import_jsx_runtime18.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime18.jsx)("h3", { "aria-hidden": "true", children: t("labels.background") }),
    /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
      ColorPicker,
      {
        topPicks: DEFAULT_ELEMENT_BACKGROUND_PICKS,
        palette: DEFAULT_ELEMENT_BACKGROUND_COLOR_PALETTE,
        type: "elementBackground",
        label: t("labels.background"),
        color: getFormValue(
          elements,
          appState,
          (element) => element.backgroundColor,
          true,
          appState.currentItemBackgroundColor
        ),
        onChange: (color) => updateData({ currentItemBackgroundColor: color }),
        elements,
        appState,
        updateData
      }
    )
  ] })
});
var actionChangeFillStyle = register({
  name: "changeFillStyle",
  trackEvent: false,
  perform: (elements, appState, value, app) => {
    trackEvent(
      "element",
      "changeFillStyle",
      `${value} (${app.device.editor.isMobile ? "mobile" : "desktop"})`
    );
    return {
      elements: changeProperty(
        elements,
        appState,
        (el) => newElementWith(el, {
          fillStyle: value
        })
      ),
      appState: { ...appState, currentItemFillStyle: value },
      commitToHistory: true
    };
  },
  PanelComponent: ({ elements, appState, updateData }) => {
    const selectedElements = getSelectedElements(elements, appState);
    const allElementsZigZag = selectedElements.length > 0 && selectedElements.every((el) => el.fillStyle === "zigzag");
    return /* @__PURE__ */ (0, import_jsx_runtime18.jsxs)("fieldset", { children: [
      /* @__PURE__ */ (0, import_jsx_runtime18.jsx)("legend", { children: t("labels.fill") }),
      /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
        ButtonIconSelect,
        {
          type: "button",
          options: [
            {
              value: "hachure",
              text: `${allElementsZigZag ? t("labels.zigzag") : t("labels.hachure")} (${getShortcutKey("Alt-Click")})`,
              icon: allElementsZigZag ? FillZigZagIcon : FillHachureIcon,
              active: allElementsZigZag ? true : void 0,
              testId: `fill-hachure`
            },
            {
              value: "cross-hatch",
              text: t("labels.crossHatch"),
              icon: FillCrossHatchIcon,
              testId: `fill-cross-hatch`
            },
            {
              value: "solid",
              text: t("labels.solid"),
              icon: FillSolidIcon,
              testId: `fill-solid`
            }
          ],
          value: getFormValue(
            elements,
            appState,
            (element) => element.fillStyle,
            (element) => element.hasOwnProperty("fillStyle"),
            (hasSelection) => hasSelection ? null : appState.currentItemFillStyle
          ),
          onClick: (value, event) => {
            const nextValue = event.altKey && value === "hachure" && selectedElements.every((el) => el.fillStyle === "hachure") ? "zigzag" : value;
            updateData(nextValue);
          }
        }
      )
    ] });
  }
});
var actionChangeStrokeWidth = register({
  name: "changeStrokeWidth",
  trackEvent: false,
  perform: (elements, appState, value) => {
    return {
      elements: changeProperty(
        elements,
        appState,
        (el) => newElementWith(el, {
          strokeWidth: value
        })
      ),
      appState: { ...appState, currentItemStrokeWidth: value },
      commitToHistory: true
    };
  },
  PanelComponent: ({ elements, appState, updateData }) => /* @__PURE__ */ (0, import_jsx_runtime18.jsxs)("fieldset", { children: [
    /* @__PURE__ */ (0, import_jsx_runtime18.jsx)("legend", { children: t("labels.strokeWidth") }),
    /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
      ButtonIconSelect,
      {
        group: "stroke-width",
        options: [
          {
            value: STROKE_WIDTH.thin,
            text: t("labels.thin"),
            icon: StrokeWidthBaseIcon,
            testId: "strokeWidth-thin"
          },
          {
            value: STROKE_WIDTH.bold,
            text: t("labels.bold"),
            icon: StrokeWidthBoldIcon,
            testId: "strokeWidth-bold"
          },
          {
            value: STROKE_WIDTH.extraBold,
            text: t("labels.extraBold"),
            icon: StrokeWidthExtraBoldIcon,
            testId: "strokeWidth-extraBold"
          }
        ],
        value: getFormValue(
          elements,
          appState,
          (element) => element.strokeWidth,
          (element) => element.hasOwnProperty("strokeWidth"),
          (hasSelection) => hasSelection ? null : appState.currentItemStrokeWidth
        ),
        onChange: (value) => updateData(value)
      }
    )
  ] })
});
var actionChangeSloppiness = register({
  name: "changeSloppiness",
  trackEvent: false,
  perform: (elements, appState, value) => {
    return {
      elements: changeProperty(
        elements,
        appState,
        (el) => newElementWith(el, {
          seed: randomInteger(),
          roughness: value
        })
      ),
      appState: { ...appState, currentItemRoughness: value },
      commitToHistory: true
    };
  },
  PanelComponent: ({ elements, appState, updateData }) => /* @__PURE__ */ (0, import_jsx_runtime18.jsxs)("fieldset", { children: [
    /* @__PURE__ */ (0, import_jsx_runtime18.jsx)("legend", { children: t("labels.sloppiness") }),
    /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
      ButtonIconSelect,
      {
        group: "sloppiness",
        options: [
          {
            value: 0,
            text: t("labels.architect"),
            icon: SloppinessArchitectIcon
          },
          {
            value: 1,
            text: t("labels.artist"),
            icon: SloppinessArtistIcon
          },
          {
            value: 2,
            text: t("labels.cartoonist"),
            icon: SloppinessCartoonistIcon
          }
        ],
        value: getFormValue(
          elements,
          appState,
          (element) => element.roughness,
          (element) => element.hasOwnProperty("roughness"),
          (hasSelection) => hasSelection ? null : appState.currentItemRoughness
        ),
        onChange: (value) => updateData(value)
      }
    )
  ] })
});
var actionChangeStrokeStyle = register({
  name: "changeStrokeStyle",
  trackEvent: false,
  perform: (elements, appState, value) => {
    return {
      elements: changeProperty(
        elements,
        appState,
        (el) => newElementWith(el, {
          strokeStyle: value
        })
      ),
      appState: { ...appState, currentItemStrokeStyle: value },
      commitToHistory: true
    };
  },
  PanelComponent: ({ elements, appState, updateData }) => /* @__PURE__ */ (0, import_jsx_runtime18.jsxs)("fieldset", { children: [
    /* @__PURE__ */ (0, import_jsx_runtime18.jsx)("legend", { children: t("labels.strokeStyle") }),
    /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
      ButtonIconSelect,
      {
        group: "strokeStyle",
        options: [
          {
            value: "solid",
            text: t("labels.strokeStyle_solid"),
            icon: StrokeWidthBaseIcon
          },
          {
            value: "dashed",
            text: t("labels.strokeStyle_dashed"),
            icon: StrokeStyleDashedIcon
          },
          {
            value: "dotted",
            text: t("labels.strokeStyle_dotted"),
            icon: StrokeStyleDottedIcon
          }
        ],
        value: getFormValue(
          elements,
          appState,
          (element) => element.strokeStyle,
          (element) => element.hasOwnProperty("strokeStyle"),
          (hasSelection) => hasSelection ? null : appState.currentItemStrokeStyle
        ),
        onChange: (value) => updateData(value)
      }
    )
  ] })
});
var actionChangeOpacity = register({
  name: "changeOpacity",
  trackEvent: false,
  perform: (elements, appState, value) => {
    return {
      elements: changeProperty(
        elements,
        appState,
        (el) => newElementWith(el, {
          opacity: value
        }),
        true
      ),
      appState: { ...appState, currentItemOpacity: value },
      commitToHistory: true
    };
  },
  PanelComponent: ({ elements, appState, updateData }) => /* @__PURE__ */ (0, import_jsx_runtime18.jsxs)("label", { className: "control-label", children: [
    t("labels.opacity"),
    /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
      "input",
      {
        type: "range",
        min: "0",
        max: "100",
        step: "10",
        onChange: (event) => updateData(+event.target.value),
        value: getFormValue(
          elements,
          appState,
          (element) => element.opacity,
          true,
          appState.currentItemOpacity
        ) ?? void 0
      }
    )
  ] })
});
var actionChangeFontSize = register({
  name: "changeFontSize",
  trackEvent: false,
  perform: (elements, appState, value, app) => {
    return changeFontSize(elements, appState, app, () => value, value);
  },
  PanelComponent: ({ elements, appState, updateData, app }) => /* @__PURE__ */ (0, import_jsx_runtime18.jsxs)("fieldset", { children: [
    /* @__PURE__ */ (0, import_jsx_runtime18.jsx)("legend", { children: t("labels.fontSize") }),
    /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
      ButtonIconSelect,
      {
        group: "font-size",
        options: [
          {
            value: 16,
            text: t("labels.small"),
            icon: FontSizeSmallIcon,
            testId: "fontSize-small"
          },
          {
            value: 20,
            text: t("labels.medium"),
            icon: FontSizeMediumIcon,
            testId: "fontSize-medium"
          },
          {
            value: 28,
            text: t("labels.large"),
            icon: FontSizeLargeIcon,
            testId: "fontSize-large"
          },
          {
            value: 36,
            text: t("labels.veryLarge"),
            icon: FontSizeExtraLargeIcon,
            testId: "fontSize-veryLarge"
          }
        ],
        value: getFormValue(
          elements,
          appState,
          (element) => {
            if (isTextElement(element)) {
              return element.fontSize;
            }
            const boundTextElement = getBoundTextElement(
              element,
              app.scene.getNonDeletedElementsMap()
            );
            if (boundTextElement) {
              return boundTextElement.fontSize;
            }
            return null;
          },
          (element) => isTextElement(element) || getBoundTextElement(
            element,
            app.scene.getNonDeletedElementsMap()
          ) !== null,
          (hasSelection) => hasSelection ? null : appState.currentItemFontSize || DEFAULT_FONT_SIZE
        ),
        onChange: (value) => updateData(value)
      }
    )
  ] })
});
var actionDecreaseFontSize = register({
  name: "decreaseFontSize",
  trackEvent: false,
  perform: (elements, appState, value, app) => {
    return changeFontSize(
      elements,
      appState,
      app,
      (element) => Math.round(
        // get previous value before relative increase (doesn't work fully
        // due to rounding and float precision issues)
        1 / (1 + FONT_SIZE_RELATIVE_INCREASE_STEP) * element.fontSize
      )
    );
  },
  keyTest: (event) => {
    return event[KEYS.CTRL_OR_CMD] && event.shiftKey && // KEYS.COMMA needed for MacOS
    (event.key === KEYS.CHEVRON_LEFT || event.key === KEYS.COMMA);
  }
});
var actionIncreaseFontSize = register({
  name: "increaseFontSize",
  trackEvent: false,
  perform: (elements, appState, value, app) => {
    return changeFontSize(
      elements,
      appState,
      app,
      (element) => Math.round(element.fontSize * (1 + FONT_SIZE_RELATIVE_INCREASE_STEP))
    );
  },
  keyTest: (event) => {
    return event[KEYS.CTRL_OR_CMD] && event.shiftKey && // KEYS.PERIOD needed for MacOS
    (event.key === KEYS.CHEVRON_RIGHT || event.key === KEYS.PERIOD);
  }
});
var actionChangeFontFamily = register({
  name: "changeFontFamily",
  trackEvent: false,
  perform: (elements, appState, value, app) => {
    return {
      elements: changeProperty(
        elements,
        appState,
        (oldElement) => {
          if (isTextElement(oldElement)) {
            const newElement2 = newElementWith(
              oldElement,
              {
                fontFamily: value,
                lineHeight: getDefaultLineHeight(value)
              }
            );
            redrawTextBoundingBox(
              newElement2,
              app.scene.getContainerElement(oldElement),
              app.scene.getNonDeletedElementsMap()
            );
            return newElement2;
          }
          return oldElement;
        },
        true
      ),
      appState: {
        ...appState,
        currentItemFontFamily: value
      },
      commitToHistory: true
    };
  },
  PanelComponent: ({ elements, appState, updateData, app }) => {
    const options = [
      {
        value: FONT_FAMILY.Virgil,
        text: t("labels.handDrawn"),
        icon: FreedrawIcon,
        testId: "font-family-virgil"
      },
      {
        value: FONT_FAMILY.Helvetica,
        text: t("labels.normal"),
        icon: FontFamilyNormalIcon,
        testId: "font-family-normal"
      },
      {
        value: FONT_FAMILY.Cascadia,
        text: t("labels.code"),
        icon: FontFamilyCodeIcon,
        testId: "font-family-code"
      }
    ];
    return /* @__PURE__ */ (0, import_jsx_runtime18.jsxs)("fieldset", { children: [
      /* @__PURE__ */ (0, import_jsx_runtime18.jsx)("legend", { children: t("labels.fontFamily") }),
      /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
        ButtonIconSelect,
        {
          group: "font-family",
          options,
          value: getFormValue(
            elements,
            appState,
            (element) => {
              if (isTextElement(element)) {
                return element.fontFamily;
              }
              const boundTextElement = getBoundTextElement(
                element,
                app.scene.getNonDeletedElementsMap()
              );
              if (boundTextElement) {
                return boundTextElement.fontFamily;
              }
              return null;
            },
            (element) => isTextElement(element) || getBoundTextElement(
              element,
              app.scene.getNonDeletedElementsMap()
            ) !== null,
            (hasSelection) => hasSelection ? null : appState.currentItemFontFamily || DEFAULT_FONT_FAMILY
          ),
          onChange: (value) => updateData(value)
        }
      )
    ] });
  }
});
var actionChangeTextAlign = register({
  name: "changeTextAlign",
  trackEvent: false,
  perform: (elements, appState, value, app) => {
    return {
      elements: changeProperty(
        elements,
        appState,
        (oldElement) => {
          if (isTextElement(oldElement)) {
            const newElement2 = newElementWith(
              oldElement,
              { textAlign: value }
            );
            redrawTextBoundingBox(
              newElement2,
              app.scene.getContainerElement(oldElement),
              app.scene.getNonDeletedElementsMap()
            );
            return newElement2;
          }
          return oldElement;
        },
        true
      ),
      appState: {
        ...appState,
        currentItemTextAlign: value
      },
      commitToHistory: true
    };
  },
  PanelComponent: ({ elements, appState, updateData, app }) => {
    const elementsMap = app.scene.getNonDeletedElementsMap();
    return /* @__PURE__ */ (0, import_jsx_runtime18.jsxs)("fieldset", { children: [
      /* @__PURE__ */ (0, import_jsx_runtime18.jsx)("legend", { children: t("labels.textAlign") }),
      /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
        ButtonIconSelect,
        {
          group: "text-align",
          options: [
            {
              value: "left",
              text: t("labels.left"),
              icon: TextAlignLeftIcon,
              testId: "align-left"
            },
            {
              value: "center",
              text: t("labels.center"),
              icon: TextAlignCenterIcon,
              testId: "align-horizontal-center"
            },
            {
              value: "right",
              text: t("labels.right"),
              icon: TextAlignRightIcon,
              testId: "align-right"
            }
          ],
          value: getFormValue(
            elements,
            appState,
            (element) => {
              if (isTextElement(element)) {
                return element.textAlign;
              }
              const boundTextElement = getBoundTextElement(
                element,
                elementsMap
              );
              if (boundTextElement) {
                return boundTextElement.textAlign;
              }
              return null;
            },
            (element) => isTextElement(element) || getBoundTextElement(element, elementsMap) !== null,
            (hasSelection) => hasSelection ? null : appState.currentItemTextAlign
          ),
          onChange: (value) => updateData(value)
        }
      )
    ] });
  }
});
var actionChangeVerticalAlign = register({
  name: "changeVerticalAlign",
  trackEvent: { category: "element" },
  perform: (elements, appState, value, app) => {
    return {
      elements: changeProperty(
        elements,
        appState,
        (oldElement) => {
          if (isTextElement(oldElement)) {
            const newElement2 = newElementWith(
              oldElement,
              { verticalAlign: value }
            );
            redrawTextBoundingBox(
              newElement2,
              app.scene.getContainerElement(oldElement),
              app.scene.getNonDeletedElementsMap()
            );
            return newElement2;
          }
          return oldElement;
        },
        true
      ),
      appState: {
        ...appState
      },
      commitToHistory: true
    };
  },
  PanelComponent: ({ elements, appState, updateData, app }) => {
    return /* @__PURE__ */ (0, import_jsx_runtime18.jsx)("fieldset", { children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
      ButtonIconSelect,
      {
        group: "text-align",
        options: [
          {
            value: VERTICAL_ALIGN.TOP,
            text: t("labels.alignTop"),
            icon: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(TextAlignTopIcon, { theme: appState.theme }),
            testId: "align-top"
          },
          {
            value: VERTICAL_ALIGN.MIDDLE,
            text: t("labels.centerVertically"),
            icon: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(TextAlignMiddleIcon, { theme: appState.theme }),
            testId: "align-middle"
          },
          {
            value: VERTICAL_ALIGN.BOTTOM,
            text: t("labels.alignBottom"),
            icon: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(TextAlignBottomIcon, { theme: appState.theme }),
            testId: "align-bottom"
          }
        ],
        value: getFormValue(
          elements,
          appState,
          (element) => {
            if (isTextElement(element) && element.containerId) {
              return element.verticalAlign;
            }
            const boundTextElement = getBoundTextElement(
              element,
              app.scene.getNonDeletedElementsMap()
            );
            if (boundTextElement) {
              return boundTextElement.verticalAlign;
            }
            return null;
          },
          (element) => isTextElement(element) || getBoundTextElement(
            element,
            app.scene.getNonDeletedElementsMap()
          ) !== null,
          (hasSelection) => hasSelection ? null : VERTICAL_ALIGN.MIDDLE
        ),
        onChange: (value) => updateData(value)
      }
    ) });
  }
});
var actionChangeRoundness = register({
  name: "changeRoundness",
  trackEvent: false,
  perform: (elements, appState, value) => {
    return {
      elements: changeProperty(
        elements,
        appState,
        (el) => newElementWith(el, {
          roundness: value === "round" ? {
            type: isUsingAdaptiveRadius(el.type) ? ROUNDNESS.ADAPTIVE_RADIUS : ROUNDNESS.PROPORTIONAL_RADIUS
          } : null
        })
      ),
      appState: {
        ...appState,
        currentItemRoundness: value
      },
      commitToHistory: true
    };
  },
  PanelComponent: ({ elements, appState, updateData }) => {
    const targetElements = getTargetElements(
      getNonDeletedElements2(elements),
      appState
    );
    const hasLegacyRoundness = targetElements.some(
      (el) => el.roundness?.type === ROUNDNESS.LEGACY
    );
    return /* @__PURE__ */ (0, import_jsx_runtime18.jsxs)("fieldset", { children: [
      /* @__PURE__ */ (0, import_jsx_runtime18.jsx)("legend", { children: t("labels.edges") }),
      /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
        ButtonIconSelect,
        {
          group: "edges",
          options: [
            {
              value: "sharp",
              text: t("labels.sharp"),
              icon: EdgeSharpIcon
            },
            {
              value: "round",
              text: t("labels.round"),
              icon: EdgeRoundIcon
            }
          ],
          value: getFormValue(
            elements,
            appState,
            (element) => hasLegacyRoundness ? null : element.roundness ? "round" : "sharp",
            (element) => element.hasOwnProperty("roundness"),
            (hasSelection) => hasSelection ? null : appState.currentItemRoundness
          ),
          onChange: (value) => updateData(value)
        }
      )
    ] });
  }
});
var getArrowheadOptions = (flip) => {
  return [
    {
      value: null,
      text: t("labels.arrowhead_none"),
      keyBinding: "q",
      icon: ArrowheadNoneIcon
    },
    {
      value: "arrow",
      text: t("labels.arrowhead_arrow"),
      keyBinding: "w",
      icon: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(ArrowheadArrowIcon, { flip })
    },
    {
      value: "bar",
      text: t("labels.arrowhead_bar"),
      keyBinding: "e",
      icon: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(ArrowheadBarIcon, { flip })
    },
    {
      value: "dot",
      text: t("labels.arrowhead_circle"),
      keyBinding: null,
      icon: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(ArrowheadCircleIcon, { flip }),
      showInPicker: false
    },
    {
      value: "circle",
      text: t("labels.arrowhead_circle"),
      keyBinding: "r",
      icon: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(ArrowheadCircleIcon, { flip }),
      showInPicker: false
    },
    {
      value: "circle_outline",
      text: t("labels.arrowhead_circle_outline"),
      keyBinding: null,
      icon: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(ArrowheadCircleOutlineIcon, { flip }),
      showInPicker: false
    },
    {
      value: "triangle",
      text: t("labels.arrowhead_triangle"),
      icon: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(ArrowheadTriangleIcon, { flip }),
      keyBinding: "t"
    },
    {
      value: "triangle_outline",
      text: t("labels.arrowhead_triangle_outline"),
      icon: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(ArrowheadTriangleOutlineIcon, { flip }),
      keyBinding: null,
      showInPicker: false
    },
    {
      value: "diamond",
      text: t("labels.arrowhead_diamond"),
      icon: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(ArrowheadDiamondIcon, { flip }),
      keyBinding: null,
      showInPicker: false
    },
    {
      value: "diamond_outline",
      text: t("labels.arrowhead_diamond_outline"),
      icon: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(ArrowheadDiamondOutlineIcon, { flip }),
      keyBinding: null,
      showInPicker: false
    }
  ];
};
var actionChangeArrowhead = register({
  name: "changeArrowhead",
  trackEvent: false,
  perform: (elements, appState, value) => {
    return {
      elements: changeProperty(elements, appState, (el) => {
        if (isLinearElement(el)) {
          const { position, type } = value;
          if (position === "start") {
            const element = newElementWith(el, {
              startArrowhead: type
            });
            return element;
          } else if (position === "end") {
            const element = newElementWith(el, {
              endArrowhead: type
            });
            return element;
          }
        }
        return el;
      }),
      appState: {
        ...appState,
        [value.position === "start" ? "currentItemStartArrowhead" : "currentItemEndArrowhead"]: value.type
      },
      commitToHistory: true
    };
  },
  PanelComponent: ({ elements, appState, updateData }) => {
    const isRTL2 = getLanguage().rtl;
    return /* @__PURE__ */ (0, import_jsx_runtime18.jsxs)("fieldset", { children: [
      /* @__PURE__ */ (0, import_jsx_runtime18.jsx)("legend", { children: t("labels.arrowheads") }),
      /* @__PURE__ */ (0, import_jsx_runtime18.jsxs)("div", { className: "iconSelectList buttonList", children: [
        /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
          IconPicker,
          {
            label: "arrowhead_start",
            options: getArrowheadOptions(!isRTL2),
            value: getFormValue(
              elements,
              appState,
              (element) => isLinearElement(element) && canHaveArrowheads(element.type) ? element.startArrowhead : appState.currentItemStartArrowhead,
              true,
              appState.currentItemStartArrowhead
            ),
            onChange: (value) => updateData({ position: "start", type: value })
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
          IconPicker,
          {
            label: "arrowhead_end",
            group: "arrowheads",
            options: getArrowheadOptions(!!isRTL2),
            value: getFormValue(
              elements,
              appState,
              (element) => isLinearElement(element) && canHaveArrowheads(element.type) ? element.endArrowhead : appState.currentItemEndArrowhead,
              true,
              appState.currentItemEndArrowhead
            ),
            onChange: (value) => updateData({ position: "end", type: value })
          }
        )
      ] })
    ] });
  }
});

// actions/actionCanvas.tsx
init_define_import_meta_env();

// components/Tooltip.tsx
init_define_import_meta_env();
var import_react36 = __toESM(require_react(), 1);
var import_jsx_runtime19 = __toESM(require_jsx_runtime(), 1);
var getTooltipDiv = () => {
  const existingDiv = document.querySelector(
    ".excalidraw-tooltip"
  );
  if (existingDiv) {
    return existingDiv;
  }
  const div = document.createElement("div");
  document.body.appendChild(div);
  div.classList.add("excalidraw-tooltip");
  return div;
};
var updateTooltipPosition = (tooltip, item, position = "bottom") => {
  const tooltipRect = tooltip.getBoundingClientRect();
  const viewportWidth = window.innerWidth;
  const viewportHeight = window.innerHeight;
  const margin = 5;
  let left = item.left + item.width / 2 - tooltipRect.width / 2;
  if (left < 0) {
    left = margin;
  } else if (left + tooltipRect.width >= viewportWidth) {
    left = viewportWidth - tooltipRect.width - margin;
  }
  let top2;
  if (position === "bottom") {
    top2 = item.top + item.height + margin;
    if (top2 + tooltipRect.height >= viewportHeight) {
      top2 = item.top - tooltipRect.height - margin;
    }
  } else {
    top2 = item.top - tooltipRect.height - margin;
    if (top2 < 0) {
      top2 = item.top + item.height + margin;
    }
  }
  Object.assign(tooltip.style, {
    top: `${top2}px`,
    left: `${left}px`
  });
};
var updateTooltip = (item, tooltip, label, long) => {
  tooltip.classList.add("excalidraw-tooltip--visible");
  tooltip.style.minWidth = long ? "50ch" : "10ch";
  tooltip.style.maxWidth = long ? "50ch" : "15ch";
  tooltip.textContent = label;
  const itemRect = item.getBoundingClientRect();
  updateTooltipPosition(tooltip, itemRect);
};
var Tooltip = ({
  children,
  label,
  long = false,
  style,
  disabled
}) => {
  (0, import_react36.useEffect)(() => {
    return () => getTooltipDiv().classList.remove("excalidraw-tooltip--visible");
  }, []);
  if (disabled) {
    return null;
  }
  return /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(
    "div",
    {
      className: "excalidraw-tooltip-wrapper",
      onPointerEnter: (event) => updateTooltip(
        event.currentTarget,
        getTooltipDiv(),
        label,
        long
      ),
      onPointerLeave: () => getTooltipDiv().classList.remove("excalidraw-tooltip--visible"),
      style,
      children
    }
  );
};

// actions/actionCanvas.tsx
var import_jsx_runtime20 = __toESM(require_jsx_runtime(), 1);
var actionChangeViewBackgroundColor = register({
  name: "changeViewBackgroundColor",
  trackEvent: false,
  predicate: (elements, appState, props, app) => {
    return !!app.props.UIOptions.canvasActions.changeViewBackgroundColor && !appState.viewModeEnabled;
  },
  perform: (_, appState, value) => {
    return {
      appState: { ...appState, ...value },
      commitToHistory: !!value.viewBackgroundColor
    };
  },
  PanelComponent: ({ elements, appState, updateData, appProps }) => {
    return /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(
      ColorPicker,
      {
        palette: null,
        topPicks: DEFAULT_CANVAS_BACKGROUND_PICKS,
        label: t("labels.canvasBackground"),
        type: "canvasBackground",
        color: appState.viewBackgroundColor,
        onChange: (color) => updateData({ viewBackgroundColor: color }),
        "data-testid": "canvas-background-picker",
        elements,
        appState,
        updateData
      }
    );
  }
});
var actionClearCanvas = register({
  name: "clearCanvas",
  trackEvent: { category: "canvas" },
  predicate: (elements, appState, props, app) => {
    return !!app.props.UIOptions.canvasActions.clearCanvas && !appState.viewModeEnabled;
  },
  perform: (elements, appState, _, app) => {
    app.imageCache.clear();
    return {
      elements: elements.map(
        (element) => newElementWith(element, { isDeleted: true })
      ),
      appState: {
        ...getDefaultAppState(),
        files: {},
        theme: appState.theme,
        penMode: appState.penMode,
        penDetected: appState.penDetected,
        exportBackground: appState.exportBackground,
        exportEmbedScene: appState.exportEmbedScene,
        gridSize: appState.gridSize,
        showStats: appState.showStats,
        pasteDialog: appState.pasteDialog,
        activeTool: appState.activeTool.type === "image" ? { ...appState.activeTool, type: "selection" } : appState.activeTool
      },
      commitToHistory: true
    };
  }
});
var actionZoomIn = register({
  name: "zoomIn",
  viewMode: true,
  trackEvent: { category: "canvas" },
  perform: (_elements, appState, _, app) => {
    return {
      appState: {
        ...appState,
        ...getStateForZoom(
          {
            viewportX: appState.width / 2 + appState.offsetLeft,
            viewportY: appState.height / 2 + appState.offsetTop,
            nextZoom: getNormalizedZoom(appState.zoom.value + ZOOM_STEP)
          },
          appState
        ),
        userToFollow: null
      },
      commitToHistory: false
    };
  },
  PanelComponent: ({ updateData }) => /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(
    ToolButton,
    {
      type: "button",
      className: "zoom-in-button zoom-button",
      icon: ZoomInIcon,
      title: `${t("buttons.zoomIn")} \u2014 ${getShortcutKey("CtrlOrCmd++")}`,
      "aria-label": t("buttons.zoomIn"),
      onClick: () => {
        updateData(null);
      }
    }
  ),
  keyTest: (event) => (event.code === CODES.EQUAL || event.code === CODES.NUM_ADD) && (event[KEYS.CTRL_OR_CMD] || event.shiftKey)
});
var actionZoomOut = register({
  name: "zoomOut",
  viewMode: true,
  trackEvent: { category: "canvas" },
  perform: (_elements, appState, _, app) => {
    return {
      appState: {
        ...appState,
        ...getStateForZoom(
          {
            viewportX: appState.width / 2 + appState.offsetLeft,
            viewportY: appState.height / 2 + appState.offsetTop,
            nextZoom: getNormalizedZoom(appState.zoom.value - ZOOM_STEP)
          },
          appState
        ),
        userToFollow: null
      },
      commitToHistory: false
    };
  },
  PanelComponent: ({ updateData }) => /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(
    ToolButton,
    {
      type: "button",
      className: "zoom-out-button zoom-button",
      icon: ZoomOutIcon,
      title: `${t("buttons.zoomOut")} \u2014 ${getShortcutKey("CtrlOrCmd+-")}`,
      "aria-label": t("buttons.zoomOut"),
      onClick: () => {
        updateData(null);
      }
    }
  ),
  keyTest: (event) => (event.code === CODES.MINUS || event.code === CODES.NUM_SUBTRACT) && (event[KEYS.CTRL_OR_CMD] || event.shiftKey)
});
var actionResetZoom = register({
  name: "resetZoom",
  viewMode: true,
  trackEvent: { category: "canvas" },
  perform: (_elements, appState, _, app) => {
    return {
      appState: {
        ...appState,
        ...getStateForZoom(
          {
            viewportX: appState.width / 2 + appState.offsetLeft,
            viewportY: appState.height / 2 + appState.offsetTop,
            nextZoom: getNormalizedZoom(1)
          },
          appState
        ),
        userToFollow: null
      },
      commitToHistory: false
    };
  },
  PanelComponent: ({ updateData, appState }) => /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(Tooltip, { label: t("buttons.resetZoom"), style: { height: "100%" }, children: /* @__PURE__ */ (0, import_jsx_runtime20.jsxs)(
    ToolButton,
    {
      type: "button",
      className: "reset-zoom-button zoom-button",
      title: t("buttons.resetZoom"),
      "aria-label": t("buttons.resetZoom"),
      onClick: () => {
        updateData(null);
      },
      children: [
        (appState.zoom.value * 100).toFixed(0),
        "%"
      ]
    }
  ) }),
  keyTest: (event) => (event.code === CODES.ZERO || event.code === CODES.NUM_ZERO) && (event[KEYS.CTRL_OR_CMD] || event.shiftKey)
});
var zoomValueToFitBoundsOnViewport = (bounds, viewportDimensions) => {
  const [x1, y1, x22, y22] = bounds;
  const commonBoundsWidth = x22 - x1;
  const zoomValueForWidth = viewportDimensions.width / commonBoundsWidth;
  const commonBoundsHeight = y22 - y1;
  const zoomValueForHeight = viewportDimensions.height / commonBoundsHeight;
  const smallestZoomValue = Math.min(zoomValueForWidth, zoomValueForHeight);
  const zoomAdjustedToSteps = Math.floor(smallestZoomValue / ZOOM_STEP) * ZOOM_STEP;
  const clampedZoomValueToFitElements = Math.min(
    Math.max(zoomAdjustedToSteps, MIN_ZOOM),
    1
  );
  return clampedZoomValueToFitElements;
};
var zoomToFitBounds = ({
  bounds,
  appState,
  fitToViewport = false,
  viewportZoomFactor = 0.7
}) => {
  const [x1, y1, x22, y22] = bounds;
  const centerX = (x1 + x22) / 2;
  const centerY = (y1 + y22) / 2;
  let newZoomValue;
  let scrollX;
  let scrollY;
  if (fitToViewport) {
    const commonBoundsWidth = x22 - x1;
    const commonBoundsHeight = y22 - y1;
    newZoomValue = Math.min(
      appState.width / commonBoundsWidth,
      appState.height / commonBoundsHeight
    ) * Math.min(1, Math.max(viewportZoomFactor, 0.1));
    newZoomValue = Math.min(
      Math.max(newZoomValue, 0.1),
      30
    );
    let appStateWidth = appState.width;
    if (appState.openSidebar) {
      const sidebarDOMElem = document.querySelector(
        ".sidebar"
      );
      const sidebarWidth = sidebarDOMElem?.offsetWidth ?? 0;
      const isRTL2 = document.documentElement.getAttribute("dir") === "rtl";
      appStateWidth = !isRTL2 ? appState.width - sidebarWidth : appState.width + sidebarWidth;
    }
    scrollX = appStateWidth / 2 * (1 / newZoomValue) - centerX;
    scrollY = appState.height / 2 * (1 / newZoomValue) - centerY;
  } else {
    newZoomValue = zoomValueToFitBoundsOnViewport(bounds, {
      width: appState.width,
      height: appState.height
    });
    const centerScroll = centerScrollOn({
      scenePoint: { x: centerX, y: centerY },
      viewportDimensions: {
        width: appState.width,
        height: appState.height
      },
      zoom: { value: newZoomValue }
    });
    scrollX = centerScroll.scrollX;
    scrollY = centerScroll.scrollY;
  }
  return {
    appState: {
      ...appState,
      scrollX,
      scrollY,
      zoom: { value: newZoomValue }
    },
    commitToHistory: false
  };
};
var zoomToFit = ({
  targetElements,
  appState,
  fitToViewport,
  viewportZoomFactor
}) => {
  const commonBounds = getCommonBounds(getNonDeletedElements2(targetElements));
  return zoomToFitBounds({
    bounds: commonBounds,
    appState,
    fitToViewport,
    viewportZoomFactor
  });
};
var actionZoomToFitSelectionInViewport = register({
  name: "zoomToFitSelectionInViewport",
  trackEvent: { category: "canvas" },
  perform: (elements, appState, _, app) => {
    const selectedElements = app.scene.getSelectedElements(appState);
    return zoomToFit({
      targetElements: selectedElements.length ? selectedElements : elements,
      appState: {
        ...appState,
        userToFollow: null
      },
      fitToViewport: false
    });
  },
  // NOTE shift-2 should have been assigned actionZoomToFitSelection.
  // TBD on how proceed
  keyTest: (event) => event.code === CODES.TWO && event.shiftKey && !event.altKey && !event[KEYS.CTRL_OR_CMD]
});
var actionZoomToFitSelection = register({
  name: "zoomToFitSelection",
  trackEvent: { category: "canvas" },
  perform: (elements, appState, _, app) => {
    const selectedElements = app.scene.getSelectedElements(appState);
    return zoomToFit({
      targetElements: selectedElements.length ? selectedElements : elements,
      appState: {
        ...appState,
        userToFollow: null
      },
      fitToViewport: true
    });
  },
  // NOTE this action should use shift-2 per figma, alas
  keyTest: (event) => event.code === CODES.THREE && event.shiftKey && !event.altKey && !event[KEYS.CTRL_OR_CMD]
});
var actionZoomToFit = register({
  name: "zoomToFit",
  viewMode: true,
  trackEvent: { category: "canvas" },
  perform: (elements, appState) => zoomToFit({
    targetElements: elements,
    appState: {
      ...appState,
      userToFollow: null
    },
    fitToViewport: false
  }),
  keyTest: (event) => event.code === CODES.ONE && event.shiftKey && !event.altKey && !event[KEYS.CTRL_OR_CMD]
});
var actionToggleTheme = register({
  name: "toggleTheme",
  viewMode: true,
  trackEvent: { category: "canvas" },
  perform: (_, appState, value) => {
    return {
      appState: {
        ...appState,
        theme: value || (appState.theme === THEME.LIGHT ? THEME.DARK : THEME.LIGHT)
      },
      commitToHistory: false
    };
  },
  keyTest: (event) => event.altKey && event.shiftKey && event.code === CODES.D,
  predicate: (elements, appState, props, app) => {
    return !!app.props.UIOptions.canvasActions.toggleTheme;
  }
});
var actionToggleEraserTool = register({
  name: "toggleEraserTool",
  trackEvent: { category: "toolbar" },
  perform: (elements, appState) => {
    let activeTool;
    if (isEraserActive(appState)) {
      activeTool = updateActiveTool(appState, {
        ...appState.activeTool.lastActiveTool || {
          type: "selection"
        },
        lastActiveToolBeforeEraser: null
      });
    } else {
      activeTool = updateActiveTool(appState, {
        type: "eraser",
        lastActiveToolBeforeEraser: appState.activeTool
      });
    }
    return {
      appState: {
        ...appState,
        selectedElementIds: {},
        selectedGroupIds: {},
        activeEmbeddable: null,
        activeTool
      },
      commitToHistory: true
    };
  },
  keyTest: (event) => event.key === KEYS.E
});
var actionToggleHandTool = register({
  name: "toggleHandTool",
  trackEvent: { category: "toolbar" },
  perform: (elements, appState, _, app) => {
    let activeTool;
    if (isHandToolActive(appState)) {
      activeTool = updateActiveTool(appState, {
        ...appState.activeTool.lastActiveTool || {
          type: "selection"
        },
        lastActiveToolBeforeEraser: null
      });
    } else {
      activeTool = updateActiveTool(appState, {
        type: "hand",
        lastActiveToolBeforeEraser: appState.activeTool
      });
      setCursor(app.interactiveCanvas, CURSOR_TYPE.GRAB);
    }
    return {
      appState: {
        ...appState,
        selectedElementIds: {},
        selectedGroupIds: {},
        activeEmbeddable: null,
        activeTool
      },
      commitToHistory: true
    };
  },
  keyTest: (event) => !event.altKey && !event[KEYS.CTRL_OR_CMD] && event.key === KEYS.H
});

// actions/actionFinalize.tsx
init_define_import_meta_env();
var import_jsx_runtime21 = __toESM(require_jsx_runtime(), 1);
var actionFinalize = register({
  name: "finalize",
  trackEvent: false,
  perform: (elements, appState, _, { interactiveCanvas, focusContainer, scene }) => {
    const elementsMap = scene.getNonDeletedElementsMap();
    if (appState.editingLinearElement) {
      const { elementId, startBindingElement, endBindingElement } = appState.editingLinearElement;
      const element = LinearElementEditor.getElement(elementId, elementsMap);
      if (element) {
        if (isBindingElement(element)) {
          bindOrUnbindLinearElement(
            element,
            startBindingElement,
            endBindingElement,
            elementsMap
          );
        }
        return {
          elements: element.points.length < 2 || isInvisiblySmallElement(element) ? elements.filter((el) => el.id !== element.id) : void 0,
          appState: {
            ...appState,
            cursorButton: "up",
            editingLinearElement: null
          },
          commitToHistory: true
        };
      }
    }
    let newElements = elements;
    const pendingImageElement = appState.pendingImageElementId && scene.getElement(appState.pendingImageElementId);
    if (pendingImageElement) {
      mutateElement(pendingImageElement, { isDeleted: true }, false);
    }
    if (window.document.activeElement instanceof HTMLElement) {
      focusContainer();
    }
    const multiPointElement = appState.multiElement ? appState.multiElement : appState.editingElement?.type === "freedraw" ? appState.editingElement : null;
    if (multiPointElement) {
      if (multiPointElement.type !== "freedraw" && appState.lastPointerDownWith !== "touch") {
        const { points, lastCommittedPoint } = multiPointElement;
        if (!lastCommittedPoint || points[points.length - 1] !== lastCommittedPoint) {
          mutateElement(multiPointElement, {
            points: multiPointElement.points.slice(0, -1)
          });
        }
      }
      if (isInvisiblySmallElement(multiPointElement)) {
        newElements = newElements.filter(
          (el) => el.id !== multiPointElement.id
        );
      }
      const isLoop = isPathALoop(multiPointElement.points, appState.zoom.value);
      if (multiPointElement.type === "line" || multiPointElement.type === "freedraw") {
        if (isLoop) {
          const linePoints = multiPointElement.points;
          const firstPoint = linePoints[0];
          mutateElement(multiPointElement, {
            points: linePoints.map(
              (point2, index2) => index2 === linePoints.length - 1 ? [firstPoint[0], firstPoint[1]] : point2
            )
          });
        }
      }
      if (isBindingElement(multiPointElement) && !isLoop && multiPointElement.points.length > 1) {
        const [x3, y3] = LinearElementEditor.getPointAtIndexGlobalCoordinates(
          multiPointElement,
          -1,
          arrayToMap(elements)
        );
        maybeBindLinearElement(
          multiPointElement,
          appState,
          Scene_default.getScene(multiPointElement),
          { x: x3, y: y3 },
          elementsMap
        );
      }
    }
    if (!appState.activeTool.locked && appState.activeTool.type !== "freedraw" || !multiPointElement) {
      resetCursor(interactiveCanvas);
    }
    let activeTool;
    if (appState.activeTool.type === "eraser") {
      activeTool = updateActiveTool(appState, {
        ...appState.activeTool.lastActiveTool || {
          type: "selection"
        },
        lastActiveToolBeforeEraser: null
      });
    } else {
      activeTool = updateActiveTool(appState, {
        type: "selection"
      });
    }
    return {
      elements: newElements,
      appState: {
        ...appState,
        cursorButton: "up",
        activeTool: (appState.activeTool.locked || appState.activeTool.type === "freedraw") && multiPointElement ? appState.activeTool : activeTool,
        activeEmbeddable: null,
        draggingElement: null,
        multiElement: null,
        editingElement: null,
        startBoundElement: null,
        suggestedBindings: [],
        selectedElementIds: multiPointElement && !appState.activeTool.locked && appState.activeTool.type !== "freedraw" ? {
          ...appState.selectedElementIds,
          [multiPointElement.id]: true
        } : appState.selectedElementIds,
        // To select the linear element when user has finished mutipoint editing
        selectedLinearElement: multiPointElement && isLinearElement(multiPointElement) ? new LinearElementEditor(multiPointElement) : appState.selectedLinearElement,
        pendingImageElementId: null
      },
      commitToHistory: appState.activeTool.type === "freedraw"
    };
  },
  keyTest: (event, appState) => event.key === KEYS.ESCAPE && (appState.editingLinearElement !== null || !appState.draggingElement && appState.multiElement === null) || (event.key === KEYS.ESCAPE || event.key === KEYS.ENTER) && appState.multiElement !== null,
  PanelComponent: ({ appState, updateData, data }) => /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(
    ToolButton,
    {
      type: "button",
      icon: done,
      title: t("buttons.done"),
      "aria-label": t("buttons.done"),
      onClick: updateData,
      visible: appState.multiElement != null,
      size: data?.size || "medium"
    }
  )
});

// actions/actionExport.tsx
init_define_import_meta_env();

// components/ProjectName.tsx
init_define_import_meta_env();
var import_react37 = __toESM(require_react(), 1);
var import_jsx_runtime22 = __toESM(require_jsx_runtime(), 1);
var ProjectName = (props) => {
  const { id } = useExcalidrawContainer();
  const [fileName, setFileName] = (0, import_react37.useState)(props.value);
  const handleBlur = (event) => {
    if (!props.ignoreFocus) {
      focusNearestParent(event.target);
    }
    const value = event.target.value;
    if (value !== props.value) {
      props.onChange(value);
    }
  };
  const handleKeyDown = (event) => {
    if (event.key === KEYS.ENTER) {
      event.preventDefault();
      if (event.nativeEvent.isComposing || event.keyCode === 229) {
        return;
      }
      event.currentTarget.blur();
    }
  };
  return /* @__PURE__ */ (0, import_jsx_runtime22.jsxs)("div", { className: "ProjectName", children: [
    /* @__PURE__ */ (0, import_jsx_runtime22.jsx)("label", { className: "ProjectName-label", htmlFor: "filename", children: `${props.label}:` }),
    /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(
      "input",
      {
        type: "text",
        className: "TextInput",
        onBlur: handleBlur,
        onKeyDown: handleKeyDown,
        id: `${id}-filename`,
        value: fileName,
        onChange: (event) => setFileName(event.target.value)
      }
    )
  ] });
};

// components/DarkModeToggle.tsx
init_define_import_meta_env();
var import_jsx_runtime23 = __toESM(require_jsx_runtime(), 1);
var DarkModeToggle = (props) => {
  const title = props.title || (props.value === "dark" ? t("buttons.lightMode") : t("buttons.darkMode"));
  return /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(
    ToolButton,
    {
      type: "icon",
      icon: props.value === THEME.LIGHT ? ICONS.MOON : ICONS.SUN,
      title,
      "aria-label": title,
      onClick: () => props.onChange(props.value === THEME.DARK ? THEME.LIGHT : THEME.DARK),
      "data-testid": "toggle-dark-mode"
    }
  );
};
var ICONS = {
  SUN: /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("svg", { width: "512", height: "512", className: "rtl-mirror", viewBox: "0 0 512 512", children: /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(
    "path",
    {
      fill: "currentColor",
      d: "M256 160c-52.9 0-96 43.1-96 96s43.1 96 96 96 96-43.1 96-96-43.1-96-96-96zm246.4 80.5l-94.7-47.3 33.5-100.4c4.5-13.6-8.4-26.5-21.9-21.9l-100.4 33.5-47.4-94.8c-6.4-12.8-24.6-12.8-31 0l-47.3 94.7L92.7 70.8c-13.6-4.5-26.5 8.4-21.9 21.9l33.5 100.4-94.7 47.4c-12.8 6.4-12.8 24.6 0 31l94.7 47.3-33.5 100.5c-4.5 13.6 8.4 26.5 21.9 21.9l100.4-33.5 47.3 94.7c6.4 12.8 24.6 12.8 31 0l47.3-94.7 100.4 33.5c13.6 4.5 26.5-8.4 21.9-21.9l-33.5-100.4 94.7-47.3c13-6.5 13-24.7.2-31.1zm-155.9 106c-49.9 49.9-131.1 49.9-181 0-49.9-49.9-49.9-131.1 0-181 49.9-49.9 131.1-49.9 181 0 49.9 49.9 49.9 131.1 0 181z"
    }
  ) }),
  MOON: /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("svg", { width: "512", height: "512", className: "rtl-mirror", viewBox: "0 0 512 512", children: /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(
    "path",
    {
      fill: "currentColor",
      d: "M283.211 512c78.962 0 151.079-35.925 198.857-94.792 7.068-8.708-.639-21.43-11.562-19.35-124.203 23.654-238.262-71.576-238.262-196.954 0-72.222 38.662-138.635 101.498-174.394 9.686-5.512 7.25-20.197-3.756-22.23A258.156 258.156 0 0 0 283.211 0c-141.309 0-256 114.511-256 256 0 141.309 114.511 256 256 256z"
    }
  ) })
};

// data/index.ts
init_define_import_meta_env();

// clipboard.ts
init_define_import_meta_env();

// charts.ts
init_define_import_meta_env();
var BAR_WIDTH = 32;
var BAR_GAP = 12;
var BAR_HEIGHT = 256;
var GRID_OPACITY = 50;
var NOT_SPREADSHEET = "NOT_SPREADSHEET";
var VALID_SPREADSHEET = "VALID_SPREADSHEET";
var tryParseNumber = (s4) => {
  const match = /^([-+]?)[$]?([-+]?)([\d.,]+)[%]?$/.exec(s4);
  if (!match) {
    return null;
  }
  return parseFloat(`${(match[1] || match[2]) + match[3]}`.replace(/,/g, ""));
};
var isNumericColumn = (lines, columnIndex) => lines.slice(1).every((line2) => tryParseNumber(line2[columnIndex]) !== null);
var tryParseCells = (cells) => {
  const numCols = cells[0].length;
  if (numCols > 2) {
    return { type: NOT_SPREADSHEET, reason: "More than 2 columns" };
  }
  if (numCols === 1) {
    if (!isNumericColumn(cells, 0)) {
      return { type: NOT_SPREADSHEET, reason: "Value is not numeric" };
    }
    const hasHeader2 = tryParseNumber(cells[0][0]) === null;
    const values = (hasHeader2 ? cells.slice(1) : cells).map(
      (line2) => tryParseNumber(line2[0])
    );
    if (values.length < 2) {
      return { type: NOT_SPREADSHEET, reason: "Less than two rows" };
    }
    return {
      type: VALID_SPREADSHEET,
      spreadsheet: {
        title: hasHeader2 ? cells[0][0] : null,
        labels: null,
        values
      }
    };
  }
  const labelColumnNumeric = isNumericColumn(cells, 0);
  const valueColumnNumeric = isNumericColumn(cells, 1);
  if (!labelColumnNumeric && !valueColumnNumeric) {
    return { type: NOT_SPREADSHEET, reason: "Value is not numeric" };
  }
  const [labelColumnIndex, valueColumnIndex] = valueColumnNumeric ? [0, 1] : [1, 0];
  const hasHeader = tryParseNumber(cells[0][valueColumnIndex]) === null;
  const rows = hasHeader ? cells.slice(1) : cells;
  if (rows.length < 2) {
    return { type: NOT_SPREADSHEET, reason: "Less than 2 rows" };
  }
  return {
    type: VALID_SPREADSHEET,
    spreadsheet: {
      title: hasHeader ? cells[0][valueColumnIndex] : null,
      labels: rows.map((row) => row[labelColumnIndex]),
      values: rows.map((row) => tryParseNumber(row[valueColumnIndex]))
    }
  };
};
var transposeCells = (cells) => {
  const nextCells = [];
  for (let col = 0; col < cells[0].length; col++) {
    const nextCellRow = [];
    for (let row = 0; row < cells.length; row++) {
      nextCellRow.push(cells[row][col]);
    }
    nextCells.push(nextCellRow);
  }
  return nextCells;
};
var tryParseSpreadsheet = (text) => {
  let lines = text.trim().split("\n").map((line2) => line2.trim().split("	"));
  if (lines.length && lines[0].length !== 2) {
    lines = text.trim().split("\n").map((line2) => line2.trim().split(","));
  }
  if (lines.length === 0) {
    return { type: NOT_SPREADSHEET, reason: "No values" };
  }
  const numColsFirstLine = lines[0].length;
  const isSpreadsheet = lines.every((line2) => line2.length === numColsFirstLine);
  if (!isSpreadsheet) {
    return {
      type: NOT_SPREADSHEET,
      reason: "All rows don't have same number of columns"
    };
  }
  const result = tryParseCells(lines);
  if (result.type !== VALID_SPREADSHEET) {
    const transposedResults = tryParseCells(transposeCells(lines));
    if (transposedResults.type === VALID_SPREADSHEET) {
      return transposedResults;
    }
  }
  return result;
};
var bgColors = getAllColorsSpecificShade(DEFAULT_CHART_COLOR_INDEX);
var commonProps = {
  fillStyle: "hachure",
  fontFamily: DEFAULT_FONT_FAMILY,
  fontSize: DEFAULT_FONT_SIZE,
  opacity: 100,
  roughness: 1,
  strokeColor: COLOR_PALETTE.black,
  roundness: null,
  strokeStyle: "solid",
  strokeWidth: 1,
  verticalAlign: VERTICAL_ALIGN.MIDDLE,
  locked: false
};
var getChartDimensions = (spreadsheet) => {
  const chartWidth = (BAR_WIDTH + BAR_GAP) * spreadsheet.values.length + BAR_GAP;
  const chartHeight = BAR_HEIGHT + BAR_GAP * 2;
  return { chartWidth, chartHeight };
};
var chartXLabels = (spreadsheet, x3, y3, groupId, backgroundColor) => {
  return spreadsheet.labels?.map((label, index2) => {
    return newTextElement({
      groupIds: [groupId],
      backgroundColor,
      ...commonProps,
      text: label.length > 8 ? `${label.slice(0, 5)}...` : label,
      x: x3 + index2 * (BAR_WIDTH + BAR_GAP) + BAR_GAP * 2,
      y: y3 + BAR_GAP / 2,
      width: BAR_WIDTH,
      angle: 5.87,
      fontSize: 16,
      textAlign: "center",
      verticalAlign: "top"
    });
  }) || [];
};
var chartYLabels = (spreadsheet, x3, y3, groupId, backgroundColor) => {
  const minYLabel = newTextElement({
    groupIds: [groupId],
    backgroundColor,
    ...commonProps,
    x: x3 - BAR_GAP,
    y: y3 - BAR_GAP,
    text: "0",
    textAlign: "right"
  });
  const maxYLabel = newTextElement({
    groupIds: [groupId],
    backgroundColor,
    ...commonProps,
    x: x3 - BAR_GAP,
    y: y3 - BAR_HEIGHT - minYLabel.height / 2,
    text: Math.max(...spreadsheet.values).toLocaleString(),
    textAlign: "right"
  });
  return [minYLabel, maxYLabel];
};
var chartLines = (spreadsheet, x3, y3, groupId, backgroundColor) => {
  const { chartWidth, chartHeight } = getChartDimensions(spreadsheet);
  const xLine = newLinearElement({
    backgroundColor,
    groupIds: [groupId],
    ...commonProps,
    type: "line",
    x: x3,
    y: y3,
    startArrowhead: null,
    endArrowhead: null,
    width: chartWidth,
    points: [
      [0, 0],
      [chartWidth, 0]
    ]
  });
  const yLine = newLinearElement({
    backgroundColor,
    groupIds: [groupId],
    ...commonProps,
    type: "line",
    x: x3,
    y: y3,
    startArrowhead: null,
    endArrowhead: null,
    height: chartHeight,
    points: [
      [0, 0],
      [0, -chartHeight]
    ]
  });
  const maxLine = newLinearElement({
    backgroundColor,
    groupIds: [groupId],
    ...commonProps,
    type: "line",
    x: x3,
    y: y3 - BAR_HEIGHT - BAR_GAP,
    startArrowhead: null,
    endArrowhead: null,
    strokeStyle: "dotted",
    width: chartWidth,
    opacity: GRID_OPACITY,
    points: [
      [0, 0],
      [chartWidth, 0]
    ]
  });
  return [xLine, yLine, maxLine];
};
var chartBaseElements = (spreadsheet, x3, y3, groupId, backgroundColor, debug) => {
  const { chartWidth, chartHeight } = getChartDimensions(spreadsheet);
  const title = spreadsheet.title ? newTextElement({
    backgroundColor,
    groupIds: [groupId],
    ...commonProps,
    text: spreadsheet.title,
    x: x3 + chartWidth / 2,
    y: y3 - BAR_HEIGHT - BAR_GAP * 2 - DEFAULT_FONT_SIZE,
    roundness: null,
    textAlign: "center"
  }) : null;
  const debugRect = debug ? newElement({
    backgroundColor,
    groupIds: [groupId],
    ...commonProps,
    type: "rectangle",
    x: x3,
    y: y3 - chartHeight,
    width: chartWidth,
    height: chartHeight,
    strokeColor: COLOR_PALETTE.black,
    fillStyle: "solid",
    opacity: 6
  }) : null;
  return [
    ...debugRect ? [debugRect] : [],
    ...title ? [title] : [],
    ...chartXLabels(spreadsheet, x3, y3, groupId, backgroundColor),
    ...chartYLabels(spreadsheet, x3, y3, groupId, backgroundColor),
    ...chartLines(spreadsheet, x3, y3, groupId, backgroundColor)
  ];
};
var chartTypeBar = (spreadsheet, x3, y3) => {
  const max = Math.max(...spreadsheet.values);
  const groupId = randomId();
  const backgroundColor = bgColors[Math.floor(Math.random() * bgColors.length)];
  const bars = spreadsheet.values.map((value, index2) => {
    const barHeight = value / max * BAR_HEIGHT;
    return newElement({
      backgroundColor,
      groupIds: [groupId],
      ...commonProps,
      type: "rectangle",
      x: x3 + index2 * (BAR_WIDTH + BAR_GAP) + BAR_GAP,
      y: y3 - barHeight - BAR_GAP,
      width: BAR_WIDTH,
      height: barHeight
    });
  });
  return [
    ...bars,
    ...chartBaseElements(
      spreadsheet,
      x3,
      y3,
      groupId,
      backgroundColor,
      define_import_meta_env_default.DEV
    )
  ];
};
var chartTypeLine = (spreadsheet, x3, y3) => {
  const max = Math.max(...spreadsheet.values);
  const groupId = randomId();
  const backgroundColor = bgColors[Math.floor(Math.random() * bgColors.length)];
  let index2 = 0;
  const points = [];
  for (const value of spreadsheet.values) {
    const cx = index2 * (BAR_WIDTH + BAR_GAP);
    const cy = -(value / max) * BAR_HEIGHT;
    points.push([cx, cy]);
    index2++;
  }
  const maxX = Math.max(...points.map((element) => element[0]));
  const maxY = Math.max(...points.map((element) => element[1]));
  const minX = Math.min(...points.map((element) => element[0]));
  const minY = Math.min(...points.map((element) => element[1]));
  const line2 = newLinearElement({
    backgroundColor,
    groupIds: [groupId],
    ...commonProps,
    type: "line",
    x: x3 + BAR_GAP + BAR_WIDTH / 2,
    y: y3 - BAR_GAP,
    startArrowhead: null,
    endArrowhead: null,
    height: maxY - minY,
    width: maxX - minX,
    strokeWidth: 2,
    points
  });
  const dots = spreadsheet.values.map((value, index3) => {
    const cx = index3 * (BAR_WIDTH + BAR_GAP) + BAR_GAP / 2;
    const cy = -(value / max) * BAR_HEIGHT + BAR_GAP / 2;
    return newElement({
      backgroundColor,
      groupIds: [groupId],
      ...commonProps,
      fillStyle: "solid",
      strokeWidth: 2,
      type: "ellipse",
      x: x3 + cx + BAR_WIDTH / 2,
      y: y3 + cy - BAR_GAP * 2,
      width: BAR_GAP,
      height: BAR_GAP
    });
  });
  const lines = spreadsheet.values.map((value, index3) => {
    const cx = index3 * (BAR_WIDTH + BAR_GAP) + BAR_GAP / 2;
    const cy = value / max * BAR_HEIGHT + BAR_GAP / 2 + BAR_GAP;
    return newLinearElement({
      backgroundColor,
      groupIds: [groupId],
      ...commonProps,
      type: "line",
      x: x3 + cx + BAR_WIDTH / 2 + BAR_GAP / 2,
      y: y3 - cy,
      startArrowhead: null,
      endArrowhead: null,
      height: cy,
      strokeStyle: "dotted",
      opacity: GRID_OPACITY,
      points: [
        [0, 0],
        [0, cy]
      ]
    });
  });
  return [
    ...chartBaseElements(
      spreadsheet,
      x3,
      y3,
      groupId,
      backgroundColor,
      define_import_meta_env_default.DEV
    ),
    line2,
    ...lines,
    ...dots
  ];
};
var renderSpreadsheet = (chartType, spreadsheet, x3, y3) => {
  if (chartType === "line") {
    return chartTypeLine(spreadsheet, x3, y3);
  }
  return chartTypeBar(spreadsheet, x3, y3);
};

// clipboard.ts
var probablySupportsClipboardReadText = "clipboard" in navigator && "readText" in navigator.clipboard;
var probablySupportsClipboardWriteText = "clipboard" in navigator && "writeText" in navigator.clipboard;
var probablySupportsClipboardBlob = "clipboard" in navigator && "write" in navigator.clipboard && "ClipboardItem" in window && "toBlob" in HTMLCanvasElement.prototype;
var clipboardContainsElements = (contents) => {
  if ([
    EXPORT_DATA_TYPES.excalidraw,
    EXPORT_DATA_TYPES.excalidrawClipboard,
    EXPORT_DATA_TYPES.excalidrawClipboardWithAPI
  ].includes(contents?.type) && Array.isArray(contents.elements)) {
    return true;
  }
  return false;
};
var createPasteEvent = ({
  types,
  files
}) => {
  if (!types && !files) {
    console.warn("createPasteEvent: no types or files provided");
  }
  const event = new ClipboardEvent("paste", {
    clipboardData: new DataTransfer()
  });
  if (types) {
    for (const [type, value] of Object.entries(types)) {
      try {
        event.clipboardData?.setData(type, value);
        if (event.clipboardData?.getData(type) !== value) {
          throw new Error(`Failed to set "${type}" as clipboardData item`);
        }
      } catch (error) {
        throw new Error(error.message);
      }
    }
  }
  if (files) {
    let idx = -1;
    for (const file2 of files) {
      idx++;
      try {
        event.clipboardData?.items.add(file2);
        if (event.clipboardData?.files[idx] !== file2) {
          throw new Error(
            `Failed to set file "${file2.name}" as clipboardData item`
          );
        }
      } catch (error) {
        throw new Error(error.message);
      }
    }
  }
  return event;
};
var serializeAsClipboardJSON = ({
  elements,
  files
}) => {
  const framesToCopy = new Set(
    elements.filter((element) => isFrameLikeElement(element))
  );
  let foundFile = false;
  const _files = elements.reduce((acc, element) => {
    if (isInitializedImageElement(element)) {
      foundFile = true;
      if (files && files[element.fileId]) {
        acc[element.fileId] = files[element.fileId];
      }
    }
    return acc;
  }, {});
  if (foundFile && !files) {
    console.warn(
      "copyToClipboard: attempting to file element(s) without providing associated `files` object."
    );
  }
  const contents = {
    type: EXPORT_DATA_TYPES.excalidrawClipboard,
    elements: elements.map((element) => {
      if (getContainingFrame(element) && !framesToCopy.has(getContainingFrame(element))) {
        const copiedElement = deepCopyElement(element);
        mutateElement(copiedElement, {
          frameId: null
        });
        return copiedElement;
      }
      return element;
    }),
    files: files ? _files : void 0
  };
  return JSON.stringify(contents);
};
var copyToClipboard = async (elements, files, clipboardEvent) => {
  await copyTextToSystemClipboard(
    serializeAsClipboardJSON({ elements, files }),
    clipboardEvent
  );
};
var parsePotentialSpreadsheet = (text) => {
  const result = tryParseSpreadsheet(text);
  if (result.type === VALID_SPREADSHEET) {
    return { spreadsheet: result.spreadsheet };
  }
  return null;
};
function parseHTMLTree(el) {
  let result = [];
  for (const node of el.childNodes) {
    if (node.nodeType === 3) {
      const text = node.textContent?.trim();
      if (text) {
        result.push({ type: "text", value: text });
      }
    } else if (node instanceof HTMLImageElement) {
      const url = node.getAttribute("src");
      if (url && url.startsWith("http")) {
        result.push({ type: "imageUrl", value: url });
      }
    } else {
      result = result.concat(parseHTMLTree(node));
    }
  }
  return result;
}
var maybeParseHTMLPaste = (event) => {
  const html = event.clipboardData?.getData("text/html");
  if (!html) {
    return null;
  }
  try {
    const doc = new DOMParser().parseFromString(html, "text/html");
    const content = parseHTMLTree(doc.body);
    if (content.length) {
      return { type: "mixedContent", value: content };
    }
  } catch (error) {
    console.error(`error in parseHTMLFromPaste: ${error.message}`);
  }
  return null;
};
var readSystemClipboard = async () => {
  const types = {};
  try {
    if (navigator.clipboard?.readText) {
      return { "text/plain": await navigator.clipboard?.readText() };
    }
  } catch (error) {
    if (navigator.clipboard?.read) {
      console.warn(
        `navigator.clipboard.readText() failed (${error.message}). Failling back to navigator.clipboard.read()`
      );
    } else {
      throw error;
    }
  }
  let clipboardItems;
  try {
    clipboardItems = await navigator.clipboard?.read();
  } catch (error) {
    if (error.name === "DataError") {
      console.warn(
        `navigator.clipboard.read() error, clipboard is probably empty: ${error.message}`
      );
      return types;
    }
    throw error;
  }
  for (const item of clipboardItems) {
    for (const type of item.types) {
      if (!isMemberOf(ALLOWED_PASTE_MIME_TYPES, type)) {
        continue;
      }
      try {
        types[type] = await (await item.getType(type)).text();
      } catch (error) {
        console.warn(
          `Cannot retrieve ${type} from clipboardItem: ${error.message}`
        );
      }
    }
  }
  if (Object.keys(types).length === 0) {
    console.warn("No clipboard data found from clipboard.read().");
    return types;
  }
  return types;
};
var parseClipboardEvent = async (event, isPlainPaste = false) => {
  try {
    const mixedContent = !isPlainPaste && event && maybeParseHTMLPaste(event);
    if (mixedContent) {
      if (mixedContent.value.every((item) => item.type === "text")) {
        return {
          type: "text",
          value: event.clipboardData?.getData("text/plain") || mixedContent.value.map((item) => item.value).join("\n").trim()
        };
      }
      return mixedContent;
    }
    const text = event.clipboardData?.getData("text/plain");
    return { type: "text", value: (text || "").trim() };
  } catch {
    return { type: "text", value: "" };
  }
};
var parseClipboard = async (event, isPlainPaste = false) => {
  const parsedEventData = await parseClipboardEvent(event, isPlainPaste);
  if (parsedEventData.type === "mixedContent") {
    return {
      mixedContent: parsedEventData.value
    };
  }
  try {
    const spreadsheetResult = !isPlainPaste && parsePotentialSpreadsheet(parsedEventData.value);
    if (spreadsheetResult) {
      return spreadsheetResult;
    }
  } catch (error) {
    console.error(error);
  }
  try {
    const systemClipboardData = JSON.parse(parsedEventData.value);
    const programmaticAPI = systemClipboardData.type === EXPORT_DATA_TYPES.excalidrawClipboardWithAPI;
    if (clipboardContainsElements(systemClipboardData)) {
      return {
        elements: systemClipboardData.elements,
        files: systemClipboardData.files,
        text: isPlainPaste ? JSON.stringify(systemClipboardData.elements, null, 2) : void 0,
        programmaticAPI
      };
    }
  } catch {
  }
  return { text: parsedEventData.value };
};
var copyBlobToClipboardAsPng = async (blob) => {
  try {
    await navigator.clipboard.write([
      new window.ClipboardItem({
        [MIME_TYPES.png]: blob
      })
    ]);
  } catch (error) {
    if (isPromiseLike(blob)) {
      await navigator.clipboard.write([
        new window.ClipboardItem({
          [MIME_TYPES.png]: await blob
        })
      ]);
    } else {
      throw error;
    }
  }
};
var copyTextToSystemClipboard = async (text, clipboardEvent) => {
  if (probablySupportsClipboardWriteText) {
    try {
      await navigator.clipboard.writeText(text || "");
      return;
    } catch (error) {
      console.error(error);
    }
  }
  try {
    if (clipboardEvent) {
      clipboardEvent.clipboardData?.setData("text/plain", text || "");
      if (clipboardEvent.clipboardData?.getData("text/plain") !== text) {
        throw new Error("Failed to setData on clipboardEvent");
      }
      return;
    }
  } catch (error) {
    console.error(error);
  }
  if (!copyTextViaExecCommand(text)) {
    throw new Error(t("errors.copyToSystemClipboardFailed"));
  }
};
var copyTextViaExecCommand = (text) => {
  if (!text) {
    text = " ";
  }
  const isRTL2 = document.documentElement.getAttribute("dir") === "rtl";
  const textarea = document.createElement("textarea");
  textarea.style.border = "0";
  textarea.style.padding = "0";
  textarea.style.margin = "0";
  textarea.style.position = "absolute";
  textarea.style[isRTL2 ? "right" : "left"] = "-9999px";
  const yPosition = window.pageYOffset || document.documentElement.scrollTop;
  textarea.style.top = `${yPosition}px`;
  textarea.style.fontSize = "12pt";
  textarea.setAttribute("readonly", "");
  textarea.value = text;
  document.body.appendChild(textarea);
  let success = false;
  try {
    textarea.select();
    textarea.setSelectionRange(0, textarea.value.length);
    success = document.execCommand("copy");
  } catch (error) {
    console.error(error);
  }
  textarea.remove();
  return success;
};

// data/filesystem.ts
init_define_import_meta_env();

// ../../node_modules/browser-fs-access/dist/index.mjs
init_define_import_meta_env();
var e2 = (() => {
  if ("undefined" == typeof self)
    return false;
  if ("top" in self && self !== top)
    try {
      top;
    } catch (e3) {
      return false;
    }
  else if ("showOpenFilePicker" in self)
    return "showOpenFilePicker";
  return false;
})();
var t3 = e2 ? import("./file-open-002ab408-XVKQNBC7.js") : import("./file-open-7c801643-3UY7RH3S.js");
async function n3(...e3) {
  return (await t3).default(...e3);
}
var i3 = e2 ? import("./directory-open-4ed118d0-KAOYP3QS.js") : import("./directory-open-01563666-CNVDULTN.js");
var o3 = e2 ? import("./file-save-745eba88-34LASP67.js") : import("./file-save-3189631c-PVOTRJAU.js");
async function s3(...e3) {
  return (await o3).default(...e3);
}

// errors.ts
init_define_import_meta_env();
var CanvasError = class extends Error {
  constructor(message = "Couldn't export canvas.", name = "CANVAS_ERROR") {
    super();
    this.name = name;
    this.message = message;
  }
};
var AbortError = class extends DOMException {
  constructor(message = "Request Aborted") {
    super(message, "AbortError");
  }
};
var ImageSceneDataError = class extends Error {
  code;
  constructor(message = "Image Scene Data Error", code = "IMAGE_SCENE_DATA_ERROR") {
    super(message);
    this.name = "EncodingError";
    this.code = code;
  }
};

// data/filesystem.ts
var INPUT_CHANGE_INTERVAL_MS = 500;
var fileOpen = (opts) => {
  const mimeTypes = opts.extensions?.reduce((mimeTypes2, type) => {
    mimeTypes2.push(MIME_TYPES[type]);
    return mimeTypes2;
  }, []);
  const extensions = opts.extensions?.reduce((acc, ext) => {
    if (ext === "jpg") {
      return acc.concat(".jpg", ".jpeg");
    }
    return acc.concat(`.${ext}`);
  }, []);
  return n3({
    description: opts.description,
    extensions,
    mimeTypes,
    multiple: opts.multiple ?? false,
    legacySetup: (resolve, reject, input) => {
      const scheduleRejection = debounce(reject, INPUT_CHANGE_INTERVAL_MS);
      const focusHandler = () => {
        checkForFile();
        document.addEventListener("keyup" /* KEYUP */, scheduleRejection);
        document.addEventListener("pointerup" /* POINTER_UP */, scheduleRejection);
        scheduleRejection();
      };
      const checkForFile = () => {
        if (input.files?.length) {
          const ret = opts.multiple ? [...input.files] : input.files[0];
          resolve(ret);
        }
      };
      requestAnimationFrame(() => {
        window.addEventListener("focus" /* FOCUS */, focusHandler);
      });
      const interval = window.setInterval(() => {
        checkForFile();
      }, INPUT_CHANGE_INTERVAL_MS);
      return (rejectPromise) => {
        clearInterval(interval);
        scheduleRejection.cancel();
        window.removeEventListener("focus" /* FOCUS */, focusHandler);
        document.removeEventListener("keyup" /* KEYUP */, scheduleRejection);
        document.removeEventListener("pointerup" /* POINTER_UP */, scheduleRejection);
        if (rejectPromise) {
          console.warn("Opening the file was canceled (legacy-fs).");
          rejectPromise(new AbortError());
        }
      };
    }
  });
};
var fileSave = (blob, opts) => {
  return s3(
    blob,
    {
      fileName: `${opts.name}.${opts.extension}`,
      description: opts.description,
      extensions: [`.${opts.extension}`]
    },
    opts.fileHandle
  );
};

// data/json.ts
init_define_import_meta_env();
var filterOutDeletedFiles = (elements, files) => {
  const nextFiles = {};
  for (const element of elements) {
    if (!element.isDeleted && "fileId" in element && element.fileId && files[element.fileId]) {
      nextFiles[element.fileId] = files[element.fileId];
    }
  }
  return nextFiles;
};
var serializeAsJSON = (elements, appState, files, type) => {
  const data = {
    type: EXPORT_DATA_TYPES.excalidraw,
    version: VERSIONS.excalidraw,
    source: EXPORT_SOURCE,
    elements: type === "local" ? clearElementsForExport(elements) : clearElementsForDatabase(elements),
    appState: type === "local" ? cleanAppStateForExport(appState) : clearAppStateForDatabase(appState),
    files: type === "local" ? filterOutDeletedFiles(elements, files) : (
      // will be stripped from JSON
      void 0
    )
  };
  return JSON.stringify(data, null, 2);
};
var saveAsJSON = async (elements, appState, files, name = appState.name || DEFAULT_FILENAME) => {
  const serialized = serializeAsJSON(elements, appState, files, "local");
  const blob = new Blob([serialized], {
    type: MIME_TYPES.excalidraw
  });
  const fileHandle = await fileSave(blob, {
    name,
    extension: "excalidraw",
    description: "Excalidraw file",
    fileHandle: isImageFileHandle(appState.fileHandle) ? null : appState.fileHandle
  });
  return { fileHandle };
};
var loadFromJSON = async (localAppState, localElements) => {
  const file2 = await fileOpen({
    description: "Excalidraw files"
    // ToDo: Be over-permissive until https://bugs.webkit.org/show_bug.cgi?id=34442
    // gets resolved. Else, iOS users cannot open `.excalidraw` files.
    // extensions: ["json", "excalidraw", "png", "svg"],
  });
  return loadFromBlob(
    await normalizeFile(file2),
    localAppState,
    localElements,
    file2.handle
  );
};
var isValidExcalidrawData = (data) => {
  return data?.type === EXPORT_DATA_TYPES.excalidraw && (!data.elements || Array.isArray(data.elements) && (!data.appState || typeof data.appState === "object"));
};
var isValidLibrary = (json) => {
  return typeof json === "object" && json && json.type === EXPORT_DATA_TYPES.excalidrawLibrary && (json.version === 1 || json.version === 2);
};
var serializeLibraryAsJSON = (libraryItems) => {
  const data = {
    type: EXPORT_DATA_TYPES.excalidrawLibrary,
    version: VERSIONS.excalidrawLibrary,
    source: EXPORT_SOURCE,
    libraryItems
  };
  return JSON.stringify(data, null, 2);
};
var saveLibraryAsJSON = async (libraryItems) => {
  const serialized = serializeLibraryAsJSON(libraryItems);
  await fileSave(
    new Blob([serialized], {
      type: MIME_TYPES.excalidrawlib
    }),
    {
      name: "library",
      extension: "excalidrawlib",
      description: "Excalidraw library file"
    }
  );
};

// data/index.ts
var prepareElementsForExport = (elements, { selectedElementIds }, exportSelectionOnly) => {
  elements = getNonDeletedElements2(elements);
  const isExportingSelection = exportSelectionOnly && isSomeElementSelected(elements, { selectedElementIds });
  let exportingFrame = null;
  let exportedElements = isExportingSelection ? getSelectedElements(
    elements,
    { selectedElementIds },
    {
      includeBoundTextElement: true
    }
  ) : elements;
  if (isExportingSelection) {
    if (exportedElements.length === 1 && isFrameLikeElement(exportedElements[0])) {
      exportingFrame = exportedElements[0];
      exportedElements = getElementsOverlappingFrame(elements, exportingFrame);
    } else if (exportedElements.length > 1) {
      exportedElements = getSelectedElements(
        elements,
        { selectedElementIds },
        {
          includeBoundTextElement: true,
          includeElementsInFrames: true
        }
      );
    }
  }
  return {
    exportingFrame,
    exportedElements: cloneJSON(exportedElements)
  };
};
var exportCanvas = async (type, elements, appState, files, {
  exportBackground,
  exportPadding = DEFAULT_EXPORT_PADDING,
  viewBackgroundColor,
  name = appState.name || DEFAULT_FILENAME,
  fileHandle = null,
  exportingFrame = null
}) => {
  if (elements.length === 0) {
    throw new Error(t("alerts.cannotExportEmptyCanvas"));
  }
  if (type === "svg" || type === "clipboard-svg") {
    const svgPromise = exportToSvg(
      elements,
      {
        exportBackground,
        exportWithDarkMode: appState.exportWithDarkMode,
        viewBackgroundColor,
        exportPadding,
        exportScale: appState.exportScale,
        exportEmbedScene: appState.exportEmbedScene && type === "svg"
      },
      files,
      { exportingFrame }
    );
    if (type === "svg") {
      return fileSave(
        svgPromise.then((svg) => {
          return new Blob([svg.outerHTML], { type: MIME_TYPES.svg });
        }),
        {
          description: "Export to SVG",
          name,
          extension: appState.exportEmbedScene ? "excalidraw.svg" : "svg",
          fileHandle
        }
      );
    } else if (type === "clipboard-svg") {
      await copyTextToSystemClipboard(
        await svgPromise.then((svg) => svg.outerHTML)
      );
      return;
    }
  }
  const tempCanvas = exportToCanvas(elements, appState, files, {
    exportBackground,
    viewBackgroundColor,
    exportPadding,
    exportingFrame
  });
  if (type === "png") {
    let blob = canvasToBlob(tempCanvas);
    if (appState.exportEmbedScene) {
      blob = blob.then(
        (blob2) => import("./image-YINPW27J.js").then(
          ({ encodePngMetadata: encodePngMetadata2 }) => encodePngMetadata2({
            blob: blob2,
            metadata: serializeAsJSON(elements, appState, files, "local")
          })
        )
      );
    }
    return fileSave(blob, {
      description: "Export to PNG",
      name,
      // FIXME reintroduce `excalidraw.png` when most people upgrade away
      // from 111.0.5563.64 (arm64), see #6349
      extension: (
        /* appState.exportEmbedScene ? "excalidraw.png" : */
        "png"
      ),
      fileHandle
    });
  } else if (type === "clipboard") {
    try {
      const blob = canvasToBlob(tempCanvas);
      await copyBlobToClipboardAsPng(blob);
    } catch (error) {
      console.warn(error);
      if (error.name === "CANVAS_POSSIBLY_TOO_BIG") {
        throw error;
      }
      if (isFirefox && error.name === "TypeError") {
        throw new Error(
          `${t("alerts.couldNotCopyToClipboard")}

${t(
            "hints.firefox_clipboard_write"
          )}`
        );
      } else {
        throw new Error(t("alerts.couldNotCopyToClipboard"));
      }
    }
  } else {
    throw new Error("Unsupported export type");
  }
};

// data/resave.ts
init_define_import_meta_env();
var resaveAsImageWithScene = async (elements, appState, files, name) => {
  const { exportBackground, viewBackgroundColor, fileHandle } = appState;
  const fileHandleType = getFileHandleType(fileHandle);
  if (!fileHandle || !isImageFileHandleType(fileHandleType)) {
    throw new Error(
      "fileHandle should exist and should be of type svg or png when resaving"
    );
  }
  appState = {
    ...appState,
    exportEmbedScene: true
  };
  const { exportedElements, exportingFrame } = prepareElementsForExport(
    elements,
    appState,
    false
  );
  await exportCanvas(fileHandleType, exportedElements, appState, files, {
    exportBackground,
    viewBackgroundColor,
    name,
    fileHandle,
    exportingFrame
  });
  return { fileHandle };
};

// components/CheckboxItem.tsx
init_define_import_meta_env();
var import_jsx_runtime24 = __toESM(require_jsx_runtime(), 1);
var CheckboxItem = ({ children, checked, onChange, className }) => {
  return /* @__PURE__ */ (0, import_jsx_runtime24.jsxs)(
    "div",
    {
      className: clsx_m_default("Checkbox", className, { "is-checked": checked }),
      onClick: (event) => {
        onChange(!checked, event);
        event.currentTarget.querySelector(
          ".Checkbox-box"
        ).focus();
      },
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime24.jsx)("button", { className: "Checkbox-box", role: "checkbox", "aria-checked": checked, children: checkIcon }),
        /* @__PURE__ */ (0, import_jsx_runtime24.jsx)("div", { className: "Checkbox-label", children })
      ]
    }
  );
};

// actions/actionExport.tsx
var import_jsx_runtime25 = __toESM(require_jsx_runtime(), 1);
var actionChangeProjectName = register({
  name: "changeProjectName",
  trackEvent: false,
  perform: (_elements, appState, value) => {
    return { appState: { ...appState, name: value }, commitToHistory: false };
  },
  PanelComponent: ({ appState, updateData, appProps, data, app }) => /* @__PURE__ */ (0, import_jsx_runtime25.jsx)(
    ProjectName,
    {
      label: t("labels.fileTitle"),
      value: app.getName(),
      onChange: (name) => updateData(name),
      ignoreFocus: data?.ignoreFocus ?? false
    }
  )
});
var actionChangeExportScale = register({
  name: "changeExportScale",
  trackEvent: { category: "export", action: "scale" },
  perform: (_elements, appState, value) => {
    return {
      appState: { ...appState, exportScale: value },
      commitToHistory: false
    };
  },
  PanelComponent: ({ elements: allElements, appState, updateData }) => {
    const elements = getNonDeletedElements2(allElements);
    const exportSelected = isSomeElementSelected(elements, appState);
    const exportedElements = exportSelected ? getSelectedElements(elements, appState) : elements;
    return /* @__PURE__ */ (0, import_jsx_runtime25.jsx)(import_jsx_runtime25.Fragment, { children: EXPORT_SCALES.map((s4) => {
      const [width, height] = getExportSize(
        exportedElements,
        DEFAULT_EXPORT_PADDING,
        s4
      );
      const scaleButtonTitle = `${t(
        "imageExportDialog.label.scale"
      )} ${s4}x (${width}x${height})`;
      return /* @__PURE__ */ (0, import_jsx_runtime25.jsx)(
        ToolButton,
        {
          size: "small",
          type: "radio",
          icon: `${s4}x`,
          name: "export-canvas-scale",
          title: scaleButtonTitle,
          "aria-label": scaleButtonTitle,
          id: "export-canvas-scale",
          checked: s4 === appState.exportScale,
          onChange: () => updateData(s4)
        },
        s4
      );
    }) });
  }
});
var actionChangeExportBackground = register({
  name: "changeExportBackground",
  trackEvent: { category: "export", action: "toggleBackground" },
  perform: (_elements, appState, value) => {
    return {
      appState: { ...appState, exportBackground: value },
      commitToHistory: false
    };
  },
  PanelComponent: ({ appState, updateData }) => /* @__PURE__ */ (0, import_jsx_runtime25.jsx)(
    CheckboxItem,
    {
      checked: appState.exportBackground,
      onChange: (checked) => updateData(checked),
      children: t("imageExportDialog.label.withBackground")
    }
  )
});
var actionChangeExportEmbedScene = register({
  name: "changeExportEmbedScene",
  trackEvent: { category: "export", action: "embedScene" },
  perform: (_elements, appState, value) => {
    return {
      appState: { ...appState, exportEmbedScene: value },
      commitToHistory: false
    };
  },
  PanelComponent: ({ appState, updateData }) => /* @__PURE__ */ (0, import_jsx_runtime25.jsxs)(
    CheckboxItem,
    {
      checked: appState.exportEmbedScene,
      onChange: (checked) => updateData(checked),
      children: [
        t("imageExportDialog.label.embedScene"),
        /* @__PURE__ */ (0, import_jsx_runtime25.jsx)(Tooltip, { label: t("imageExportDialog.tooltip.embedScene"), long: true, children: /* @__PURE__ */ (0, import_jsx_runtime25.jsx)("div", { className: "excalidraw-tooltip-icon", children: questionCircle }) })
      ]
    }
  )
});
var actionSaveToActiveFile = register({
  name: "saveToActiveFile",
  trackEvent: { category: "export" },
  predicate: (elements, appState, props, app) => {
    return !!app.props.UIOptions.canvasActions.saveToActiveFile && !!appState.fileHandle && !appState.viewModeEnabled;
  },
  perform: async (elements, appState, value, app) => {
    const fileHandleExists = !!appState.fileHandle;
    try {
      const { fileHandle } = isImageFileHandle(appState.fileHandle) ? await resaveAsImageWithScene(
        elements,
        appState,
        app.files,
        app.getName()
      ) : await saveAsJSON(elements, appState, app.files, app.getName());
      return {
        commitToHistory: false,
        appState: {
          ...appState,
          fileHandle,
          toast: fileHandleExists ? {
            message: fileHandle?.name ? t("toast.fileSavedToFilename").replace(
              "{filename}",
              `"${fileHandle.name}"`
            ) : t("toast.fileSaved")
          } : null
        }
      };
    } catch (error) {
      if (error?.name !== "AbortError") {
        console.error(error);
      } else {
        console.warn(error);
      }
      return { commitToHistory: false };
    }
  },
  keyTest: (event) => event.key === KEYS.S && event[KEYS.CTRL_OR_CMD] && !event.shiftKey
});
var actionSaveFileToDisk = register({
  name: "saveFileToDisk",
  viewMode: true,
  trackEvent: { category: "export" },
  perform: async (elements, appState, value, app) => {
    try {
      const { fileHandle } = await saveAsJSON(
        elements,
        {
          ...appState,
          fileHandle: null
        },
        app.files,
        app.getName()
      );
      return {
        commitToHistory: false,
        appState: {
          ...appState,
          openDialog: null,
          fileHandle,
          toast: { message: t("toast.fileSaved") }
        }
      };
    } catch (error) {
      if (error?.name !== "AbortError") {
        console.error(error);
      } else {
        console.warn(error);
      }
      return { commitToHistory: false };
    }
  },
  keyTest: (event) => event.key === KEYS.S && event.shiftKey && event[KEYS.CTRL_OR_CMD],
  PanelComponent: ({ updateData }) => /* @__PURE__ */ (0, import_jsx_runtime25.jsx)(
    ToolButton,
    {
      type: "button",
      icon: saveAs,
      title: t("buttons.saveAs"),
      "aria-label": t("buttons.saveAs"),
      showAriaLabel: useDevice().editor.isMobile,
      hidden: !e2,
      onClick: () => updateData(null),
      "data-testid": "save-as-button"
    }
  )
});
var actionLoadScene = register({
  name: "loadScene",
  trackEvent: { category: "export" },
  predicate: (elements, appState, props, app) => {
    return !!app.props.UIOptions.canvasActions.loadScene && !appState.viewModeEnabled;
  },
  perform: async (elements, appState, _, app) => {
    try {
      const {
        elements: loadedElements,
        appState: loadedAppState,
        files
      } = await loadFromJSON(appState, elements);
      return {
        elements: loadedElements,
        appState: loadedAppState,
        files,
        commitToHistory: true
      };
    } catch (error) {
      if (error?.name === "AbortError") {
        console.warn(error);
        return false;
      }
      return {
        elements,
        appState: { ...appState, errorMessage: error.message },
        files: app.files,
        commitToHistory: false
      };
    }
  },
  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.key === KEYS.O
});
var actionExportWithDarkMode = register({
  name: "exportWithDarkMode",
  trackEvent: { category: "export", action: "toggleTheme" },
  perform: (_elements, appState, value) => {
    return {
      appState: { ...appState, exportWithDarkMode: value },
      commitToHistory: false
    };
  },
  PanelComponent: ({ appState, updateData }) => /* @__PURE__ */ (0, import_jsx_runtime25.jsx)(
    "div",
    {
      style: {
        display: "flex",
        justifyContent: "flex-end",
        marginTop: "-45px",
        marginBottom: "10px"
      },
      children: /* @__PURE__ */ (0, import_jsx_runtime25.jsx)(
        DarkModeToggle,
        {
          value: appState.exportWithDarkMode ? THEME.DARK : THEME.LIGHT,
          onChange: (theme) => {
            updateData(theme === THEME.DARK);
          },
          title: t("imageExportDialog.label.darkMode")
        }
      )
    }
  )
});

// actions/actionStyles.ts
init_define_import_meta_env();
var copiedStyles = "{}";
var actionCopyStyles = register({
  name: "copyStyles",
  trackEvent: { category: "element" },
  perform: (elements, appState, formData, app) => {
    const elementsCopied = [];
    const element = elements.find((el) => appState.selectedElementIds[el.id]);
    elementsCopied.push(element);
    if (element && hasBoundTextElement(element)) {
      const boundTextElement = getBoundTextElement(
        element,
        app.scene.getNonDeletedElementsMap()
      );
      elementsCopied.push(boundTextElement);
    }
    if (element) {
      copiedStyles = JSON.stringify(elementsCopied);
    }
    return {
      appState: {
        ...appState,
        toast: { message: t("toast.copyStyles") }
      },
      commitToHistory: false
    };
  },
  contextItemLabel: "labels.copyStyles",
  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.C
});
var actionPasteStyles = register({
  name: "pasteStyles",
  trackEvent: { category: "element" },
  perform: (elements, appState, formData, app) => {
    const elementsCopied = JSON.parse(copiedStyles);
    const pastedElement = elementsCopied[0];
    const boundTextElement = elementsCopied[1];
    if (!isExcalidrawElement(pastedElement)) {
      return { elements, commitToHistory: false };
    }
    const selectedElements = getSelectedElements(elements, appState, {
      includeBoundTextElement: true
    });
    const selectedElementIds = selectedElements.map((element) => element.id);
    return {
      elements: elements.map((element) => {
        if (selectedElementIds.includes(element.id)) {
          let elementStylesToCopyFrom = pastedElement;
          if (isTextElement(element) && element.containerId) {
            elementStylesToCopyFrom = boundTextElement;
          }
          if (!elementStylesToCopyFrom) {
            return element;
          }
          let newElement2 = newElementWith(element, {
            backgroundColor: elementStylesToCopyFrom?.backgroundColor,
            strokeWidth: elementStylesToCopyFrom?.strokeWidth,
            strokeColor: elementStylesToCopyFrom?.strokeColor,
            strokeStyle: elementStylesToCopyFrom?.strokeStyle,
            fillStyle: elementStylesToCopyFrom?.fillStyle,
            opacity: elementStylesToCopyFrom?.opacity,
            roughness: elementStylesToCopyFrom?.roughness,
            roundness: elementStylesToCopyFrom.roundness ? canApplyRoundnessTypeToElement(
              elementStylesToCopyFrom.roundness.type,
              element
            ) ? elementStylesToCopyFrom.roundness : getDefaultRoundnessTypeForElement(element) : null
          });
          if (isTextElement(newElement2)) {
            const fontSize = elementStylesToCopyFrom.fontSize || DEFAULT_FONT_SIZE;
            const fontFamily = elementStylesToCopyFrom.fontFamily || DEFAULT_FONT_FAMILY;
            newElement2 = newElementWith(newElement2, {
              fontSize,
              fontFamily,
              textAlign: elementStylesToCopyFrom.textAlign || DEFAULT_TEXT_ALIGN,
              lineHeight: elementStylesToCopyFrom.lineHeight || getDefaultLineHeight(fontFamily)
            });
            let container = null;
            if (newElement2.containerId) {
              container = selectedElements.find(
                (element2) => isTextElement(newElement2) && element2.id === newElement2.containerId
              ) || null;
            }
            redrawTextBoundingBox(
              newElement2,
              container,
              app.scene.getNonDeletedElementsMap()
            );
          }
          if (newElement2.type === "arrow" && isArrowElement(elementStylesToCopyFrom)) {
            newElement2 = newElementWith(newElement2, {
              startArrowhead: elementStylesToCopyFrom.startArrowhead,
              endArrowhead: elementStylesToCopyFrom.endArrowhead
            });
          }
          if (isFrameLikeElement(element)) {
            newElement2 = newElementWith(newElement2, {
              roundness: null,
              backgroundColor: "transparent"
            });
          }
          return newElement2;
        }
        return element;
      }),
      commitToHistory: true
    };
  },
  contextItemLabel: "labels.pasteStyles",
  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.V
});

// actions/actionMenu.tsx
init_define_import_meta_env();
var import_jsx_runtime26 = __toESM(require_jsx_runtime(), 1);
var actionToggleCanvasMenu = register({
  name: "toggleCanvasMenu",
  trackEvent: { category: "menu" },
  perform: (_, appState) => ({
    appState: {
      ...appState,
      openMenu: appState.openMenu === "canvas" ? null : "canvas"
    },
    commitToHistory: false
  }),
  PanelComponent: ({ appState, updateData }) => /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(
    ToolButton,
    {
      type: "button",
      icon: HamburgerMenuIcon,
      "aria-label": t("buttons.menu"),
      onClick: updateData,
      selected: appState.openMenu === "canvas"
    }
  )
});
var actionToggleEditMenu = register({
  name: "toggleEditMenu",
  trackEvent: { category: "menu" },
  perform: (_elements, appState) => ({
    appState: {
      ...appState,
      openMenu: appState.openMenu === "shape" ? null : "shape"
    },
    commitToHistory: false
  }),
  PanelComponent: ({ elements, appState, updateData }) => /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(
    ToolButton,
    {
      visible: showSelectedShapeActions(
        appState,
        getNonDeletedElements2(elements)
      ),
      type: "button",
      icon: palette,
      "aria-label": t("buttons.edit"),
      onClick: updateData,
      selected: appState.openMenu === "shape"
    }
  )
});
var actionShortcuts = register({
  name: "toggleShortcuts",
  viewMode: true,
  trackEvent: { category: "menu", action: "toggleHelpDialog" },
  perform: (_elements, appState, _, { focusContainer }) => {
    if (appState.openDialog?.name === "help") {
      focusContainer();
    }
    return {
      appState: {
        ...appState,
        openDialog: appState.openDialog?.name === "help" ? null : {
          name: "help"
        }
      },
      commitToHistory: false
    };
  },
  keyTest: (event) => event.key === KEYS.QUESTION_MARK
});

// actions/actionGroup.tsx
init_define_import_meta_env();
var import_jsx_runtime27 = __toESM(require_jsx_runtime(), 1);
var allElementsInSameGroup = (elements) => {
  if (elements.length >= 2) {
    const groupIds = elements[0].groupIds;
    for (const groupId of groupIds) {
      if (elements.reduce(
        (acc, element) => acc && isElementInGroup(element, groupId),
        true
      )) {
        return true;
      }
    }
  }
  return false;
};
var enableActionGroup = (elements, appState, app) => {
  const selectedElements = app.scene.getSelectedElements({
    selectedElementIds: appState.selectedElementIds,
    includeBoundTextElement: true
  });
  return selectedElements.length >= 2 && !allElementsInSameGroup(selectedElements);
};
var actionGroup = register({
  name: "group",
  trackEvent: { category: "element" },
  perform: (elements, appState, _, app) => {
    const selectedElements = app.scene.getSelectedElements({
      selectedElementIds: appState.selectedElementIds,
      includeBoundTextElement: true
    });
    if (selectedElements.length < 2) {
      return { appState, elements, commitToHistory: false };
    }
    const selectedGroupIds = getSelectedGroupIds(appState);
    if (selectedGroupIds.length === 1) {
      const selectedGroupId = selectedGroupIds[0];
      const elementIdsInGroup = new Set(
        getElementsInGroup(elements, selectedGroupId).map(
          (element) => element.id
        )
      );
      const selectedElementIds = new Set(
        selectedElements.map((element) => element.id)
      );
      const combinedSet = /* @__PURE__ */ new Set([
        ...Array.from(elementIdsInGroup),
        ...Array.from(selectedElementIds)
      ]);
      if (combinedSet.size === elementIdsInGroup.size) {
        return { appState, elements, commitToHistory: false };
      }
    }
    let nextElements = [...elements];
    const groupingElementsFromDifferentFrames = new Set(selectedElements.map((element) => element.frameId)).size > 1;
    if (groupingElementsFromDifferentFrames) {
      const frameElementsMap = groupByFrameLikes(selectedElements);
      frameElementsMap.forEach((elementsInFrame, frameId) => {
        removeElementsFromFrame(
          elementsInFrame,
          app.scene.getNonDeletedElementsMap()
        );
      });
    }
    const newGroupId = randomId();
    const selectElementIds = arrayToMap(selectedElements);
    nextElements = nextElements.map((element) => {
      if (!selectElementIds.get(element.id)) {
        return element;
      }
      return newElementWith(element, {
        groupIds: addToGroup(
          element.groupIds,
          newGroupId,
          appState.editingGroupId
        )
      });
    });
    const elementsInGroup = getElementsInGroup(nextElements, newGroupId);
    const lastElementInGroup = elementsInGroup[elementsInGroup.length - 1];
    const lastGroupElementIndex = nextElements.lastIndexOf(lastElementInGroup);
    const elementsAfterGroup = nextElements.slice(lastGroupElementIndex + 1);
    const elementsBeforeGroup = nextElements.slice(0, lastGroupElementIndex).filter(
      (updatedElement) => !isElementInGroup(updatedElement, newGroupId)
    );
    nextElements = [
      ...elementsBeforeGroup,
      ...elementsInGroup,
      ...elementsAfterGroup
    ];
    return {
      appState: {
        ...appState,
        ...selectGroup(
          newGroupId,
          { ...appState, selectedGroupIds: {} },
          getNonDeletedElements2(nextElements)
        )
      },
      elements: nextElements,
      commitToHistory: true
    };
  },
  contextItemLabel: "labels.group",
  predicate: (elements, appState, _, app) => enableActionGroup(elements, appState, app),
  keyTest: (event) => !event.shiftKey && event[KEYS.CTRL_OR_CMD] && event.key === KEYS.G,
  PanelComponent: ({ elements, appState, updateData, app }) => /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(
    ToolButton,
    {
      hidden: !enableActionGroup(elements, appState, app),
      type: "button",
      icon: /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(GroupIcon, { theme: appState.theme }),
      onClick: () => updateData(null),
      title: `${t("labels.group")} \u2014 ${getShortcutKey("CtrlOrCmd+G")}`,
      "aria-label": t("labels.group"),
      visible: isSomeElementSelected(getNonDeletedElements2(elements), appState)
    }
  )
});
var actionUngroup = register({
  name: "ungroup",
  trackEvent: { category: "element" },
  perform: (elements, appState, _, app) => {
    const groupIds = getSelectedGroupIds(appState);
    const elementsMap = arrayToMap(elements);
    if (groupIds.length === 0) {
      return { appState, elements, commitToHistory: false };
    }
    let nextElements = [...elements];
    const boundTextElementIds = [];
    nextElements = nextElements.map((element) => {
      if (isBoundToContainer(element)) {
        boundTextElementIds.push(element.id);
      }
      const nextGroupIds = removeFromSelectedGroups(
        element.groupIds,
        appState.selectedGroupIds
      );
      if (nextGroupIds.length === element.groupIds.length) {
        return element;
      }
      return newElementWith(element, {
        groupIds: nextGroupIds
      });
    });
    const updateAppState = selectGroupsForSelectedElements(
      appState,
      getNonDeletedElements2(nextElements),
      appState,
      null
    );
    const selectedElements = app.scene.getSelectedElements(appState);
    const selectedElementFrameIds = new Set(
      selectedElements.filter((element) => element.frameId).map((element) => element.frameId)
    );
    const targetFrames = getFrameLikeElements(elements).filter(
      (frame) => selectedElementFrameIds.has(frame.id)
    );
    targetFrames.forEach((frame) => {
      if (frame) {
        nextElements = replaceAllElementsInFrame(
          nextElements,
          getElementsInResizingFrame(
            nextElements,
            frame,
            appState,
            elementsMap
          ),
          frame,
          app
        );
      }
    });
    updateAppState.selectedElementIds = Object.entries(
      updateAppState.selectedElementIds
    ).reduce(
      (acc, [id, selected]) => {
        if (selected && !boundTextElementIds.includes(id)) {
          acc[id] = true;
        }
        return acc;
      },
      {}
    );
    return {
      appState: { ...appState, ...updateAppState },
      elements: nextElements,
      commitToHistory: true
    };
  },
  keyTest: (event) => event.shiftKey && event[KEYS.CTRL_OR_CMD] && event.key === KEYS.G.toUpperCase(),
  contextItemLabel: "labels.ungroup",
  predicate: (elements, appState) => getSelectedGroupIds(appState).length > 0,
  PanelComponent: ({ elements, appState, updateData }) => /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(
    ToolButton,
    {
      type: "button",
      hidden: getSelectedGroupIds(appState).length === 0,
      icon: /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(UngroupIcon, { theme: appState.theme }),
      onClick: () => updateData(null),
      title: `${t("labels.ungroup")} \u2014 ${getShortcutKey("CtrlOrCmd+Shift+G")}`,
      "aria-label": t("labels.ungroup"),
      visible: isSomeElementSelected(getNonDeletedElements2(elements), appState)
    }
  )
});

// actions/actionNavigate.tsx
init_define_import_meta_env();

// components/Avatar.tsx
init_define_import_meta_env();
var import_react38 = __toESM(require_react(), 1);
var import_jsx_runtime28 = __toESM(require_jsx_runtime(), 1);
var Avatar = ({
  color,
  onClick,
  name,
  src,
  isBeingFollowed,
  isCurrentUser
}) => {
  const shortName = getNameInitial(name);
  const [error, setError] = (0, import_react38.useState)(false);
  const loadImg = !error && src;
  const style = loadImg ? void 0 : { background: color };
  return /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(
    "div",
    {
      className: clsx_m_default("Avatar", {
        "Avatar--is-followed": isBeingFollowed,
        "Avatar--is-current-user": isCurrentUser
      }),
      style,
      onClick,
      children: loadImg ? /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(
        "img",
        {
          className: "Avatar-img",
          src,
          alt: shortName,
          referrerPolicy: "no-referrer",
          onError: () => setError(true)
        }
      ) : shortName
    }
  );
};

// actions/actionNavigate.tsx
var import_jsx_runtime29 = __toESM(require_jsx_runtime(), 1);
var actionGoToCollaborator = register({
  name: "goToCollaborator",
  viewMode: true,
  trackEvent: { category: "collab" },
  perform: (_elements, appState, collaborator) => {
    if (!collaborator.socketId || appState.userToFollow?.socketId === collaborator.socketId || collaborator.isCurrentUser) {
      return {
        appState: {
          ...appState,
          userToFollow: null
        },
        commitToHistory: false
      };
    }
    return {
      appState: {
        ...appState,
        userToFollow: {
          socketId: collaborator.socketId,
          username: collaborator.username || ""
        },
        // Close mobile menu
        openMenu: appState.openMenu === "canvas" ? null : appState.openMenu
      },
      commitToHistory: false
    };
  },
  PanelComponent: ({ updateData, data, appState }) => {
    const { clientId, collaborator, withName, isBeingFollowed } = data;
    const background = getClientColor(clientId);
    return withName ? /* @__PURE__ */ (0, import_jsx_runtime29.jsxs)(
      "div",
      {
        className: "dropdown-menu-item dropdown-menu-item-base UserList__collaborator",
        onClick: () => updateData(collaborator),
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(
            Avatar,
            {
              color: background,
              onClick: () => {
              },
              name: collaborator.username || "",
              src: collaborator.avatarUrl,
              isBeingFollowed,
              isCurrentUser: collaborator.isCurrentUser === true
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime29.jsx)("div", { className: "UserList__collaborator-name", children: collaborator.username }),
          /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(
            "div",
            {
              className: "UserList__collaborator-follow-status-icon",
              style: { visibility: isBeingFollowed ? "visible" : "hidden" },
              title: isBeingFollowed ? t("userList.hint.followStatus") : void 0,
              "aria-hidden": true,
              children: eyeIcon
            }
          )
        ]
      }
    ) : /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(
      Avatar,
      {
        color: background,
        onClick: () => {
          updateData(collaborator);
        },
        name: collaborator.username || "",
        src: collaborator.avatarUrl,
        isBeingFollowed,
        isCurrentUser: collaborator.isCurrentUser === true
      }
    );
  }
});

// actions/actionAddToLibrary.ts
init_define_import_meta_env();
var actionAddToLibrary = register({
  name: "addToLibrary",
  trackEvent: { category: "element" },
  perform: (elements, appState, _, app) => {
    const selectedElements = app.scene.getSelectedElements({
      selectedElementIds: appState.selectedElementIds,
      includeBoundTextElement: true,
      includeElementsInFrames: true
    });
    for (const type of LIBRARY_DISABLED_TYPES) {
      if (selectedElements.some((element) => element.type === type)) {
        return {
          commitToHistory: false,
          appState: {
            ...appState,
            errorMessage: t(`errors.libraryElementTypeError.${type}`)
          }
        };
      }
    }
    return app.library.getLatestLibrary().then((items) => {
      return app.library.setLibrary([
        {
          id: randomId(),
          status: "unpublished",
          elements: selectedElements.map(deepCopyElement),
          created: Date.now()
        },
        ...items
      ]);
    }).then(() => {
      return {
        commitToHistory: false,
        appState: {
          ...appState,
          toast: { message: t("toast.addedToLibrary") }
        }
      };
    }).catch((error) => {
      return {
        commitToHistory: false,
        appState: {
          ...appState,
          errorMessage: error.message
        }
      };
    });
  },
  contextItemLabel: "labels.addToLibrary"
});

// actions/actionAlign.tsx
init_define_import_meta_env();

// align.ts
init_define_import_meta_env();
var alignElements = (selectedElements, elementsMap, alignment) => {
  const groups = getMaximumGroups(
    selectedElements,
    elementsMap
  );
  const selectionBoundingBox = getCommonBoundingBox(selectedElements);
  return groups.flatMap((group) => {
    const translation2 = calculateTranslation(
      group,
      selectionBoundingBox,
      alignment
    );
    return group.map(
      (element) => newElementWith(element, {
        x: element.x + translation2.x,
        y: element.y + translation2.y
      })
    );
  });
};
var calculateTranslation = (group, selectionBoundingBox, { axis, position }) => {
  const groupBoundingBox = getCommonBoundingBox(group);
  const [min, max] = axis === "x" ? ["minX", "maxX"] : ["minY", "maxY"];
  const noTranslation = { x: 0, y: 0 };
  if (position === "start") {
    return {
      ...noTranslation,
      [axis]: selectionBoundingBox[min] - groupBoundingBox[min]
    };
  } else if (position === "end") {
    return {
      ...noTranslation,
      [axis]: selectionBoundingBox[max] - groupBoundingBox[max]
    };
  }
  return {
    ...noTranslation,
    [axis]: (selectionBoundingBox[min] + selectionBoundingBox[max]) / 2 - (groupBoundingBox[min] + groupBoundingBox[max]) / 2
  };
};

// actions/actionAlign.tsx
var import_jsx_runtime30 = __toESM(require_jsx_runtime(), 1);
var alignActionsPredicate = (elements, appState, _, app) => {
  const selectedElements = app.scene.getSelectedElements(appState);
  return selectedElements.length > 1 && // TODO enable aligning frames when implemented properly
  !selectedElements.some((el) => isFrameLikeElement(el));
};
var alignSelectedElements = (elements, appState, app, alignment) => {
  const selectedElements = app.scene.getSelectedElements(appState);
  const elementsMap = arrayToMap(elements);
  const updatedElements = alignElements(
    selectedElements,
    elementsMap,
    alignment
  );
  const updatedElementsMap = arrayToMap(updatedElements);
  return updateFrameMembershipOfSelectedElements(
    elements.map((element) => updatedElementsMap.get(element.id) || element),
    appState,
    app
  );
};
var actionAlignTop = register({
  name: "alignTop",
  trackEvent: { category: "element" },
  predicate: alignActionsPredicate,
  perform: (elements, appState, _, app) => {
    return {
      appState,
      elements: alignSelectedElements(elements, appState, app, {
        position: "start",
        axis: "y"
      }),
      commitToHistory: true
    };
  },
  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.shiftKey && event.key === KEYS.ARROW_UP,
  PanelComponent: ({ elements, appState, updateData, app }) => /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(
    ToolButton,
    {
      hidden: !alignActionsPredicate(elements, appState, null, app),
      type: "button",
      icon: AlignTopIcon,
      onClick: () => updateData(null),
      title: `${t("labels.alignTop")} \u2014 ${getShortcutKey(
        "CtrlOrCmd+Shift+Up"
      )}`,
      "aria-label": t("labels.alignTop"),
      visible: isSomeElementSelected(getNonDeletedElements2(elements), appState)
    }
  )
});
var actionAlignBottom = register({
  name: "alignBottom",
  trackEvent: { category: "element" },
  predicate: alignActionsPredicate,
  perform: (elements, appState, _, app) => {
    return {
      appState,
      elements: alignSelectedElements(elements, appState, app, {
        position: "end",
        axis: "y"
      }),
      commitToHistory: true
    };
  },
  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.shiftKey && event.key === KEYS.ARROW_DOWN,
  PanelComponent: ({ elements, appState, updateData, app }) => /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(
    ToolButton,
    {
      hidden: !alignActionsPredicate(elements, appState, null, app),
      type: "button",
      icon: AlignBottomIcon,
      onClick: () => updateData(null),
      title: `${t("labels.alignBottom")} \u2014 ${getShortcutKey(
        "CtrlOrCmd+Shift+Down"
      )}`,
      "aria-label": t("labels.alignBottom"),
      visible: isSomeElementSelected(getNonDeletedElements2(elements), appState)
    }
  )
});
var actionAlignLeft = register({
  name: "alignLeft",
  trackEvent: { category: "element" },
  predicate: alignActionsPredicate,
  perform: (elements, appState, _, app) => {
    return {
      appState,
      elements: alignSelectedElements(elements, appState, app, {
        position: "start",
        axis: "x"
      }),
      commitToHistory: true
    };
  },
  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.shiftKey && event.key === KEYS.ARROW_LEFT,
  PanelComponent: ({ elements, appState, updateData, app }) => /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(
    ToolButton,
    {
      hidden: !alignActionsPredicate(elements, appState, null, app),
      type: "button",
      icon: AlignLeftIcon,
      onClick: () => updateData(null),
      title: `${t("labels.alignLeft")} \u2014 ${getShortcutKey(
        "CtrlOrCmd+Shift+Left"
      )}`,
      "aria-label": t("labels.alignLeft"),
      visible: isSomeElementSelected(getNonDeletedElements2(elements), appState)
    }
  )
});
var actionAlignRight = register({
  name: "alignRight",
  trackEvent: { category: "element" },
  predicate: alignActionsPredicate,
  perform: (elements, appState, _, app) => {
    return {
      appState,
      elements: alignSelectedElements(elements, appState, app, {
        position: "end",
        axis: "x"
      }),
      commitToHistory: true
    };
  },
  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.shiftKey && event.key === KEYS.ARROW_RIGHT,
  PanelComponent: ({ elements, appState, updateData, app }) => /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(
    ToolButton,
    {
      hidden: !alignActionsPredicate(elements, appState, null, app),
      type: "button",
      icon: AlignRightIcon,
      onClick: () => updateData(null),
      title: `${t("labels.alignRight")} \u2014 ${getShortcutKey(
        "CtrlOrCmd+Shift+Right"
      )}`,
      "aria-label": t("labels.alignRight"),
      visible: isSomeElementSelected(getNonDeletedElements2(elements), appState)
    }
  )
});
var actionAlignVerticallyCentered = register({
  name: "alignVerticallyCentered",
  trackEvent: { category: "element" },
  predicate: alignActionsPredicate,
  perform: (elements, appState, _, app) => {
    return {
      appState,
      elements: alignSelectedElements(elements, appState, app, {
        position: "center",
        axis: "y"
      }),
      commitToHistory: true
    };
  },
  PanelComponent: ({ elements, appState, updateData, app }) => /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(
    ToolButton,
    {
      hidden: !alignActionsPredicate(elements, appState, null, app),
      type: "button",
      icon: CenterVerticallyIcon,
      onClick: () => updateData(null),
      title: t("labels.centerVertically"),
      "aria-label": t("labels.centerVertically"),
      visible: isSomeElementSelected(getNonDeletedElements2(elements), appState)
    }
  )
});
var actionAlignHorizontallyCentered = register({
  name: "alignHorizontallyCentered",
  trackEvent: { category: "element" },
  predicate: alignActionsPredicate,
  perform: (elements, appState, _, app) => {
    return {
      appState,
      elements: alignSelectedElements(elements, appState, app, {
        position: "center",
        axis: "x"
      }),
      commitToHistory: true
    };
  },
  PanelComponent: ({ elements, appState, updateData, app }) => /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(
    ToolButton,
    {
      hidden: !alignActionsPredicate(elements, appState, null, app),
      type: "button",
      icon: CenterHorizontallyIcon,
      onClick: () => updateData(null),
      title: t("labels.centerHorizontally"),
      "aria-label": t("labels.centerHorizontally"),
      visible: isSomeElementSelected(getNonDeletedElements2(elements), appState)
    }
  )
});

// actions/actionDistribute.tsx
init_define_import_meta_env();

// distribute.ts
init_define_import_meta_env();
var distributeElements = (selectedElements, elementsMap, distribution) => {
  const [start2, mid, end, extent] = distribution.axis === "x" ? ["minX", "midX", "maxX", "width"] : ["minY", "midY", "maxY", "height"];
  const bounds = getCommonBoundingBox(selectedElements);
  const groups = getMaximumGroups(selectedElements, elementsMap).map((group) => [group, getCommonBoundingBox(group)]).sort((a4, b4) => a4[1][mid] - b4[1][mid]);
  let span = 0;
  for (const group of groups) {
    span += group[1][extent];
  }
  const step = (bounds[extent] - span) / (groups.length - 1);
  if (step < 0) {
    const index0 = groups.findIndex((g3) => g3[1][start2] === bounds[start2]);
    const index1 = groups.findIndex((g3) => g3[1][end] === bounds[end]);
    const step2 = (groups[index1][1][mid] - groups[index0][1][mid]) / (groups.length - 1);
    let pos2 = groups[index0][1][mid];
    return groups.flatMap(([group, box], index2) => {
      const translation2 = {
        x: 0,
        y: 0
      };
      if (index2 !== index0 && index2 !== index1) {
        pos2 += step2;
        translation2[distribution.axis] = pos2 - box[mid];
      }
      return group.map(
        (element) => newElementWith(element, {
          x: element.x + translation2.x,
          y: element.y + translation2.y
        })
      );
    });
  }
  let pos = bounds[start2];
  return groups.flatMap(([group, box]) => {
    const translation2 = {
      x: 0,
      y: 0
    };
    translation2[distribution.axis] = pos - box[start2];
    pos += step;
    pos += box[extent];
    return group.map(
      (element) => newElementWith(element, {
        x: element.x + translation2.x,
        y: element.y + translation2.y
      })
    );
  });
};

// actions/actionDistribute.tsx
var import_jsx_runtime31 = __toESM(require_jsx_runtime(), 1);
var enableActionGroup2 = (appState, app) => {
  const selectedElements = app.scene.getSelectedElements(appState);
  return selectedElements.length > 1 && // TODO enable distributing frames when implemented properly
  !selectedElements.some((el) => isFrameLikeElement(el));
};
var distributeSelectedElements = (elements, appState, app, distribution) => {
  const selectedElements = app.scene.getSelectedElements(appState);
  const updatedElements = distributeElements(
    selectedElements,
    app.scene.getNonDeletedElementsMap(),
    distribution
  );
  const updatedElementsMap = arrayToMap(updatedElements);
  return updateFrameMembershipOfSelectedElements(
    elements.map((element) => updatedElementsMap.get(element.id) || element),
    appState,
    app
  );
};
var distributeHorizontally = register({
  name: "distributeHorizontally",
  trackEvent: { category: "element" },
  perform: (elements, appState, _, app) => {
    return {
      appState,
      elements: distributeSelectedElements(elements, appState, app, {
        space: "between",
        axis: "x"
      }),
      commitToHistory: true
    };
  },
  keyTest: (event) => !event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.H,
  PanelComponent: ({ elements, appState, updateData, app }) => /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(
    ToolButton,
    {
      hidden: !enableActionGroup2(appState, app),
      type: "button",
      icon: DistributeHorizontallyIcon,
      onClick: () => updateData(null),
      title: `${t("labels.distributeHorizontally")} \u2014 ${getShortcutKey(
        "Alt+H"
      )}`,
      "aria-label": t("labels.distributeHorizontally"),
      visible: isSomeElementSelected(getNonDeletedElements2(elements), appState)
    }
  )
});
var distributeVertically = register({
  name: "distributeVertically",
  trackEvent: { category: "element" },
  perform: (elements, appState, _, app) => {
    return {
      appState,
      elements: distributeSelectedElements(elements, appState, app, {
        space: "between",
        axis: "y"
      }),
      commitToHistory: true
    };
  },
  keyTest: (event) => !event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.V,
  PanelComponent: ({ elements, appState, updateData, app }) => /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(
    ToolButton,
    {
      hidden: !enableActionGroup2(appState, app),
      type: "button",
      icon: DistributeVerticallyIcon,
      onClick: () => updateData(null),
      title: `${t("labels.distributeVertically")} \u2014 ${getShortcutKey("Alt+V")}`,
      "aria-label": t("labels.distributeVertically"),
      visible: isSomeElementSelected(getNonDeletedElements2(elements), appState)
    }
  )
});

// actions/actionFlip.ts
init_define_import_meta_env();

// element/resizeElements.ts
init_define_import_meta_env();
var normalizeAngle = (angle) => {
  if (angle < 0) {
    return angle + 2 * Math.PI;
  }
  if (angle >= 2 * Math.PI) {
    return angle - 2 * Math.PI;
  }
  return angle;
};
var transformElements = (originalElements, transformHandleType, selectedElements, elementsMap, shouldRotateWithDiscreteAngle2, shouldResizeFromCenter2, shouldMaintainAspectRatio2, pointerX, pointerY, centerX, centerY) => {
  if (selectedElements.length === 1) {
    const [element] = selectedElements;
    if (transformHandleType === "rotation") {
      rotateSingleElement(
        element,
        elementsMap,
        pointerX,
        pointerY,
        shouldRotateWithDiscreteAngle2
      );
      updateBoundElements(element, elementsMap);
    } else if (isTextElement(element) && (transformHandleType === "nw" || transformHandleType === "ne" || transformHandleType === "sw" || transformHandleType === "se")) {
      resizeSingleTextElement(
        element,
        elementsMap,
        transformHandleType,
        shouldResizeFromCenter2,
        pointerX,
        pointerY
      );
      updateBoundElements(element, elementsMap);
    } else if (transformHandleType) {
      resizeSingleElement(
        originalElements,
        shouldMaintainAspectRatio2,
        element,
        elementsMap,
        transformHandleType,
        shouldResizeFromCenter2,
        pointerX,
        pointerY
      );
    }
    return true;
  } else if (selectedElements.length > 1) {
    if (transformHandleType === "rotation") {
      rotateMultipleElements(
        originalElements,
        selectedElements,
        elementsMap,
        pointerX,
        pointerY,
        shouldRotateWithDiscreteAngle2,
        centerX,
        centerY
      );
      return true;
    } else if (transformHandleType === "nw" || transformHandleType === "ne" || transformHandleType === "sw" || transformHandleType === "se") {
      resizeMultipleElements(
        originalElements,
        selectedElements,
        elementsMap,
        transformHandleType,
        shouldResizeFromCenter2,
        pointerX,
        pointerY
      );
      return true;
    }
  }
  return false;
};
var rotateSingleElement = (element, elementsMap, pointerX, pointerY, shouldRotateWithDiscreteAngle2) => {
  const [x1, y1, x22, y22] = getElementAbsoluteCoords(element, elementsMap);
  const cx = (x1 + x22) / 2;
  const cy = (y1 + y22) / 2;
  let angle;
  if (isFrameLikeElement(element)) {
    angle = 0;
  } else {
    angle = 5 * Math.PI / 2 + Math.atan2(pointerY - cy, pointerX - cx);
    if (shouldRotateWithDiscreteAngle2) {
      angle += SHIFT_LOCKING_ANGLE / 2;
      angle -= angle % SHIFT_LOCKING_ANGLE;
    }
    angle = normalizeAngle(angle);
  }
  const boundTextElementId = getBoundTextElementId(element);
  mutateElement(element, { angle });
  if (boundTextElementId) {
    const textElement = Scene_default.getScene(element)?.getElement(
      boundTextElementId
    );
    if (textElement && !isArrowElement(element)) {
      mutateElement(textElement, { angle });
    }
  }
};
var rescalePointsInElement = (element, width, height, normalizePoints) => isLinearElement(element) || isFreeDrawElement(element) ? {
  points: rescalePoints(
    0,
    width,
    rescalePoints(1, height, element.points, normalizePoints),
    normalizePoints
  )
} : {};
var measureFontSizeFromWidth = (element, elementsMap, nextWidth, nextHeight) => {
  let width = element.width;
  const hasContainer = isBoundToContainer(element);
  if (hasContainer) {
    const container = getContainerElement(element, elementsMap);
    if (container) {
      width = getBoundTextMaxWidth(container, element);
    }
  }
  const nextFontSize = element.fontSize * (nextWidth / width);
  if (nextFontSize < MIN_FONT_SIZE) {
    return null;
  }
  const metrics = measureText(
    element.text,
    getFontString({ fontSize: nextFontSize, fontFamily: element.fontFamily }),
    element.lineHeight
  );
  return {
    size: nextFontSize,
    baseline: metrics.baseline + (nextHeight - metrics.height)
  };
};
var getSidesForTransformHandle = (transformHandleType, shouldResizeFromCenter2) => {
  return {
    n: /^(n|ne|nw)$/.test(transformHandleType) || shouldResizeFromCenter2 && /^(s|se|sw)$/.test(transformHandleType),
    s: /^(s|se|sw)$/.test(transformHandleType) || shouldResizeFromCenter2 && /^(n|ne|nw)$/.test(transformHandleType),
    w: /^(w|nw|sw)$/.test(transformHandleType) || shouldResizeFromCenter2 && /^(e|ne|se)$/.test(transformHandleType),
    e: /^(e|ne|se)$/.test(transformHandleType) || shouldResizeFromCenter2 && /^(w|nw|sw)$/.test(transformHandleType)
  };
};
var resizeSingleTextElement = (element, elementsMap, transformHandleType, shouldResizeFromCenter2, pointerX, pointerY) => {
  const [x1, y1, x22, y22] = getElementAbsoluteCoords(element, elementsMap);
  const cx = (x1 + x22) / 2;
  const cy = (y1 + y22) / 2;
  const [rotatedX, rotatedY] = rotate2(
    pointerX,
    pointerY,
    cx,
    cy,
    -element.angle
  );
  let scale;
  switch (transformHandleType) {
    case "se":
      scale = Math.max(
        (rotatedX - x1) / (x22 - x1),
        (rotatedY - y1) / (y22 - y1)
      );
      break;
    case "nw":
      scale = Math.max(
        (x22 - rotatedX) / (x22 - x1),
        (y22 - rotatedY) / (y22 - y1)
      );
      break;
    case "ne":
      scale = Math.max(
        (rotatedX - x1) / (x22 - x1),
        (y22 - rotatedY) / (y22 - y1)
      );
      break;
    case "sw":
      scale = Math.max(
        (x22 - rotatedX) / (x22 - x1),
        (rotatedY - y1) / (y22 - y1)
      );
      break;
  }
  if (scale > 0) {
    const nextWidth = element.width * scale;
    const nextHeight = element.height * scale;
    const metrics = measureFontSizeFromWidth(
      element,
      elementsMap,
      nextWidth,
      nextHeight
    );
    if (metrics === null) {
      return;
    }
    const [nextX1, nextY1, nextX2, nextY2] = getResizedElementAbsoluteCoords(
      element,
      nextWidth,
      nextHeight,
      false
    );
    const deltaX1 = (x1 - nextX1) / 2;
    const deltaY1 = (y1 - nextY1) / 2;
    const deltaX2 = (x22 - nextX2) / 2;
    const deltaY2 = (y22 - nextY2) / 2;
    const [nextElementX, nextElementY] = adjustXYWithRotation(
      getSidesForTransformHandle(transformHandleType, shouldResizeFromCenter2),
      element.x,
      element.y,
      element.angle,
      deltaX1,
      deltaY1,
      deltaX2,
      deltaY2
    );
    mutateElement(element, {
      fontSize: metrics.size,
      width: nextWidth,
      height: nextHeight,
      baseline: metrics.baseline,
      x: nextElementX,
      y: nextElementY
    });
  }
};
var resizeSingleElement = (originalElements, shouldMaintainAspectRatio2, element, elementsMap, transformHandleDirection, shouldResizeFromCenter2, pointerX, pointerY) => {
  const stateAtResizeStart = originalElements.get(element.id);
  const [x1, y1, x22, y22] = getResizedElementAbsoluteCoords(
    stateAtResizeStart,
    stateAtResizeStart.width,
    stateAtResizeStart.height,
    true
  );
  const startTopLeft = [x1, y1];
  const startBottomRight = [x22, y22];
  const startCenter = centerPoint(startTopLeft, startBottomRight);
  const rotatedPointer = rotatePoint(
    [pointerX, pointerY],
    startCenter,
    -stateAtResizeStart.angle
  );
  const [esx1, esy1, esx2, esy2] = getResizedElementAbsoluteCoords(
    element,
    element.width,
    element.height,
    true
  );
  const boundsCurrentWidth = esx2 - esx1;
  const boundsCurrentHeight = esy2 - esy1;
  const atStartBoundsWidth = startBottomRight[0] - startTopLeft[0];
  const atStartBoundsHeight = startBottomRight[1] - startTopLeft[1];
  let scaleX = atStartBoundsWidth / boundsCurrentWidth;
  let scaleY = atStartBoundsHeight / boundsCurrentHeight;
  let boundTextFont = {};
  const boundTextElement = getBoundTextElement(element, elementsMap);
  if (transformHandleDirection.includes("e")) {
    scaleX = (rotatedPointer[0] - startTopLeft[0]) / boundsCurrentWidth;
  }
  if (transformHandleDirection.includes("s")) {
    scaleY = (rotatedPointer[1] - startTopLeft[1]) / boundsCurrentHeight;
  }
  if (transformHandleDirection.includes("w")) {
    scaleX = (startBottomRight[0] - rotatedPointer[0]) / boundsCurrentWidth;
  }
  if (transformHandleDirection.includes("n")) {
    scaleY = (startBottomRight[1] - rotatedPointer[1]) / boundsCurrentHeight;
  }
  const eleInitialWidth = stateAtResizeStart.width;
  const eleInitialHeight = stateAtResizeStart.height;
  let eleNewWidth = element.width * scaleX;
  let eleNewHeight = element.height * scaleY;
  if (shouldResizeFromCenter2) {
    eleNewWidth = 2 * eleNewWidth - eleInitialWidth;
    eleNewHeight = 2 * eleNewHeight - eleInitialHeight;
  }
  if (shouldMaintainAspectRatio2) {
    const widthRatio = Math.abs(eleNewWidth) / eleInitialWidth;
    const heightRatio = Math.abs(eleNewHeight) / eleInitialHeight;
    if (transformHandleDirection.length === 1) {
      eleNewHeight *= widthRatio;
      eleNewWidth *= heightRatio;
    }
    if (transformHandleDirection.length === 2) {
      const ratio = Math.max(widthRatio, heightRatio);
      eleNewWidth = eleInitialWidth * ratio * Math.sign(eleNewWidth);
      eleNewHeight = eleInitialHeight * ratio * Math.sign(eleNewHeight);
    }
  }
  if (boundTextElement) {
    const stateOfBoundTextElementAtResize = originalElements.get(
      boundTextElement.id
    );
    if (stateOfBoundTextElementAtResize) {
      boundTextFont = {
        fontSize: stateOfBoundTextElementAtResize.fontSize,
        baseline: stateOfBoundTextElementAtResize.baseline
      };
    }
    if (shouldMaintainAspectRatio2) {
      const updatedElement = {
        ...element,
        width: eleNewWidth,
        height: eleNewHeight
      };
      const nextFont = measureFontSizeFromWidth(
        boundTextElement,
        elementsMap,
        getBoundTextMaxWidth(updatedElement, boundTextElement),
        getBoundTextMaxHeight(updatedElement, boundTextElement)
      );
      if (nextFont === null) {
        return;
      }
      boundTextFont = {
        fontSize: nextFont.size,
        baseline: nextFont.baseline
      };
    } else {
      const minWidth = getApproxMinLineWidth(
        getFontString(boundTextElement),
        boundTextElement.lineHeight
      );
      const minHeight = getApproxMinLineHeight(
        boundTextElement.fontSize,
        boundTextElement.lineHeight
      );
      eleNewWidth = Math.max(eleNewWidth, minWidth);
      eleNewHeight = Math.max(eleNewHeight, minHeight);
    }
  }
  const [newBoundsX1, newBoundsY1, newBoundsX2, newBoundsY2] = getResizedElementAbsoluteCoords(
    stateAtResizeStart,
    eleNewWidth,
    eleNewHeight,
    true
  );
  const newBoundsWidth = newBoundsX2 - newBoundsX1;
  const newBoundsHeight = newBoundsY2 - newBoundsY1;
  let newTopLeft = [...startTopLeft];
  if (["n", "w", "nw"].includes(transformHandleDirection)) {
    newTopLeft = [
      startBottomRight[0] - Math.abs(newBoundsWidth),
      startBottomRight[1] - Math.abs(newBoundsHeight)
    ];
  }
  if (transformHandleDirection === "ne") {
    const bottomLeft = [startTopLeft[0], startBottomRight[1]];
    newTopLeft = [bottomLeft[0], bottomLeft[1] - Math.abs(newBoundsHeight)];
  }
  if (transformHandleDirection === "sw") {
    const topRight = [startBottomRight[0], startTopLeft[1]];
    newTopLeft = [topRight[0] - Math.abs(newBoundsWidth), topRight[1]];
  }
  if (shouldMaintainAspectRatio2) {
    if (["s", "n"].includes(transformHandleDirection)) {
      newTopLeft[0] = startCenter[0] - newBoundsWidth / 2;
    }
    if (["e", "w"].includes(transformHandleDirection)) {
      newTopLeft[1] = startCenter[1] - newBoundsHeight / 2;
    }
  }
  const flipX = eleNewWidth < 0;
  const flipY = eleNewHeight < 0;
  if (flipX) {
    if (transformHandleDirection.includes("e")) {
      newTopLeft[0] -= Math.abs(newBoundsWidth);
    }
    if (transformHandleDirection.includes("w")) {
      newTopLeft[0] += Math.abs(newBoundsWidth);
    }
  }
  if (flipY) {
    if (transformHandleDirection.includes("s")) {
      newTopLeft[1] -= Math.abs(newBoundsHeight);
    }
    if (transformHandleDirection.includes("n")) {
      newTopLeft[1] += Math.abs(newBoundsHeight);
    }
  }
  if (shouldResizeFromCenter2) {
    newTopLeft[0] = startCenter[0] - Math.abs(newBoundsWidth) / 2;
    newTopLeft[1] = startCenter[1] - Math.abs(newBoundsHeight) / 2;
  }
  const angle = stateAtResizeStart.angle;
  const rotatedTopLeft = rotatePoint(newTopLeft, startCenter, angle);
  const newCenter = [
    newTopLeft[0] + Math.abs(newBoundsWidth) / 2,
    newTopLeft[1] + Math.abs(newBoundsHeight) / 2
  ];
  const rotatedNewCenter = rotatePoint(newCenter, startCenter, angle);
  newTopLeft = rotatePoint(rotatedTopLeft, rotatedNewCenter, -angle);
  const newOrigin = [...newTopLeft];
  const linearElementXOffset = stateAtResizeStart.x - newBoundsX1;
  const linearElementYOffset = stateAtResizeStart.y - newBoundsY1;
  newOrigin[0] += linearElementXOffset;
  newOrigin[1] += linearElementYOffset;
  const nextX = newOrigin[0];
  const nextY = newOrigin[1];
  let rescaledElementPointsY;
  let rescaledPoints;
  if (isLinearElement(element) || isFreeDrawElement(element)) {
    rescaledElementPointsY = rescalePoints(
      1,
      eleNewHeight,
      stateAtResizeStart.points,
      true
    );
    rescaledPoints = rescalePoints(
      0,
      eleNewWidth,
      rescaledElementPointsY,
      true
    );
  }
  const resizedElement = {
    width: Math.abs(eleNewWidth),
    height: Math.abs(eleNewHeight),
    x: nextX,
    y: nextY,
    points: rescaledPoints
  };
  if ("scale" in element && "scale" in stateAtResizeStart) {
    mutateElement(element, {
      scale: [
        // defaulting because scaleX/Y can be 0/-0
        (Math.sign(newBoundsX2 - stateAtResizeStart.x) || stateAtResizeStart.scale[0]) * stateAtResizeStart.scale[0],
        (Math.sign(newBoundsY2 - stateAtResizeStart.y) || stateAtResizeStart.scale[1]) * stateAtResizeStart.scale[1]
      ]
    });
  }
  if (isArrowElement(element) && boundTextElement && shouldMaintainAspectRatio2) {
    const fontSize = resizedElement.width / element.width * boundTextElement.fontSize;
    if (fontSize < MIN_FONT_SIZE) {
      return;
    }
    boundTextFont.fontSize = fontSize;
  }
  if (resizedElement.width !== 0 && resizedElement.height !== 0 && Number.isFinite(resizedElement.x) && Number.isFinite(resizedElement.y)) {
    mutateElement(element, resizedElement);
    updateBoundElements(element, elementsMap, {
      newSize: { width: resizedElement.width, height: resizedElement.height }
    });
    if (boundTextElement && boundTextFont != null) {
      mutateElement(boundTextElement, {
        fontSize: boundTextFont.fontSize,
        baseline: boundTextFont.baseline
      });
    }
    handleBindTextResize(
      element,
      elementsMap,
      transformHandleDirection,
      shouldMaintainAspectRatio2
    );
  }
};
var resizeMultipleElements = (originalElements, selectedElements, elementsMap, transformHandleType, shouldResizeFromCenter2, pointerX, pointerY) => {
  const targetElements = selectedElements.reduce(
    (acc, element) => {
      const origElement = originalElements.get(element.id);
      if (origElement) {
        acc.push({ orig: origElement, latest: element });
      }
      return acc;
    },
    []
  );
  const boundTextElements = targetElements.reduce((acc, { orig }) => {
    if (!isLinearElement(orig)) {
      return acc;
    }
    const textId = getBoundTextElementId(orig);
    if (!textId) {
      return acc;
    }
    const text = originalElements.get(textId) ?? null;
    if (!isBoundToContainer(text)) {
      return acc;
    }
    const xy = LinearElementEditor.getBoundTextElementPosition(
      orig,
      text,
      elementsMap
    );
    return [...acc, { ...text, ...xy }];
  }, []);
  const { minX, minY, maxX, maxY, midX, midY } = getCommonBoundingBox(
    targetElements.map(({ orig }) => orig).concat(boundTextElements)
  );
  const direction = transformHandleType;
  const mapDirectionsToAnchors = {
    ne: [minX, maxY],
    se: [minX, minY],
    sw: [maxX, minY],
    nw: [maxX, maxY]
  };
  const [anchorX, anchorY] = shouldResizeFromCenter2 ? [midX, midY] : mapDirectionsToAnchors[direction];
  const scale = Math.max(
    Math.abs(pointerX - anchorX) / (maxX - minX) || 0,
    Math.abs(pointerY - anchorY) / (maxY - minY) || 0
  ) * (shouldResizeFromCenter2 ? 2 : 1);
  if (scale === 0) {
    return;
  }
  const mapDirectionsToPointerPositions = {
    ne: [pointerX >= anchorX, pointerY <= anchorY],
    se: [pointerX >= anchorX, pointerY >= anchorY],
    sw: [pointerX <= anchorX, pointerY >= anchorY],
    nw: [pointerX <= anchorX, pointerY <= anchorY]
  };
  const [flipFactorX, flipFactorY] = mapDirectionsToPointerPositions[direction].map((condition) => condition ? 1 : -1);
  const isFlippedByX = flipFactorX < 0;
  const isFlippedByY = flipFactorY < 0;
  const elementsAndUpdates = [];
  for (const { orig, latest } of targetElements) {
    if (isTextElement(orig) && isBoundToContainer(orig)) {
      continue;
    }
    const width = orig.width * scale;
    const height = orig.height * scale;
    const angle = normalizeAngle(orig.angle * flipFactorX * flipFactorY);
    const isLinearOrFreeDraw = isLinearElement(orig) || isFreeDrawElement(orig);
    const offsetX = orig.x - anchorX;
    const offsetY = orig.y - anchorY;
    const shiftX = isFlippedByX && !isLinearOrFreeDraw ? width : 0;
    const shiftY = isFlippedByY && !isLinearOrFreeDraw ? height : 0;
    const x3 = anchorX + flipFactorX * (offsetX * scale + shiftX);
    const y3 = anchorY + flipFactorY * (offsetY * scale + shiftY);
    const rescaledPoints = rescalePointsInElement(
      orig,
      width * flipFactorX,
      height * flipFactorY,
      false
    );
    const update = {
      x: x3,
      y: y3,
      width,
      height,
      angle,
      ...rescaledPoints
    };
    if (isImageElement(orig) && targetElements.length === 1) {
      update.scale = [orig.scale[0] * flipFactorX, orig.scale[1] * flipFactorY];
    }
    if (isLinearElement(orig) && (isFlippedByX || isFlippedByY)) {
      const origBounds = getElementPointsCoords(orig, orig.points);
      const newBounds = getElementPointsCoords(
        { ...orig, x: x3, y: y3 },
        rescaledPoints.points
      );
      const origXY = [orig.x, orig.y];
      const newXY = [x3, y3];
      const linearShift = (axis) => {
        const i4 = axis === "x" ? 0 : 1;
        return (newBounds[i4 + 2] - newXY[i4] - (origXY[i4] - origBounds[i4]) * scale + (origBounds[i4 + 2] - origXY[i4]) * scale - (newXY[i4] - newBounds[i4])) / 2;
      };
      if (isFlippedByX) {
        update.x -= linearShift("x");
      }
      if (isFlippedByY) {
        update.y -= linearShift("y");
      }
    }
    if (isTextElement(orig)) {
      const metrics = measureFontSizeFromWidth(
        orig,
        elementsMap,
        width,
        height
      );
      if (!metrics) {
        return;
      }
      update.fontSize = metrics.size;
      update.baseline = metrics.baseline;
    }
    const boundTextElement = originalElements.get(
      getBoundTextElementId(orig) ?? ""
    );
    if (boundTextElement) {
      const newFontSize = boundTextElement.fontSize * scale;
      if (newFontSize < MIN_FONT_SIZE) {
        return;
      }
      update.boundTextFontSize = newFontSize;
    }
    elementsAndUpdates.push({
      element: latest,
      update
    });
  }
  const elementsToUpdate = elementsAndUpdates.map(({ element }) => element);
  for (const {
    element,
    update: { boundTextFontSize, ...update }
  } of elementsAndUpdates) {
    const { width, height, angle } = update;
    mutateElement(element, update, false);
    updateBoundElements(element, elementsMap, {
      simultaneouslyUpdated: elementsToUpdate,
      newSize: { width, height }
    });
    const boundTextElement = getBoundTextElement(element, elementsMap);
    if (boundTextElement && boundTextFontSize) {
      mutateElement(
        boundTextElement,
        {
          fontSize: boundTextFontSize,
          angle: isLinearElement(element) ? void 0 : angle
        },
        false
      );
      handleBindTextResize(element, elementsMap, transformHandleType, true);
    }
  }
  Scene_default.getScene(elementsAndUpdates[0].element)?.informMutation();
};
var rotateMultipleElements = (originalElements, elements, elementsMap, pointerX, pointerY, shouldRotateWithDiscreteAngle2, centerX, centerY) => {
  let centerAngle = 5 * Math.PI / 2 + Math.atan2(pointerY - centerY, pointerX - centerX);
  if (shouldRotateWithDiscreteAngle2) {
    centerAngle += SHIFT_LOCKING_ANGLE / 2;
    centerAngle -= centerAngle % SHIFT_LOCKING_ANGLE;
  }
  elements.filter((element) => !isFrameLikeElement(element)).forEach((element) => {
    const [x1, y1, x22, y22] = getElementAbsoluteCoords(element, elementsMap);
    const cx = (x1 + x22) / 2;
    const cy = (y1 + y22) / 2;
    const origAngle = originalElements.get(element.id)?.angle ?? element.angle;
    const [rotatedCX, rotatedCY] = rotate2(
      cx,
      cy,
      centerX,
      centerY,
      centerAngle + origAngle - element.angle
    );
    mutateElement(
      element,
      {
        x: element.x + (rotatedCX - cx),
        y: element.y + (rotatedCY - cy),
        angle: normalizeAngle(centerAngle + origAngle)
      },
      false
    );
    updateBoundElements(element, elementsMap, {
      simultaneouslyUpdated: elements
    });
    const boundText = getBoundTextElement(element, elementsMap);
    if (boundText && !isArrowElement(element)) {
      mutateElement(
        boundText,
        {
          x: boundText.x + (rotatedCX - cx),
          y: boundText.y + (rotatedCY - cy),
          angle: normalizeAngle(centerAngle + origAngle)
        },
        false
      );
    }
  });
  Scene_default.getScene(elements[0])?.informMutation();
};
var getResizeOffsetXY = (transformHandleType, selectedElements, elementsMap, x3, y3) => {
  const [x1, y1, x22, y22] = selectedElements.length === 1 ? getElementAbsoluteCoords(selectedElements[0], elementsMap) : getCommonBounds(selectedElements);
  const cx = (x1 + x22) / 2;
  const cy = (y1 + y22) / 2;
  const angle = selectedElements.length === 1 ? selectedElements[0].angle : 0;
  [x3, y3] = rotate2(x3, y3, cx, cy, -angle);
  switch (transformHandleType) {
    case "n":
      return rotate2(x3 - (x1 + x22) / 2, y3 - y1, 0, 0, angle);
    case "s":
      return rotate2(x3 - (x1 + x22) / 2, y3 - y22, 0, 0, angle);
    case "w":
      return rotate2(x3 - x1, y3 - (y1 + y22) / 2, 0, 0, angle);
    case "e":
      return rotate2(x3 - x22, y3 - (y1 + y22) / 2, 0, 0, angle);
    case "nw":
      return rotate2(x3 - x1, y3 - y1, 0, 0, angle);
    case "ne":
      return rotate2(x3 - x22, y3 - y1, 0, 0, angle);
    case "sw":
      return rotate2(x3 - x1, y3 - y22, 0, 0, angle);
    case "se":
      return rotate2(x3 - x22, y3 - y22, 0, 0, angle);
    default:
      return [0, 0];
  }
};
var getResizeArrowDirection = (transformHandleType, element) => {
  const [, [px, py]] = element.points;
  const isResizeEnd = transformHandleType === "nw" && (px < 0 || py < 0) || transformHandleType === "ne" && px >= 0 || transformHandleType === "sw" && px <= 0 || transformHandleType === "se" && (px > 0 || py > 0);
  return isResizeEnd ? "end" : "origin";
};

// actions/actionFlip.ts
var actionFlipHorizontal = register({
  name: "flipHorizontal",
  trackEvent: { category: "element" },
  perform: (elements, appState, _, app) => {
    return {
      elements: updateFrameMembershipOfSelectedElements(
        flipSelectedElements(
          elements,
          app.scene.getNonDeletedElementsMap(),
          appState,
          "horizontal"
        ),
        appState,
        app
      ),
      appState,
      commitToHistory: true
    };
  },
  keyTest: (event) => event.shiftKey && event.code === CODES.H,
  contextItemLabel: "labels.flipHorizontal"
});
var actionFlipVertical = register({
  name: "flipVertical",
  trackEvent: { category: "element" },
  perform: (elements, appState, _, app) => {
    return {
      elements: updateFrameMembershipOfSelectedElements(
        flipSelectedElements(
          elements,
          app.scene.getNonDeletedElementsMap(),
          appState,
          "vertical"
        ),
        appState,
        app
      ),
      appState,
      commitToHistory: true
    };
  },
  keyTest: (event) => event.shiftKey && event.code === CODES.V && !event[KEYS.CTRL_OR_CMD],
  contextItemLabel: "labels.flipVertical"
});
var flipSelectedElements = (elements, elementsMap, appState, flipDirection) => {
  const selectedElements = getSelectedElements(
    getNonDeletedElements2(elements),
    appState,
    {
      includeBoundTextElement: true,
      includeElementsInFrames: true
    }
  );
  const updatedElements = flipElements(
    selectedElements,
    elements,
    elementsMap,
    appState,
    flipDirection
  );
  const updatedElementsMap = arrayToMap(updatedElements);
  return elements.map(
    (element) => updatedElementsMap.get(element.id) || element
  );
};
var flipElements = (selectedElements, elements, elementsMap, appState, flipDirection) => {
  const { minX, minY, maxX, maxY } = getCommonBoundingBox(selectedElements);
  resizeMultipleElements(
    elementsMap,
    selectedElements,
    elementsMap,
    "nw",
    true,
    flipDirection === "horizontal" ? maxX : minX,
    flipDirection === "horizontal" ? minY : maxY
  );
  isBindingEnabled(appState) ? bindOrUnbindSelectedElements(selectedElements, elements, elementsMap) : unbindLinearElements(selectedElements, elementsMap);
  return selectedElements;
};

// actions/actionClipboard.tsx
init_define_import_meta_env();
var actionCopy = register({
  name: "copy",
  trackEvent: { category: "element" },
  perform: async (elements, appState, event, app) => {
    const elementsToCopy = app.scene.getSelectedElements({
      selectedElementIds: appState.selectedElementIds,
      includeBoundTextElement: true,
      includeElementsInFrames: true
    });
    try {
      await copyToClipboard(elementsToCopy, app.files, event);
    } catch (error) {
      return {
        commitToHistory: false,
        appState: {
          ...appState,
          errorMessage: error.message
        }
      };
    }
    return {
      commitToHistory: false
    };
  },
  contextItemLabel: "labels.copy",
  // don't supply a shortcut since we handle this conditionally via onCopy event
  keyTest: void 0
});
var actionPaste = register({
  name: "paste",
  trackEvent: { category: "element" },
  perform: async (elements, appState, data, app) => {
    let types;
    try {
      types = await readSystemClipboard();
    } catch (error) {
      if (error.name === "AbortError" || error.name === "NotAllowedError") {
        return false;
      }
      console.error(`actionPaste ${error.name}: ${error.message}`);
      if (isFirefox) {
        return {
          commitToHistory: false,
          appState: {
            ...appState,
            errorMessage: t("hints.firefox_clipboard_write")
          }
        };
      }
      return {
        commitToHistory: false,
        appState: {
          ...appState,
          errorMessage: t("errors.asyncPasteFailedOnRead")
        }
      };
    }
    try {
      app.pasteFromClipboard(createPasteEvent({ types }));
    } catch (error) {
      console.error(error);
      return {
        commitToHistory: false,
        appState: {
          ...appState,
          errorMessage: t("errors.asyncPasteFailedOnParse")
        }
      };
    }
    return {
      commitToHistory: false
    };
  },
  contextItemLabel: "labels.paste",
  // don't supply a shortcut since we handle this conditionally via onCopy event
  keyTest: void 0
});
var actionCut = register({
  name: "cut",
  trackEvent: { category: "element" },
  perform: (elements, appState, event, app) => {
    actionCopy.perform(elements, appState, event, app);
    return actionDeleteSelected.perform(elements, appState, null, app);
  },
  contextItemLabel: "labels.cut",
  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.key === KEYS.X
});
var actionCopyAsSvg = register({
  name: "copyAsSvg",
  trackEvent: { category: "element" },
  perform: async (elements, appState, _data, app) => {
    if (!app.canvas) {
      return {
        commitToHistory: false
      };
    }
    const { exportedElements, exportingFrame } = prepareElementsForExport(
      elements,
      appState,
      true
    );
    try {
      await exportCanvas(
        "clipboard-svg",
        exportedElements,
        appState,
        app.files,
        {
          ...appState,
          exportingFrame,
          name: app.getName()
        }
      );
      return {
        commitToHistory: false
      };
    } catch (error) {
      console.error(error);
      return {
        appState: {
          ...appState,
          errorMessage: error.message
        },
        commitToHistory: false
      };
    }
  },
  predicate: (elements) => {
    return probablySupportsClipboardWriteText && elements.length > 0;
  },
  contextItemLabel: "labels.copyAsSvg"
});
var actionCopyAsPng = register({
  name: "copyAsPng",
  trackEvent: { category: "element" },
  perform: async (elements, appState, _data, app) => {
    if (!app.canvas) {
      return {
        commitToHistory: false
      };
    }
    const selectedElements = app.scene.getSelectedElements({
      selectedElementIds: appState.selectedElementIds,
      includeBoundTextElement: true,
      includeElementsInFrames: true
    });
    const { exportedElements, exportingFrame } = prepareElementsForExport(
      elements,
      appState,
      true
    );
    try {
      await exportCanvas("clipboard", exportedElements, appState, app.files, {
        ...appState,
        exportingFrame,
        name: app.getName()
      });
      return {
        appState: {
          ...appState,
          toast: {
            message: t("toast.copyToClipboardAsPng", {
              exportSelection: selectedElements.length ? t("toast.selection") : t("toast.canvas"),
              exportColorScheme: appState.exportWithDarkMode ? t("buttons.darkMode") : t("buttons.lightMode")
            })
          }
        },
        commitToHistory: false
      };
    } catch (error) {
      console.error(error);
      return {
        appState: {
          ...appState,
          errorMessage: error.message
        },
        commitToHistory: false
      };
    }
  },
  predicate: (elements) => {
    return probablySupportsClipboardBlob && elements.length > 0;
  },
  contextItemLabel: "labels.copyAsPng",
  keyTest: (event) => event.code === CODES.C && event.altKey && event.shiftKey
});
var copyText = register({
  name: "copyText",
  trackEvent: { category: "element" },
  perform: (elements, appState, _, app) => {
    const selectedElements = app.scene.getSelectedElements({
      selectedElementIds: appState.selectedElementIds,
      includeBoundTextElement: true
    });
    const text = selectedElements.reduce((acc, element) => {
      if (isTextElement(element)) {
        acc.push(element.text);
      }
      return acc;
    }, []).join("\n\n");
    copyTextToSystemClipboard(text);
    return {
      commitToHistory: false
    };
  },
  predicate: (elements, appState, _, app) => {
    return probablySupportsClipboardWriteText && app.scene.getSelectedElements({
      selectedElementIds: appState.selectedElementIds,
      includeBoundTextElement: true
    }).some(isTextElement);
  },
  contextItemLabel: "labels.copyText"
});

// actions/actionToggleGridMode.tsx
init_define_import_meta_env();
var actionToggleGridMode = register({
  name: "gridMode",
  viewMode: true,
  trackEvent: {
    category: "canvas",
    predicate: (appState) => !appState.gridSize
  },
  perform(elements, appState) {
    return {
      appState: {
        ...appState,
        gridSize: this.checked(appState) ? null : GRID_SIZE,
        objectsSnapModeEnabled: false
      },
      commitToHistory: false
    };
  },
  checked: (appState) => appState.gridSize !== null,
  predicate: (element, appState, props) => {
    return typeof props.gridModeEnabled === "undefined";
  },
  contextItemLabel: "labels.showGrid",
  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.code === CODES.QUOTE
});

// actions/actionToggleZenMode.tsx
init_define_import_meta_env();
var actionToggleZenMode = register({
  name: "zenMode",
  viewMode: true,
  trackEvent: {
    category: "canvas",
    predicate: (appState) => !appState.zenModeEnabled
  },
  perform(elements, appState) {
    return {
      appState: {
        ...appState,
        zenModeEnabled: !this.checked(appState)
      },
      commitToHistory: false
    };
  },
  checked: (appState) => appState.zenModeEnabled,
  predicate: (elements, appState, appProps) => {
    return typeof appProps.zenModeEnabled === "undefined";
  },
  contextItemLabel: "buttons.zenMode",
  keyTest: (event) => !event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.Z
});

// actions/actionToggleObjectsSnapMode.tsx
init_define_import_meta_env();
var actionToggleObjectsSnapMode = register({
  name: "objectsSnapMode",
  viewMode: true,
  trackEvent: {
    category: "canvas",
    predicate: (appState) => !appState.objectsSnapModeEnabled
  },
  perform(elements, appState) {
    return {
      appState: {
        ...appState,
        objectsSnapModeEnabled: !this.checked(appState),
        gridSize: null
      },
      commitToHistory: false
    };
  },
  checked: (appState) => appState.objectsSnapModeEnabled,
  predicate: (elements, appState, appProps) => {
    return typeof appProps.objectsSnapModeEnabled === "undefined";
  },
  contextItemLabel: "buttons.objectsSnapMode",
  keyTest: (event) => !event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.S
});

// actions/actionToggleStats.tsx
init_define_import_meta_env();
var actionToggleStats = register({
  name: "stats",
  viewMode: true,
  trackEvent: { category: "menu" },
  perform(elements, appState) {
    return {
      appState: {
        ...appState,
        showStats: !this.checked(appState)
      },
      commitToHistory: false
    };
  },
  checked: (appState) => appState.showStats,
  contextItemLabel: "stats.title",
  keyTest: (event) => !event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.SLASH
});

// actions/actionBoundText.tsx
init_define_import_meta_env();
var actionUnbindText = register({
  name: "unbindText",
  contextItemLabel: "labels.unbindText",
  trackEvent: { category: "element" },
  predicate: (elements, appState, _, app) => {
    const selectedElements = app.scene.getSelectedElements(appState);
    return selectedElements.some((element) => hasBoundTextElement(element));
  },
  perform: (elements, appState, _, app) => {
    const selectedElements = app.scene.getSelectedElements(appState);
    const elementsMap = app.scene.getNonDeletedElementsMap();
    selectedElements.forEach((element) => {
      const boundTextElement = getBoundTextElement(element, elementsMap);
      if (boundTextElement) {
        const { width, height, baseline } = measureText(
          boundTextElement.originalText,
          getFontString(boundTextElement),
          boundTextElement.lineHeight
        );
        const originalContainerHeight = getOriginalContainerHeightFromCache(
          element.id
        );
        resetOriginalContainerCache(element.id);
        const { x: x3, y: y3 } = computeBoundTextPosition(
          element,
          boundTextElement,
          elementsMap
        );
        mutateElement(boundTextElement, {
          containerId: null,
          width,
          height,
          baseline,
          text: boundTextElement.originalText,
          x: x3,
          y: y3
        });
        mutateElement(element, {
          boundElements: element.boundElements?.filter(
            (ele) => ele.id !== boundTextElement.id
          ),
          height: originalContainerHeight ? originalContainerHeight : element.height
        });
      }
    });
    return {
      elements,
      appState,
      commitToHistory: true
    };
  }
});
var actionBindText = register({
  name: "bindText",
  contextItemLabel: "labels.bindText",
  trackEvent: { category: "element" },
  predicate: (elements, appState, _, app) => {
    const selectedElements = app.scene.getSelectedElements(appState);
    if (selectedElements.length === 2) {
      const textElement = isTextElement(selectedElements[0]) || isTextElement(selectedElements[1]);
      let bindingContainer;
      if (isTextBindableContainer(selectedElements[0])) {
        bindingContainer = selectedElements[0];
      } else if (isTextBindableContainer(selectedElements[1])) {
        bindingContainer = selectedElements[1];
      }
      if (textElement && bindingContainer && getBoundTextElement(
        bindingContainer,
        app.scene.getNonDeletedElementsMap()
      ) === null) {
        return true;
      }
    }
    return false;
  },
  perform: (elements, appState, _, app) => {
    const selectedElements = app.scene.getSelectedElements(appState);
    let textElement;
    let container;
    if (isTextElement(selectedElements[0]) && isTextBindableContainer(selectedElements[1])) {
      textElement = selectedElements[0];
      container = selectedElements[1];
    } else {
      textElement = selectedElements[1];
      container = selectedElements[0];
    }
    mutateElement(textElement, {
      containerId: container.id,
      verticalAlign: VERTICAL_ALIGN.MIDDLE,
      textAlign: TEXT_ALIGN.CENTER
    });
    mutateElement(container, {
      boundElements: (container.boundElements || []).concat({
        type: "text",
        id: textElement.id
      })
    });
    const originalContainerHeight = container.height;
    redrawTextBoundingBox(
      textElement,
      container,
      app.scene.getNonDeletedElementsMap()
    );
    updateOriginalContainerCache(container.id, originalContainerHeight);
    return {
      elements: pushTextAboveContainer(elements, container, textElement),
      appState: { ...appState, selectedElementIds: { [container.id]: true } },
      commitToHistory: true
    };
  }
});
var pushTextAboveContainer = (elements, container, textElement) => {
  const updatedElements = elements.slice();
  const textElementIndex = updatedElements.findIndex(
    (ele) => ele.id === textElement.id
  );
  updatedElements.splice(textElementIndex, 1);
  const containerIndex = updatedElements.findIndex(
    (ele) => ele.id === container.id
  );
  updatedElements.splice(containerIndex + 1, 0, textElement);
  return updatedElements;
};
var pushContainerBelowText = (elements, container, textElement) => {
  const updatedElements = elements.slice();
  const containerIndex = updatedElements.findIndex(
    (ele) => ele.id === container.id
  );
  updatedElements.splice(containerIndex, 1);
  const textElementIndex = updatedElements.findIndex(
    (ele) => ele.id === textElement.id
  );
  updatedElements.splice(textElementIndex, 0, container);
  return updatedElements;
};
var actionWrapTextInContainer = register({
  name: "wrapTextInContainer",
  contextItemLabel: "labels.createContainerFromText",
  trackEvent: { category: "element" },
  predicate: (elements, appState, _, app) => {
    const selectedElements = app.scene.getSelectedElements(appState);
    const areTextElements = selectedElements.every((el) => isTextElement(el));
    return selectedElements.length > 0 && areTextElements;
  },
  perform: (elements, appState, _, app) => {
    const selectedElements = app.scene.getSelectedElements(appState);
    let updatedElements = elements.slice();
    const containerIds = {};
    for (const textElement of selectedElements) {
      if (isTextElement(textElement)) {
        const container = newElement({
          type: "rectangle",
          backgroundColor: appState.currentItemBackgroundColor,
          boundElements: [
            ...textElement.boundElements || [],
            { id: textElement.id, type: "text" }
          ],
          angle: textElement.angle,
          fillStyle: appState.currentItemFillStyle,
          strokeColor: appState.currentItemStrokeColor,
          roughness: appState.currentItemRoughness,
          strokeWidth: appState.currentItemStrokeWidth,
          strokeStyle: appState.currentItemStrokeStyle,
          roundness: appState.currentItemRoundness === "round" ? {
            type: isUsingAdaptiveRadius("rectangle") ? ROUNDNESS.ADAPTIVE_RADIUS : ROUNDNESS.PROPORTIONAL_RADIUS
          } : null,
          opacity: 100,
          locked: false,
          x: textElement.x - BOUND_TEXT_PADDING,
          y: textElement.y - BOUND_TEXT_PADDING,
          width: computeContainerDimensionForBoundText(
            textElement.width,
            "rectangle"
          ),
          height: computeContainerDimensionForBoundText(
            textElement.height,
            "rectangle"
          ),
          groupIds: textElement.groupIds,
          frameId: textElement.frameId
        });
        if (textElement.boundElements?.length) {
          const linearElementIds = textElement.boundElements.filter((ele) => ele.type === "arrow").map((el) => el.id);
          const linearElements = updatedElements.filter(
            (ele) => linearElementIds.includes(ele.id)
          );
          linearElements.forEach((ele) => {
            let startBinding = ele.startBinding;
            let endBinding = ele.endBinding;
            if (startBinding?.elementId === textElement.id) {
              startBinding = {
                ...startBinding,
                elementId: container.id
              };
            }
            if (endBinding?.elementId === textElement.id) {
              endBinding = { ...endBinding, elementId: container.id };
            }
            if (startBinding || endBinding) {
              mutateElement(ele, { startBinding, endBinding }, false);
            }
          });
        }
        mutateElement(
          textElement,
          {
            containerId: container.id,
            verticalAlign: VERTICAL_ALIGN.MIDDLE,
            boundElements: null,
            textAlign: TEXT_ALIGN.CENTER
          },
          false
        );
        redrawTextBoundingBox(
          textElement,
          container,
          app.scene.getNonDeletedElementsMap()
        );
        updatedElements = pushContainerBelowText(
          [...updatedElements, container],
          container,
          textElement
        );
        containerIds[container.id] = true;
      }
    }
    return {
      elements: updatedElements,
      appState: {
        ...appState,
        selectedElementIds: containerIds
      },
      commitToHistory: true
    };
  }
});

// actions/actionElementLock.ts
init_define_import_meta_env();
var shouldLock = (elements) => elements.every((el) => !el.locked);
var actionToggleElementLock = register({
  name: "toggleElementLock",
  trackEvent: { category: "element" },
  predicate: (elements, appState, _, app) => {
    const selectedElements = app.scene.getSelectedElements(appState);
    return !selectedElements.some(
      (element) => element.locked && element.frameId
    );
  },
  perform: (elements, appState, _, app) => {
    const selectedElements = app.scene.getSelectedElements({
      selectedElementIds: appState.selectedElementIds,
      includeBoundTextElement: true,
      includeElementsInFrames: true
    });
    if (!selectedElements.length) {
      return false;
    }
    const nextLockState = shouldLock(selectedElements);
    const selectedElementsMap = arrayToMap(selectedElements);
    return {
      elements: elements.map((element) => {
        if (!selectedElementsMap.has(element.id)) {
          return element;
        }
        return newElementWith(element, { locked: nextLockState });
      }),
      appState: {
        ...appState,
        selectedLinearElement: nextLockState ? null : appState.selectedLinearElement
      },
      commitToHistory: true
    };
  },
  contextItemLabel: (elements, appState, app) => {
    const selected = app.scene.getSelectedElements({
      selectedElementIds: appState.selectedElementIds,
      includeBoundTextElement: false
    });
    if (selected.length === 1 && !isFrameLikeElement(selected[0])) {
      return selected[0].locked ? "labels.elementLock.unlock" : "labels.elementLock.lock";
    }
    return shouldLock(selected) ? "labels.elementLock.lockAll" : "labels.elementLock.unlockAll";
  },
  keyTest: (event, appState, elements, app) => {
    return event.key.toLocaleLowerCase() === KEYS.L && event[KEYS.CTRL_OR_CMD] && event.shiftKey && app.scene.getSelectedElements({
      selectedElementIds: appState.selectedElementIds,
      includeBoundTextElement: false
    }).length > 0;
  }
});
var actionUnlockAllElements = register({
  name: "unlockAllElements",
  trackEvent: { category: "canvas" },
  viewMode: false,
  predicate: (elements) => {
    return elements.some((element) => element.locked);
  },
  perform: (elements, appState) => {
    const lockedElements = elements.filter((el) => el.locked);
    return {
      elements: elements.map((element) => {
        if (element.locked) {
          return newElementWith(element, { locked: false });
        }
        return element;
      }),
      appState: {
        ...appState,
        selectedElementIds: Object.fromEntries(
          lockedElements.map((el) => [el.id, true])
        )
      },
      commitToHistory: true
    };
  },
  contextItemLabel: "labels.elementLock.unlockAll"
});

// actions/actionLinearEditor.ts
init_define_import_meta_env();
var actionToggleLinearEditor = register({
  name: "toggleLinearEditor",
  trackEvent: {
    category: "element"
  },
  predicate: (elements, appState, _, app) => {
    const selectedElements = app.scene.getSelectedElements(appState);
    if (selectedElements.length === 1 && isLinearElement(selectedElements[0])) {
      return true;
    }
    return false;
  },
  perform(elements, appState, _, app) {
    const selectedElement = app.scene.getSelectedElements({
      selectedElementIds: appState.selectedElementIds,
      includeBoundTextElement: true
    })[0];
    const editingLinearElement = appState.editingLinearElement?.elementId === selectedElement.id ? null : new LinearElementEditor(selectedElement);
    return {
      appState: {
        ...appState,
        editingLinearElement
      },
      commitToHistory: false
    };
  },
  contextItemLabel: (elements, appState, app) => {
    const selectedElement = app.scene.getSelectedElements({
      selectedElementIds: appState.selectedElementIds,
      includeBoundTextElement: true
    })[0];
    return appState.editingLinearElement?.elementId === selectedElement.id ? "labels.lineEditor.exit" : "labels.lineEditor.edit";
  }
});

// actions/actionHistory.tsx
init_define_import_meta_env();
var import_jsx_runtime32 = __toESM(require_jsx_runtime(), 1);
var writeData = (prevElements, appState, updater) => {
  const commitToHistory = false;
  if (!appState.multiElement && !appState.resizingElement && !appState.editingElement && !appState.draggingElement) {
    const data = updater();
    if (data === null) {
      return { commitToHistory };
    }
    const prevElementMap = arrayToMap(prevElements);
    const nextElements = data.elements;
    const nextElementMap = arrayToMap(nextElements);
    const deletedElements = prevElements.filter(
      (prevElement) => !nextElementMap.has(prevElement.id)
    );
    const elements = nextElements.map(
      (nextElement) => newElementWith(
        prevElementMap.get(nextElement.id) || nextElement,
        nextElement
      )
    ).concat(
      deletedElements.map(
        (prevElement) => newElementWith(prevElement, { isDeleted: true })
      )
    );
    fixBindingsAfterDeletion(elements, deletedElements);
    return {
      elements,
      appState: { ...appState, ...data.appState },
      commitToHistory,
      syncHistory: true
    };
  }
  return { commitToHistory };
};
var createUndoAction = (history) => ({
  name: "undo",
  trackEvent: { category: "history" },
  perform: (elements, appState) => writeData(elements, appState, () => history.undoOnce()),
  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.key.toLowerCase() === KEYS.Z && !event.shiftKey,
  PanelComponent: ({ updateData, data }) => /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(
    ToolButton,
    {
      type: "button",
      icon: UndoIcon,
      "aria-label": t("buttons.undo"),
      onClick: updateData,
      size: data?.size || "medium"
    }
  ),
  commitToHistory: () => false
});
var createRedoAction = (history) => ({
  name: "redo",
  trackEvent: { category: "history" },
  perform: (elements, appState) => writeData(elements, appState, () => history.redoOnce()),
  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.shiftKey && event.key.toLowerCase() === KEYS.Z || isWindows && event.ctrlKey && !event.shiftKey && event.key === KEYS.Y,
  PanelComponent: ({ updateData, data }) => /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(
    ToolButton,
    {
      type: "button",
      icon: RedoIcon,
      "aria-label": t("buttons.redo"),
      onClick: updateData,
      size: data?.size || "medium"
    }
  ),
  commitToHistory: () => false
});

// actions/manager.tsx
init_define_import_meta_env();
var import_jsx_runtime33 = __toESM(require_jsx_runtime(), 1);
var trackAction = (action, source, appState, elements, app, value) => {
  if (action.trackEvent) {
    try {
      if (typeof action.trackEvent === "object") {
        const shouldTrack = action.trackEvent.predicate ? action.trackEvent.predicate(appState, elements, value) : true;
        if (shouldTrack) {
          trackEvent(
            action.trackEvent.category,
            action.trackEvent.action || action.name,
            `${source} (${app.device.editor.isMobile ? "mobile" : "desktop"})`
          );
        }
      }
    } catch (error) {
      console.error("error while logging action:", error);
    }
  }
};
var ActionManager = class {
  actions = {};
  updater;
  getAppState;
  getElementsIncludingDeleted;
  app;
  constructor(updater, getAppState, getElementsIncludingDeleted, app) {
    this.updater = (actionResult) => {
      if (isPromiseLike(actionResult)) {
        actionResult.then((actionResult2) => {
          return updater(actionResult2);
        });
      } else {
        return updater(actionResult);
      }
    };
    this.getAppState = getAppState;
    this.getElementsIncludingDeleted = getElementsIncludingDeleted;
    this.app = app;
  }
  registerAction(action) {
    this.actions[action.name] = action;
  }
  registerAll(actions2) {
    actions2.forEach((action) => this.registerAction(action));
  }
  handleKeyDown(event) {
    const canvasActions = this.app.props.UIOptions.canvasActions;
    const data = Object.values(this.actions).sort((a4, b4) => (b4.keyPriority || 0) - (a4.keyPriority || 0)).filter(
      (action2) => (action2.name in canvasActions ? canvasActions[action2.name] : true) && action2.keyTest && action2.keyTest(
        event,
        this.getAppState(),
        this.getElementsIncludingDeleted(),
        this.app
      )
    );
    if (data.length !== 1) {
      if (data.length > 1) {
        console.warn("Canceling as multiple actions match this shortcut", data);
      }
      return false;
    }
    const action = data[0];
    if (this.getAppState().viewModeEnabled && action.viewMode !== true) {
      return false;
    }
    const elements = this.getElementsIncludingDeleted();
    const appState = this.getAppState();
    const value = null;
    trackAction(action, "keyboard", appState, elements, this.app, null);
    event.preventDefault();
    event.stopPropagation();
    this.updater(data[0].perform(elements, appState, value, this.app));
    return true;
  }
  executeAction(action, source = "api", value = null) {
    const elements = this.getElementsIncludingDeleted();
    const appState = this.getAppState();
    trackAction(action, source, appState, elements, this.app, value);
    this.updater(action.perform(elements, appState, value, this.app));
  }
  /**
   * @param data additional data sent to the PanelComponent
   */
  renderAction = (name, data) => {
    const canvasActions = this.app.props.UIOptions.canvasActions;
    if (this.actions[name] && "PanelComponent" in this.actions[name] && (name in canvasActions ? canvasActions[name] : true)) {
      const action = this.actions[name];
      const PanelComponent = action.PanelComponent;
      PanelComponent.displayName = "PanelComponent";
      const elements = this.getElementsIncludingDeleted();
      const appState = this.getAppState();
      const updateData = (formState) => {
        trackAction(action, "ui", appState, elements, this.app, formState);
        this.updater(
          action.perform(
            this.getElementsIncludingDeleted(),
            this.getAppState(),
            formState,
            this.app
          )
        );
      };
      return /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(
        PanelComponent,
        {
          elements: this.getElementsIncludingDeleted(),
          appState: this.getAppState(),
          updateData,
          appProps: this.app.props,
          app: this.app,
          data
        }
      );
    }
    return null;
  };
  isActionEnabled = (action) => {
    const elements = this.getElementsIncludingDeleted();
    const appState = this.getAppState();
    return !action.predicate || action.predicate(elements, appState, this.app.props, this.app);
  };
};

// data/library.ts
init_define_import_meta_env();

// data/restore.ts
init_define_import_meta_env();
var AllowedExcalidrawActiveTools = {
  selection: true,
  text: true,
  rectangle: true,
  diamond: true,
  ellipse: true,
  line: true,
  image: true,
  arrow: true,
  freedraw: true,
  eraser: false,
  custom: true,
  frame: true,
  embeddable: true,
  hand: true,
  laser: false,
  magicframe: false
};
var getFontFamilyByName = (fontFamilyName) => {
  if (Object.keys(FONT_FAMILY).includes(fontFamilyName)) {
    return FONT_FAMILY[fontFamilyName];
  }
  return DEFAULT_FONT_FAMILY;
};
var repairBinding = (binding) => {
  if (!binding) {
    return null;
  }
  return { ...binding, focus: binding.focus || 0 };
};
var restoreElementWithProperties = (element, extra) => {
  const base = {
    type: extra.type || element.type,
    // all elements must have version > 0 so getSceneVersion() will pick up
    // newly added elements
    version: element.version || 1,
    versionNonce: element.versionNonce ?? 0,
    isDeleted: element.isDeleted ?? false,
    id: element.id || randomId(),
    fillStyle: element.fillStyle || DEFAULT_ELEMENT_PROPS.fillStyle,
    strokeWidth: element.strokeWidth || DEFAULT_ELEMENT_PROPS.strokeWidth,
    strokeStyle: element.strokeStyle ?? DEFAULT_ELEMENT_PROPS.strokeStyle,
    roughness: element.roughness ?? DEFAULT_ELEMENT_PROPS.roughness,
    opacity: element.opacity == null ? DEFAULT_ELEMENT_PROPS.opacity : element.opacity,
    angle: element.angle || 0,
    x: extra.x ?? element.x ?? 0,
    y: extra.y ?? element.y ?? 0,
    strokeColor: element.strokeColor || DEFAULT_ELEMENT_PROPS.strokeColor,
    backgroundColor: element.backgroundColor || DEFAULT_ELEMENT_PROPS.backgroundColor,
    width: element.width || 0,
    height: element.height || 0,
    seed: element.seed ?? 1,
    groupIds: element.groupIds ?? [],
    frameId: element.frameId ?? null,
    roundness: element.roundness ? element.roundness : element.strokeSharpness === "round" ? {
      // for old elements that would now use adaptive radius algo,
      // use legacy algo instead
      type: isUsingAdaptiveRadius(element.type) ? ROUNDNESS.LEGACY : ROUNDNESS.PROPORTIONAL_RADIUS
    } : null,
    boundElements: element.boundElementIds ? element.boundElementIds.map((id) => ({ type: "arrow", id })) : element.boundElements ?? [],
    updated: element.updated ?? getUpdatedTimestamp(),
    link: element.link ? normalizeLink(element.link) : null,
    locked: element.locked ?? false
  };
  if ("customData" in element || "customData" in extra) {
    base.customData = "customData" in extra ? extra.customData : element.customData;
  }
  if (PRECEDING_ELEMENT_KEY in element) {
    base[PRECEDING_ELEMENT_KEY] = element[PRECEDING_ELEMENT_KEY];
  }
  return {
    ...base,
    ...getNormalizedDimensions(base),
    ...extra
  };
};
var restoreElement = (element) => {
  switch (element.type) {
    case "text":
      let fontSize = element.fontSize;
      let fontFamily = element.fontFamily;
      if ("font" in element) {
        const [fontPx, _fontFamily] = element.font.split(" ");
        fontSize = parseFloat(fontPx);
        fontFamily = getFontFamilyByName(_fontFamily);
      }
      const text = typeof element.text === "string" && element.text || "";
      const lineHeight = element.lineHeight || (element.height ? (
        // detect line-height from current element height and font-size
        detectLineHeight(element)
      ) : (
        // no element height likely means programmatic use, so default
        // to a fixed line height
        getDefaultLineHeight(element.fontFamily)
      ));
      const baseline = measureBaseline(
        element.text,
        getFontString(element),
        lineHeight
      );
      element = restoreElementWithProperties(element, {
        fontSize,
        fontFamily,
        text,
        textAlign: element.textAlign || DEFAULT_TEXT_ALIGN,
        verticalAlign: element.verticalAlign || DEFAULT_VERTICAL_ALIGN,
        containerId: element.containerId ?? null,
        originalText: element.originalText || text,
        lineHeight,
        baseline
      });
      if (!text && !element.isDeleted) {
        element = { ...element, originalText: text, isDeleted: true };
        element = bumpVersion(element);
      }
      return element;
    case "freedraw": {
      return restoreElementWithProperties(element, {
        points: element.points,
        lastCommittedPoint: null,
        simulatePressure: element.simulatePressure,
        pressures: element.pressures
      });
    }
    case "image":
      return restoreElementWithProperties(element, {
        status: element.status || "pending",
        fileId: element.fileId,
        scale: element.scale || [1, 1]
      });
    case "line":
    case "draw":
    case "arrow": {
      const {
        startArrowhead = null,
        endArrowhead = element.type === "arrow" ? "arrow" : null
      } = element;
      let x3 = element.x;
      let y3 = element.y;
      let points = (
        // migrate old arrow model to new one
        !Array.isArray(element.points) || element.points.length < 2 ? [
          [0, 0],
          [element.width, element.height]
        ] : element.points
      );
      if (points[0][0] !== 0 || points[0][1] !== 0) {
        ({ points, x: x3, y: y3 } = LinearElementEditor.getNormalizedPoints(element));
      }
      return restoreElementWithProperties(element, {
        type: element.type === "draw" ? "line" : element.type,
        startBinding: repairBinding(element.startBinding),
        endBinding: repairBinding(element.endBinding),
        lastCommittedPoint: null,
        startArrowhead,
        endArrowhead,
        points,
        x: x3,
        y: y3
      });
    }
    case "ellipse":
    case "rectangle":
    case "diamond":
    case "iframe":
    case "embeddable":
      return restoreElementWithProperties(element, {});
    case "magicframe":
    case "frame":
      return restoreElementWithProperties(element, {
        name: element.name ?? null
      });
  }
  return null;
};
var repairContainerElement = (container, elementsMap) => {
  if (container.boundElements) {
    const boundElements = container.boundElements.slice();
    const boundIds = /* @__PURE__ */ new Set();
    container.boundElements = boundElements.reduce(
      (acc, binding) => {
        const boundElement = elementsMap.get(binding.id);
        if (boundElement && !boundIds.has(binding.id)) {
          boundIds.add(binding.id);
          if (boundElement.isDeleted) {
            return acc;
          }
          acc.push(binding);
          if (isTextElement(boundElement) && // being slightly conservative here, preserving existing containerId
          // if defined, lest boundElements is stale
          !boundElement.containerId) {
            boundElement.containerId = container.id;
          }
        }
        return acc;
      },
      []
    );
  }
};
var repairBoundElement = (boundElement, elementsMap) => {
  const container = boundElement.containerId ? elementsMap.get(boundElement.containerId) : null;
  if (!container) {
    boundElement.containerId = null;
    return;
  }
  if (boundElement.isDeleted) {
    return;
  }
  if (container.boundElements && !container.boundElements.find((binding) => binding.id === boundElement.id)) {
    const boundElements = (container.boundElements || (container.boundElements = [])).slice();
    boundElements.push({ type: "text", id: boundElement.id });
    container.boundElements = boundElements;
  }
};
var repairFrameMembership = (element, elementsMap) => {
  if (element.frameId) {
    const containingFrame = elementsMap.get(element.frameId);
    if (!containingFrame) {
      element.frameId = null;
    }
  }
};
var restoreElements = (elements, localElements, opts) => {
  const existingIds = /* @__PURE__ */ new Set();
  const localElementsMap = localElements ? arrayToMap(localElements) : null;
  const restoredElements = (elements || []).reduce((elements2, element) => {
    if (element.type !== "selection" && !isInvisiblySmallElement(element)) {
      let migratedElement = restoreElement(element);
      if (migratedElement) {
        const localElement = localElementsMap?.get(element.id);
        if (localElement && localElement.version > migratedElement.version) {
          migratedElement = bumpVersion(migratedElement, localElement.version);
        }
        if (existingIds.has(migratedElement.id)) {
          migratedElement = { ...migratedElement, id: randomId() };
        }
        existingIds.add(migratedElement.id);
        elements2.push(migratedElement);
      }
    }
    return elements2;
  }, []);
  if (!opts?.repairBindings) {
    return restoredElements;
  }
  const restoredElementsMap = arrayToMap(restoredElements);
  for (const element of restoredElements) {
    if (element.frameId) {
      repairFrameMembership(element, restoredElementsMap);
    }
    if (isTextElement(element) && element.containerId) {
      repairBoundElement(element, restoredElementsMap);
    } else if (element.boundElements) {
      repairContainerElement(element, restoredElementsMap);
    }
    if (opts.refreshDimensions && isTextElement(element)) {
      Object.assign(
        element,
        refreshTextDimensions(
          element,
          getContainerElement(element, restoredElementsMap),
          restoredElementsMap
        )
      );
    }
  }
  return restoredElements;
};
var coalesceAppStateValue = (key, appState, defaultAppState2) => {
  const value = appState[key];
  return value !== void 0 ? value : defaultAppState2[key];
};
var LegacyAppStateMigrations = {
  isSidebarDocked: (appState, defaultAppState2) => {
    return [
      "defaultSidebarDockedPreference",
      appState.isSidebarDocked ?? coalesceAppStateValue(
        "defaultSidebarDockedPreference",
        appState,
        defaultAppState2
      )
    ];
  }
};
var restoreAppState = (appState, localAppState) => {
  appState = appState || {};
  const defaultAppState2 = getDefaultAppState();
  const nextAppState = {};
  for (const legacyKey of Object.keys(
    LegacyAppStateMigrations
  )) {
    if (legacyKey in appState) {
      const [nextKey, nextValue] = LegacyAppStateMigrations[legacyKey](
        appState,
        defaultAppState2
      );
      nextAppState[nextKey] = nextValue;
    }
  }
  for (const [key, defaultValue] of Object.entries(defaultAppState2)) {
    const suppliedValue = appState[key];
    const localValue = localAppState ? localAppState[key] : void 0;
    nextAppState[key] = suppliedValue !== void 0 ? suppliedValue : localValue !== void 0 ? localValue : defaultValue;
  }
  return {
    ...nextAppState,
    cursorButton: localAppState?.cursorButton || "up",
    // reset on fresh restore so as to hide the UI button if penMode not active
    penDetected: localAppState?.penDetected ?? (appState.penMode ? appState.penDetected ?? false : false),
    activeTool: {
      ...updateActiveTool(
        defaultAppState2,
        nextAppState.activeTool.type && AllowedExcalidrawActiveTools[nextAppState.activeTool.type] ? nextAppState.activeTool : { type: "selection" }
      ),
      lastActiveTool: null,
      locked: nextAppState.activeTool.locked ?? false
    },
    // Migrates from previous version where appState.zoom was a number
    zoom: typeof appState.zoom === "number" ? {
      value: appState.zoom
    } : appState.zoom?.value ? appState.zoom : defaultAppState2.zoom,
    openSidebar: (
      // string (legacy)
      typeof appState.openSidebar === "string" ? { name: DEFAULT_SIDEBAR.name } : nextAppState.openSidebar
    )
  };
};
var restore = (data, localAppState, localElements, elementsConfig) => {
  return {
    elements: restoreElements(data?.elements, localElements, elementsConfig),
    appState: restoreAppState(data?.appState, localAppState || null),
    files: data?.files || {}
  };
};
var restoreLibraryItem = (libraryItem) => {
  const elements = restoreElements(
    getNonDeletedElements2(libraryItem.elements),
    null
  );
  return elements.length ? { ...libraryItem, elements } : null;
};
var restoreLibraryItems = (libraryItems = [], defaultStatus) => {
  const restoredItems = [];
  for (const item of libraryItems) {
    if (Array.isArray(item)) {
      const restoredItem = restoreLibraryItem({
        status: defaultStatus,
        elements: item,
        id: randomId(),
        created: Date.now()
      });
      if (restoredItem) {
        restoredItems.push(restoredItem);
      }
    } else {
      const _item = item;
      const restoredItem = restoreLibraryItem({
        ..._item,
        id: _item.id || randomId(),
        status: _item.status || defaultStatus,
        created: _item.created || Date.now()
      });
      if (restoredItem) {
        restoredItems.push(restoredItem);
      }
    }
  }
  return restoredItems;
};

// data/library.ts
var import_react40 = __toESM(require_react(), 1);

// hooks/useLibraryItemSvg.ts
init_define_import_meta_env();
var import_react39 = __toESM(require_react(), 1);
var libraryItemSvgsCache = atom2(/* @__PURE__ */ new Map());
var exportLibraryItemToSvg = async (elements) => {
  return await exportToSvg2({
    elements,
    appState: {
      exportBackground: false,
      viewBackgroundColor: COLOR_PALETTE.white
    },
    files: null,
    renderEmbeddables: false
  });
};
var useLibraryItemSvg = (id, elements, svgCache) => {
  const [svg, setSvg] = (0, import_react39.useState)();
  (0, import_react39.useEffect)(() => {
    if (elements) {
      if (id) {
        const cachedSvg = svgCache.get(id);
        if (cachedSvg) {
          setSvg(cachedSvg);
        } else {
          (async () => {
            const exportedSvg = await exportLibraryItemToSvg(elements);
            exportedSvg.querySelector(".style-fonts")?.remove();
            if (exportedSvg) {
              svgCache.set(id, exportedSvg);
              setSvg(exportedSvg);
            }
          })();
        }
      } else {
        (async () => {
          const exportedSvg = await exportLibraryItemToSvg(elements);
          setSvg(exportedSvg);
        })();
      }
    }
  }, [id, elements, svgCache, setSvg]);
  return svg;
};
var useLibraryCache = () => {
  const [svgCache] = useAtom(libraryItemSvgsCache, jotaiScope);
  const clearLibraryCache = () => svgCache.clear();
  const deleteItemsFromLibraryCache = (items) => {
    items.forEach((item) => svgCache.delete(item));
  };
  return {
    clearLibraryCache,
    deleteItemsFromLibraryCache,
    svgCache
  };
};

// data/library.ts
var libraryItemsAtom = atom2({ status: "loaded", isInitialized: true, libraryItems: [] });
var cloneLibraryItems = (libraryItems) => cloneJSON(libraryItems);
var isUniqueItem = (existingLibraryItems, targetLibraryItem) => {
  return !existingLibraryItems.find((libraryItem) => {
    if (libraryItem.elements.length !== targetLibraryItem.elements.length) {
      return false;
    }
    return libraryItem.elements.every((libItemExcalidrawItem, idx) => {
      return libItemExcalidrawItem.id === targetLibraryItem.elements[idx].id && libItemExcalidrawItem.versionNonce === targetLibraryItem.elements[idx].versionNonce;
    });
  });
};
var mergeLibraryItems = (localItems, otherItems) => {
  const newItems = [];
  for (const item of otherItems) {
    if (isUniqueItem(localItems, item)) {
      newItems.push(item);
    }
  }
  return [...newItems, ...localItems];
};
var Library = class {
  /** latest libraryItems */
  lastLibraryItems = [];
  /** indicates whether library is initialized with library items (has gone
   * though at least one update) */
  isInitialized = false;
  app;
  constructor(app) {
    this.app = app;
  }
  updateQueue = [];
  getLastUpdateTask = () => {
    return this.updateQueue[this.updateQueue.length - 1];
  };
  notifyListeners = () => {
    if (this.updateQueue.length > 0) {
      jotaiStore.set(libraryItemsAtom, {
        status: "loading",
        libraryItems: this.lastLibraryItems,
        isInitialized: this.isInitialized
      });
    } else {
      this.isInitialized = true;
      jotaiStore.set(libraryItemsAtom, {
        status: "loaded",
        libraryItems: this.lastLibraryItems,
        isInitialized: this.isInitialized
      });
      try {
        this.app.props.onLibraryChange?.(
          cloneLibraryItems(this.lastLibraryItems)
        );
      } catch (error) {
        console.error(error);
      }
    }
  };
  /** call on excalidraw instance unmount */
  destroy = () => {
    this.isInitialized = false;
    this.updateQueue = [];
    this.lastLibraryItems = [];
    jotaiStore.set(libraryItemSvgsCache, /* @__PURE__ */ new Map());
  };
  resetLibrary = () => {
    return this.setLibrary([]);
  };
  /**
   * @returns latest cloned libraryItems. Awaits all in-progress updates first.
   */
  getLatestLibrary = () => {
    return new Promise(async (resolve) => {
      try {
        const libraryItems = await (this.getLastUpdateTask() || this.lastLibraryItems);
        if (this.updateQueue.length > 0) {
          resolve(this.getLatestLibrary());
        } else {
          resolve(cloneLibraryItems(libraryItems));
        }
      } catch (error) {
        return resolve(this.lastLibraryItems);
      }
    });
  };
  // NOTE this is a high-level public API (exposed on ExcalidrawAPI) with
  // a slight overhead (always restoring library items). For internal use
  // where merging isn't needed, use `library.setLibrary()` directly.
  updateLibrary = async ({
    libraryItems,
    prompt = false,
    merge = false,
    openLibraryMenu = false,
    defaultStatus = "unpublished"
  }) => {
    if (openLibraryMenu) {
      this.app.setState({
        openSidebar: { name: DEFAULT_SIDEBAR.name, tab: LIBRARY_SIDEBAR_TAB }
      });
    }
    return this.setLibrary(() => {
      return new Promise(async (resolve, reject) => {
        try {
          const source = await (typeof libraryItems === "function" && !(libraryItems instanceof Blob) ? libraryItems(this.lastLibraryItems) : libraryItems);
          let nextItems;
          if (source instanceof Blob) {
            nextItems = await loadLibraryFromBlob(source, defaultStatus);
          } else {
            nextItems = restoreLibraryItems(source, defaultStatus);
          }
          if (!prompt || window.confirm(
            t("alerts.confirmAddLibrary", {
              numShapes: nextItems.length
            })
          )) {
            if (prompt) {
              this.app.focusContainer();
            }
            if (merge) {
              resolve(mergeLibraryItems(this.lastLibraryItems, nextItems));
            } else {
              resolve(nextItems);
            }
          } else {
            reject(new AbortError());
          }
        } catch (error) {
          reject(error);
        }
      });
    });
  };
  setLibrary = (libraryItems) => {
    const task = new Promise(async (resolve, reject) => {
      try {
        await this.getLastUpdateTask();
        if (typeof libraryItems === "function") {
          libraryItems = libraryItems(this.lastLibraryItems);
        }
        this.lastLibraryItems = cloneLibraryItems(await libraryItems);
        resolve(this.lastLibraryItems);
      } catch (error) {
        reject(error);
      }
    }).catch((error) => {
      if (error.name === "AbortError") {
        console.warn("Library update aborted by user");
        return this.lastLibraryItems;
      }
      throw error;
    }).finally(() => {
      this.updateQueue = this.updateQueue.filter((_task) => _task !== task);
      this.notifyListeners();
    });
    this.updateQueue.push(task);
    this.notifyListeners();
    return task;
  };
};
var library_default = Library;
var distributeLibraryItemsOnSquareGrid = (libraryItems) => {
  const PADDING = 50;
  const ITEMS_PER_ROW = Math.ceil(Math.sqrt(libraryItems.length));
  const resElements = [];
  const getMaxHeightPerRow = (row2) => {
    const maxHeight = libraryItems.slice(row2 * ITEMS_PER_ROW, row2 * ITEMS_PER_ROW + ITEMS_PER_ROW).reduce((acc, item) => {
      const { height } = getCommonBoundingBox(item.elements);
      return Math.max(acc, height);
    }, 0);
    return maxHeight;
  };
  const getMaxWidthPerCol = (targetCol) => {
    let index3 = 0;
    let currCol = 0;
    let maxWidth = 0;
    for (const item of libraryItems) {
      if (index3 % ITEMS_PER_ROW === 0) {
        currCol = 0;
      }
      if (currCol === targetCol) {
        const { width } = getCommonBoundingBox(item.elements);
        maxWidth = Math.max(maxWidth, width);
      }
      index3++;
      currCol++;
    }
    return maxWidth;
  };
  let colOffsetX = 0;
  let rowOffsetY = 0;
  let maxHeightCurrRow = 0;
  let maxWidthCurrCol = 0;
  let index2 = 0;
  let col = 0;
  let row = 0;
  for (const item of libraryItems) {
    if (index2 && index2 % ITEMS_PER_ROW === 0) {
      rowOffsetY += maxHeightCurrRow + PADDING;
      colOffsetX = 0;
      col = 0;
      row++;
    }
    if (col === 0) {
      maxHeightCurrRow = getMaxHeightPerRow(row);
    }
    maxWidthCurrCol = getMaxWidthPerCol(col);
    const { minX, minY, width, height } = getCommonBoundingBox(item.elements);
    const offsetCenterX = (maxWidthCurrCol - width) / 2;
    const offsetCenterY = (maxHeightCurrRow - height) / 2;
    resElements.push(
      ...item.elements.map((element) => ({
        ...element,
        x: element.x + // offset for column
        colOffsetX + // offset to center in given square grid
        offsetCenterX - // subtract minX so that given item starts at 0 coord
        minX,
        y: element.y + // offset for row
        rowOffsetY + // offset to center in given square grid
        offsetCenterY - // subtract minY so that given item starts at 0 coord
        minY
      }))
    );
    colOffsetX += maxWidthCurrCol + PADDING;
    index2++;
    col++;
  }
  return resElements;
};
var parseLibraryTokensFromUrl = () => {
  const libraryUrl = (
    // current
    new URLSearchParams(window.location.hash.slice(1)).get(
      URL_HASH_KEYS.addLibrary
    ) || // legacy, kept for compat reasons
    new URLSearchParams(window.location.search).get(URL_QUERY_KEYS.addLibrary)
  );
  const idToken = libraryUrl ? new URLSearchParams(window.location.hash.slice(1)).get("token") : null;
  return libraryUrl ? { libraryUrl, idToken } : null;
};
var useHandleLibrary = ({
  excalidrawAPI,
  getInitialLibraryItems
}) => {
  const getInitialLibraryRef = (0, import_react40.useRef)(getInitialLibraryItems);
  (0, import_react40.useEffect)(() => {
    if (!excalidrawAPI) {
      return;
    }
    const importLibraryFromURL = async ({
      libraryUrl,
      idToken
    }) => {
      const libraryPromise = new Promise(async (resolve, reject) => {
        try {
          const request = await fetch(decodeURIComponent(libraryUrl));
          const blob = await request.blob();
          resolve(blob);
        } catch (error) {
          reject(error);
        }
      });
      const shouldPrompt = idToken !== excalidrawAPI.id;
      await (shouldPrompt && document.hidden ? new Promise((resolve) => {
        window.addEventListener("focus", () => resolve(), {
          once: true
        });
      }) : null);
      try {
        await excalidrawAPI.updateLibrary({
          libraryItems: libraryPromise,
          prompt: shouldPrompt,
          merge: true,
          defaultStatus: "published",
          openLibraryMenu: true
        });
      } catch (error) {
        throw error;
      } finally {
        if (window.location.hash.includes(URL_HASH_KEYS.addLibrary)) {
          const hash = new URLSearchParams(window.location.hash.slice(1));
          hash.delete(URL_HASH_KEYS.addLibrary);
          window.history.replaceState({}, APP_NAME, `#${hash.toString()}`);
        } else if (window.location.search.includes(URL_QUERY_KEYS.addLibrary)) {
          const query = new URLSearchParams(window.location.search);
          query.delete(URL_QUERY_KEYS.addLibrary);
          window.history.replaceState({}, APP_NAME, `?${query.toString()}`);
        }
      }
    };
    const onHashChange = (event) => {
      event.preventDefault();
      const libraryUrlTokens2 = parseLibraryTokensFromUrl();
      if (libraryUrlTokens2) {
        event.stopImmediatePropagation();
        window.history.replaceState({}, "", event.oldURL);
        importLibraryFromURL(libraryUrlTokens2);
      }
    };
    if (getInitialLibraryRef.current) {
      excalidrawAPI.updateLibrary({
        libraryItems: getInitialLibraryRef.current()
      });
    }
    const libraryUrlTokens = parseLibraryTokensFromUrl();
    if (libraryUrlTokens) {
      importLibraryFromURL(libraryUrlTokens);
    }
    window.addEventListener("hashchange" /* HASHCHANGE */, onHashChange);
    return () => {
      window.removeEventListener("hashchange" /* HASHCHANGE */, onHashChange);
    };
  }, [excalidrawAPI]);
};

// gesture.ts
init_define_import_meta_env();
var getCenter = (pointers) => {
  const allCoords = Array.from(pointers.values());
  return {
    x: sum(allCoords, (coords) => coords.x) / allCoords.length,
    y: sum(allCoords, (coords) => coords.y) / allCoords.length
  };
};
var getDistance = ([a4, b4]) => Math.hypot(a4.x - b4.x, a4.y - b4.y);
var sum = (array, mapper) => array.reduce((acc, item) => acc + mapper(item), 0);

// history.ts
init_define_import_meta_env();
var clearAppStatePropertiesForHistory = (appState) => {
  return {
    selectedElementIds: appState.selectedElementIds,
    selectedGroupIds: appState.selectedGroupIds,
    viewBackgroundColor: appState.viewBackgroundColor,
    editingLinearElement: appState.editingLinearElement,
    editingGroupId: appState.editingGroupId,
    name: appState.name
  };
};
var History = class {
  elementCache = /* @__PURE__ */ new Map();
  recording = true;
  stateHistory = [];
  redoStack = [];
  lastEntry = null;
  hydrateHistoryEntry({
    appState,
    elements
  }) {
    return {
      appState: JSON.parse(appState),
      elements: elements.map((dehydratedExcalidrawElement) => {
        const element = this.elementCache.get(dehydratedExcalidrawElement.id)?.get(dehydratedExcalidrawElement.versionNonce);
        if (!element) {
          throw new Error(
            `Element not found: ${dehydratedExcalidrawElement.id}:${dehydratedExcalidrawElement.versionNonce}`
          );
        }
        return element;
      })
    };
  }
  dehydrateHistoryEntry({
    appState,
    elements
  }) {
    return {
      appState: JSON.stringify(appState),
      elements: elements.map((element) => {
        if (!this.elementCache.has(element.id)) {
          this.elementCache.set(element.id, /* @__PURE__ */ new Map());
        }
        const versions = this.elementCache.get(element.id);
        if (!versions.has(element.versionNonce)) {
          versions.set(element.versionNonce, deepCopyElement(element));
        }
        return {
          id: element.id,
          versionNonce: element.versionNonce
        };
      })
    };
  }
  getSnapshotForTest() {
    return {
      recording: this.recording,
      stateHistory: this.stateHistory.map(
        (dehydratedHistoryEntry) => this.hydrateHistoryEntry(dehydratedHistoryEntry)
      ),
      redoStack: this.redoStack.map(
        (dehydratedHistoryEntry) => this.hydrateHistoryEntry(dehydratedHistoryEntry)
      )
    };
  }
  clear() {
    this.stateHistory.length = 0;
    this.redoStack.length = 0;
    this.lastEntry = null;
    this.elementCache.clear();
  }
  generateEntry = (appState, elements) => this.dehydrateHistoryEntry({
    appState: clearAppStatePropertiesForHistory(appState),
    elements: elements.reduce((elements2, element) => {
      if (isLinearElement(element) && appState.multiElement && appState.multiElement.id === element.id) {
        if (appState.multiElement && appState.multiElement.id === element.id && element.points.length < 2) {
          return elements2;
        }
        elements2.push({
          ...element,
          // don't store last point if not committed
          points: element.lastCommittedPoint !== element.points[element.points.length - 1] ? element.points.slice(0, -1) : element.points
        });
      } else {
        elements2.push(element);
      }
      return elements2;
    }, [])
  });
  shouldCreateEntry(nextEntry) {
    const { lastEntry } = this;
    if (!lastEntry) {
      return true;
    }
    if (nextEntry.elements.length !== lastEntry.elements.length) {
      return true;
    }
    for (let i4 = nextEntry.elements.length - 1; i4 > -1; i4--) {
      const prev = nextEntry.elements[i4];
      const next = lastEntry.elements[i4];
      if (!prev || !next || prev.id !== next.id || prev.versionNonce !== next.versionNonce) {
        return true;
      }
    }
    let key;
    for (key in nextEntry.appState) {
      if (key === "editingLinearElement") {
        if (nextEntry.appState[key]?.elementId === lastEntry.appState[key]?.elementId) {
          continue;
        }
      }
      if (key === "selectedElementIds" || key === "selectedGroupIds") {
        continue;
      }
      if (nextEntry.appState[key] !== lastEntry.appState[key]) {
        return true;
      }
    }
    return false;
  }
  pushEntry(appState, elements) {
    const newEntryDehydrated = this.generateEntry(appState, elements);
    const newEntry = this.hydrateHistoryEntry(newEntryDehydrated);
    if (newEntry) {
      if (!this.shouldCreateEntry(newEntry)) {
        return;
      }
      this.stateHistory.push(newEntryDehydrated);
      this.lastEntry = newEntry;
      this.clearRedoStack();
    }
  }
  clearRedoStack() {
    this.redoStack.splice(0, this.redoStack.length);
  }
  redoOnce() {
    if (this.redoStack.length === 0) {
      return null;
    }
    const entryToRestore = this.redoStack.pop();
    if (entryToRestore !== void 0) {
      this.stateHistory.push(entryToRestore);
      return this.hydrateHistoryEntry(entryToRestore);
    }
    return null;
  }
  undoOnce() {
    if (this.stateHistory.length === 1) {
      return null;
    }
    const currentEntry = this.stateHistory.pop();
    const entryToRestore = this.stateHistory[this.stateHistory.length - 1];
    if (currentEntry !== void 0) {
      this.redoStack.push(currentEntry);
      return this.hydrateHistoryEntry(entryToRestore);
    }
    return null;
  }
  /**
   * Updates history's `lastEntry` to latest app state. This is necessary
   *  when doing undo/redo which itself doesn't commit to history, but updates
   *  app state in a way that would break `shouldCreateEntry` which relies on
   *  `lastEntry` to reflect last comittable history state.
   * We can't update `lastEntry` from within history when calling undo/redo
   *  because the action potentially mutates appState/elements before storing
   *  it.
   */
  setCurrentState(appState, elements) {
    this.lastEntry = this.hydrateHistoryEntry(
      this.generateEntry(appState, elements)
    );
  }
  // Suspicious that this is called so many places. Seems error-prone.
  resumeRecording() {
    this.recording = true;
  }
  record(state, elements) {
    if (this.recording) {
      this.pushEntry(state, elements);
      this.recording = false;
    }
  }
};
var history_default = History;

// shapes.tsx
init_define_import_meta_env();
var SHAPES = [
  {
    icon: SelectionIcon,
    value: "selection",
    key: KEYS.V,
    numericKey: KEYS["1"],
    fillable: true
  },
  {
    icon: RectangleIcon,
    value: "rectangle",
    key: KEYS.R,
    numericKey: KEYS["2"],
    fillable: true
  },
  {
    icon: DiamondIcon,
    value: "diamond",
    key: KEYS.D,
    numericKey: KEYS["3"],
    fillable: true
  },
  {
    icon: EllipseIcon,
    value: "ellipse",
    key: KEYS.O,
    numericKey: KEYS["4"],
    fillable: true
  },
  {
    icon: ArrowIcon,
    value: "arrow",
    key: KEYS.A,
    numericKey: KEYS["5"],
    fillable: true
  },
  {
    icon: LineIcon,
    value: "line",
    key: KEYS.L,
    numericKey: KEYS["6"],
    fillable: true
  },
  {
    icon: FreedrawIcon,
    value: "freedraw",
    key: [KEYS.P, KEYS.X],
    numericKey: KEYS["7"],
    fillable: false
  },
  {
    icon: TextIcon,
    value: "text",
    key: KEYS.T,
    numericKey: KEYS["8"],
    fillable: false
  },
  {
    icon: ImageIcon,
    value: "image",
    key: null,
    numericKey: KEYS["9"],
    fillable: false
  },
  {
    icon: EraserIcon,
    value: "eraser",
    key: KEYS.E,
    numericKey: KEYS["0"],
    fillable: false
  }
];
var findShapeByKey = (key) => {
  const shape = SHAPES.find((shape2, index2) => {
    return shape2.numericKey != null && key === shape2.numericKey.toString() || shape2.key && (typeof shape2.key === "string" ? shape2.key === key : shape2.key.includes(key));
  });
  return shape?.value || null;
};

// components/ContextMenu.tsx
init_define_import_meta_env();

// actions/shortcuts.ts
init_define_import_meta_env();
var shortcutMap = {
  toggleTheme: [getShortcutKey("Shift+Alt+D")],
  saveScene: [getShortcutKey("CtrlOrCmd+S")],
  loadScene: [getShortcutKey("CtrlOrCmd+O")],
  clearCanvas: [getShortcutKey("CtrlOrCmd+Delete")],
  imageExport: [getShortcutKey("CtrlOrCmd+Shift+E")],
  cut: [getShortcutKey("CtrlOrCmd+X")],
  copy: [getShortcutKey("CtrlOrCmd+C")],
  paste: [getShortcutKey("CtrlOrCmd+V")],
  copyStyles: [getShortcutKey("CtrlOrCmd+Alt+C")],
  pasteStyles: [getShortcutKey("CtrlOrCmd+Alt+V")],
  selectAll: [getShortcutKey("CtrlOrCmd+A")],
  deleteSelectedElements: [getShortcutKey("Delete")],
  duplicateSelection: [
    getShortcutKey("CtrlOrCmd+D"),
    getShortcutKey(`Alt+${t("helpDialog.drag")}`)
  ],
  sendBackward: [getShortcutKey("CtrlOrCmd+[")],
  bringForward: [getShortcutKey("CtrlOrCmd+]")],
  sendToBack: [
    isDarwin ? getShortcutKey("CtrlOrCmd+Alt+[") : getShortcutKey("CtrlOrCmd+Shift+[")
  ],
  bringToFront: [
    isDarwin ? getShortcutKey("CtrlOrCmd+Alt+]") : getShortcutKey("CtrlOrCmd+Shift+]")
  ],
  copyAsPng: [getShortcutKey("Shift+Alt+C")],
  copyAsSvg: [],
  group: [getShortcutKey("CtrlOrCmd+G")],
  ungroup: [getShortcutKey("CtrlOrCmd+Shift+G")],
  gridMode: [getShortcutKey("CtrlOrCmd+'")],
  zenMode: [getShortcutKey("Alt+Z")],
  objectsSnapMode: [getShortcutKey("Alt+S")],
  stats: [getShortcutKey("Alt+/")],
  addToLibrary: [],
  flipHorizontal: [getShortcutKey("Shift+H")],
  flipVertical: [getShortcutKey("Shift+V")],
  viewMode: [getShortcutKey("Alt+R")],
  hyperlink: [getShortcutKey("CtrlOrCmd+K")],
  toggleElementLock: [getShortcutKey("CtrlOrCmd+Shift+L")]
};
var getShortcutFromShortcutName = (name) => {
  const shortcuts = shortcutMap[name];
  return shortcuts && shortcuts.length > 0 ? shortcuts[0] : "";
};

// components/ContextMenu.tsx
var import_react41 = __toESM(require_react(), 1);
var import_jsx_runtime34 = __toESM(require_jsx_runtime(), 1);
var CONTEXT_MENU_SEPARATOR = "separator";
var ContextMenu = import_react41.default.memo(
  ({ actionManager, items, top: top2, left, onClose }) => {
    const appState = useExcalidrawAppState();
    const elements = useExcalidrawElements();
    const filteredItems = items.reduce((acc, item) => {
      if (item && (item === CONTEXT_MENU_SEPARATOR || !item.predicate || item.predicate(
        elements,
        appState,
        actionManager.app.props,
        actionManager.app
      ))) {
        acc.push(item);
      }
      return acc;
    }, []);
    return /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(
      Popover,
      {
        onCloseRequest: () => {
          onClose();
        },
        top: top2,
        left,
        fitInViewport: true,
        offsetLeft: appState.offsetLeft,
        offsetTop: appState.offsetTop,
        viewportWidth: appState.width,
        viewportHeight: appState.height,
        children: /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(
          "ul",
          {
            className: "context-menu",
            onContextMenu: (event) => event.preventDefault(),
            children: filteredItems.map((item, idx) => {
              if (item === CONTEXT_MENU_SEPARATOR) {
                if (!filteredItems[idx - 1] || filteredItems[idx - 1] === CONTEXT_MENU_SEPARATOR) {
                  return null;
                }
                return /* @__PURE__ */ (0, import_jsx_runtime34.jsx)("hr", { className: "context-menu-item-separator" }, idx);
              }
              const actionName = item.name;
              let label = "";
              if (item.contextItemLabel) {
                if (typeof item.contextItemLabel === "function") {
                  label = t(
                    item.contextItemLabel(
                      elements,
                      appState,
                      actionManager.app
                    )
                  );
                } else {
                  label = t(item.contextItemLabel);
                }
              }
              return /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(
                "li",
                {
                  "data-testid": actionName,
                  onClick: () => {
                    onClose(() => {
                      actionManager.executeAction(item, "contextMenu");
                    });
                  },
                  children: /* @__PURE__ */ (0, import_jsx_runtime34.jsxs)(
                    "button",
                    {
                      className: clsx_m_default("context-menu-item", {
                        dangerous: actionName === "deleteSelectedElements",
                        checkmark: item.checked?.(appState)
                      }),
                      children: [
                        /* @__PURE__ */ (0, import_jsx_runtime34.jsx)("div", { className: "context-menu-item__label", children: label }),
                        /* @__PURE__ */ (0, import_jsx_runtime34.jsx)("kbd", { className: "context-menu-item__shortcut", children: actionName ? getShortcutFromShortcutName(actionName) : "" })
                      ]
                    }
                  )
                },
                idx
              );
            })
          }
        )
      }
    );
  }
);

// components/LayerUI.tsx
init_define_import_meta_env();
var import_react89 = __toESM(require_react(), 1);

// components/Actions.tsx
init_define_import_meta_env();
var import_react50 = __toESM(require_react(), 1);

// components/Stack.tsx
init_define_import_meta_env();
var import_react42 = __toESM(require_react(), 1);
var import_jsx_runtime35 = __toESM(require_jsx_runtime(), 1);
var RowStack = (0, import_react42.forwardRef)(
  ({ children, gap, align, justifyContent, className, style }, ref) => {
    return /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(
      "div",
      {
        className: clsx_m_default("Stack Stack_horizontal", className),
        style: {
          "--gap": gap,
          alignItems: align,
          justifyContent,
          ...style
        },
        ref,
        children
      }
    );
  }
);
var ColStack = (0, import_react42.forwardRef)(
  ({ children, gap, align, justifyContent, className, style }, ref) => {
    return /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(
      "div",
      {
        className: clsx_m_default("Stack Stack_vertical", className),
        style: {
          "--gap": gap,
          justifyItems: align,
          justifyContent,
          ...style
        },
        ref,
        children
      }
    );
  }
);
var Stack_default = {
  Row: RowStack,
  Col: ColStack
};

// components/dropdownMenu/DropdownMenu.tsx
init_define_import_meta_env();

// components/dropdownMenu/DropdownMenuTrigger.tsx
init_define_import_meta_env();
var import_jsx_runtime36 = __toESM(require_jsx_runtime(), 1);
var MenuTrigger = ({
  className = "",
  children,
  onToggle,
  title,
  ...rest
}) => {
  const device = useDevice();
  const classNames = clsx_m_default(
    `dropdown-menu-button ${className}`,
    "zen-mode-transition",
    {
      "dropdown-menu-button--mobile": device.editor.isMobile
    }
  ).trim();
  return /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(
    "button",
    {
      "data-prevent-outside-click": true,
      className: classNames,
      onClick: onToggle,
      type: "button",
      "data-testid": "dropdown-menu-button",
      title,
      ...rest,
      children
    }
  );
};
var DropdownMenuTrigger_default = MenuTrigger;
MenuTrigger.displayName = "DropdownMenuTrigger";

// components/dropdownMenu/DropdownMenuItem.tsx
init_define_import_meta_env();

// components/dropdownMenu/common.ts
init_define_import_meta_env();
var import_react43 = __toESM(require_react(), 1);
var DropdownMenuContentPropsContext = import_react43.default.createContext({});
var getDropdownMenuItemClassName = (className = "", selected = false) => {
  return `dropdown-menu-item dropdown-menu-item-base ${className} ${selected ? "dropdown-menu-item--selected" : ""}`.trim();
};
var useHandleDropdownMenuItemClick = (origOnClick, onSelect) => {
  const DropdownMenuContentProps = (0, import_react43.useContext)(DropdownMenuContentPropsContext);
  return composeEventHandlers(origOnClick, (event) => {
    const itemSelectEvent = new CustomEvent("menu.itemSelect" /* MENU_ITEM_SELECT */, {
      bubbles: true,
      cancelable: true
    });
    onSelect?.(itemSelectEvent);
    if (!itemSelectEvent.defaultPrevented) {
      DropdownMenuContentProps.onSelect?.(itemSelectEvent);
    }
  });
};

// components/dropdownMenu/DropdownMenuItemContent.tsx
init_define_import_meta_env();
var import_jsx_runtime37 = __toESM(require_jsx_runtime(), 1);
var MenuItemContent = ({
  icon,
  shortcut,
  children
}) => {
  const device = useDevice();
  return /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)(import_jsx_runtime37.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("div", { className: "dropdown-menu-item__icon", children: icon }),
    /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("div", { className: "dropdown-menu-item__text", children }),
    shortcut && !device.editor.isMobile && /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("div", { className: "dropdown-menu-item__shortcut", children: shortcut })
  ] });
};
var DropdownMenuItemContent_default = MenuItemContent;

// components/dropdownMenu/DropdownMenuItem.tsx
var import_jsx_runtime38 = __toESM(require_jsx_runtime(), 1);
var DropdownMenuItem = ({
  icon,
  onSelect,
  children,
  shortcut,
  className,
  selected,
  ...rest
}) => {
  const handleClick = useHandleDropdownMenuItemClick(rest.onClick, onSelect);
  return /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(
    "button",
    {
      ...rest,
      onClick: handleClick,
      type: "button",
      className: getDropdownMenuItemClassName(className, selected),
      title: rest.title ?? rest["aria-label"],
      children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(DropdownMenuItemContent_default, { icon, shortcut, children })
    }
  );
};
DropdownMenuItem.displayName = "DropdownMenuItem";
var DropDownMenuItemBadge = ({
  children
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(
    "div",
    {
      style: {
        display: "inline-flex",
        marginLeft: "auto",
        padding: "2px 4px",
        background: "pink",
        borderRadius: 6,
        fontSize: 9,
        color: "black",
        fontFamily: "Cascadia, monospace"
      },
      children
    }
  );
};
DropDownMenuItemBadge.displayName = "DropdownMenuItemBadge";
DropdownMenuItem.Badge = DropDownMenuItemBadge;
var DropdownMenuItem_default = DropdownMenuItem;

// components/dropdownMenu/DropdownMenuSeparator.tsx
init_define_import_meta_env();
var import_jsx_runtime39 = __toESM(require_jsx_runtime(), 1);
var MenuSeparator = () => /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(
  "div",
  {
    style: {
      height: "1px",
      backgroundColor: "var(--default-border-color)",
      margin: ".5rem 0"
    }
  }
);
var DropdownMenuSeparator_default = MenuSeparator;
MenuSeparator.displayName = "DropdownMenuSeparator";

// components/dropdownMenu/DropdownMenuGroup.tsx
init_define_import_meta_env();
var import_jsx_runtime40 = __toESM(require_jsx_runtime(), 1);
var MenuGroup = ({
  children,
  className = "",
  style,
  title
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime40.jsxs)("div", { className: `dropdown-menu-group ${className}`, style, children: [
    title && /* @__PURE__ */ (0, import_jsx_runtime40.jsx)("p", { className: "dropdown-menu-group-title", children: title }),
    children
  ] });
};
var DropdownMenuGroup_default = MenuGroup;
MenuGroup.displayName = "DropdownMenuGroup";

// components/dropdownMenu/DropdownMenuContent.tsx
init_define_import_meta_env();

// components/Island.tsx
init_define_import_meta_env();
var import_react44 = __toESM(require_react(), 1);
var import_jsx_runtime41 = __toESM(require_jsx_runtime(), 1);
var Island = import_react44.default.forwardRef(
  ({ children, padding, className, style }, ref) => /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(
    "div",
    {
      className: clsx_m_default("Island", className),
      style: { "--padding": padding, ...style },
      ref,
      children
    }
  )
);

// components/dropdownMenu/DropdownMenuContent.tsx
var import_react45 = __toESM(require_react(), 1);
var import_jsx_runtime42 = __toESM(require_jsx_runtime(), 1);
var MenuContent = ({
  children,
  onClickOutside,
  className = "",
  onSelect,
  style
}) => {
  const device = useDevice();
  const menuRef = (0, import_react45.useRef)(null);
  useOutsideClick(menuRef, () => {
    onClickOutside?.();
  });
  const classNames = clsx_m_default(`dropdown-menu ${className}`, {
    "dropdown-menu--mobile": device.editor.isMobile
  }).trim();
  return /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(DropdownMenuContentPropsContext.Provider, { value: { onSelect }, children: /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(
    "div",
    {
      ref: menuRef,
      className: classNames,
      style,
      "data-testid": "dropdown-menu",
      children: device.editor.isMobile ? /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(Stack_default.Col, { className: "dropdown-menu-container", children }) : /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(
        Island,
        {
          className: "dropdown-menu-container",
          padding: 2,
          style: { zIndex: 2 },
          children
        }
      )
    }
  ) });
};
MenuContent.displayName = "DropdownMenuContent";
var DropdownMenuContent_default = MenuContent;

// components/dropdownMenu/DropdownMenuItemLink.tsx
init_define_import_meta_env();
var import_jsx_runtime43 = __toESM(require_jsx_runtime(), 1);
var DropdownMenuItemLink = ({
  icon,
  shortcut,
  href,
  children,
  onSelect,
  className = "",
  selected,
  ...rest
}) => {
  const handleClick = useHandleDropdownMenuItemClick(rest.onClick, onSelect);
  return /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(
    "a",
    {
      ...rest,
      href,
      target: "_blank",
      rel: "noreferrer",
      className: getDropdownMenuItemClassName(className, selected),
      title: rest.title ?? rest["aria-label"],
      onClick: handleClick,
      children: /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(DropdownMenuItemContent_default, { icon, shortcut, children })
    }
  );
};
var DropdownMenuItemLink_default = DropdownMenuItemLink;
DropdownMenuItemLink.displayName = "DropdownMenuItemLink";

// components/dropdownMenu/DropdownMenuItemCustom.tsx
init_define_import_meta_env();
var import_jsx_runtime44 = __toESM(require_jsx_runtime(), 1);
var DropdownMenuItemCustom = ({
  children,
  className = "",
  selected,
  ...rest
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime44.jsx)(
    "div",
    {
      ...rest,
      className: `dropdown-menu-item-base dropdown-menu-item-custom ${className} ${selected ? `dropdown-menu-item--selected` : ``}`.trim(),
      children
    }
  );
};
var DropdownMenuItemCustom_default = DropdownMenuItemCustom;

// components/dropdownMenu/dropdownMenuUtils.ts
init_define_import_meta_env();
var import_react46 = __toESM(require_react(), 1);
var getMenuTriggerComponent = (children) => {
  const comp = import_react46.default.Children.toArray(children).find(
    (child) => import_react46.default.isValidElement(child) && typeof child.type !== "string" && //@ts-ignore
    child?.type.displayName && //@ts-ignore
    child.type.displayName === "DropdownMenuTrigger"
  );
  if (!comp) {
    return null;
  }
  return comp;
};
var getMenuContentComponent = (children) => {
  const comp = import_react46.default.Children.toArray(children).find(
    (child) => import_react46.default.isValidElement(child) && typeof child.type !== "string" && //@ts-ignore
    child?.type.displayName && //@ts-ignore
    child.type.displayName === "DropdownMenuContent"
  );
  if (!comp) {
    return null;
  }
  return comp;
};

// components/dropdownMenu/DropdownMenu.tsx
var import_jsx_runtime45 = __toESM(require_jsx_runtime(), 1);
var DropdownMenu = ({
  children,
  open
}) => {
  const MenuTriggerComp = getMenuTriggerComponent(children);
  const MenuContentComp = getMenuContentComponent(children);
  return /* @__PURE__ */ (0, import_jsx_runtime45.jsxs)(import_jsx_runtime45.Fragment, { children: [
    MenuTriggerComp,
    open && MenuContentComp
  ] });
};
DropdownMenu.Trigger = DropdownMenuTrigger_default;
DropdownMenu.Content = DropdownMenuContent_default;
DropdownMenu.Item = DropdownMenuItem_default;
DropdownMenu.ItemLink = DropdownMenuItemLink_default;
DropdownMenu.ItemCustom = DropdownMenuItemCustom_default;
DropdownMenu.Group = DropdownMenuGroup_default;
DropdownMenu.Separator = DropdownMenuSeparator_default;
var DropdownMenu_default = DropdownMenu;
DropdownMenu.displayName = "DropdownMenu";

// context/tunnels.ts
init_define_import_meta_env();
var import_react49 = __toESM(require_react(), 1);

// ../../node_modules/tunnel-rat/dist/index.js
init_define_import_meta_env();
var import_react48 = __toESM(require_react());

// ../../node_modules/zustand/esm/index.mjs
init_define_import_meta_env();

// ../../node_modules/zustand/esm/vanilla.mjs
init_define_import_meta_env();
var createStoreImpl = (createState) => {
  let state;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial, replace) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state = (replace != null ? replace : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };
  const getState = () => state;
  const subscribe = (listener) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const destroy = () => {
    if ((define_import_meta_env_default ? define_import_meta_env_default.MODE : void 0) !== "production") {
      console.warn(
        "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
      );
    }
    listeners.clear();
  };
  const api = { setState, getState, subscribe, destroy };
  state = createState(setState, getState, api);
  return api;
};
var createStore2 = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;

// ../../node_modules/zustand/esm/index.mjs
var import_react47 = __toESM(require_react(), 1);
var import_with_selector = __toESM(require_with_selector(), 1);
var { useDebugValue: useDebugValue2 } = import_react47.default;
var { useSyncExternalStoreWithSelector } = import_with_selector.default;
var didWarnAboutEqualityFn = false;
function useStore(api, selector = api.getState, equalityFn) {
  if ((define_import_meta_env_default ? define_import_meta_env_default.MODE : void 0) !== "production" && equalityFn && !didWarnAboutEqualityFn) {
    console.warn(
      "[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"
    );
    didWarnAboutEqualityFn = true;
  }
  const slice = useSyncExternalStoreWithSelector(
    api.subscribe,
    api.getState,
    api.getServerState || api.getState,
    selector,
    equalityFn
  );
  useDebugValue2(slice);
  return slice;
}
var createImpl = (createState) => {
  if ((define_import_meta_env_default ? define_import_meta_env_default.MODE : void 0) !== "production" && typeof createState !== "function") {
    console.warn(
      "[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`."
    );
  }
  const api = typeof createState === "function" ? createStore2(createState) : createState;
  const useBoundStore = (selector, equalityFn) => useStore(api, selector, equalityFn);
  Object.assign(useBoundStore, api);
  return useBoundStore;
};
var create = (createState) => createState ? createImpl(createState) : createImpl;

// ../../node_modules/tunnel-rat/dist/index.js
var _window$document;
var _window$navigator;
var useIsomorphicLayoutEffect = typeof window !== "undefined" && ((_window$document = window.document) != null && _window$document.createElement || ((_window$navigator = window.navigator) == null ? void 0 : _window$navigator.product) === "ReactNative") ? import_react48.default.useLayoutEffect : import_react48.default.useEffect;
function tunnel() {
  const useStore2 = create((set) => ({
    current: new Array(),
    version: 0,
    set
  }));
  return {
    In: ({
      children
    }) => {
      const set = useStore2((state) => state.set);
      const version = useStore2((state) => state.version);
      useIsomorphicLayoutEffect(() => {
        set((state) => ({
          version: state.version + 1
        }));
      }, []);
      useIsomorphicLayoutEffect(() => {
        set(({
          current
        }) => ({
          current: [...current, children]
        }));
        return () => set(({
          current
        }) => ({
          current: current.filter((c3) => c3 !== children)
        }));
      }, [children, version]);
      return null;
    },
    Out: () => {
      const current = useStore2((state) => state.current);
      return /* @__PURE__ */ import_react48.default.createElement(import_react48.default.Fragment, null, current);
    }
  };
}

// context/tunnels.ts
var TunnelsContext = import_react49.default.createContext(null);
var useTunnels = () => import_react49.default.useContext(TunnelsContext);
var useInitializeTunnels = () => {
  return import_react49.default.useMemo(() => {
    return {
      MainMenuTunnel: tunnel(),
      WelcomeScreenMenuHintTunnel: tunnel(),
      WelcomeScreenToolbarHintTunnel: tunnel(),
      WelcomeScreenHelpHintTunnel: tunnel(),
      WelcomeScreenCenterTunnel: tunnel(),
      FooterCenterTunnel: tunnel(),
      DefaultSidebarTriggerTunnel: tunnel(),
      DefaultSidebarTabTriggersTunnel: tunnel(),
      OverwriteConfirmDialogTunnel: tunnel(),
      TTDDialogTriggerTunnel: tunnel(),
      jotaiScope: Symbol()
    };
  }, []);
};

// components/Actions.tsx
var import_jsx_runtime46 = __toESM(require_jsx_runtime(), 1);
var SelectedShapeActions = ({
  appState,
  elementsMap,
  renderAction
}) => {
  const targetElements = getTargetElements(elementsMap, appState);
  let isSingleElementBoundContainer = false;
  if (targetElements.length === 2 && (hasBoundTextElement(targetElements[0]) || hasBoundTextElement(targetElements[1]))) {
    isSingleElementBoundContainer = true;
  }
  const isEditing = Boolean(appState.editingElement);
  const device = useDevice();
  const isRTL2 = document.documentElement.getAttribute("dir") === "rtl";
  const showFillIcons = hasBackground(appState.activeTool.type) && !isTransparent(appState.currentItemBackgroundColor) || targetElements.some(
    (element) => hasBackground(element.type) && !isTransparent(element.backgroundColor)
  );
  const showChangeBackgroundIcons = hasBackground(appState.activeTool.type) || targetElements.some((element) => hasBackground(element.type));
  const showLinkIcon = targetElements.length === 1 || isSingleElementBoundContainer;
  let commonSelectedType = targetElements[0]?.type || null;
  for (const element of targetElements) {
    if (element.type !== commonSelectedType) {
      commonSelectedType = null;
      break;
    }
  }
  return /* @__PURE__ */ (0, import_jsx_runtime46.jsxs)("div", { className: "panelColumn", children: [
    /* @__PURE__ */ (0, import_jsx_runtime46.jsx)("div", { children: (hasStrokeColor(appState.activeTool.type) && appState.activeTool.type !== "image" && commonSelectedType !== "image" && commonSelectedType !== "frame" && commonSelectedType !== "magicframe" || targetElements.some((element) => hasStrokeColor(element.type))) && renderAction("changeStrokeColor") }),
    showChangeBackgroundIcons && /* @__PURE__ */ (0, import_jsx_runtime46.jsx)("div", { children: renderAction("changeBackgroundColor") }),
    showFillIcons && renderAction("changeFillStyle"),
    (hasStrokeWidth(appState.activeTool.type) || targetElements.some((element) => hasStrokeWidth(element.type))) && renderAction("changeStrokeWidth"),
    (appState.activeTool.type === "freedraw" || targetElements.some((element) => element.type === "freedraw")) && renderAction("changeStrokeShape"),
    (hasStrokeStyle(appState.activeTool.type) || targetElements.some((element) => hasStrokeStyle(element.type))) && /* @__PURE__ */ (0, import_jsx_runtime46.jsxs)(import_jsx_runtime46.Fragment, { children: [
      renderAction("changeStrokeStyle"),
      renderAction("changeSloppiness")
    ] }),
    (canChangeRoundness(appState.activeTool.type) || targetElements.some((element) => canChangeRoundness(element.type))) && /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(import_jsx_runtime46.Fragment, { children: renderAction("changeRoundness") }),
    (appState.activeTool.type === "text" || targetElements.some(isTextElement)) && /* @__PURE__ */ (0, import_jsx_runtime46.jsxs)(import_jsx_runtime46.Fragment, { children: [
      renderAction("changeFontSize"),
      renderAction("changeFontFamily"),
      (appState.activeTool.type === "text" || suppportsHorizontalAlign(targetElements, elementsMap)) && renderAction("changeTextAlign")
    ] }),
    shouldAllowVerticalAlign(targetElements, elementsMap) && renderAction("changeVerticalAlign"),
    (canHaveArrowheads(appState.activeTool.type) || targetElements.some((element) => canHaveArrowheads(element.type))) && /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(import_jsx_runtime46.Fragment, { children: renderAction("changeArrowhead") }),
    renderAction("changeOpacity"),
    /* @__PURE__ */ (0, import_jsx_runtime46.jsxs)("fieldset", { children: [
      /* @__PURE__ */ (0, import_jsx_runtime46.jsx)("legend", { children: t("labels.layers") }),
      /* @__PURE__ */ (0, import_jsx_runtime46.jsxs)("div", { className: "buttonList", children: [
        renderAction("sendToBack"),
        renderAction("sendBackward"),
        renderAction("bringToFront"),
        renderAction("bringForward")
      ] })
    ] }),
    targetElements.length > 1 && !isSingleElementBoundContainer && /* @__PURE__ */ (0, import_jsx_runtime46.jsxs)("fieldset", { children: [
      /* @__PURE__ */ (0, import_jsx_runtime46.jsx)("legend", { children: t("labels.align") }),
      /* @__PURE__ */ (0, import_jsx_runtime46.jsxs)("div", { className: "buttonList", children: [
        isRTL2 ? /* @__PURE__ */ (0, import_jsx_runtime46.jsxs)(import_jsx_runtime46.Fragment, { children: [
          renderAction("alignRight"),
          renderAction("alignHorizontallyCentered"),
          renderAction("alignLeft")
        ] }) : /* @__PURE__ */ (0, import_jsx_runtime46.jsxs)(import_jsx_runtime46.Fragment, { children: [
          renderAction("alignLeft"),
          renderAction("alignHorizontallyCentered"),
          renderAction("alignRight")
        ] }),
        targetElements.length > 2 && renderAction("distributeHorizontally"),
        /* @__PURE__ */ (0, import_jsx_runtime46.jsx)("div", { style: { flexBasis: "100%", height: 0 } }),
        /* @__PURE__ */ (0, import_jsx_runtime46.jsxs)(
          "div",
          {
            style: {
              display: "flex",
              flexWrap: "wrap",
              gap: ".5rem",
              marginTop: "-0.5rem"
            },
            children: [
              renderAction("alignTop"),
              renderAction("alignVerticallyCentered"),
              renderAction("alignBottom"),
              targetElements.length > 2 && renderAction("distributeVertically")
            ]
          }
        )
      ] })
    ] }),
    !isEditing && targetElements.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime46.jsxs)("fieldset", { children: [
      /* @__PURE__ */ (0, import_jsx_runtime46.jsx)("legend", { children: t("labels.actions") }),
      /* @__PURE__ */ (0, import_jsx_runtime46.jsxs)("div", { className: "buttonList", children: [
        !device.editor.isMobile && renderAction("duplicateSelection"),
        !device.editor.isMobile && renderAction("deleteSelectedElements"),
        renderAction("group"),
        renderAction("ungroup"),
        showLinkIcon && renderAction("hyperlink")
      ] })
    ] })
  ] });
};
var ShapesSwitcher = ({
  activeTool,
  appState,
  app,
  UIOptions
}) => {
  const [isExtraToolsMenuOpen, setIsExtraToolsMenuOpen] = (0, import_react50.useState)(false);
  const frameToolSelected = activeTool.type === "frame";
  const laserToolSelected = activeTool.type === "laser";
  const embeddableToolSelected = activeTool.type === "embeddable";
  const { TTDDialogTriggerTunnel } = useTunnels();
  return /* @__PURE__ */ (0, import_jsx_runtime46.jsxs)(import_jsx_runtime46.Fragment, { children: [
    SHAPES.map(({ value, icon, key, numericKey, fillable }, index2) => {
      if (UIOptions.tools?.[value] === false) {
        return null;
      }
      const label = t(`toolBar.${value}`);
      const letter = key && capitalizeString(typeof key === "string" ? key : key[0]);
      const shortcut = letter ? `${letter} ${t("helpDialog.or")} ${numericKey}` : `${numericKey}`;
      return /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(
        ToolButton,
        {
          className: clsx_m_default("Shape", { fillable }),
          type: "radio",
          icon,
          checked: activeTool.type === value,
          name: "editor-current-shape",
          title: `${capitalizeString(label)} \u2014 ${shortcut}`,
          keyBindingLabel: numericKey || letter,
          "aria-label": capitalizeString(label),
          "aria-keyshortcuts": shortcut,
          "data-testid": `toolbar-${value}`,
          onPointerDown: ({ pointerType }) => {
            if (!appState.penDetected && pointerType === "pen") {
              app.togglePenMode(true);
            }
          },
          onChange: ({ pointerType }) => {
            if (appState.activeTool.type !== value) {
              trackEvent("toolbar", value, "ui");
            }
            if (value === "image") {
              app.setActiveTool({
                type: value,
                insertOnCanvasDirectly: pointerType !== "mouse"
              });
            } else {
              app.setActiveTool({ type: value });
            }
          }
        },
        value
      );
    }),
    /* @__PURE__ */ (0, import_jsx_runtime46.jsx)("div", { className: "App-toolbar__divider" }),
    /* @__PURE__ */ (0, import_jsx_runtime46.jsxs)(DropdownMenu_default, { open: isExtraToolsMenuOpen, children: [
      /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(
        DropdownMenu_default.Trigger,
        {
          className: clsx_m_default("App-toolbar__extra-tools-trigger", {
            "App-toolbar__extra-tools-trigger--selected": frameToolSelected || embeddableToolSelected || // in collab we're already highlighting the laser button
            // outside toolbar, so let's not highlight extra-tools button
            // on top of it
            laserToolSelected && !app.props.isCollaborating
          }),
          onToggle: () => setIsExtraToolsMenuOpen(!isExtraToolsMenuOpen),
          title: t("toolBar.extraTools"),
          children: extraToolsIcon
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime46.jsxs)(
        DropdownMenu_default.Content,
        {
          onClickOutside: () => setIsExtraToolsMenuOpen(false),
          onSelect: () => setIsExtraToolsMenuOpen(false),
          className: "App-toolbar__extra-tools-dropdown",
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(
              DropdownMenu_default.Item,
              {
                onSelect: () => app.setActiveTool({ type: "frame" }),
                icon: frameToolIcon,
                shortcut: KEYS.F.toLocaleUpperCase(),
                "data-testid": "toolbar-frame",
                selected: frameToolSelected,
                children: t("toolBar.frame")
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(
              DropdownMenu_default.Item,
              {
                onSelect: () => app.setActiveTool({ type: "embeddable" }),
                icon: EmbedIcon,
                "data-testid": "toolbar-embeddable",
                selected: embeddableToolSelected,
                children: t("toolBar.embeddable")
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(
              DropdownMenu_default.Item,
              {
                onSelect: () => app.setActiveTool({ type: "laser" }),
                icon: laserPointerToolIcon,
                "data-testid": "toolbar-laser",
                selected: laserToolSelected,
                shortcut: KEYS.K.toLocaleUpperCase(),
                children: t("toolBar.laser")
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime46.jsx)("div", { style: { margin: "6px 0", fontSize: 14, fontWeight: 600 }, children: "Generate" }),
            app.props.aiEnabled !== false && /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(TTDDialogTriggerTunnel.Out, {}),
            /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(
              DropdownMenu_default.Item,
              {
                onSelect: () => app.setOpenDialog({ name: "ttd", tab: "mermaid" }),
                icon: mermaidLogoIcon,
                "data-testid": "toolbar-embeddable",
                children: t("toolBar.mermaidToExcalidraw")
              }
            ),
            app.props.aiEnabled !== false && /* @__PURE__ */ (0, import_jsx_runtime46.jsxs)(import_jsx_runtime46.Fragment, { children: [
              /* @__PURE__ */ (0, import_jsx_runtime46.jsxs)(
                DropdownMenu_default.Item,
                {
                  onSelect: () => app.onMagicframeToolSelect(),
                  icon: MagicIcon,
                  "data-testid": "toolbar-magicframe",
                  children: [
                    t("toolBar.magicframe"),
                    /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(DropdownMenu_default.Item.Badge, { children: "AI" })
                  ]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(
                DropdownMenu_default.Item,
                {
                  onSelect: () => {
                    trackEvent("ai", "open-settings", "d2c");
                    app.setOpenDialog({
                      name: "settings",
                      source: "settings",
                      tab: "diagram-to-code"
                    });
                  },
                  icon: OpenAIIcon,
                  "data-testid": "toolbar-magicSettings",
                  children: t("toolBar.magicSettings")
                }
              )
            ] })
          ]
        }
      )
    ] })
  ] });
};
var ZoomActions = ({
  renderAction,
  zoom
}) => /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(Stack_default.Col, { gap: 1, className: "zoom-actions", children: /* @__PURE__ */ (0, import_jsx_runtime46.jsxs)(Stack_default.Row, { align: "center", children: [
  renderAction("zoomOut"),
  renderAction("resetZoom"),
  renderAction("zoomIn")
] }) });
var UndoRedoActions = ({
  renderAction,
  className
}) => /* @__PURE__ */ (0, import_jsx_runtime46.jsxs)("div", { className: `undo-redo-buttons ${className}`, children: [
  /* @__PURE__ */ (0, import_jsx_runtime46.jsx)("div", { className: "undo-button-container", children: /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(Tooltip, { label: t("buttons.undo"), children: renderAction("undo") }) }),
  /* @__PURE__ */ (0, import_jsx_runtime46.jsx)("div", { className: "redo-button-container", children: /* @__PURE__ */ (0, import_jsx_runtime46.jsxs)(Tooltip, { label: t("buttons.redo"), children: [
    " ",
    renderAction("redo")
  ] }) })
] });
var ExitZenModeAction = ({
  actionManager,
  showExitZenModeBtn
}) => /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(
  "button",
  {
    className: clsx_m_default("disable-zen-mode", {
      "disable-zen-mode--visible": showExitZenModeBtn
    }),
    onClick: () => actionManager.executeAction(actionToggleZenMode),
    children: t("buttons.exitZenMode")
  }
);
var FinalizeAction = ({
  renderAction,
  className
}) => /* @__PURE__ */ (0, import_jsx_runtime46.jsx)("div", { className: `finalize-button ${className}`, children: renderAction("finalize", { size: "small" }) });

// components/ErrorDialog.tsx
init_define_import_meta_env();
var import_react63 = __toESM(require_react(), 1);

// components/Dialog.tsx
init_define_import_meta_env();
var import_react62 = __toESM(require_react(), 1);

// hooks/useCallbackRefState.ts
init_define_import_meta_env();
var import_react51 = __toESM(require_react(), 1);
var useCallbackRefState = () => {
  const [refValue, setRefValue] = (0, import_react51.useState)(null);
  const refCallback = (0, import_react51.useCallback)((value) => setRefValue(value), []);
  return [refValue, refCallback];
};

// components/Modal.tsx
init_define_import_meta_env();
var import_react_dom7 = __toESM(require_react_dom(), 1);
var import_jsx_runtime47 = __toESM(require_jsx_runtime(), 1);
var Modal = (props) => {
  const { closeOnClickOutside = true } = props;
  const modalRoot = useCreatePortalContainer({
    className: "excalidraw-modal-container"
  });
  if (!modalRoot) {
    return null;
  }
  const handleKeydown = (event) => {
    if (event.key === KEYS.ESCAPE) {
      event.nativeEvent.stopImmediatePropagation();
      event.stopPropagation();
      props.onCloseRequest();
    }
  };
  return (0, import_react_dom7.createPortal)(
    /* @__PURE__ */ (0, import_jsx_runtime47.jsxs)(
      "div",
      {
        className: clsx_m_default("Modal", props.className),
        role: "dialog",
        "aria-modal": "true",
        onKeyDown: handleKeydown,
        "aria-labelledby": props.labelledBy,
        "data-prevent-outside-click": true,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime47.jsx)(
            "div",
            {
              className: "Modal__background",
              onClick: closeOnClickOutside ? props.onCloseRequest : void 0
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime47.jsx)(
            "div",
            {
              className: "Modal__content",
              style: { "--max-width": `${props.maxWidth}px` },
              tabIndex: 0,
              children: props.children
            }
          )
        ]
      }
    ),
    modalRoot
  );
};

// components/LibraryMenu.tsx
init_define_import_meta_env();
var import_react61 = __toESM(require_react(), 1);

// components/LibraryMenuItems.tsx
init_define_import_meta_env();
var import_react60 = __toESM(require_react(), 1);

// components/Spinner.tsx
init_define_import_meta_env();
var import_react52 = __toESM(require_react(), 1);
var import_jsx_runtime48 = __toESM(require_jsx_runtime(), 1);
var Spinner = ({
  size = "1em",
  circleWidth = 8,
  synchronized = false
}) => {
  const mountTime = import_react52.default.useRef(Date.now());
  const mountDelay = -(mountTime.current % 1600);
  return /* @__PURE__ */ (0, import_jsx_runtime48.jsx)("div", { className: "Spinner", children: /* @__PURE__ */ (0, import_jsx_runtime48.jsx)(
    "svg",
    {
      viewBox: "0 0 100 100",
      style: {
        width: size,
        height: size,
        // fix for remounting causing spinner flicker
        ["--spinner-delay"]: synchronized ? `${mountDelay}ms` : 0
      },
      children: /* @__PURE__ */ (0, import_jsx_runtime48.jsx)(
        "circle",
        {
          cx: "50",
          cy: "50",
          r: 50 - circleWidth / 2,
          strokeWidth: circleWidth,
          fill: "none",
          strokeMiterlimit: "10"
        }
      )
    }
  ) });
};
var Spinner_default = Spinner;

// components/LibraryMenuControlButtons.tsx
init_define_import_meta_env();

// components/LibraryMenuBrowseButton.tsx
init_define_import_meta_env();
var import_jsx_runtime49 = __toESM(require_jsx_runtime(), 1);
var LibraryMenuBrowseButton = ({
  theme,
  id,
  libraryReturnUrl
}) => {
  const referrer = libraryReturnUrl || window.location.origin + window.location.pathname;
  return /* @__PURE__ */ (0, import_jsx_runtime49.jsx)(
    "a",
    {
      className: "library-menu-browse-button",
      href: `${define_import_meta_env_default.VITE_APP_LIBRARY_URL}?target=${window.name || "_blank"}&referrer=${referrer}&useHash=true&token=${id}&theme=${theme}&version=${VERSIONS.excalidrawLibrary}`,
      target: "_excalidraw_libraries",
      children: t("labels.libraries")
    }
  );
};
var LibraryMenuBrowseButton_default = LibraryMenuBrowseButton;

// components/LibraryMenuControlButtons.tsx
var import_jsx_runtime50 = __toESM(require_jsx_runtime(), 1);
var LibraryMenuControlButtons = ({
  libraryReturnUrl,
  theme,
  id,
  style,
  children,
  className
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime50.jsxs)(
    "div",
    {
      className: clsx_m_default("library-menu-control-buttons", className),
      style,
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime50.jsx)(
          LibraryMenuBrowseButton_default,
          {
            id,
            libraryReturnUrl,
            theme
          }
        ),
        children
      ]
    }
  );
};

// components/LibraryMenuHeaderContent.tsx
init_define_import_meta_env();
var import_react55 = __toESM(require_react(), 1);

// components/Trans.tsx
init_define_import_meta_env();
var import_react53 = __toESM(require_react(), 1);
var SPLIT_REGEX = /({{[\w-]+}})|(<[\w-]+>)|(<\/[\w-]+>)/g;
var KEY_REGEXP = /{{([\w-]+)}}/;
var TAG_START_REGEXP = /<([\w-]+)>/;
var TAG_END_REGEXP = /<\/([\w-]+)>/;
var getTransChildren = (format, props) => {
  const stack = [
    {
      name: "",
      children: []
    }
  ];
  format.split(SPLIT_REGEX).filter(Boolean).forEach((match) => {
    const tagStartMatch = match.match(TAG_START_REGEXP);
    const tagEndMatch = match.match(TAG_END_REGEXP);
    const keyMatch = match.match(KEY_REGEXP);
    if (tagStartMatch !== null) {
      const name = tagStartMatch[1];
      if (props.hasOwnProperty(name)) {
        stack.push({
          name,
          children: []
        });
      } else {
        console.warn(
          `Trans: missed to pass in prop ${name} for interpolating ${format}`
        );
      }
    } else if (tagEndMatch !== null) {
      const name = tagEndMatch[1];
      if (name === stack[stack.length - 1].name) {
        const item = stack.pop();
        const itemChildren = import_react53.default.createElement(
          import_react53.default.Fragment,
          {},
          ...item.children
        );
        const fn = props[item.name];
        if (typeof fn === "function") {
          stack[stack.length - 1].children.push(fn(itemChildren));
        }
      } else {
        console.warn(
          `Trans: unexpected end tag ${match} for interpolating ${format}`
        );
      }
    } else if (keyMatch !== null) {
      const name = keyMatch[1];
      if (props.hasOwnProperty(name)) {
        stack[stack.length - 1].children.push(props[name]);
      } else {
        console.warn(
          `Trans: key ${name} not in props for interpolating ${format}`
        );
      }
    } else {
      stack[stack.length - 1].children.push(match);
    }
  });
  if (stack.length !== 1) {
    console.warn(`Trans: stack not empty for interpolating ${format}`);
  }
  return stack[0].children;
};
var Trans = ({
  i18nKey,
  children,
  ...props
}) => {
  const { t: t4 } = useI18n();
  return import_react53.default.createElement(
    import_react53.default.Fragment,
    {},
    ...getTransChildren(t4(i18nKey), props)
  );
};
var Trans_default = Trans;

// components/ConfirmDialog.tsx
init_define_import_meta_env();

// components/DialogActionButton.tsx
init_define_import_meta_env();
var import_jsx_runtime51 = __toESM(require_jsx_runtime(), 1);
var DialogActionButton = ({
  label,
  onClick,
  className,
  children,
  actionType,
  type = "button",
  isLoading,
  ...rest
}) => {
  const cs = actionType ? `Dialog__action-button--${actionType}` : "";
  return /* @__PURE__ */ (0, import_jsx_runtime51.jsxs)(
    "button",
    {
      className: clsx_m_default("Dialog__action-button", cs, className),
      type,
      "aria-label": label,
      onClick,
      ...rest,
      children: [
        children && /* @__PURE__ */ (0, import_jsx_runtime51.jsx)("div", { style: isLoading ? { visibility: "hidden" } : {}, children }),
        /* @__PURE__ */ (0, import_jsx_runtime51.jsx)("div", { style: isLoading ? { visibility: "hidden" } : {}, children: label }),
        isLoading && /* @__PURE__ */ (0, import_jsx_runtime51.jsx)("div", { style: { position: "absolute", inset: 0 }, children: /* @__PURE__ */ (0, import_jsx_runtime51.jsx)(Spinner_default, {}) })
      ]
    }
  );
};
var DialogActionButton_default = DialogActionButton;

// components/ConfirmDialog.tsx
var import_jsx_runtime52 = __toESM(require_jsx_runtime(), 1);
var ConfirmDialog = (props) => {
  const {
    onConfirm,
    onCancel,
    children,
    confirmText = t("buttons.confirm"),
    cancelText = t("buttons.cancel"),
    className = "",
    ...rest
  } = props;
  const setAppState = useExcalidrawSetAppState();
  const setIsLibraryMenuOpen = useSetAtom(isLibraryMenuOpenAtom, jotaiScope);
  const { container } = useExcalidrawContainer();
  return /* @__PURE__ */ (0, import_jsx_runtime52.jsxs)(
    Dialog,
    {
      onCloseRequest: onCancel,
      size: "small",
      ...rest,
      className: `confirm-dialog ${className}`,
      children: [
        children,
        /* @__PURE__ */ (0, import_jsx_runtime52.jsxs)("div", { className: "confirm-dialog-buttons", children: [
          /* @__PURE__ */ (0, import_jsx_runtime52.jsx)(
            DialogActionButton_default,
            {
              label: cancelText,
              onClick: () => {
                setAppState({ openMenu: null });
                setIsLibraryMenuOpen(false);
                onCancel();
                container?.focus();
              }
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime52.jsx)(
            DialogActionButton_default,
            {
              label: confirmText,
              onClick: () => {
                setAppState({ openMenu: null });
                setIsLibraryMenuOpen(false);
                onConfirm();
                container?.focus();
              },
              actionType: "danger"
            }
          )
        ] })
      ]
    }
  );
};
var ConfirmDialog_default = ConfirmDialog;

// components/PublishLibrary.tsx
init_define_import_meta_env();
var import_react54 = __toESM(require_react(), 1);

// data/EditorLocalStorage.ts
init_define_import_meta_env();
var EditorLocalStorage = class {
  static has(key) {
    try {
      return !!window.localStorage.getItem(key);
    } catch (error) {
      console.warn(`localStorage.getItem error: ${error.message}`);
      return false;
    }
  }
  static get(key) {
    try {
      const value = window.localStorage.getItem(key);
      if (value) {
        return JSON.parse(value);
      }
      return null;
    } catch (error) {
      console.warn(`localStorage.getItem error: ${error.message}`);
      return null;
    }
  }
  static set = (key, value) => {
    try {
      window.localStorage.setItem(key, JSON.stringify(value));
      return true;
    } catch (error) {
      console.warn(`localStorage.setItem error: ${error.message}`);
      return false;
    }
  };
  static delete = (name) => {
    try {
      window.localStorage.removeItem(name);
    } catch (error) {
      console.warn(`localStorage.removeItem error: ${error.message}`);
    }
  };
};

// components/PublishLibrary.tsx
var import_jsx_runtime53 = __toESM(require_jsx_runtime(), 1);
var generatePreviewImage = async (libraryItems) => {
  const MAX_ITEMS_PER_ROW = 6;
  const BOX_SIZE = 128;
  const BOX_PADDING = Math.round(BOX_SIZE / 16);
  const BORDER_WIDTH = Math.max(Math.round(BOX_SIZE / 64), 2);
  const rows = chunk(libraryItems, MAX_ITEMS_PER_ROW);
  const canvas2 = document.createElement("canvas");
  canvas2.width = rows[0].length * BOX_SIZE + (rows[0].length + 1) * (BOX_PADDING * 2) - BOX_PADDING * 2;
  canvas2.height = rows.length * BOX_SIZE + (rows.length + 1) * (BOX_PADDING * 2) - BOX_PADDING * 2;
  const ctx = canvas2.getContext("2d");
  ctx.fillStyle = open_color_default.white;
  ctx.fillRect(0, 0, canvas2.width, canvas2.height);
  for (const [index2, item] of libraryItems.entries()) {
    const itemCanvas = await exportToCanvas2({
      elements: item.elements,
      files: null,
      maxWidthOrHeight: BOX_SIZE
    });
    const { width, height } = itemCanvas;
    const rowOffset = Math.floor(index2 / MAX_ITEMS_PER_ROW) * (BOX_SIZE + BOX_PADDING * 2);
    const colOffset = index2 % MAX_ITEMS_PER_ROW * (BOX_SIZE + BOX_PADDING * 2);
    ctx.drawImage(
      itemCanvas,
      colOffset + (BOX_SIZE - width) / 2 + BOX_PADDING,
      rowOffset + (BOX_SIZE - height) / 2 + BOX_PADDING
    );
    ctx.lineWidth = BORDER_WIDTH;
    ctx.strokeStyle = open_color_default.gray[4];
    ctx.strokeRect(
      colOffset + BOX_PADDING / 2,
      rowOffset + BOX_PADDING / 2,
      BOX_SIZE + BOX_PADDING,
      BOX_SIZE + BOX_PADDING
    );
  }
  return await resizeImageFile(
    new File([await canvasToBlob(canvas2)], "preview", { type: MIME_TYPES.png }),
    {
      outputType: MIME_TYPES.jpg,
      maxWidthOrHeight: 5e3
    }
  );
};
var SingleLibraryItem = ({
  libItem,
  appState,
  index: index2,
  onChange,
  onRemove
}) => {
  const svgRef = (0, import_react54.useRef)(null);
  const inputRef = (0, import_react54.useRef)(null);
  (0, import_react54.useEffect)(() => {
    const node = svgRef.current;
    if (!node) {
      return;
    }
    (async () => {
      const svg = await exportToSvg2({
        elements: libItem.elements,
        appState: {
          ...appState,
          viewBackgroundColor: open_color_default.white,
          exportBackground: true
        },
        files: null
      });
      node.innerHTML = svg.outerHTML;
    })();
  }, [libItem.elements, appState]);
  return /* @__PURE__ */ (0, import_jsx_runtime53.jsxs)("div", { className: "single-library-item", children: [
    libItem.status === "published" && /* @__PURE__ */ (0, import_jsx_runtime53.jsx)("span", { className: "single-library-item-status", children: t("labels.statusPublished") }),
    /* @__PURE__ */ (0, import_jsx_runtime53.jsx)("div", { ref: svgRef, className: "single-library-item__svg" }),
    /* @__PURE__ */ (0, import_jsx_runtime53.jsx)(
      ToolButton,
      {
        "aria-label": t("buttons.remove"),
        type: "button",
        icon: CloseIcon,
        className: "single-library-item--remove",
        onClick: onRemove.bind(null, libItem.id),
        title: t("buttons.remove")
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime53.jsxs)(
      "div",
      {
        style: {
          display: "flex",
          margin: "0.8rem 0",
          width: "100%",
          fontSize: "14px",
          fontWeight: 500,
          flexDirection: "column"
        },
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime53.jsxs)(
            "label",
            {
              style: {
                display: "flex",
                justifyContent: "space-between",
                flexDirection: "column"
              },
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime53.jsxs)("div", { style: { padding: "0.5em 0" }, children: [
                  /* @__PURE__ */ (0, import_jsx_runtime53.jsx)("span", { style: { fontWeight: 500, color: open_color_default.gray[6] }, children: t("publishDialog.itemName") }),
                  /* @__PURE__ */ (0, import_jsx_runtime53.jsx)("span", { "aria-hidden": "true", className: "required", children: "*" })
                ] }),
                /* @__PURE__ */ (0, import_jsx_runtime53.jsx)(
                  "input",
                  {
                    type: "text",
                    ref: inputRef,
                    style: { width: "80%", padding: "0.2rem" },
                    defaultValue: libItem.name,
                    placeholder: "Item name",
                    onChange: (event) => {
                      onChange(event.target.value, index2);
                    }
                  }
                )
              ]
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime53.jsx)("span", { className: "error", children: libItem.error })
        ]
      }
    )
  ] });
};
var PublishLibrary = ({
  onClose,
  libraryItems,
  appState,
  onSuccess,
  onError,
  updateItemsInStorage,
  onRemove
}) => {
  const [libraryData, setLibraryData] = (0, import_react54.useState)({
    authorName: "",
    githubHandle: "",
    name: "",
    description: "",
    twitterHandle: "",
    website: ""
  });
  const [isSubmitting, setIsSubmitting] = (0, import_react54.useState)(false);
  (0, import_react54.useEffect)(() => {
    const data = EditorLocalStorage.get(
      EDITOR_LS_KEYS.PUBLISH_LIBRARY
    );
    if (data) {
      setLibraryData(data);
    }
  }, []);
  const [clonedLibItems, setClonedLibItems] = (0, import_react54.useState)(
    libraryItems.slice()
  );
  (0, import_react54.useEffect)(() => {
    setClonedLibItems(libraryItems.slice());
  }, [libraryItems]);
  const onInputChange = (event) => {
    setLibraryData({
      ...libraryData,
      [event.target.name]: event.target.value
    });
  };
  const onSubmit = async (event) => {
    event.preventDefault();
    setIsSubmitting(true);
    const erroredLibItems = [];
    let isError = false;
    clonedLibItems.forEach((libItem) => {
      let error = "";
      if (!libItem.name) {
        error = t("publishDialog.errors.required");
        isError = true;
      }
      erroredLibItems.push({ ...libItem, error });
    });
    if (isError) {
      setClonedLibItems(erroredLibItems);
      setIsSubmitting(false);
      return;
    }
    const previewImage = await generatePreviewImage(clonedLibItems);
    const libContent = {
      type: EXPORT_DATA_TYPES.excalidrawLibrary,
      version: VERSIONS.excalidrawLibrary,
      source: EXPORT_SOURCE,
      libraryItems: clonedLibItems
    };
    const content = JSON.stringify(libContent, null, 2);
    const lib = new Blob([content], { type: "application/json" });
    const formData = new FormData();
    formData.append("excalidrawLib", lib);
    formData.append("previewImage", previewImage);
    formData.append("previewImageType", previewImage.type);
    formData.append("title", libraryData.name);
    formData.append("authorName", libraryData.authorName);
    formData.append("githubHandle", libraryData.githubHandle);
    formData.append("name", libraryData.name);
    formData.append("description", libraryData.description);
    formData.append("twitterHandle", libraryData.twitterHandle);
    formData.append("website", libraryData.website);
    fetch(`${define_import_meta_env_default.VITE_APP_LIBRARY_BACKEND}/submit`, {
      method: "post",
      body: formData
    }).then(
      (response) => {
        if (response.ok) {
          return response.json().then(({ url }) => {
            EditorLocalStorage.delete(EDITOR_LS_KEYS.PUBLISH_LIBRARY);
            onSuccess({
              url,
              authorName: libraryData.authorName,
              items: clonedLibItems
            });
          });
        }
        return response.json().catch(() => {
          throw new Error(response.statusText || "something went wrong");
        }).then((error) => {
          throw new Error(
            error.message || response.statusText || "something went wrong"
          );
        });
      },
      (err) => {
        console.error(err);
        onError(err);
        setIsSubmitting(false);
      }
    ).catch((err) => {
      console.error(err);
      onError(err);
      setIsSubmitting(false);
    });
  };
  const renderLibraryItems = () => {
    const items = [];
    clonedLibItems.forEach((libItem, index2) => {
      items.push(
        /* @__PURE__ */ (0, import_jsx_runtime53.jsx)("div", { className: "single-library-item-wrapper", children: /* @__PURE__ */ (0, import_jsx_runtime53.jsx)(
          SingleLibraryItem,
          {
            libItem,
            appState,
            index: index2,
            onChange: (val, index3) => {
              const items2 = clonedLibItems.slice();
              items2[index3].name = val;
              setClonedLibItems(items2);
            },
            onRemove
          }
        ) }, index2)
      );
    });
    return /* @__PURE__ */ (0, import_jsx_runtime53.jsx)("div", { className: "selected-library-items", children: items });
  };
  const onDialogClose = (0, import_react54.useCallback)(() => {
    updateItemsInStorage(clonedLibItems);
    EditorLocalStorage.set(EDITOR_LS_KEYS.PUBLISH_LIBRARY, libraryData);
    onClose();
  }, [clonedLibItems, onClose, updateItemsInStorage, libraryData]);
  const shouldRenderForm = !!libraryItems.length;
  const containsPublishedItems = libraryItems.some(
    (item) => item.status === "published"
  );
  return /* @__PURE__ */ (0, import_jsx_runtime53.jsx)(
    Dialog,
    {
      onCloseRequest: onDialogClose,
      title: t("publishDialog.title"),
      className: "publish-library",
      children: shouldRenderForm ? /* @__PURE__ */ (0, import_jsx_runtime53.jsxs)("form", { onSubmit, children: [
        /* @__PURE__ */ (0, import_jsx_runtime53.jsx)("div", { className: "publish-library-note", children: /* @__PURE__ */ (0, import_jsx_runtime53.jsx)(
          Trans_default,
          {
            i18nKey: "publishDialog.noteDescription",
            link: (el) => /* @__PURE__ */ (0, import_jsx_runtime53.jsx)(
              "a",
              {
                href: "https://libraries.excalidraw.com",
                target: "_blank",
                rel: "noopener noreferrer",
                children: el
              }
            )
          }
        ) }),
        /* @__PURE__ */ (0, import_jsx_runtime53.jsx)("span", { className: "publish-library-note", children: /* @__PURE__ */ (0, import_jsx_runtime53.jsx)(
          Trans_default,
          {
            i18nKey: "publishDialog.noteGuidelines",
            link: (el) => /* @__PURE__ */ (0, import_jsx_runtime53.jsx)(
              "a",
              {
                href: "https://github.com/excalidraw/excalidraw-libraries#guidelines",
                target: "_blank",
                rel: "noopener noreferrer",
                children: el
              }
            )
          }
        ) }),
        /* @__PURE__ */ (0, import_jsx_runtime53.jsx)("div", { className: "publish-library-note", children: t("publishDialog.noteItems") }),
        containsPublishedItems && /* @__PURE__ */ (0, import_jsx_runtime53.jsx)("span", { className: "publish-library-note publish-library-warning", children: t("publishDialog.republishWarning") }),
        renderLibraryItems(),
        /* @__PURE__ */ (0, import_jsx_runtime53.jsxs)("div", { className: "publish-library__fields", children: [
          /* @__PURE__ */ (0, import_jsx_runtime53.jsxs)("label", { children: [
            /* @__PURE__ */ (0, import_jsx_runtime53.jsxs)("div", { children: [
              /* @__PURE__ */ (0, import_jsx_runtime53.jsx)("span", { children: t("publishDialog.libraryName") }),
              /* @__PURE__ */ (0, import_jsx_runtime53.jsx)("span", { "aria-hidden": "true", className: "required", children: "*" })
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime53.jsx)(
              "input",
              {
                type: "text",
                name: "name",
                required: true,
                value: libraryData.name,
                onChange: onInputChange,
                placeholder: t("publishDialog.placeholder.libraryName")
              }
            )
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime53.jsxs)("label", { style: { alignItems: "flex-start" }, children: [
            /* @__PURE__ */ (0, import_jsx_runtime53.jsxs)("div", { children: [
              /* @__PURE__ */ (0, import_jsx_runtime53.jsx)("span", { children: t("publishDialog.libraryDesc") }),
              /* @__PURE__ */ (0, import_jsx_runtime53.jsx)("span", { "aria-hidden": "true", className: "required", children: "*" })
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime53.jsx)(
              "textarea",
              {
                name: "description",
                rows: 4,
                required: true,
                value: libraryData.description,
                onChange: onInputChange,
                placeholder: t("publishDialog.placeholder.libraryDesc")
              }
            )
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime53.jsxs)("label", { children: [
            /* @__PURE__ */ (0, import_jsx_runtime53.jsxs)("div", { children: [
              /* @__PURE__ */ (0, import_jsx_runtime53.jsx)("span", { children: t("publishDialog.authorName") }),
              /* @__PURE__ */ (0, import_jsx_runtime53.jsx)("span", { "aria-hidden": "true", className: "required", children: "*" })
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime53.jsx)(
              "input",
              {
                type: "text",
                name: "authorName",
                required: true,
                value: libraryData.authorName,
                onChange: onInputChange,
                placeholder: t("publishDialog.placeholder.authorName")
              }
            )
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime53.jsxs)("label", { children: [
            /* @__PURE__ */ (0, import_jsx_runtime53.jsx)("span", { children: t("publishDialog.githubUsername") }),
            /* @__PURE__ */ (0, import_jsx_runtime53.jsx)(
              "input",
              {
                type: "text",
                name: "githubHandle",
                value: libraryData.githubHandle,
                onChange: onInputChange,
                placeholder: t("publishDialog.placeholder.githubHandle")
              }
            )
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime53.jsxs)("label", { children: [
            /* @__PURE__ */ (0, import_jsx_runtime53.jsx)("span", { children: t("publishDialog.twitterUsername") }),
            /* @__PURE__ */ (0, import_jsx_runtime53.jsx)(
              "input",
              {
                type: "text",
                name: "twitterHandle",
                value: libraryData.twitterHandle,
                onChange: onInputChange,
                placeholder: t("publishDialog.placeholder.twitterHandle")
              }
            )
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime53.jsxs)("label", { children: [
            /* @__PURE__ */ (0, import_jsx_runtime53.jsx)("span", { children: t("publishDialog.website") }),
            /* @__PURE__ */ (0, import_jsx_runtime53.jsx)(
              "input",
              {
                type: "text",
                name: "website",
                pattern: "https?://.+",
                title: t("publishDialog.errors.website"),
                value: libraryData.website,
                onChange: onInputChange,
                placeholder: t("publishDialog.placeholder.website")
              }
            )
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime53.jsx)("span", { className: "publish-library-note", children: /* @__PURE__ */ (0, import_jsx_runtime53.jsx)(
            Trans_default,
            {
              i18nKey: "publishDialog.noteLicense",
              link: (el) => /* @__PURE__ */ (0, import_jsx_runtime53.jsx)(
                "a",
                {
                  href: "https://github.com/excalidraw/excalidraw-libraries/blob/main/LICENSE",
                  target: "_blank",
                  rel: "noopener noreferrer",
                  children: el
                }
              )
            }
          ) })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime53.jsxs)("div", { className: "publish-library__buttons", children: [
          /* @__PURE__ */ (0, import_jsx_runtime53.jsx)(
            DialogActionButton_default,
            {
              label: t("buttons.cancel"),
              onClick: onDialogClose,
              "data-testid": "cancel-clear-canvas-button"
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime53.jsx)(
            DialogActionButton_default,
            {
              type: "submit",
              label: t("buttons.submit"),
              actionType: "primary",
              isLoading: isSubmitting
            }
          )
        ] })
      ] }) : /* @__PURE__ */ (0, import_jsx_runtime53.jsx)("p", { style: { padding: "1em", textAlign: "center", fontWeight: 500 }, children: t("publishDialog.atleastOneLibItem") })
    }
  );
};
var PublishLibrary_default = PublishLibrary;

// components/LibraryMenuHeaderContent.tsx
var import_jsx_runtime54 = __toESM(require_jsx_runtime(), 1);
var getSelectedItems = (libraryItems, selectedItems) => libraryItems.filter((item) => selectedItems.includes(item.id));
var LibraryDropdownMenuButton = ({
  setAppState,
  selectedItems,
  library,
  onRemoveFromLibrary,
  resetLibrary,
  onSelectItems,
  appState,
  className
}) => {
  const [libraryItemsData] = useAtom(libraryItemsAtom, jotaiScope);
  const [isLibraryMenuOpen, setIsLibraryMenuOpen] = useAtom(
    isLibraryMenuOpenAtom,
    jotaiScope
  );
  const renderRemoveLibAlert = () => {
    const content = selectedItems.length ? t("alerts.removeItemsFromsLibrary", { count: selectedItems.length }) : t("alerts.resetLibrary");
    const title = selectedItems.length ? t("confirmDialog.removeItemsFromLib") : t("confirmDialog.resetLibrary");
    return /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(
      ConfirmDialog_default,
      {
        onConfirm: () => {
          if (selectedItems.length) {
            onRemoveFromLibrary();
          } else {
            resetLibrary();
          }
          setShowRemoveLibAlert(false);
        },
        onCancel: () => {
          setShowRemoveLibAlert(false);
        },
        title,
        children: /* @__PURE__ */ (0, import_jsx_runtime54.jsx)("p", { children: content })
      }
    );
  };
  const [showRemoveLibAlert, setShowRemoveLibAlert] = (0, import_react55.useState)(false);
  const itemsSelected = !!selectedItems.length;
  const items = itemsSelected ? libraryItemsData.libraryItems.filter(
    (item) => selectedItems.includes(item.id)
  ) : libraryItemsData.libraryItems;
  const resetLabel = itemsSelected ? t("buttons.remove") : t("buttons.resetLibrary");
  const [showPublishLibraryDialog, setShowPublishLibraryDialog] = (0, import_react55.useState)(false);
  const [publishLibSuccess, setPublishLibSuccess] = (0, import_react55.useState)(null);
  const renderPublishSuccess = (0, import_react55.useCallback)(() => {
    return /* @__PURE__ */ (0, import_jsx_runtime54.jsxs)(
      Dialog,
      {
        onCloseRequest: () => setPublishLibSuccess(null),
        title: t("publishSuccessDialog.title"),
        className: "publish-library-success",
        size: "small",
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime54.jsx)("p", { children: /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(
            Trans_default,
            {
              i18nKey: "publishSuccessDialog.content",
              authorName: publishLibSuccess.authorName,
              link: (el) => /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(
                "a",
                {
                  href: publishLibSuccess?.url,
                  target: "_blank",
                  rel: "noopener noreferrer",
                  children: el
                }
              )
            }
          ) }),
          /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(
            ToolButton,
            {
              type: "button",
              title: t("buttons.close"),
              "aria-label": t("buttons.close"),
              label: t("buttons.close"),
              onClick: () => setPublishLibSuccess(null),
              "data-testid": "publish-library-success-close",
              className: "publish-library-success-close"
            }
          )
        ]
      }
    );
  }, [setPublishLibSuccess, publishLibSuccess]);
  const onPublishLibSuccess = (data, libraryItems) => {
    setShowPublishLibraryDialog(false);
    setPublishLibSuccess({ url: data.url, authorName: data.authorName });
    const nextLibItems = libraryItems.slice();
    nextLibItems.forEach((libItem) => {
      if (selectedItems.includes(libItem.id)) {
        libItem.status = "published";
      }
    });
    library.setLibrary(nextLibItems);
  };
  const onLibraryImport = async () => {
    try {
      await library.updateLibrary({
        libraryItems: fileOpen({
          description: "Excalidraw library files"
          // ToDo: Be over-permissive until https://bugs.webkit.org/show_bug.cgi?id=34442
          // gets resolved. Else, iOS users cannot open `.excalidraw` files.
          /*
            extensions: [".json", ".excalidrawlib"],
            */
        }),
        merge: true,
        openLibraryMenu: true
      });
    } catch (error) {
      if (error?.name === "AbortError") {
        console.warn(error);
        return;
      }
      setAppState({ errorMessage: t("errors.importLibraryError") });
    }
  };
  const onLibraryExport = async () => {
    const libraryItems = itemsSelected ? items : await library.getLatestLibrary();
    saveLibraryAsJSON(libraryItems).catch(muteFSAbortError).catch((error) => {
      setAppState({ errorMessage: error.message });
    });
  };
  const renderLibraryMenu = () => {
    return /* @__PURE__ */ (0, import_jsx_runtime54.jsxs)(DropdownMenu_default, { open: isLibraryMenuOpen, children: [
      /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(
        DropdownMenu_default.Trigger,
        {
          onToggle: () => setIsLibraryMenuOpen(!isLibraryMenuOpen),
          children: DotsIcon
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime54.jsxs)(
        DropdownMenu_default.Content,
        {
          onClickOutside: () => setIsLibraryMenuOpen(false),
          onSelect: () => setIsLibraryMenuOpen(false),
          className: "library-menu",
          children: [
            !itemsSelected && /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(
              DropdownMenu_default.Item,
              {
                onSelect: onLibraryImport,
                icon: LoadIcon,
                "data-testid": "lib-dropdown--load",
                children: t("buttons.load")
              }
            ),
            !!items.length && /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(
              DropdownMenu_default.Item,
              {
                onSelect: onLibraryExport,
                icon: ExportIcon,
                "data-testid": "lib-dropdown--export",
                children: t("buttons.export")
              }
            ),
            !!items.length && /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(
              DropdownMenu_default.Item,
              {
                onSelect: () => setShowRemoveLibAlert(true),
                icon: TrashIcon,
                children: resetLabel
              }
            ),
            itemsSelected && /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(
              DropdownMenu_default.Item,
              {
                icon: publishIcon,
                onSelect: () => setShowPublishLibraryDialog(true),
                "data-testid": "lib-dropdown--remove",
                children: t("buttons.publishLibrary")
              }
            )
          ]
        }
      )
    ] });
  };
  return /* @__PURE__ */ (0, import_jsx_runtime54.jsxs)("div", { className: clsx_m_default("library-menu-dropdown-container", className), children: [
    renderLibraryMenu(),
    selectedItems.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime54.jsx)("div", { className: "library-actions-counter", children: selectedItems.length }),
    showRemoveLibAlert && renderRemoveLibAlert(),
    showPublishLibraryDialog && /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(
      PublishLibrary_default,
      {
        onClose: () => setShowPublishLibraryDialog(false),
        libraryItems: getSelectedItems(
          libraryItemsData.libraryItems,
          selectedItems
        ),
        appState,
        onSuccess: (data) => onPublishLibSuccess(data, libraryItemsData.libraryItems),
        onError: (error) => window.alert(error),
        updateItemsInStorage: () => library.setLibrary(libraryItemsData.libraryItems),
        onRemove: (id) => onSelectItems(selectedItems.filter((_id) => _id !== id))
      }
    ),
    publishLibSuccess && renderPublishSuccess()
  ] });
};
var LibraryDropdownMenu = ({
  selectedItems,
  onSelectItems,
  className
}) => {
  const { library } = useApp();
  const { clearLibraryCache, deleteItemsFromLibraryCache } = useLibraryCache();
  const appState = useUIAppState();
  const setAppState = useExcalidrawSetAppState();
  const [libraryItemsData] = useAtom(libraryItemsAtom, jotaiScope);
  const removeFromLibrary = async (libraryItems) => {
    const nextItems = libraryItems.filter(
      (item) => !selectedItems.includes(item.id)
    );
    library.setLibrary(nextItems).catch(() => {
      setAppState({ errorMessage: t("alerts.errorRemovingFromLibrary") });
    });
    deleteItemsFromLibraryCache(selectedItems);
    onSelectItems([]);
  };
  const resetLibrary = () => {
    library.resetLibrary();
    clearLibraryCache();
  };
  return /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(
    LibraryDropdownMenuButton,
    {
      appState,
      setAppState,
      selectedItems,
      onSelectItems,
      library,
      onRemoveFromLibrary: () => removeFromLibrary(libraryItemsData.libraryItems),
      resetLibrary,
      className
    }
  );
};

// components/LibraryMenuSection.tsx
init_define_import_meta_env();
var import_react58 = __toESM(require_react(), 1);

// components/LibraryUnit.tsx
init_define_import_meta_env();
var import_react56 = __toESM(require_react(), 1);
var import_jsx_runtime55 = __toESM(require_jsx_runtime(), 1);
var LibraryUnit = (0, import_react56.memo)(
  ({
    id,
    elements,
    isPending,
    onClick,
    selected,
    onToggle,
    onDrag,
    svgCache
  }) => {
    const ref = (0, import_react56.useRef)(null);
    const svg = useLibraryItemSvg(id, elements, svgCache);
    (0, import_react56.useEffect)(() => {
      const node = ref.current;
      if (!node) {
        return;
      }
      if (svg) {
        node.innerHTML = svg.outerHTML;
      }
      return () => {
        node.innerHTML = "";
      };
    }, [svg]);
    const [isHovered, setIsHovered] = (0, import_react56.useState)(false);
    const isMobile = useDevice().editor.isMobile;
    const adder = isPending && /* @__PURE__ */ (0, import_jsx_runtime55.jsx)("div", { className: "library-unit__adder", children: PlusIcon });
    return /* @__PURE__ */ (0, import_jsx_runtime55.jsxs)(
      "div",
      {
        className: clsx_m_default("library-unit", {
          "library-unit__active": elements,
          "library-unit--hover": elements && isHovered,
          "library-unit--selected": selected,
          "library-unit--skeleton": !svg
        }),
        onMouseEnter: () => setIsHovered(true),
        onMouseLeave: () => setIsHovered(false),
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(
            "div",
            {
              className: clsx_m_default("library-unit__dragger", {
                "library-unit__pulse": !!isPending
              }),
              ref,
              draggable: !!elements,
              onClick: !!elements || !!isPending ? (event) => {
                if (id && event.shiftKey) {
                  onToggle(id, event);
                } else {
                  onClick(id);
                }
              } : void 0,
              onDragStart: (event) => {
                if (!id) {
                  event.preventDefault();
                  return;
                }
                setIsHovered(false);
                onDrag(id, event);
              }
            }
          ),
          adder,
          id && elements && (isHovered || isMobile || selected) && /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(
            CheckboxItem,
            {
              checked: selected,
              onChange: (checked, event) => onToggle(id, event),
              className: "library-unit__checkbox"
            }
          )
        ]
      }
    );
  }
);
var EmptyLibraryUnit = () => /* @__PURE__ */ (0, import_jsx_runtime55.jsx)("div", { className: "library-unit library-unit--skeleton" });

// hooks/useTransition.ts
init_define_import_meta_env();
var import_react57 = __toESM(require_react(), 1);
function useTransitionPolyfill() {
  const startTransition = (0, import_react57.useCallback)((callback) => callback(), []);
  return [false, startTransition];
}
var useTransition = import_react57.default.useTransition || useTransitionPolyfill;

// components/LibraryMenuSection.tsx
var import_jsx_runtime56 = __toESM(require_jsx_runtime(), 1);
var LibraryMenuSectionGrid = ({
  children
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime56.jsx)("div", { className: "library-menu-items-container__grid", children });
};
var LibraryMenuSection = (0, import_react58.memo)(
  ({
    items,
    onItemSelectToggle,
    onItemDrag,
    isItemSelected,
    onClick,
    svgCache,
    itemsRenderedPerBatch
  }) => {
    const [, startTransition] = useTransition();
    const [index2, setIndex] = (0, import_react58.useState)(0);
    (0, import_react58.useEffect)(() => {
      if (index2 < items.length) {
        startTransition(() => {
          setIndex(index2 + itemsRenderedPerBatch);
        });
      }
    }, [index2, items.length, startTransition, itemsRenderedPerBatch]);
    return /* @__PURE__ */ (0, import_jsx_runtime56.jsx)(import_jsx_runtime56.Fragment, { children: items.map((item, i4) => {
      return i4 < index2 ? /* @__PURE__ */ (0, import_jsx_runtime56.jsx)(
        LibraryUnit,
        {
          elements: item?.elements,
          isPending: !item?.id && !!item?.elements,
          onClick,
          svgCache,
          id: item?.id,
          selected: isItemSelected(item.id),
          onToggle: onItemSelectToggle,
          onDrag: onItemDrag
        },
        item?.id ?? i4
      ) : /* @__PURE__ */ (0, import_jsx_runtime56.jsx)(EmptyLibraryUnit, {}, i4);
    }) });
  }
);

// hooks/useScrollPosition.ts
init_define_import_meta_env();
var import_react59 = __toESM(require_react(), 1);
var import_lodash = __toESM(require_lodash(), 1);
var scrollPositionAtom = atom2(0);
var useScrollPosition = (elementRef) => {
  const [scrollPosition, setScrollPosition] = useAtom(scrollPositionAtom);
  (0, import_react59.useEffect)(() => {
    const { current: element } = elementRef;
    if (!element) {
      return;
    }
    const handleScroll2 = (0, import_lodash.default)(() => {
      const { scrollTop } = element;
      setScrollPosition(scrollTop);
    }, 200);
    element.addEventListener("scroll", handleScroll2);
    return () => {
      handleScroll2.cancel();
      element.removeEventListener("scroll", handleScroll2);
    };
  }, [elementRef, setScrollPosition]);
  return scrollPosition;
};

// components/LibraryMenuItems.tsx
var import_jsx_runtime57 = __toESM(require_jsx_runtime(), 1);
var ITEMS_RENDERED_PER_BATCH = 17;
var CACHED_ITEMS_RENDERED_PER_BATCH = 64;
function LibraryMenuItems({
  isLoading,
  libraryItems,
  onAddToLibrary,
  onInsertLibraryItems,
  pendingElements,
  theme,
  id,
  libraryReturnUrl,
  onSelectItems,
  selectedItems
}) {
  const libraryContainerRef = (0, import_react60.useRef)(null);
  const scrollPosition = useScrollPosition(libraryContainerRef);
  (0, import_react60.useEffect)(() => {
    if (scrollPosition > 0) {
      libraryContainerRef.current?.scrollTo(0, scrollPosition);
    }
  }, []);
  const { svgCache } = useLibraryCache();
  const unpublishedItems = (0, import_react60.useMemo)(
    () => libraryItems.filter((item) => item.status !== "published"),
    [libraryItems]
  );
  const publishedItems = (0, import_react60.useMemo)(
    () => libraryItems.filter((item) => item.status === "published"),
    [libraryItems]
  );
  const showBtn = !libraryItems.length && !pendingElements.length;
  const isLibraryEmpty = !pendingElements.length && !unpublishedItems.length && !publishedItems.length;
  const [lastSelectedItem, setLastSelectedItem] = (0, import_react60.useState)(null);
  const onItemSelectToggle = (0, import_react60.useCallback)(
    (id2, event) => {
      const shouldSelect = !selectedItems.includes(id2);
      const orderedItems = [...unpublishedItems, ...publishedItems];
      if (shouldSelect) {
        if (event.shiftKey && lastSelectedItem) {
          const rangeStart = orderedItems.findIndex(
            (item) => item.id === lastSelectedItem
          );
          const rangeEnd = orderedItems.findIndex((item) => item.id === id2);
          if (rangeStart === -1 || rangeEnd === -1) {
            onSelectItems([...selectedItems, id2]);
            return;
          }
          const selectedItemsMap = arrayToMap(selectedItems);
          const nextSelectedIds = orderedItems.reduce(
            (acc, item, idx) => {
              if (idx >= rangeStart && idx <= rangeEnd || selectedItemsMap.has(item.id)) {
                acc.push(item.id);
              }
              return acc;
            },
            []
          );
          onSelectItems(nextSelectedIds);
        } else {
          onSelectItems([...selectedItems, id2]);
        }
        setLastSelectedItem(id2);
      } else {
        setLastSelectedItem(null);
        onSelectItems(selectedItems.filter((_id) => _id !== id2));
      }
    },
    [
      lastSelectedItem,
      onSelectItems,
      publishedItems,
      selectedItems,
      unpublishedItems
    ]
  );
  const getInsertedElements = (0, import_react60.useCallback)(
    (id2) => {
      let targetElements;
      if (selectedItems.includes(id2)) {
        targetElements = libraryItems.filter(
          (item) => selectedItems.includes(item.id)
        );
      } else {
        targetElements = libraryItems.filter((item) => item.id === id2);
      }
      return targetElements.map((item) => {
        return {
          ...item,
          // duplicate each library item before inserting on canvas to confine
          // ids and bindings to each library item. See #6465
          elements: duplicateElements(item.elements, { randomizeSeed: true })
        };
      });
    },
    [libraryItems, selectedItems]
  );
  const onItemDrag = (0, import_react60.useCallback)(
    (id2, event) => {
      event.dataTransfer.setData(
        MIME_TYPES.excalidrawlib,
        serializeLibraryAsJSON(getInsertedElements(id2))
      );
    },
    [getInsertedElements]
  );
  const isItemSelected = (0, import_react60.useCallback)(
    (id2) => {
      if (!id2) {
        return false;
      }
      return selectedItems.includes(id2);
    },
    [selectedItems]
  );
  const onAddToLibraryClick = (0, import_react60.useCallback)(() => {
    onAddToLibrary(pendingElements);
  }, [pendingElements, onAddToLibrary]);
  const onItemClick = (0, import_react60.useCallback)(
    (id2) => {
      if (id2) {
        onInsertLibraryItems(getInsertedElements(id2));
      }
    },
    [getInsertedElements, onInsertLibraryItems]
  );
  const itemsRenderedPerBatch = svgCache.size >= libraryItems.length ? CACHED_ITEMS_RENDERED_PER_BATCH : ITEMS_RENDERED_PER_BATCH;
  return /* @__PURE__ */ (0, import_jsx_runtime57.jsxs)(
    "div",
    {
      className: "library-menu-items-container",
      style: pendingElements.length || unpublishedItems.length || publishedItems.length ? { justifyContent: "flex-start" } : { borderBottom: 0 },
      children: [
        !isLibraryEmpty && /* @__PURE__ */ (0, import_jsx_runtime57.jsx)(
          LibraryDropdownMenu,
          {
            selectedItems,
            onSelectItems,
            className: "library-menu-dropdown-container--in-heading"
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime57.jsxs)(
          Stack_default.Col,
          {
            className: "library-menu-items-container__items",
            align: "start",
            gap: 1,
            style: {
              flex: publishedItems.length > 0 ? 1 : "0 1 auto",
              marginBottom: 0
            },
            ref: libraryContainerRef,
            children: [
              /* @__PURE__ */ (0, import_jsx_runtime57.jsxs)(import_jsx_runtime57.Fragment, { children: [
                !isLibraryEmpty && /* @__PURE__ */ (0, import_jsx_runtime57.jsx)("div", { className: "library-menu-items-container__header", children: t("labels.personalLib") }),
                isLoading && /* @__PURE__ */ (0, import_jsx_runtime57.jsx)(
                  "div",
                  {
                    style: {
                      position: "absolute",
                      top: "var(--container-padding-y)",
                      right: "var(--container-padding-x)",
                      transform: "translateY(50%)"
                    },
                    children: /* @__PURE__ */ (0, import_jsx_runtime57.jsx)(Spinner_default, {})
                  }
                ),
                !pendingElements.length && !unpublishedItems.length ? /* @__PURE__ */ (0, import_jsx_runtime57.jsxs)("div", { className: "library-menu-items__no-items", children: [
                  /* @__PURE__ */ (0, import_jsx_runtime57.jsx)("div", { className: "library-menu-items__no-items__label", children: t("library.noItems") }),
                  /* @__PURE__ */ (0, import_jsx_runtime57.jsx)("div", { className: "library-menu-items__no-items__hint", children: publishedItems.length > 0 ? t("library.hint_emptyPrivateLibrary") : t("library.hint_emptyLibrary") })
                ] }) : /* @__PURE__ */ (0, import_jsx_runtime57.jsxs)(LibraryMenuSectionGrid, { children: [
                  pendingElements.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime57.jsx)(
                    LibraryMenuSection,
                    {
                      itemsRenderedPerBatch,
                      items: [{ id: null, elements: pendingElements }],
                      onItemSelectToggle,
                      onItemDrag,
                      onClick: onAddToLibraryClick,
                      isItemSelected,
                      svgCache
                    }
                  ),
                  /* @__PURE__ */ (0, import_jsx_runtime57.jsx)(
                    LibraryMenuSection,
                    {
                      itemsRenderedPerBatch,
                      items: unpublishedItems,
                      onItemSelectToggle,
                      onItemDrag,
                      onClick: onItemClick,
                      isItemSelected,
                      svgCache
                    }
                  )
                ] })
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime57.jsxs)(import_jsx_runtime57.Fragment, { children: [
                (publishedItems.length > 0 || pendingElements.length > 0 || unpublishedItems.length > 0) && /* @__PURE__ */ (0, import_jsx_runtime57.jsx)("div", { className: "library-menu-items-container__header library-menu-items-container__header--excal", children: t("labels.excalidrawLib") }),
                publishedItems.length > 0 ? /* @__PURE__ */ (0, import_jsx_runtime57.jsx)(LibraryMenuSectionGrid, { children: /* @__PURE__ */ (0, import_jsx_runtime57.jsx)(
                  LibraryMenuSection,
                  {
                    itemsRenderedPerBatch,
                    items: publishedItems,
                    onItemSelectToggle,
                    onItemDrag,
                    onClick: onItemClick,
                    isItemSelected,
                    svgCache
                  }
                ) }) : unpublishedItems.length > 0 ? /* @__PURE__ */ (0, import_jsx_runtime57.jsx)(
                  "div",
                  {
                    style: {
                      margin: "1rem 0",
                      display: "flex",
                      flexDirection: "column",
                      alignItems: "center",
                      justifyContent: "center",
                      width: "100%",
                      fontSize: ".9rem"
                    },
                    children: t("library.noItems")
                  }
                ) : null
              ] }),
              showBtn && /* @__PURE__ */ (0, import_jsx_runtime57.jsx)(
                LibraryMenuControlButtons,
                {
                  style: { padding: "16px 0", width: "100%" },
                  id,
                  libraryReturnUrl,
                  theme,
                  children: /* @__PURE__ */ (0, import_jsx_runtime57.jsx)(
                    LibraryDropdownMenu,
                    {
                      selectedItems,
                      onSelectItems
                    }
                  )
                }
              )
            ]
          }
        )
      ]
    }
  );
}

// components/LibraryMenu.tsx
var import_jsx_runtime58 = __toESM(require_jsx_runtime(), 1);
var isLibraryMenuOpenAtom = atom2(false);
var LibraryMenuWrapper = ({ children }) => {
  return /* @__PURE__ */ (0, import_jsx_runtime58.jsx)("div", { className: "layer-ui__library", children });
};
var LibraryMenuContent = ({
  onInsertLibraryItems,
  pendingElements,
  onAddToLibrary,
  setAppState,
  libraryReturnUrl,
  library,
  id,
  theme,
  selectedItems,
  onSelectItems
}) => {
  const [libraryItemsData] = useAtom(libraryItemsAtom, jotaiScope);
  const _onAddToLibrary = (0, import_react61.useCallback)(
    (elements) => {
      const addToLibrary = async (processedElements, libraryItems2) => {
        trackEvent("element", "addToLibrary", "ui");
        for (const type of LIBRARY_DISABLED_TYPES) {
          if (processedElements.some((element) => element.type === type)) {
            return setAppState({
              errorMessage: t(`errors.libraryElementTypeError.${type}`)
            });
          }
        }
        const nextItems = [
          {
            status: "unpublished",
            elements: processedElements,
            id: randomId(),
            created: Date.now()
          },
          ...libraryItems2
        ];
        onAddToLibrary();
        library.setLibrary(nextItems).catch(() => {
          setAppState({ errorMessage: t("alerts.errorAddingToLibrary") });
        });
      };
      addToLibrary(elements, libraryItemsData.libraryItems);
    },
    [onAddToLibrary, library, setAppState, libraryItemsData.libraryItems]
  );
  const libraryItems = (0, import_react61.useMemo)(
    () => libraryItemsData.libraryItems,
    [libraryItemsData]
  );
  if (libraryItemsData.status === "loading" && !libraryItemsData.isInitialized) {
    return /* @__PURE__ */ (0, import_jsx_runtime58.jsx)(LibraryMenuWrapper, { children: /* @__PURE__ */ (0, import_jsx_runtime58.jsx)("div", { className: "layer-ui__library-message", children: /* @__PURE__ */ (0, import_jsx_runtime58.jsxs)("div", { children: [
      /* @__PURE__ */ (0, import_jsx_runtime58.jsx)(Spinner_default, { size: "2em" }),
      /* @__PURE__ */ (0, import_jsx_runtime58.jsx)("span", { children: t("labels.libraryLoadingMessage") })
    ] }) }) });
  }
  const showBtn = libraryItemsData.libraryItems.length > 0 || pendingElements.length > 0;
  return /* @__PURE__ */ (0, import_jsx_runtime58.jsxs)(LibraryMenuWrapper, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime58.jsx)(
      LibraryMenuItems,
      {
        isLoading: libraryItemsData.status === "loading",
        libraryItems,
        onAddToLibrary: _onAddToLibrary,
        onInsertLibraryItems,
        pendingElements,
        id,
        libraryReturnUrl,
        theme,
        onSelectItems,
        selectedItems
      }
    ),
    showBtn && /* @__PURE__ */ (0, import_jsx_runtime58.jsx)(
      LibraryMenuControlButtons,
      {
        className: "library-menu-control-buttons--at-bottom",
        style: { padding: "16px 12px 0 12px" },
        id,
        libraryReturnUrl,
        theme
      }
    )
  ] });
};
var usePendingElementsMemo = (appState, elements) => {
  const create2 = () => getSelectedElements(elements, appState, {
    includeBoundTextElement: true,
    includeElementsInFrames: true
  });
  const val = (0, import_react61.useRef)(create2());
  const prevAppState = (0, import_react61.useRef)(appState);
  const prevElements = (0, import_react61.useRef)(elements);
  if (!isShallowEqual(
    appState.selectedElementIds,
    prevAppState.current.selectedElementIds
  ) || !isShallowEqual(elements, prevElements.current)) {
    val.current = create2();
    prevAppState.current = appState;
    prevElements.current = elements;
  }
  return val.current;
};
var LibraryMenu = () => {
  const { library, id, onInsertElements } = useApp();
  const appProps = useAppProps();
  const appState = useUIAppState();
  const setAppState = useExcalidrawSetAppState();
  const elements = useExcalidrawElements();
  const [selectedItems, setSelectedItems] = (0, import_react61.useState)([]);
  const memoizedLibrary = (0, import_react61.useMemo)(() => library, [library]);
  const pendingElements = usePendingElementsMemo(appState, elements);
  const onInsertLibraryItems = (0, import_react61.useCallback)(
    (libraryItems) => {
      onInsertElements(distributeLibraryItemsOnSquareGrid(libraryItems));
    },
    [onInsertElements]
  );
  const deselectItems = (0, import_react61.useCallback)(() => {
    setAppState({
      selectedElementIds: {},
      selectedGroupIds: {},
      activeEmbeddable: null
    });
  }, [setAppState]);
  return /* @__PURE__ */ (0, import_jsx_runtime58.jsx)(
    LibraryMenuContent,
    {
      pendingElements,
      onInsertLibraryItems,
      onAddToLibrary: deselectItems,
      setAppState,
      libraryReturnUrl: appProps.libraryReturnUrl,
      library: memoizedLibrary,
      id,
      theme: appState.theme,
      selectedItems,
      onSelectItems: setSelectedItems
    }
  );
};

// components/Dialog.tsx
var import_jsx_runtime59 = __toESM(require_jsx_runtime(), 1);
function getDialogSize(size) {
  if (size && typeof size === "number") {
    return size;
  }
  switch (size) {
    case "small":
      return 550;
    case "wide":
      return 1024;
    case "regular":
    default:
      return 800;
  }
}
var Dialog = (props) => {
  const [islandNode, setIslandNode] = useCallbackRefState();
  const [lastActiveElement] = (0, import_react62.useState)(document.activeElement);
  const { id } = useExcalidrawContainer();
  const isFullscreen = useDevice().viewport.isMobile;
  (0, import_react62.useEffect)(() => {
    if (!islandNode) {
      return;
    }
    const focusableElements = queryFocusableElements(islandNode);
    if (focusableElements.length > 0 && props.autofocus !== false) {
      (focusableElements[1] || focusableElements[0]).focus();
    }
    const handleKeyDown = (event) => {
      if (event.key === KEYS.TAB) {
        const focusableElements2 = queryFocusableElements(islandNode);
        const { activeElement } = document;
        const currentIndex = focusableElements2.findIndex(
          (element) => element === activeElement
        );
        if (currentIndex === 0 && event.shiftKey) {
          focusableElements2[focusableElements2.length - 1].focus();
          event.preventDefault();
        } else if (currentIndex === focusableElements2.length - 1 && !event.shiftKey) {
          focusableElements2[0].focus();
          event.preventDefault();
        }
      }
    };
    islandNode.addEventListener("keydown", handleKeyDown);
    return () => islandNode.removeEventListener("keydown", handleKeyDown);
  }, [islandNode, props.autofocus]);
  const setAppState = useExcalidrawSetAppState();
  const setIsLibraryMenuOpen = useSetAtom(isLibraryMenuOpenAtom, jotaiScope);
  const onClose = () => {
    setAppState({ openMenu: null });
    setIsLibraryMenuOpen(false);
    lastActiveElement.focus();
    props.onCloseRequest();
  };
  return /* @__PURE__ */ (0, import_jsx_runtime59.jsx)(
    Modal,
    {
      className: clsx_m_default("Dialog", props.className, {
        "Dialog--fullscreen": isFullscreen
      }),
      labelledBy: "dialog-title",
      maxWidth: getDialogSize(props.size),
      onCloseRequest: onClose,
      closeOnClickOutside: props.closeOnClickOutside,
      children: /* @__PURE__ */ (0, import_jsx_runtime59.jsxs)(Island, { ref: setIslandNode, children: [
        props.title && /* @__PURE__ */ (0, import_jsx_runtime59.jsx)("h2", { id: `${id}-dialog-title`, className: "Dialog__title", children: /* @__PURE__ */ (0, import_jsx_runtime59.jsx)("span", { className: "Dialog__titleContent", children: props.title }) }),
        /* @__PURE__ */ (0, import_jsx_runtime59.jsx)(
          "button",
          {
            className: "Dialog__close",
            onClick: onClose,
            title: t("buttons.close"),
            "aria-label": t("buttons.close"),
            children: isFullscreen ? back : CloseIcon
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime59.jsx)("div", { className: "Dialog__content", children: props.children })
      ] })
    }
  );
};

// components/ErrorDialog.tsx
var import_jsx_runtime60 = __toESM(require_jsx_runtime(), 1);
var ErrorDialog = ({
  children,
  onClose
}) => {
  const [modalIsShown, setModalIsShown] = (0, import_react63.useState)(!!children);
  const { container: excalidrawContainer } = useExcalidrawContainer();
  const handleClose = import_react63.default.useCallback(() => {
    setModalIsShown(false);
    if (onClose) {
      onClose();
    }
    excalidrawContainer?.focus();
  }, [onClose, excalidrawContainer]);
  return /* @__PURE__ */ (0, import_jsx_runtime60.jsx)(import_jsx_runtime60.Fragment, { children: modalIsShown && /* @__PURE__ */ (0, import_jsx_runtime60.jsx)(
    Dialog,
    {
      size: "small",
      onCloseRequest: handleClose,
      title: t("errorDialog.title"),
      children: /* @__PURE__ */ (0, import_jsx_runtime60.jsx)("div", { style: { whiteSpace: "pre-wrap" }, children })
    }
  ) });
};

// components/ImageExportDialog.tsx
init_define_import_meta_env();
var import_react65 = __toESM(require_react(), 1);

// components/RadioGroup.tsx
init_define_import_meta_env();
var import_jsx_runtime61 = __toESM(require_jsx_runtime(), 1);
var RadioGroup = function({
  onChange,
  value,
  choices,
  name
}) {
  return /* @__PURE__ */ (0, import_jsx_runtime61.jsx)("div", { className: "RadioGroup", children: choices.map((choice) => /* @__PURE__ */ (0, import_jsx_runtime61.jsxs)(
    "div",
    {
      className: clsx_m_default("RadioGroup__choice", {
        active: choice.value === value
      }),
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime61.jsx)(
          "input",
          {
            name,
            type: "radio",
            checked: choice.value === value,
            onChange: () => onChange(choice.value)
          }
        ),
        choice.label
      ]
    },
    choice.label
  )) });
};

// components/Switch.tsx
init_define_import_meta_env();
var import_jsx_runtime62 = __toESM(require_jsx_runtime(), 1);
var Switch = ({
  title,
  name,
  checked,
  onChange,
  disabled = false
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime62.jsx)("div", { className: clsx_m_default("Switch", { toggled: checked, disabled }), children: /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(
    "input",
    {
      name,
      id: name,
      title,
      type: "checkbox",
      checked,
      disabled,
      onChange: () => onChange(!checked),
      onKeyDown: (event) => {
        if (event.key === " ") {
          onChange(!checked);
        }
      }
    }
  ) });
};

// components/FilledButton.tsx
init_define_import_meta_env();
var import_react64 = __toESM(require_react(), 1);
var import_jsx_runtime63 = __toESM(require_jsx_runtime(), 1);
var FilledButton = (0, import_react64.forwardRef)(
  ({
    children,
    icon,
    onClick,
    label,
    variant = "filled",
    color = "primary",
    size = "medium",
    fullWidth,
    className
  }, ref) => {
    const [isLoading, setIsLoading] = (0, import_react64.useState)(false);
    const _onClick = async (event) => {
      const ret = onClick?.(event);
      if (isPromiseLike(ret)) {
        try {
          setIsLoading(true);
          await ret;
        } catch (error) {
          if (!(error instanceof AbortError)) {
            throw error;
          } else {
            console.warn(error);
          }
        } finally {
          setIsLoading(false);
        }
      }
    };
    return /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(
      "button",
      {
        className: clsx_m_default(
          "ExcButton",
          `ExcButton--color-${color}`,
          `ExcButton--variant-${variant}`,
          `ExcButton--size-${size}`,
          { "ExcButton--fullWidth": fullWidth },
          className
        ),
        onClick: _onClick,
        type: "button",
        "aria-label": label,
        ref,
        disabled: isLoading,
        children: /* @__PURE__ */ (0, import_jsx_runtime63.jsxs)("div", { className: "ExcButton__contents", children: [
          isLoading && /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(Spinner_default, {}),
          icon && /* @__PURE__ */ (0, import_jsx_runtime63.jsx)("div", { className: "ExcButton__icon", "aria-hidden": true, children: icon }),
          variant !== "icon" && (children ?? label)
        ] })
      }
    );
  }
);

// components/ImageExportDialog.tsx
var import_jsx_runtime64 = __toESM(require_jsx_runtime(), 1);
var supportsContextFilters = "filter" in document.createElement("canvas").getContext("2d");
var ErrorCanvasPreview = () => {
  return /* @__PURE__ */ (0, import_jsx_runtime64.jsxs)("div", { children: [
    /* @__PURE__ */ (0, import_jsx_runtime64.jsx)("h3", { children: t("canvasError.cannotShowPreview") }),
    /* @__PURE__ */ (0, import_jsx_runtime64.jsx)("p", { children: /* @__PURE__ */ (0, import_jsx_runtime64.jsx)("span", { children: t("canvasError.canvasTooBig") }) }),
    /* @__PURE__ */ (0, import_jsx_runtime64.jsxs)("em", { children: [
      "(",
      t("canvasError.canvasTooBigTip"),
      ")"
    ] })
  ] });
};
var ImageExportModal = ({
  appStateSnapshot,
  elementsSnapshot,
  files,
  actionManager,
  onExportImage,
  name
}) => {
  const hasSelection = isSomeElementSelected(
    elementsSnapshot,
    appStateSnapshot
  );
  const [projectName, setProjectName] = (0, import_react65.useState)(name);
  const [exportSelectionOnly, setExportSelectionOnly] = (0, import_react65.useState)(hasSelection);
  const [exportWithBackground, setExportWithBackground] = (0, import_react65.useState)(
    appStateSnapshot.exportBackground
  );
  const [exportDarkMode, setExportDarkMode] = (0, import_react65.useState)(
    appStateSnapshot.exportWithDarkMode
  );
  const [embedScene, setEmbedScene] = (0, import_react65.useState)(
    appStateSnapshot.exportEmbedScene
  );
  const [exportScale, setExportScale] = (0, import_react65.useState)(appStateSnapshot.exportScale);
  const previewRef = (0, import_react65.useRef)(null);
  const [renderError, setRenderError] = (0, import_react65.useState)(null);
  const { exportedElements, exportingFrame } = prepareElementsForExport(
    elementsSnapshot,
    appStateSnapshot,
    exportSelectionOnly
  );
  (0, import_react65.useEffect)(() => {
    const previewNode = previewRef.current;
    if (!previewNode) {
      return;
    }
    const maxWidth = previewNode.offsetWidth;
    const maxHeight = previewNode.offsetHeight;
    if (!maxWidth) {
      return;
    }
    exportToCanvas2({
      elements: exportedElements,
      appState: {
        ...appStateSnapshot,
        name: projectName,
        exportBackground: exportWithBackground,
        exportWithDarkMode: exportDarkMode,
        exportScale,
        exportEmbedScene: embedScene
      },
      files,
      exportPadding: DEFAULT_EXPORT_PADDING,
      maxWidthOrHeight: Math.max(maxWidth, maxHeight),
      exportingFrame
    }).then((canvas2) => {
      setRenderError(null);
      return canvasToBlob(canvas2).then(() => {
        previewNode.replaceChildren(canvas2);
      });
    }).catch((error) => {
      console.error(error);
      setRenderError(error);
    });
  }, [
    appStateSnapshot,
    files,
    exportedElements,
    exportingFrame,
    projectName,
    exportWithBackground,
    exportDarkMode,
    exportScale,
    embedScene
  ]);
  return /* @__PURE__ */ (0, import_jsx_runtime64.jsxs)("div", { className: "ImageExportModal", children: [
    /* @__PURE__ */ (0, import_jsx_runtime64.jsx)("h3", { children: t("imageExportDialog.header") }),
    /* @__PURE__ */ (0, import_jsx_runtime64.jsxs)("div", { className: "ImageExportModal__preview", children: [
      /* @__PURE__ */ (0, import_jsx_runtime64.jsx)("div", { className: "ImageExportModal__preview__canvas", ref: previewRef, children: renderError && /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(ErrorCanvasPreview, {}) }),
      /* @__PURE__ */ (0, import_jsx_runtime64.jsx)("div", { className: "ImageExportModal__preview__filename", children: !e2 && /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(
        "input",
        {
          type: "text",
          className: "TextInput",
          value: projectName,
          style: { width: "30ch" },
          onChange: (event) => {
            setProjectName(event.target.value);
            actionManager.executeAction(
              actionChangeProjectName,
              "ui",
              event.target.value
            );
          }
        }
      ) })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime64.jsxs)("div", { className: "ImageExportModal__settings", children: [
      /* @__PURE__ */ (0, import_jsx_runtime64.jsx)("h3", { children: t("imageExportDialog.header") }),
      hasSelection && /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(
        ExportSetting,
        {
          label: t("imageExportDialog.label.onlySelected"),
          name: "exportOnlySelected",
          children: /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(
            Switch,
            {
              name: "exportOnlySelected",
              checked: exportSelectionOnly,
              onChange: (checked) => {
                setExportSelectionOnly(checked);
              }
            }
          )
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(
        ExportSetting,
        {
          label: t("imageExportDialog.label.withBackground"),
          name: "exportBackgroundSwitch",
          children: /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(
            Switch,
            {
              name: "exportBackgroundSwitch",
              checked: exportWithBackground,
              onChange: (checked) => {
                setExportWithBackground(checked);
                actionManager.executeAction(
                  actionChangeExportBackground,
                  "ui",
                  checked
                );
              }
            }
          )
        }
      ),
      supportsContextFilters && /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(
        ExportSetting,
        {
          label: t("imageExportDialog.label.darkMode"),
          name: "exportDarkModeSwitch",
          children: /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(
            Switch,
            {
              name: "exportDarkModeSwitch",
              checked: exportDarkMode,
              onChange: (checked) => {
                setExportDarkMode(checked);
                actionManager.executeAction(
                  actionExportWithDarkMode,
                  "ui",
                  checked
                );
              }
            }
          )
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(
        ExportSetting,
        {
          label: t("imageExportDialog.label.embedScene"),
          tooltip: t("imageExportDialog.tooltip.embedScene"),
          name: "exportEmbedSwitch",
          children: /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(
            Switch,
            {
              name: "exportEmbedSwitch",
              checked: embedScene,
              onChange: (checked) => {
                setEmbedScene(checked);
                actionManager.executeAction(
                  actionChangeExportEmbedScene,
                  "ui",
                  checked
                );
              }
            }
          )
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(
        ExportSetting,
        {
          label: t("imageExportDialog.label.scale"),
          name: "exportScale",
          children: /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(
            RadioGroup,
            {
              name: "exportScale",
              value: exportScale,
              onChange: (scale) => {
                setExportScale(scale);
                actionManager.executeAction(actionChangeExportScale, "ui", scale);
              },
              choices: EXPORT_SCALES.map((scale) => ({
                value: scale,
                label: `${scale}\xD7`
              }))
            }
          )
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime64.jsxs)("div", { className: "ImageExportModal__settings__buttons", children: [
        /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(
          FilledButton,
          {
            className: "ImageExportModal__settings__buttons__button",
            label: t("imageExportDialog.title.exportToPng"),
            onClick: () => onExportImage(EXPORT_IMAGE_TYPES.png, exportedElements, {
              exportingFrame
            }),
            icon: downloadIcon,
            children: t("imageExportDialog.button.exportToPng")
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(
          FilledButton,
          {
            className: "ImageExportModal__settings__buttons__button",
            label: t("imageExportDialog.title.exportToSvg"),
            onClick: () => onExportImage(EXPORT_IMAGE_TYPES.svg, exportedElements, {
              exportingFrame
            }),
            icon: downloadIcon,
            children: t("imageExportDialog.button.exportToSvg")
          }
        ),
        (probablySupportsClipboardBlob || isFirefox) && /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(
          FilledButton,
          {
            className: "ImageExportModal__settings__buttons__button",
            label: t("imageExportDialog.title.copyPngToClipboard"),
            onClick: () => onExportImage(EXPORT_IMAGE_TYPES.clipboard, exportedElements, {
              exportingFrame
            }),
            icon: copyIcon,
            children: t("imageExportDialog.button.copyPngToClipboard")
          }
        )
      ] })
    ] })
  ] });
};
var ExportSetting = ({
  label,
  children,
  tooltip,
  name
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime64.jsxs)("div", { className: "ImageExportModal__settings__setting", title: label, children: [
    /* @__PURE__ */ (0, import_jsx_runtime64.jsxs)(
      "label",
      {
        htmlFor: name,
        className: "ImageExportModal__settings__setting__label",
        children: [
          label,
          tooltip && /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(Tooltip, { label: tooltip, long: true, children: helpIcon })
        ]
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime64.jsx)("div", { className: "ImageExportModal__settings__setting__content", children })
  ] });
};
var ImageExportDialog = ({
  elements,
  appState,
  files,
  actionManager,
  onExportImage,
  onCloseRequest,
  name
}) => {
  const [{ appStateSnapshot, elementsSnapshot }] = (0, import_react65.useState)(() => {
    return {
      appStateSnapshot: cloneJSON(appState),
      elementsSnapshot: cloneJSON(elements)
    };
  });
  return /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(Dialog, { onCloseRequest, size: "wide", title: false, children: /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(
    ImageExportModal,
    {
      elementsSnapshot,
      appStateSnapshot,
      files,
      actionManager,
      onExportImage,
      name
    }
  ) });
};

// components/FixedSideContainer.tsx
init_define_import_meta_env();
var import_jsx_runtime65 = __toESM(require_jsx_runtime(), 1);
var FixedSideContainer = ({
  children,
  side,
  className
}) => /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(
  "div",
  {
    className: clsx_m_default(
      "FixedSideContainer",
      `FixedSideContainer_side_${side}`,
      className
    ),
    children
  }
);

// components/HintViewer.tsx
init_define_import_meta_env();
var import_jsx_runtime66 = __toESM(require_jsx_runtime(), 1);
var getHints = ({ appState, isMobile, device, app }) => {
  const { activeTool, isResizing, isRotating, lastPointerDownWith } = appState;
  const multiMode = appState.multiElement !== null;
  if (appState.openSidebar && !device.editor.canFitSidebar) {
    return null;
  }
  if (isEraserActive(appState)) {
    return t("hints.eraserRevert");
  }
  if (activeTool.type === "arrow" || activeTool.type === "line") {
    if (!multiMode) {
      return t("hints.linearElement");
    }
    return t("hints.linearElementMulti");
  }
  if (activeTool.type === "freedraw") {
    return t("hints.freeDraw");
  }
  if (activeTool.type === "text") {
    return t("hints.text");
  }
  if (activeTool.type === "embeddable") {
    return t("hints.embeddable");
  }
  if (appState.activeTool.type === "image" && appState.pendingImageElementId) {
    return t("hints.placeImage");
  }
  const selectedElements = app.scene.getSelectedElements(appState);
  if (isResizing && lastPointerDownWith === "mouse" && selectedElements.length === 1) {
    const targetElement = selectedElements[0];
    if (isLinearElement(targetElement) && targetElement.points.length === 2) {
      return t("hints.lockAngle");
    }
    return isImageElement(targetElement) ? t("hints.resizeImage") : t("hints.resize");
  }
  if (isRotating && lastPointerDownWith === "mouse") {
    return t("hints.rotate");
  }
  if (selectedElements.length === 1 && isTextElement(selectedElements[0])) {
    return t("hints.text_selected");
  }
  if (appState.editingElement && isTextElement(appState.editingElement)) {
    return t("hints.text_editing");
  }
  if (activeTool.type === "selection") {
    if (appState.draggingElement?.type === "selection" && !selectedElements.length && !appState.editingElement && !appState.editingLinearElement) {
      return t("hints.deepBoxSelect");
    }
    if (appState.gridSize && appState.draggingElement) {
      return t("hints.disableSnapping");
    }
    if (!selectedElements.length && !isMobile) {
      return t("hints.canvasPanning");
    }
    if (selectedElements.length === 1) {
      if (isLinearElement(selectedElements[0])) {
        if (appState.editingLinearElement) {
          return appState.editingLinearElement.selectedPointsIndices ? t("hints.lineEditor_pointSelected") : t("hints.lineEditor_nothingSelected");
        }
        return t("hints.lineEditor_info");
      }
      if (!appState.draggingElement && isTextBindableContainer(selectedElements[0])) {
        return t("hints.bindTextToElement");
      }
    }
  }
  return null;
};
var HintViewer = ({
  appState,
  isMobile,
  device,
  app
}) => {
  let hint = getHints({
    appState,
    isMobile,
    device,
    app
  });
  if (!hint) {
    return null;
  }
  hint = getShortcutKey(hint);
  return /* @__PURE__ */ (0, import_jsx_runtime66.jsx)("div", { className: "HintViewer", children: /* @__PURE__ */ (0, import_jsx_runtime66.jsx)("span", { children: hint }) });
};

// components/LoadingMessage.tsx
init_define_import_meta_env();
var import_react66 = __toESM(require_react(), 1);
var import_jsx_runtime67 = __toESM(require_jsx_runtime(), 1);
var LoadingMessage = ({
  delay,
  theme
}) => {
  const [isWaiting, setIsWaiting] = (0, import_react66.useState)(!!delay);
  (0, import_react66.useEffect)(() => {
    if (!delay) {
      return;
    }
    const timer = setTimeout(() => {
      setIsWaiting(false);
    }, delay);
    return () => clearTimeout(timer);
  }, [delay]);
  if (isWaiting) {
    return null;
  }
  return /* @__PURE__ */ (0, import_jsx_runtime67.jsxs)(
    "div",
    {
      className: clsx_m_default("LoadingMessage", {
        "LoadingMessage--dark": theme === THEME.DARK
      }),
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime67.jsx)("div", { children: /* @__PURE__ */ (0, import_jsx_runtime67.jsx)(Spinner_default, {}) }),
        /* @__PURE__ */ (0, import_jsx_runtime67.jsx)("div", { className: "LoadingMessage-text", children: t("labels.loadingScene") })
      ]
    }
  );
};

// components/LockButton.tsx
init_define_import_meta_env();
var import_jsx_runtime68 = __toESM(require_jsx_runtime(), 1);
var DEFAULT_SIZE = "medium";
var ICONS2 = {
  CHECKED: LockedIcon,
  UNCHECKED: UnlockedIcon
};
var LockButton = (props) => {
  return /* @__PURE__ */ (0, import_jsx_runtime68.jsxs)(
    "label",
    {
      className: clsx_m_default(
        "ToolIcon ToolIcon__lock",
        `ToolIcon_size_${DEFAULT_SIZE}`,
        {
          "is-mobile": props.isMobile
        }
      ),
      title: `${props.title} \u2014 Q`,
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime68.jsx)(
          "input",
          {
            className: "ToolIcon_type_checkbox",
            type: "checkbox",
            name: props.name,
            onChange: props.onChange,
            checked: props.checked,
            "aria-label": props.title,
            "data-testid": "toolbar-lock"
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime68.jsx)("div", { className: "ToolIcon__icon", children: props.checked ? ICONS2.CHECKED : ICONS2.UNCHECKED })
      ]
    }
  );
};

// components/MobileMenu.tsx
init_define_import_meta_env();

// components/Section.tsx
init_define_import_meta_env();
var import_jsx_runtime69 = __toESM(require_jsx_runtime(), 1);
var Section = ({ heading, children, ...props }) => {
  const { id } = useExcalidrawContainer();
  const header = /* @__PURE__ */ (0, import_jsx_runtime69.jsx)("h2", { className: "visually-hidden", id: `${id}-${heading}-title`, children: t(`headings.${heading}`) });
  return /* @__PURE__ */ (0, import_jsx_runtime69.jsx)("section", { ...props, "aria-labelledby": `${id}-${heading}-title`, children: typeof children === "function" ? children(header) : /* @__PURE__ */ (0, import_jsx_runtime69.jsxs)(import_jsx_runtime69.Fragment, { children: [
    header,
    children
  ] }) });
};

// components/PenModeButton.tsx
init_define_import_meta_env();
var import_jsx_runtime70 = __toESM(require_jsx_runtime(), 1);
var DEFAULT_SIZE2 = "medium";
var PenModeButton = (props) => {
  if (!props.penDetected) {
    return null;
  }
  return /* @__PURE__ */ (0, import_jsx_runtime70.jsxs)(
    "label",
    {
      className: clsx_m_default(
        "ToolIcon ToolIcon__penMode",
        `ToolIcon_size_${DEFAULT_SIZE2}`,
        {
          "is-mobile": props.isMobile
        }
      ),
      title: `${props.title}`,
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime70.jsx)(
          "input",
          {
            className: "ToolIcon_type_checkbox",
            type: "checkbox",
            name: props.name,
            onChange: props.onChange,
            checked: props.checked,
            "aria-label": props.title
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime70.jsx)("div", { className: "ToolIcon__icon", children: PenModeIcon })
      ]
    }
  );
};

// components/Stats.tsx
init_define_import_meta_env();
var import_jsx_runtime71 = __toESM(require_jsx_runtime(), 1);
var Stats = (props) => {
  const boundingBox = getCommonBounds(props.elements);
  const selectedElements = getTargetElements(props.elements, props.appState);
  const selectedBoundingBox = getCommonBounds(selectedElements);
  return /* @__PURE__ */ (0, import_jsx_runtime71.jsx)("div", { className: "Stats", children: /* @__PURE__ */ (0, import_jsx_runtime71.jsxs)(Island, { padding: 2, children: [
    /* @__PURE__ */ (0, import_jsx_runtime71.jsx)("div", { className: "close", onClick: props.onClose, children: CloseIcon }),
    /* @__PURE__ */ (0, import_jsx_runtime71.jsx)("h3", { children: t("stats.title") }),
    /* @__PURE__ */ (0, import_jsx_runtime71.jsx)("table", { children: /* @__PURE__ */ (0, import_jsx_runtime71.jsxs)("tbody", { children: [
      /* @__PURE__ */ (0, import_jsx_runtime71.jsx)("tr", { children: /* @__PURE__ */ (0, import_jsx_runtime71.jsx)("th", { colSpan: 2, children: t("stats.scene") }) }),
      /* @__PURE__ */ (0, import_jsx_runtime71.jsxs)("tr", { children: [
        /* @__PURE__ */ (0, import_jsx_runtime71.jsx)("td", { children: t("stats.elements") }),
        /* @__PURE__ */ (0, import_jsx_runtime71.jsx)("td", { children: props.elements.length })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime71.jsxs)("tr", { children: [
        /* @__PURE__ */ (0, import_jsx_runtime71.jsx)("td", { children: t("stats.width") }),
        /* @__PURE__ */ (0, import_jsx_runtime71.jsx)("td", { children: Math.round(boundingBox[2]) - Math.round(boundingBox[0]) })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime71.jsxs)("tr", { children: [
        /* @__PURE__ */ (0, import_jsx_runtime71.jsx)("td", { children: t("stats.height") }),
        /* @__PURE__ */ (0, import_jsx_runtime71.jsx)("td", { children: Math.round(boundingBox[3]) - Math.round(boundingBox[1]) })
      ] }),
      selectedElements.length === 1 && /* @__PURE__ */ (0, import_jsx_runtime71.jsx)("tr", { children: /* @__PURE__ */ (0, import_jsx_runtime71.jsx)("th", { colSpan: 2, children: t("stats.element") }) }),
      selectedElements.length > 1 && /* @__PURE__ */ (0, import_jsx_runtime71.jsxs)(import_jsx_runtime71.Fragment, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime71.jsx)("tr", { children: /* @__PURE__ */ (0, import_jsx_runtime71.jsx)("th", { colSpan: 2, children: t("stats.selected") }) }),
        /* @__PURE__ */ (0, import_jsx_runtime71.jsxs)("tr", { children: [
          /* @__PURE__ */ (0, import_jsx_runtime71.jsx)("td", { children: t("stats.elements") }),
          /* @__PURE__ */ (0, import_jsx_runtime71.jsx)("td", { children: selectedElements.length })
        ] })
      ] }),
      selectedElements.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime71.jsxs)(import_jsx_runtime71.Fragment, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime71.jsxs)("tr", { children: [
          /* @__PURE__ */ (0, import_jsx_runtime71.jsx)("td", { children: "x" }),
          /* @__PURE__ */ (0, import_jsx_runtime71.jsx)("td", { children: Math.round(selectedBoundingBox[0]) })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime71.jsxs)("tr", { children: [
          /* @__PURE__ */ (0, import_jsx_runtime71.jsx)("td", { children: "y" }),
          /* @__PURE__ */ (0, import_jsx_runtime71.jsx)("td", { children: Math.round(selectedBoundingBox[1]) })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime71.jsxs)("tr", { children: [
          /* @__PURE__ */ (0, import_jsx_runtime71.jsx)("td", { children: t("stats.width") }),
          /* @__PURE__ */ (0, import_jsx_runtime71.jsx)("td", { children: Math.round(
            selectedBoundingBox[2] - selectedBoundingBox[0]
          ) })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime71.jsxs)("tr", { children: [
          /* @__PURE__ */ (0, import_jsx_runtime71.jsx)("td", { children: t("stats.height") }),
          /* @__PURE__ */ (0, import_jsx_runtime71.jsx)("td", { children: Math.round(
            selectedBoundingBox[3] - selectedBoundingBox[1]
          ) })
        ] })
      ] }),
      selectedElements.length === 1 && /* @__PURE__ */ (0, import_jsx_runtime71.jsxs)("tr", { children: [
        /* @__PURE__ */ (0, import_jsx_runtime71.jsx)("td", { children: t("stats.angle") }),
        /* @__PURE__ */ (0, import_jsx_runtime71.jsx)("td", { children: `${Math.round(
          selectedElements[0].angle * 180 / Math.PI
        )}\xB0` })
      ] }),
      props.renderCustomStats?.(props.elements, props.appState)
    ] }) })
  ] }) });
};

// components/HandButton.tsx
init_define_import_meta_env();
var import_jsx_runtime72 = __toESM(require_jsx_runtime(), 1);
var HandButton = (props) => {
  return /* @__PURE__ */ (0, import_jsx_runtime72.jsx)(
    ToolButton,
    {
      className: clsx_m_default("Shape", { fillable: false }),
      type: "radio",
      icon: handIcon,
      name: "editor-current-shape",
      checked: props.checked,
      title: `${props.title} \u2014 H`,
      keyBindingLabel: !props.isMobile ? KEYS.H.toLocaleUpperCase() : void 0,
      "aria-label": `${props.title} \u2014 H`,
      "aria-keyshortcuts": KEYS.H,
      "data-testid": `toolbar-hand`,
      onChange: () => props.onChange?.()
    }
  );
};

// components/MobileMenu.tsx
var import_jsx_runtime73 = __toESM(require_jsx_runtime(), 1);
var MobileMenu = ({
  appState,
  elements,
  actionManager,
  setAppState,
  onLockToggle,
  onHandToolToggle,
  onPenModeToggle,
  renderTopRightUI,
  renderCustomStats,
  renderSidebars,
  device,
  renderWelcomeScreen,
  UIOptions,
  app
}) => {
  const {
    WelcomeScreenCenterTunnel,
    MainMenuTunnel,
    DefaultSidebarTriggerTunnel
  } = useTunnels();
  const renderToolbar = () => {
    return /* @__PURE__ */ (0, import_jsx_runtime73.jsxs)(FixedSideContainer, { side: "top", className: "App-top-bar", children: [
      renderWelcomeScreen && /* @__PURE__ */ (0, import_jsx_runtime73.jsx)(WelcomeScreenCenterTunnel.Out, {}),
      /* @__PURE__ */ (0, import_jsx_runtime73.jsx)(Section, { heading: "shapes", children: (heading) => /* @__PURE__ */ (0, import_jsx_runtime73.jsx)(Stack_default.Col, { gap: 4, align: "center", children: /* @__PURE__ */ (0, import_jsx_runtime73.jsxs)(Stack_default.Row, { gap: 1, className: "App-toolbar-container", children: [
        /* @__PURE__ */ (0, import_jsx_runtime73.jsxs)(Island, { padding: 1, className: "App-toolbar App-toolbar--mobile", children: [
          heading,
          /* @__PURE__ */ (0, import_jsx_runtime73.jsx)(Stack_default.Row, { gap: 1, children: /* @__PURE__ */ (0, import_jsx_runtime73.jsx)(
            ShapesSwitcher,
            {
              appState,
              activeTool: appState.activeTool,
              UIOptions,
              app
            }
          ) })
        ] }),
        renderTopRightUI && renderTopRightUI(true, appState),
        /* @__PURE__ */ (0, import_jsx_runtime73.jsxs)("div", { className: "mobile-misc-tools-container", children: [
          !appState.viewModeEnabled && /* @__PURE__ */ (0, import_jsx_runtime73.jsx)(DefaultSidebarTriggerTunnel.Out, {}),
          /* @__PURE__ */ (0, import_jsx_runtime73.jsx)(
            PenModeButton,
            {
              checked: appState.penMode,
              onChange: () => onPenModeToggle(null),
              title: t("toolBar.penMode"),
              isMobile: true,
              penDetected: appState.penDetected
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime73.jsx)(
            LockButton,
            {
              checked: appState.activeTool.locked,
              onChange: onLockToggle,
              title: t("toolBar.lock"),
              isMobile: true
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime73.jsx)(
            HandButton,
            {
              checked: isHandToolActive(appState),
              onChange: () => onHandToolToggle(),
              title: t("toolBar.hand"),
              isMobile: true
            }
          )
        ] })
      ] }) }) }),
      /* @__PURE__ */ (0, import_jsx_runtime73.jsx)(
        HintViewer,
        {
          appState,
          isMobile: true,
          device,
          app
        }
      )
    ] });
  };
  const renderAppToolbar = () => {
    if (appState.viewModeEnabled) {
      return /* @__PURE__ */ (0, import_jsx_runtime73.jsx)("div", { className: "App-toolbar-content", children: /* @__PURE__ */ (0, import_jsx_runtime73.jsx)(MainMenuTunnel.Out, {}) });
    }
    return /* @__PURE__ */ (0, import_jsx_runtime73.jsxs)("div", { className: "App-toolbar-content", children: [
      /* @__PURE__ */ (0, import_jsx_runtime73.jsx)(MainMenuTunnel.Out, {}),
      actionManager.renderAction("toggleEditMenu"),
      actionManager.renderAction("undo"),
      actionManager.renderAction("redo"),
      actionManager.renderAction(
        appState.multiElement ? "finalize" : "duplicateSelection"
      ),
      actionManager.renderAction("deleteSelectedElements")
    ] });
  };
  return /* @__PURE__ */ (0, import_jsx_runtime73.jsxs)(import_jsx_runtime73.Fragment, { children: [
    renderSidebars(),
    !appState.viewModeEnabled && renderToolbar(),
    !appState.openMenu && appState.showStats && /* @__PURE__ */ (0, import_jsx_runtime73.jsx)(
      Stats,
      {
        appState,
        setAppState,
        elements,
        onClose: () => {
          actionManager.executeAction(actionToggleStats);
        },
        renderCustomStats
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime73.jsx)(
      "div",
      {
        className: "App-bottom-bar",
        style: {
          marginBottom: SCROLLBAR_WIDTH + SCROLLBAR_MARGIN * 2,
          marginLeft: SCROLLBAR_WIDTH + SCROLLBAR_MARGIN * 2,
          marginRight: SCROLLBAR_WIDTH + SCROLLBAR_MARGIN * 2
        },
        children: /* @__PURE__ */ (0, import_jsx_runtime73.jsxs)(Island, { padding: 0, children: [
          appState.openMenu === "shape" && !appState.viewModeEnabled && showSelectedShapeActions(appState, elements) ? /* @__PURE__ */ (0, import_jsx_runtime73.jsx)(Section, { className: "App-mobile-menu", heading: "selectedShapeActions", children: /* @__PURE__ */ (0, import_jsx_runtime73.jsx)(
            SelectedShapeActions,
            {
              appState,
              elementsMap: app.scene.getNonDeletedElementsMap(),
              renderAction: actionManager.renderAction
            }
          ) }) : null,
          /* @__PURE__ */ (0, import_jsx_runtime73.jsxs)("footer", { className: "App-toolbar", children: [
            renderAppToolbar(),
            appState.scrolledOutside && !appState.openMenu && !appState.openSidebar && /* @__PURE__ */ (0, import_jsx_runtime73.jsx)(
              "button",
              {
                className: "scroll-back-to-content",
                onClick: () => {
                  setAppState((appState2) => ({
                    ...calculateScrollCenter(elements, appState2)
                  }));
                },
                children: t("buttons.scrollBackToContent")
              }
            )
          ] })
        ] })
      }
    )
  ] });
};

// components/PasteChartDialog.tsx
init_define_import_meta_env();
var import_react67 = __toESM(require_react(), 1);
var import_jsx_runtime74 = __toESM(require_jsx_runtime(), 1);
var ChartPreviewBtn = (props) => {
  const previewRef = (0, import_react67.useRef)(null);
  const [chartElements, setChartElements] = (0, import_react67.useState)(
    null
  );
  (0, import_react67.useLayoutEffect)(() => {
    if (!props.spreadsheet) {
      return;
    }
    const elements = renderSpreadsheet(
      props.chartType,
      props.spreadsheet,
      0,
      0
    );
    setChartElements(elements);
    let svg;
    const previewNode = previewRef.current;
    (async () => {
      svg = await exportToSvg(
        elements,
        {
          exportBackground: false,
          viewBackgroundColor: open_color_default.white
        },
        null
        // files
      );
      svg.querySelector(".style-fonts")?.remove();
      previewNode.replaceChildren();
      previewNode.appendChild(svg);
      if (props.selected) {
        previewNode.parentNode.focus();
      }
    })();
    return () => {
      previewNode.replaceChildren();
    };
  }, [props.spreadsheet, props.chartType, props.selected]);
  return /* @__PURE__ */ (0, import_jsx_runtime74.jsx)(
    "button",
    {
      className: "ChartPreview",
      onClick: () => {
        if (chartElements) {
          props.onClick(props.chartType, chartElements);
        }
      },
      children: /* @__PURE__ */ (0, import_jsx_runtime74.jsx)("div", { ref: previewRef })
    }
  );
};
var PasteChartDialog = ({
  setAppState,
  appState,
  onClose
}) => {
  const { onInsertElements } = useApp();
  const handleClose = import_react67.default.useCallback(() => {
    if (onClose) {
      onClose();
    }
  }, [onClose]);
  const handleChartClick = (chartType, elements) => {
    onInsertElements(elements);
    trackEvent("paste", "chart", chartType);
    setAppState({
      currentChartType: chartType,
      pasteDialog: {
        shown: false,
        data: null
      }
    });
  };
  return /* @__PURE__ */ (0, import_jsx_runtime74.jsx)(
    Dialog,
    {
      size: "small",
      onCloseRequest: handleClose,
      title: t("labels.pasteCharts"),
      className: "PasteChartDialog",
      autofocus: false,
      children: /* @__PURE__ */ (0, import_jsx_runtime74.jsxs)("div", { className: "container", children: [
        /* @__PURE__ */ (0, import_jsx_runtime74.jsx)(
          ChartPreviewBtn,
          {
            chartType: "bar",
            spreadsheet: appState.pasteDialog.data,
            selected: appState.currentChartType === "bar",
            onClick: handleChartClick
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime74.jsx)(
          ChartPreviewBtn,
          {
            chartType: "line",
            spreadsheet: appState.pasteDialog.data,
            selected: appState.currentChartType === "line",
            onClick: handleChartClick
          }
        )
      ] })
    }
  );
};

// components/HelpDialog.tsx
init_define_import_meta_env();
var import_react68 = __toESM(require_react(), 1);
var import_jsx_runtime75 = __toESM(require_jsx_runtime(), 1);
var Header = () => /* @__PURE__ */ (0, import_jsx_runtime75.jsxs)("div", { className: "HelpDialog__header", children: [
  /* @__PURE__ */ (0, import_jsx_runtime75.jsxs)(
    "a",
    {
      className: "HelpDialog__btn",
      href: "https://docs.excalidraw.com",
      target: "_blank",
      rel: "noopener noreferrer",
      children: [
        t("helpDialog.documentation"),
        /* @__PURE__ */ (0, import_jsx_runtime75.jsx)("div", { className: "HelpDialog__link-icon", children: ExternalLinkIcon })
      ]
    }
  ),
  /* @__PURE__ */ (0, import_jsx_runtime75.jsxs)(
    "a",
    {
      className: "HelpDialog__btn",
      href: "https://blog.excalidraw.com",
      target: "_blank",
      rel: "noopener noreferrer",
      children: [
        t("helpDialog.blog"),
        /* @__PURE__ */ (0, import_jsx_runtime75.jsx)("div", { className: "HelpDialog__link-icon", children: ExternalLinkIcon })
      ]
    }
  ),
  /* @__PURE__ */ (0, import_jsx_runtime75.jsxs)(
    "a",
    {
      className: "HelpDialog__btn",
      href: "https://github.com/excalidraw/excalidraw/issues",
      target: "_blank",
      rel: "noopener noreferrer",
      children: [
        t("helpDialog.github"),
        /* @__PURE__ */ (0, import_jsx_runtime75.jsx)("div", { className: "HelpDialog__link-icon", children: ExternalLinkIcon })
      ]
    }
  )
] });
var Section2 = (props) => /* @__PURE__ */ (0, import_jsx_runtime75.jsxs)(import_jsx_runtime75.Fragment, { children: [
  /* @__PURE__ */ (0, import_jsx_runtime75.jsx)("h3", { children: props.title }),
  /* @__PURE__ */ (0, import_jsx_runtime75.jsx)("div", { className: "HelpDialog__islands-container", children: props.children })
] });
var ShortcutIsland = (props) => /* @__PURE__ */ (0, import_jsx_runtime75.jsxs)("div", { className: `HelpDialog__island ${props.className}`, children: [
  /* @__PURE__ */ (0, import_jsx_runtime75.jsx)("h4", { className: "HelpDialog__island-title", children: props.caption }),
  /* @__PURE__ */ (0, import_jsx_runtime75.jsx)("div", { className: "HelpDialog__island-content", children: props.children })
] });
function* intersperse(as, delim) {
  let first = true;
  for (const x3 of as) {
    if (!first) {
      yield delim;
    }
    first = false;
    yield x3;
  }
}
var upperCaseSingleChars = (str) => {
  return str.replace(/\b[a-z]\b/, (c3) => c3.toUpperCase());
};
var Shortcut = ({
  label,
  shortcuts,
  isOr = true
}) => {
  const splitShortcutKeys = shortcuts.map((shortcut) => {
    const keys = shortcut.endsWith("++") ? [...shortcut.slice(0, -2).split("+"), "+"] : shortcut.split("+");
    return keys.map((key) => /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(ShortcutKey, { children: upperCaseSingleChars(key) }, key));
  });
  return /* @__PURE__ */ (0, import_jsx_runtime75.jsxs)("div", { className: "HelpDialog__shortcut", children: [
    /* @__PURE__ */ (0, import_jsx_runtime75.jsx)("div", { children: label }),
    /* @__PURE__ */ (0, import_jsx_runtime75.jsx)("div", { className: "HelpDialog__key-container", children: [...intersperse(splitShortcutKeys, isOr ? t("helpDialog.or") : null)] })
  ] });
};
var ShortcutKey = (props) => /* @__PURE__ */ (0, import_jsx_runtime75.jsx)("kbd", { className: "HelpDialog__key", ...props });
var HelpDialog = ({ onClose }) => {
  const handleClose = import_react68.default.useCallback(() => {
    if (onClose) {
      onClose();
    }
  }, [onClose]);
  return /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(import_jsx_runtime75.Fragment, { children: /* @__PURE__ */ (0, import_jsx_runtime75.jsxs)(
    Dialog,
    {
      onCloseRequest: handleClose,
      title: t("helpDialog.title"),
      className: "HelpDialog",
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(Header, {}),
        /* @__PURE__ */ (0, import_jsx_runtime75.jsxs)(Section2, { title: t("helpDialog.shortcuts"), children: [
          /* @__PURE__ */ (0, import_jsx_runtime75.jsxs)(
            ShortcutIsland,
            {
              className: "HelpDialog__island--tools",
              caption: t("helpDialog.tools"),
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(Shortcut, { label: t("toolBar.hand"), shortcuts: [KEYS.H] }),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("toolBar.selection"),
                    shortcuts: [KEYS.V, KEYS["1"]]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("toolBar.rectangle"),
                    shortcuts: [KEYS.R, KEYS["2"]]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("toolBar.diamond"),
                    shortcuts: [KEYS.D, KEYS["3"]]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("toolBar.ellipse"),
                    shortcuts: [KEYS.O, KEYS["4"]]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("toolBar.arrow"),
                    shortcuts: [KEYS.A, KEYS["5"]]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("toolBar.line"),
                    shortcuts: [KEYS.L, KEYS["6"]]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("toolBar.freedraw"),
                    shortcuts: [KEYS.P, KEYS["7"]]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("toolBar.text"),
                    shortcuts: [KEYS.T, KEYS["8"]]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(Shortcut, { label: t("toolBar.image"), shortcuts: [KEYS["9"]] }),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("toolBar.eraser"),
                    shortcuts: [KEYS.E, KEYS["0"]]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(Shortcut, { label: t("toolBar.frame"), shortcuts: [KEYS.F] }),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(Shortcut, { label: t("toolBar.laser"), shortcuts: [KEYS.K] }),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("labels.eyeDropper"),
                    shortcuts: [KEYS.I, "Shift+S", "Shift+G"]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("helpDialog.editLineArrowPoints"),
                    shortcuts: [getShortcutKey("CtrlOrCmd+Enter")]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("helpDialog.editText"),
                    shortcuts: [getShortcutKey("Enter")]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("helpDialog.textNewLine"),
                    shortcuts: [
                      getShortcutKey("Enter"),
                      getShortcutKey("Shift+Enter")
                    ]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("helpDialog.textFinish"),
                    shortcuts: [
                      getShortcutKey("Esc"),
                      getShortcutKey("CtrlOrCmd+Enter")
                    ]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("helpDialog.curvedArrow"),
                    shortcuts: [
                      "A",
                      t("helpDialog.click"),
                      t("helpDialog.click"),
                      t("helpDialog.click")
                    ],
                    isOr: false
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("helpDialog.curvedLine"),
                    shortcuts: [
                      "L",
                      t("helpDialog.click"),
                      t("helpDialog.click"),
                      t("helpDialog.click")
                    ],
                    isOr: false
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(Shortcut, { label: t("toolBar.lock"), shortcuts: [KEYS.Q] }),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("helpDialog.preventBinding"),
                    shortcuts: [getShortcutKey("CtrlOrCmd")]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("toolBar.link"),
                    shortcuts: [getShortcutKey("CtrlOrCmd+K")]
                  }
                )
              ]
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime75.jsxs)(
            ShortcutIsland,
            {
              className: "HelpDialog__island--view",
              caption: t("helpDialog.view"),
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("buttons.zoomIn"),
                    shortcuts: [getShortcutKey("CtrlOrCmd++")]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("buttons.zoomOut"),
                    shortcuts: [getShortcutKey("CtrlOrCmd+-")]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("buttons.resetZoom"),
                    shortcuts: [getShortcutKey("CtrlOrCmd+0")]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("helpDialog.zoomToFit"),
                    shortcuts: ["Shift+1"]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("helpDialog.zoomToSelection"),
                    shortcuts: ["Shift+2"]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("helpDialog.movePageUpDown"),
                    shortcuts: ["PgUp/PgDn"]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("helpDialog.movePageLeftRight"),
                    shortcuts: ["Shift+PgUp/PgDn"]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("buttons.zenMode"),
                    shortcuts: [getShortcutKey("Alt+Z")]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("buttons.objectsSnapMode"),
                    shortcuts: [getShortcutKey("Alt+S")]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("labels.showGrid"),
                    shortcuts: [getShortcutKey("CtrlOrCmd+'")]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("labels.viewMode"),
                    shortcuts: [getShortcutKey("Alt+R")]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("labels.toggleTheme"),
                    shortcuts: [getShortcutKey("Alt+Shift+D")]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("stats.title"),
                    shortcuts: [getShortcutKey("Alt+/")]
                  }
                )
              ]
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime75.jsxs)(
            ShortcutIsland,
            {
              className: "HelpDialog__island--editor",
              caption: t("helpDialog.editor"),
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("labels.moveCanvas"),
                    shortcuts: [
                      getShortcutKey(`Space+${t("helpDialog.drag")}`),
                      getShortcutKey(`Wheel+${t("helpDialog.drag")}`)
                    ],
                    isOr: true
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("buttons.clearReset"),
                    shortcuts: [getShortcutKey("CtrlOrCmd+Delete")]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("labels.delete"),
                    shortcuts: [getShortcutKey("Delete")]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("labels.cut"),
                    shortcuts: [getShortcutKey("CtrlOrCmd+X")]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("labels.copy"),
                    shortcuts: [getShortcutKey("CtrlOrCmd+C")]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("labels.paste"),
                    shortcuts: [getShortcutKey("CtrlOrCmd+V")]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("labels.pasteAsPlaintext"),
                    shortcuts: [getShortcutKey("CtrlOrCmd+Shift+V")]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("labels.selectAll"),
                    shortcuts: [getShortcutKey("CtrlOrCmd+A")]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("labels.multiSelect"),
                    shortcuts: [getShortcutKey(`Shift+${t("helpDialog.click")}`)]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("helpDialog.deepSelect"),
                    shortcuts: [getShortcutKey(`CtrlOrCmd+${t("helpDialog.click")}`)]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("helpDialog.deepBoxSelect"),
                    shortcuts: [getShortcutKey(`CtrlOrCmd+${t("helpDialog.drag")}`)]
                  }
                ),
                (probablySupportsClipboardBlob || isFirefox) && /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("labels.copyAsPng"),
                    shortcuts: [getShortcutKey("Shift+Alt+C")]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("labels.copyStyles"),
                    shortcuts: [getShortcutKey("CtrlOrCmd+Alt+C")]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("labels.pasteStyles"),
                    shortcuts: [getShortcutKey("CtrlOrCmd+Alt+V")]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("labels.sendToBack"),
                    shortcuts: [
                      isDarwin ? getShortcutKey("CtrlOrCmd+Alt+[") : getShortcutKey("CtrlOrCmd+Shift+[")
                    ]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("labels.bringToFront"),
                    shortcuts: [
                      isDarwin ? getShortcutKey("CtrlOrCmd+Alt+]") : getShortcutKey("CtrlOrCmd+Shift+]")
                    ]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("labels.sendBackward"),
                    shortcuts: [getShortcutKey("CtrlOrCmd+[")]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("labels.bringForward"),
                    shortcuts: [getShortcutKey("CtrlOrCmd+]")]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("labels.alignTop"),
                    shortcuts: [getShortcutKey("CtrlOrCmd+Shift+Up")]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("labels.alignBottom"),
                    shortcuts: [getShortcutKey("CtrlOrCmd+Shift+Down")]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("labels.alignLeft"),
                    shortcuts: [getShortcutKey("CtrlOrCmd+Shift+Left")]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("labels.alignRight"),
                    shortcuts: [getShortcutKey("CtrlOrCmd+Shift+Right")]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("labels.duplicateSelection"),
                    shortcuts: [
                      getShortcutKey("CtrlOrCmd+D"),
                      getShortcutKey(`Alt+${t("helpDialog.drag")}`)
                    ]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("helpDialog.toggleElementLock"),
                    shortcuts: [getShortcutKey("CtrlOrCmd+Shift+L")]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("buttons.undo"),
                    shortcuts: [getShortcutKey("CtrlOrCmd+Z")]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("buttons.redo"),
                    shortcuts: isWindows ? [
                      getShortcutKey("CtrlOrCmd+Y"),
                      getShortcutKey("CtrlOrCmd+Shift+Z")
                    ] : [getShortcutKey("CtrlOrCmd+Shift+Z")]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("labels.group"),
                    shortcuts: [getShortcutKey("CtrlOrCmd+G")]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("labels.ungroup"),
                    shortcuts: [getShortcutKey("CtrlOrCmd+Shift+G")]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("labels.flipHorizontal"),
                    shortcuts: [getShortcutKey("Shift+H")]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("labels.flipVertical"),
                    shortcuts: [getShortcutKey("Shift+V")]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("labels.showStroke"),
                    shortcuts: [getShortcutKey("S")]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("labels.showBackground"),
                    shortcuts: [getShortcutKey("G")]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("labels.decreaseFontSize"),
                    shortcuts: [getShortcutKey("CtrlOrCmd+Shift+<")]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
                  Shortcut,
                  {
                    label: t("labels.increaseFontSize"),
                    shortcuts: [getShortcutKey("CtrlOrCmd+Shift+>")]
                  }
                )
              ]
            }
          )
        ] })
      ]
    }
  ) });
};

// components/UserList.tsx
init_define_import_meta_env();
var import_react69 = __toESM(require_react(), 1);
var import_jsx_runtime76 = __toESM(require_jsx_runtime(), 1);
var FIRST_N_AVATARS = 3;
var SHOW_COLLABORATORS_FILTER_AT = 8;
var ConditionalTooltipWrapper = ({
  shouldWrap,
  children,
  clientId,
  username
}) => shouldWrap ? /* @__PURE__ */ (0, import_jsx_runtime76.jsx)(Tooltip, { label: username || "Unknown user", children }, clientId) : /* @__PURE__ */ (0, import_jsx_runtime76.jsx)(import_react69.default.Fragment, { children }, clientId);
var renderCollaborator = ({
  actionManager,
  collaborator,
  clientId,
  withName = false,
  shouldWrapWithTooltip = false,
  isBeingFollowed
}) => {
  const data = {
    clientId,
    collaborator,
    withName,
    isBeingFollowed
  };
  const avatarJSX = actionManager.renderAction("goToCollaborator", data);
  return /* @__PURE__ */ (0, import_jsx_runtime76.jsx)(
    ConditionalTooltipWrapper,
    {
      clientId,
      username: collaborator.username,
      shouldWrap: shouldWrapWithTooltip,
      children: avatarJSX
    },
    clientId
  );
};
var collaboratorComparatorKeys = [
  "avatarUrl",
  "id",
  "socketId",
  "username"
];
var UserList = import_react69.default.memo(
  ({ className, mobile, collaborators, userToFollow }) => {
    const actionManager = useExcalidrawActionManager();
    const uniqueCollaboratorsMap = /* @__PURE__ */ new Map();
    collaborators.forEach((collaborator, socketId) => {
      const userId = collaborator.id || socketId;
      uniqueCollaboratorsMap.set(
        // filter on user id, else fall back on unique socketId
        userId,
        { ...collaborator, socketId }
      );
    });
    const uniqueCollaboratorsArray = Array.from(uniqueCollaboratorsMap).filter(
      ([_, collaborator]) => collaborator.username?.trim()
    );
    const [searchTerm, setSearchTerm] = import_react69.default.useState("");
    if (uniqueCollaboratorsArray.length === 0) {
      return null;
    }
    const searchTermNormalized = searchTerm.trim().toLowerCase();
    const filteredCollaborators = searchTermNormalized ? uniqueCollaboratorsArray.filter(
      ([, collaborator]) => collaborator.username?.toLowerCase().includes(searchTerm)
    ) : uniqueCollaboratorsArray;
    const firstNCollaborators = uniqueCollaboratorsArray.slice(
      0,
      FIRST_N_AVATARS
    );
    const firstNAvatarsJSX = firstNCollaborators.map(
      ([clientId, collaborator]) => renderCollaborator({
        actionManager,
        collaborator,
        clientId,
        shouldWrapWithTooltip: true,
        isBeingFollowed: collaborator.socketId === userToFollow
      })
    );
    return mobile ? /* @__PURE__ */ (0, import_jsx_runtime76.jsx)("div", { className: clsx_m_default("UserList UserList_mobile", className), children: uniqueCollaboratorsArray.map(
      ([clientId, collaborator]) => renderCollaborator({
        actionManager,
        collaborator,
        clientId,
        shouldWrapWithTooltip: true,
        isBeingFollowed: collaborator.socketId === userToFollow
      })
    ) }) : /* @__PURE__ */ (0, import_jsx_runtime76.jsxs)("div", { className: clsx_m_default("UserList", className), children: [
      firstNAvatarsJSX,
      uniqueCollaboratorsArray.length > FIRST_N_AVATARS && /* @__PURE__ */ (0, import_jsx_runtime76.jsxs)(
        $cb5cc270b50c6fcd$export$be92b6f5f03c0fe9,
        {
          onOpenChange: (isOpen) => {
            if (!isOpen) {
              setSearchTerm("");
            }
          },
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime76.jsxs)($cb5cc270b50c6fcd$export$41fb9f06171c75f4, { className: "UserList__more", children: [
              "+",
              uniqueCollaboratorsArray.length - FIRST_N_AVATARS
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime76.jsx)(
              $cb5cc270b50c6fcd$export$7c6e2c02157bb7d2,
              {
                style: {
                  zIndex: 2,
                  width: "13rem",
                  textAlign: "left"
                },
                align: "end",
                sideOffset: 10,
                children: /* @__PURE__ */ (0, import_jsx_runtime76.jsxs)(Island, { style: { overflow: "hidden" }, children: [
                  uniqueCollaboratorsArray.length >= SHOW_COLLABORATORS_FILTER_AT && /* @__PURE__ */ (0, import_jsx_runtime76.jsxs)("div", { className: "UserList__search-wrapper", children: [
                    searchIcon,
                    /* @__PURE__ */ (0, import_jsx_runtime76.jsx)(
                      "input",
                      {
                        className: "UserList__search",
                        type: "text",
                        placeholder: t("userList.search.placeholder"),
                        value: searchTerm,
                        onChange: (e3) => {
                          setSearchTerm(e3.target.value);
                        }
                      }
                    )
                  ] }),
                  /* @__PURE__ */ (0, import_jsx_runtime76.jsxs)("div", { className: "dropdown-menu UserList__collaborators", children: [
                    filteredCollaborators.length === 0 && /* @__PURE__ */ (0, import_jsx_runtime76.jsx)("div", { className: "UserList__collaborators__empty", children: t("userList.search.empty") }),
                    /* @__PURE__ */ (0, import_jsx_runtime76.jsx)("div", { className: "UserList__hint", children: t("userList.hint.text") }),
                    filteredCollaborators.map(
                      ([clientId, collaborator]) => renderCollaborator({
                        actionManager,
                        collaborator,
                        clientId,
                        withName: true,
                        isBeingFollowed: collaborator.socketId === userToFollow
                      })
                    )
                  ] })
                ] })
              }
            )
          ]
        }
      )
    ] });
  },
  (prev, next) => {
    if (prev.collaborators.size !== next.collaborators.size || prev.mobile !== next.mobile || prev.className !== next.className || prev.userToFollow !== next.userToFollow) {
      return false;
    }
    for (const [socketId, collaborator] of prev.collaborators) {
      const nextCollaborator = next.collaborators.get(socketId);
      if (!nextCollaborator || !isShallowEqual(
        collaborator,
        nextCollaborator,
        collaboratorComparatorKeys
      )) {
        return false;
      }
    }
    return true;
  }
);

// components/JSONExportDialog.tsx
init_define_import_meta_env();
var import_react70 = __toESM(require_react(), 1);

// components/Card.tsx
init_define_import_meta_env();
var import_jsx_runtime77 = __toESM(require_jsx_runtime(), 1);
var Card = ({ children, color }) => {
  return /* @__PURE__ */ (0, import_jsx_runtime77.jsx)(
    "div",
    {
      className: "Card",
      style: {
        ["--card-color"]: color === "primary" ? "var(--color-primary)" : open_color_default[color][7],
        ["--card-color-darker"]: color === "primary" ? "var(--color-primary-darker)" : open_color_default[color][8],
        ["--card-color-darkest"]: color === "primary" ? "var(--color-primary-darkest)" : open_color_default[color][9]
      },
      children
    }
  );
};

// components/JSONExportDialog.tsx
var import_jsx_runtime78 = __toESM(require_jsx_runtime(), 1);
var JSONExportModal = ({
  elements,
  appState,
  setAppState,
  files,
  actionManager,
  exportOpts,
  canvas: canvas2,
  onCloseRequest
}) => {
  const { onExportToBackend } = exportOpts;
  return /* @__PURE__ */ (0, import_jsx_runtime78.jsx)("div", { className: "ExportDialog ExportDialog--json", children: /* @__PURE__ */ (0, import_jsx_runtime78.jsxs)("div", { className: "ExportDialog-cards", children: [
    exportOpts.saveFileToDisk && /* @__PURE__ */ (0, import_jsx_runtime78.jsxs)(Card, { color: "lime", children: [
      /* @__PURE__ */ (0, import_jsx_runtime78.jsx)("div", { className: "Card-icon", children: exportToFileIcon }),
      /* @__PURE__ */ (0, import_jsx_runtime78.jsx)("h2", { children: t("exportDialog.disk_title") }),
      /* @__PURE__ */ (0, import_jsx_runtime78.jsxs)("div", { className: "Card-details", children: [
        t("exportDialog.disk_details"),
        !e2 && actionManager.renderAction("changeProjectName")
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime78.jsx)(
        ToolButton,
        {
          className: "Card-button",
          type: "button",
          title: t("exportDialog.disk_button"),
          "aria-label": t("exportDialog.disk_button"),
          showAriaLabel: true,
          onClick: () => {
            actionManager.executeAction(actionSaveFileToDisk, "ui");
          }
        }
      )
    ] }),
    onExportToBackend && /* @__PURE__ */ (0, import_jsx_runtime78.jsxs)(Card, { color: "pink", children: [
      /* @__PURE__ */ (0, import_jsx_runtime78.jsx)("div", { className: "Card-icon", children: LinkIcon }),
      /* @__PURE__ */ (0, import_jsx_runtime78.jsx)("h2", { children: t("exportDialog.link_title") }),
      /* @__PURE__ */ (0, import_jsx_runtime78.jsx)("div", { className: "Card-details", children: t("exportDialog.link_details") }),
      /* @__PURE__ */ (0, import_jsx_runtime78.jsx)(
        ToolButton,
        {
          className: "Card-button",
          type: "button",
          title: t("exportDialog.link_button"),
          "aria-label": t("exportDialog.link_button"),
          showAriaLabel: true,
          onClick: async () => {
            try {
              trackEvent("export", "link", `ui (${getFrame()})`);
              await onExportToBackend(elements, appState, files);
              onCloseRequest();
            } catch (error) {
              setAppState({ errorMessage: error.message });
            }
          }
        }
      )
    ] }),
    exportOpts.renderCustomUI && exportOpts.renderCustomUI(elements, appState, files, canvas2)
  ] }) });
};
var JSONExportDialog = ({
  elements,
  appState,
  files,
  actionManager,
  exportOpts,
  canvas: canvas2,
  setAppState
}) => {
  const handleClose = import_react70.default.useCallback(() => {
    setAppState({ openDialog: null });
  }, [setAppState]);
  return /* @__PURE__ */ (0, import_jsx_runtime78.jsx)(import_jsx_runtime78.Fragment, { children: appState.openDialog?.name === "jsonExport" && /* @__PURE__ */ (0, import_jsx_runtime78.jsx)(Dialog, { onCloseRequest: handleClose, title: t("buttons.export"), children: /* @__PURE__ */ (0, import_jsx_runtime78.jsx)(
    JSONExportModal,
    {
      elements,
      appState,
      setAppState,
      files,
      actionManager,
      onCloseRequest: handleClose,
      exportOpts,
      canvas: canvas2
    }
  ) }) });
};

// components/footer/Footer.tsx
init_define_import_meta_env();

// components/HelpButton.tsx
init_define_import_meta_env();
var import_jsx_runtime79 = __toESM(require_jsx_runtime(), 1);
var HelpButton = (props) => /* @__PURE__ */ (0, import_jsx_runtime79.jsx)(
  "button",
  {
    className: "help-icon",
    onClick: props.onClick,
    type: "button",
    title: `${t("helpDialog.title")} \u2014 ?`,
    "aria-label": t("helpDialog.title"),
    children: HelpIcon
  }
);

// components/footer/Footer.tsx
var import_jsx_runtime80 = __toESM(require_jsx_runtime(), 1);
var Footer = ({
  appState,
  actionManager,
  showExitZenModeBtn,
  renderWelcomeScreen
}) => {
  const { FooterCenterTunnel, WelcomeScreenHelpHintTunnel } = useTunnels();
  const device = useDevice();
  const showFinalize = !appState.viewModeEnabled && appState.multiElement && device.isTouchScreen;
  return /* @__PURE__ */ (0, import_jsx_runtime80.jsxs)(
    "footer",
    {
      role: "contentinfo",
      className: "layer-ui__wrapper__footer App-menu App-menu_bottom",
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime80.jsx)(
          "div",
          {
            className: clsx_m_default("layer-ui__wrapper__footer-left zen-mode-transition", {
              "layer-ui__wrapper__footer-left--transition-left": appState.zenModeEnabled
            }),
            children: /* @__PURE__ */ (0, import_jsx_runtime80.jsx)(Stack_default.Col, { gap: 2, children: /* @__PURE__ */ (0, import_jsx_runtime80.jsxs)(Section, { heading: "canvasActions", children: [
              /* @__PURE__ */ (0, import_jsx_runtime80.jsx)(
                ZoomActions,
                {
                  renderAction: actionManager.renderAction,
                  zoom: appState.zoom
                }
              ),
              !appState.viewModeEnabled && /* @__PURE__ */ (0, import_jsx_runtime80.jsx)(
                UndoRedoActions,
                {
                  renderAction: actionManager.renderAction,
                  className: clsx_m_default("zen-mode-transition", {
                    "layer-ui__wrapper__footer-left--transition-bottom": appState.zenModeEnabled
                  })
                }
              ),
              showFinalize && /* @__PURE__ */ (0, import_jsx_runtime80.jsx)(
                FinalizeAction,
                {
                  renderAction: actionManager.renderAction,
                  className: clsx_m_default("zen-mode-transition", {
                    "layer-ui__wrapper__footer-left--transition-left": appState.zenModeEnabled
                  })
                }
              )
            ] }) })
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime80.jsx)(FooterCenterTunnel.Out, {}),
        /* @__PURE__ */ (0, import_jsx_runtime80.jsx)(
          "div",
          {
            className: clsx_m_default("layer-ui__wrapper__footer-right zen-mode-transition", {
              "transition-right": appState.zenModeEnabled
            }),
            children: /* @__PURE__ */ (0, import_jsx_runtime80.jsxs)("div", { style: { position: "relative" }, children: [
              renderWelcomeScreen && /* @__PURE__ */ (0, import_jsx_runtime80.jsx)(WelcomeScreenHelpHintTunnel.Out, {}),
              /* @__PURE__ */ (0, import_jsx_runtime80.jsx)(
                HelpButton,
                {
                  onClick: () => actionManager.executeAction(actionShortcuts)
                }
              )
            ] })
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime80.jsx)(
          ExitZenModeAction,
          {
            actionManager,
            showExitZenModeBtn
          }
        )
      ]
    }
  );
};
var Footer_default = Footer;
Footer.displayName = "Footer";

// components/Sidebar/Sidebar.tsx
init_define_import_meta_env();
var import_react77 = __toESM(require_react(), 1);

// components/Sidebar/common.ts
init_define_import_meta_env();
var import_react71 = __toESM(require_react(), 1);
var SidebarPropsContext = import_react71.default.createContext({});

// components/Sidebar/SidebarHeader.tsx
init_define_import_meta_env();
var import_react72 = __toESM(require_react(), 1);

// components/Button.tsx
init_define_import_meta_env();
var import_jsx_runtime81 = __toESM(require_jsx_runtime(), 1);
var Button = ({
  type = "button",
  onSelect,
  selected,
  children,
  className = "",
  ...rest
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime81.jsx)(
    "button",
    {
      onClick: composeEventHandlers(rest.onClick, (event) => {
        onSelect();
      }),
      type,
      className: clsx_m_default("excalidraw-button", className, { selected }),
      ...rest,
      children
    }
  );
};

// components/Sidebar/SidebarHeader.tsx
var import_jsx_runtime82 = __toESM(require_jsx_runtime(), 1);
var SidebarHeader = ({
  children,
  className
}) => {
  const device = useDevice();
  const props = (0, import_react72.useContext)(SidebarPropsContext);
  const renderDockButton = !!(device.editor.canFitSidebar && props.shouldRenderDockButton);
  return /* @__PURE__ */ (0, import_jsx_runtime82.jsxs)(
    "div",
    {
      className: clsx_m_default("sidebar__header", className),
      "data-testid": "sidebar-header",
      children: [
        children,
        /* @__PURE__ */ (0, import_jsx_runtime82.jsxs)("div", { className: "sidebar__header__buttons", children: [
          renderDockButton && /* @__PURE__ */ (0, import_jsx_runtime82.jsx)(Tooltip, { label: t("labels.sidebarLock"), children: /* @__PURE__ */ (0, import_jsx_runtime82.jsx)(
            Button,
            {
              onSelect: () => props.onDock?.(!props.docked),
              selected: !!props.docked,
              className: "sidebar__dock",
              "data-testid": "sidebar-dock",
              "aria-label": t("labels.sidebarLock"),
              children: PinIcon
            }
          ) }),
          /* @__PURE__ */ (0, import_jsx_runtime82.jsx)(
            Button,
            {
              "data-testid": "sidebar-close",
              className: "sidebar__close",
              onSelect: props.onCloseRequest,
              "aria-label": t("buttons.close"),
              children: CloseIcon
            }
          )
        ] })
      ]
    }
  );
};
SidebarHeader.displayName = "SidebarHeader";

// components/Sidebar/SidebarTrigger.tsx
init_define_import_meta_env();
var import_jsx_runtime83 = __toESM(require_jsx_runtime(), 1);
var SidebarTrigger = ({
  name,
  tab,
  icon,
  title,
  children,
  onToggle,
  className,
  style
}) => {
  const setAppState = useExcalidrawSetAppState();
  const appState = useUIAppState();
  return /* @__PURE__ */ (0, import_jsx_runtime83.jsxs)("label", { title, className: "sidebar-trigger__label-element", children: [
    /* @__PURE__ */ (0, import_jsx_runtime83.jsx)(
      "input",
      {
        className: "ToolIcon_type_checkbox",
        type: "checkbox",
        onChange: (event) => {
          document.querySelector(".layer-ui__wrapper")?.classList.remove("animate");
          const isOpen = event.target.checked;
          setAppState({ openSidebar: isOpen ? { name, tab } : null });
          onToggle?.(isOpen);
        },
        checked: appState.openSidebar?.name === name,
        "aria-label": title,
        "aria-keyshortcuts": "0"
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime83.jsxs)("div", { className: clsx_m_default("sidebar-trigger", className), style, children: [
      icon && /* @__PURE__ */ (0, import_jsx_runtime83.jsx)("div", { children: icon }),
      children && /* @__PURE__ */ (0, import_jsx_runtime83.jsx)("div", { className: "sidebar-trigger__label", children })
    ] })
  ] });
};
SidebarTrigger.displayName = "SidebarTrigger";

// components/Sidebar/SidebarTabTriggers.tsx
init_define_import_meta_env();

// ../../node_modules/@radix-ui/react-tabs/dist/index.module.js
init_define_import_meta_env();
var import_react76 = __toESM(require_react());

// ../../node_modules/@radix-ui/react-roving-focus/dist/index.module.js
init_define_import_meta_env();
var import_react75 = __toESM(require_react());

// ../../node_modules/@radix-ui/react-collection/dist/index.module.js
init_define_import_meta_env();
var import_react73 = __toESM(require_react());
function $e02a7d9cb1dc128c$export$c74125a8e3af6bb2(name) {
  const PROVIDER_NAME = name + "CollectionProvider";
  const [createCollectionContext, createCollectionScope] = $c512c27ab02ef895$export$50c7b4e9d9f19c1(PROVIDER_NAME);
  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext(PROVIDER_NAME, {
    collectionRef: {
      current: null
    },
    itemMap: /* @__PURE__ */ new Map()
  });
  const CollectionProvider = (props) => {
    const { scope, children } = props;
    const ref = import_react73.default.useRef(null);
    const itemMap = import_react73.default.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ import_react73.default.createElement(CollectionProviderImpl, {
      scope,
      itemMap,
      collectionRef: ref
    }, children);
  };
  /* @__PURE__ */ Object.assign(CollectionProvider, {
    displayName: PROVIDER_NAME
  });
  const COLLECTION_SLOT_NAME = name + "CollectionSlot";
  const CollectionSlot = /* @__PURE__ */ import_react73.default.forwardRef((props, forwardedRef) => {
    const { scope, children } = props;
    const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, context.collectionRef);
    return /* @__PURE__ */ import_react73.default.createElement($5e63c961fc1ce211$export$8c6ed5c666ac1360, {
      ref: composedRefs
    }, children);
  });
  /* @__PURE__ */ Object.assign(CollectionSlot, {
    displayName: COLLECTION_SLOT_NAME
  });
  const ITEM_SLOT_NAME = name + "CollectionItemSlot";
  const ITEM_DATA_ATTR = "data-radix-collection-item";
  const CollectionItemSlot = /* @__PURE__ */ import_react73.default.forwardRef((props, forwardedRef) => {
    const { scope, children, ...itemData } = props;
    const ref = import_react73.default.useRef(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
    const context = useCollectionContext(ITEM_SLOT_NAME, scope);
    import_react73.default.useEffect(() => {
      context.itemMap.set(ref, {
        ref,
        ...itemData
      });
      return () => void context.itemMap.delete(ref);
    });
    return /* @__PURE__ */ import_react73.default.createElement($5e63c961fc1ce211$export$8c6ed5c666ac1360, {
      [ITEM_DATA_ATTR]: "",
      ref: composedRefs
    }, children);
  });
  /* @__PURE__ */ Object.assign(CollectionItemSlot, {
    displayName: ITEM_SLOT_NAME
  });
  function useCollection(scope) {
    const context = useCollectionContext(name + "CollectionConsumer", scope);
    const getItems = import_react73.default.useCallback(() => {
      const collectionNode = context.collectionRef.current;
      if (!collectionNode)
        return [];
      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));
      const items = Array.from(context.itemMap.values());
      const orderedItems = items.sort(
        (a4, b4) => orderedNodes.indexOf(a4.ref.current) - orderedNodes.indexOf(b4.ref.current)
      );
      return orderedItems;
    }, [
      context.collectionRef,
      context.itemMap
    ]);
    return getItems;
  }
  return [
    {
      Provider: CollectionProvider,
      Slot: CollectionSlot,
      ItemSlot: CollectionItemSlot
    },
    useCollection,
    createCollectionScope
  ];
}

// ../../node_modules/@radix-ui/react-direction/dist/index.module.js
init_define_import_meta_env();
var import_react74 = __toESM(require_react());
var $f631663db3294ace$var$DirectionContext = /* @__PURE__ */ (0, import_react74.createContext)(void 0);
function $f631663db3294ace$export$b39126d51d94e6f3(localDir) {
  const globalDir = (0, import_react74.useContext)($f631663db3294ace$var$DirectionContext);
  return localDir || globalDir || "ltr";
}

// ../../node_modules/@radix-ui/react-roving-focus/dist/index.module.js
var $d7bdfb9eb0fdf311$var$ENTRY_FOCUS = "rovingFocusGroup.onEntryFocus";
var $d7bdfb9eb0fdf311$var$EVENT_OPTIONS = {
  bubbles: false,
  cancelable: true
};
var $d7bdfb9eb0fdf311$var$GROUP_NAME = "RovingFocusGroup";
var [$d7bdfb9eb0fdf311$var$Collection, $d7bdfb9eb0fdf311$var$useCollection, $d7bdfb9eb0fdf311$var$createCollectionScope] = $e02a7d9cb1dc128c$export$c74125a8e3af6bb2($d7bdfb9eb0fdf311$var$GROUP_NAME);
var [$d7bdfb9eb0fdf311$var$createRovingFocusGroupContext, $d7bdfb9eb0fdf311$export$c7109489551a4f4] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($d7bdfb9eb0fdf311$var$GROUP_NAME, [
  $d7bdfb9eb0fdf311$var$createCollectionScope
]);
var [$d7bdfb9eb0fdf311$var$RovingFocusProvider, $d7bdfb9eb0fdf311$var$useRovingFocusContext] = $d7bdfb9eb0fdf311$var$createRovingFocusGroupContext($d7bdfb9eb0fdf311$var$GROUP_NAME);
var $d7bdfb9eb0fdf311$export$8699f7c8af148338 = /* @__PURE__ */ (0, import_react75.forwardRef)((props, forwardedRef) => {
  return /* @__PURE__ */ (0, import_react75.createElement)($d7bdfb9eb0fdf311$var$Collection.Provider, {
    scope: props.__scopeRovingFocusGroup
  }, /* @__PURE__ */ (0, import_react75.createElement)($d7bdfb9eb0fdf311$var$Collection.Slot, {
    scope: props.__scopeRovingFocusGroup
  }, /* @__PURE__ */ (0, import_react75.createElement)($d7bdfb9eb0fdf311$var$RovingFocusGroupImpl, _extends({}, props, {
    ref: forwardedRef
  }))));
});
var $d7bdfb9eb0fdf311$var$RovingFocusGroupImpl = /* @__PURE__ */ (0, import_react75.forwardRef)((props, forwardedRef) => {
  const { __scopeRovingFocusGroup, orientation, loop = false, dir, currentTabStopId: currentTabStopIdProp, defaultCurrentTabStopId, onCurrentTabStopIdChange, onEntryFocus, ...groupProps } = props;
  const ref = (0, import_react75.useRef)(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
  const direction = $f631663db3294ace$export$b39126d51d94e6f3(dir);
  const [currentTabStopId = null, setCurrentTabStopId] = $71cd76cc60e0454e$export$6f32135080cb4c3({
    prop: currentTabStopIdProp,
    defaultProp: defaultCurrentTabStopId,
    onChange: onCurrentTabStopIdChange
  });
  const [isTabbingBackOut, setIsTabbingBackOut] = (0, import_react75.useState)(false);
  const handleEntryFocus = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onEntryFocus);
  const getItems = $d7bdfb9eb0fdf311$var$useCollection(__scopeRovingFocusGroup);
  const isClickFocusRef = (0, import_react75.useRef)(false);
  const [focusableItemsCount, setFocusableItemsCount] = (0, import_react75.useState)(0);
  (0, import_react75.useEffect)(() => {
    const node = ref.current;
    if (node) {
      node.addEventListener($d7bdfb9eb0fdf311$var$ENTRY_FOCUS, handleEntryFocus);
      return () => node.removeEventListener($d7bdfb9eb0fdf311$var$ENTRY_FOCUS, handleEntryFocus);
    }
  }, [
    handleEntryFocus
  ]);
  return /* @__PURE__ */ (0, import_react75.createElement)($d7bdfb9eb0fdf311$var$RovingFocusProvider, {
    scope: __scopeRovingFocusGroup,
    orientation,
    dir: direction,
    loop,
    currentTabStopId,
    onItemFocus: (0, import_react75.useCallback)(
      (tabStopId) => setCurrentTabStopId(tabStopId),
      [
        setCurrentTabStopId
      ]
    ),
    onItemShiftTab: (0, import_react75.useCallback)(
      () => setIsTabbingBackOut(true),
      []
    ),
    onFocusableItemAdd: (0, import_react75.useCallback)(
      () => setFocusableItemsCount(
        (prevCount) => prevCount + 1
      ),
      []
    ),
    onFocusableItemRemove: (0, import_react75.useCallback)(
      () => setFocusableItemsCount(
        (prevCount) => prevCount - 1
      ),
      []
    )
  }, /* @__PURE__ */ (0, import_react75.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
    tabIndex: isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0,
    "data-orientation": orientation
  }, groupProps, {
    ref: composedRefs,
    style: {
      outline: "none",
      ...props.style
    },
    onMouseDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onMouseDown, () => {
      isClickFocusRef.current = true;
    }),
    onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onFocus, (event) => {
      const isKeyboardFocus = !isClickFocusRef.current;
      if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {
        const entryFocusEvent = new CustomEvent($d7bdfb9eb0fdf311$var$ENTRY_FOCUS, $d7bdfb9eb0fdf311$var$EVENT_OPTIONS);
        event.currentTarget.dispatchEvent(entryFocusEvent);
        if (!entryFocusEvent.defaultPrevented) {
          const items = getItems().filter(
            (item) => item.focusable
          );
          const activeItem = items.find(
            (item) => item.active
          );
          const currentItem = items.find(
            (item) => item.id === currentTabStopId
          );
          const candidateItems = [
            activeItem,
            currentItem,
            ...items
          ].filter(Boolean);
          const candidateNodes = candidateItems.map(
            (item) => item.ref.current
          );
          $d7bdfb9eb0fdf311$var$focusFirst(candidateNodes);
        }
      }
      isClickFocusRef.current = false;
    }),
    onBlur: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
      props.onBlur,
      () => setIsTabbingBackOut(false)
    )
  })));
});
var $d7bdfb9eb0fdf311$var$ITEM_NAME = "RovingFocusGroupItem";
var $d7bdfb9eb0fdf311$export$ab9df7c53fe8454 = /* @__PURE__ */ (0, import_react75.forwardRef)((props, forwardedRef) => {
  const { __scopeRovingFocusGroup, focusable = true, active = false, tabStopId, ...itemProps } = props;
  const autoId = $1746a345f3d73bb7$export$f680877a34711e37();
  const id = tabStopId || autoId;
  const context = $d7bdfb9eb0fdf311$var$useRovingFocusContext($d7bdfb9eb0fdf311$var$ITEM_NAME, __scopeRovingFocusGroup);
  const isCurrentTabStop = context.currentTabStopId === id;
  const getItems = $d7bdfb9eb0fdf311$var$useCollection(__scopeRovingFocusGroup);
  const { onFocusableItemAdd, onFocusableItemRemove } = context;
  (0, import_react75.useEffect)(() => {
    if (focusable) {
      onFocusableItemAdd();
      return () => onFocusableItemRemove();
    }
  }, [
    focusable,
    onFocusableItemAdd,
    onFocusableItemRemove
  ]);
  return /* @__PURE__ */ (0, import_react75.createElement)($d7bdfb9eb0fdf311$var$Collection.ItemSlot, {
    scope: __scopeRovingFocusGroup,
    id,
    focusable,
    active
  }, /* @__PURE__ */ (0, import_react75.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.span, _extends({
    tabIndex: isCurrentTabStop ? 0 : -1,
    "data-orientation": context.orientation
  }, itemProps, {
    ref: forwardedRef,
    onMouseDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onMouseDown, (event) => {
      if (!focusable)
        event.preventDefault();
      else
        context.onItemFocus(id);
    }),
    onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
      props.onFocus,
      () => context.onItemFocus(id)
    ),
    onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event) => {
      if (event.key === "Tab" && event.shiftKey) {
        context.onItemShiftTab();
        return;
      }
      if (event.target !== event.currentTarget)
        return;
      const focusIntent = $d7bdfb9eb0fdf311$var$getFocusIntent(event, context.orientation, context.dir);
      if (focusIntent !== void 0) {
        event.preventDefault();
        const items = getItems().filter(
          (item) => item.focusable
        );
        let candidateNodes = items.map(
          (item) => item.ref.current
        );
        if (focusIntent === "last")
          candidateNodes.reverse();
        else if (focusIntent === "prev" || focusIntent === "next") {
          if (focusIntent === "prev")
            candidateNodes.reverse();
          const currentIndex = candidateNodes.indexOf(event.currentTarget);
          candidateNodes = context.loop ? $d7bdfb9eb0fdf311$var$wrapArray(candidateNodes, currentIndex + 1) : candidateNodes.slice(currentIndex + 1);
        }
        setTimeout(
          () => $d7bdfb9eb0fdf311$var$focusFirst(candidateNodes)
        );
      }
    })
  })));
});
var $d7bdfb9eb0fdf311$var$MAP_KEY_TO_FOCUS_INTENT = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function $d7bdfb9eb0fdf311$var$getDirectionAwareKey(key, dir) {
  if (dir !== "rtl")
    return key;
  return key === "ArrowLeft" ? "ArrowRight" : key === "ArrowRight" ? "ArrowLeft" : key;
}
function $d7bdfb9eb0fdf311$var$getFocusIntent(event, orientation, dir) {
  const key = $d7bdfb9eb0fdf311$var$getDirectionAwareKey(event.key, dir);
  if (orientation === "vertical" && [
    "ArrowLeft",
    "ArrowRight"
  ].includes(key))
    return void 0;
  if (orientation === "horizontal" && [
    "ArrowUp",
    "ArrowDown"
  ].includes(key))
    return void 0;
  return $d7bdfb9eb0fdf311$var$MAP_KEY_TO_FOCUS_INTENT[key];
}
function $d7bdfb9eb0fdf311$var$focusFirst(candidates) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT)
      return;
    candidate.focus();
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT)
      return;
  }
}
function $d7bdfb9eb0fdf311$var$wrapArray(array, startIndex) {
  return array.map(
    (_, index2) => array[(startIndex + index2) % array.length]
  );
}
var $d7bdfb9eb0fdf311$export$be92b6f5f03c0fe9 = $d7bdfb9eb0fdf311$export$8699f7c8af148338;
var $d7bdfb9eb0fdf311$export$6d08773d2e66f8f2 = $d7bdfb9eb0fdf311$export$ab9df7c53fe8454;

// ../../node_modules/@radix-ui/react-tabs/dist/index.module.js
var $69cb30bb0017df05$var$TABS_NAME = "Tabs";
var [$69cb30bb0017df05$var$createTabsContext, $69cb30bb0017df05$export$355f5bd209d7b13a] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($69cb30bb0017df05$var$TABS_NAME, [
  $d7bdfb9eb0fdf311$export$c7109489551a4f4
]);
var $69cb30bb0017df05$var$useRovingFocusGroupScope = $d7bdfb9eb0fdf311$export$c7109489551a4f4();
var [$69cb30bb0017df05$var$TabsProvider, $69cb30bb0017df05$var$useTabsContext] = $69cb30bb0017df05$var$createTabsContext($69cb30bb0017df05$var$TABS_NAME);
var $69cb30bb0017df05$export$b2539bed5023c21c = /* @__PURE__ */ (0, import_react76.forwardRef)((props, forwardedRef) => {
  const { __scopeTabs, value: valueProp, onValueChange, defaultValue, orientation = "horizontal", dir, activationMode = "automatic", ...tabsProps } = props;
  const direction = $f631663db3294ace$export$b39126d51d94e6f3(dir);
  const [value, setValue] = $71cd76cc60e0454e$export$6f32135080cb4c3({
    prop: valueProp,
    onChange: onValueChange,
    defaultProp: defaultValue
  });
  return /* @__PURE__ */ (0, import_react76.createElement)($69cb30bb0017df05$var$TabsProvider, {
    scope: __scopeTabs,
    baseId: $1746a345f3d73bb7$export$f680877a34711e37(),
    value,
    onValueChange: setValue,
    orientation,
    dir: direction,
    activationMode
  }, /* @__PURE__ */ (0, import_react76.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
    dir: direction,
    "data-orientation": orientation
  }, tabsProps, {
    ref: forwardedRef
  })));
});
var $69cb30bb0017df05$var$TAB_LIST_NAME = "TabsList";
var $69cb30bb0017df05$export$9712d22edc0d78c1 = /* @__PURE__ */ (0, import_react76.forwardRef)((props, forwardedRef) => {
  const { __scopeTabs, loop = true, ...listProps } = props;
  const context = $69cb30bb0017df05$var$useTabsContext($69cb30bb0017df05$var$TAB_LIST_NAME, __scopeTabs);
  const rovingFocusGroupScope = $69cb30bb0017df05$var$useRovingFocusGroupScope(__scopeTabs);
  return /* @__PURE__ */ (0, import_react76.createElement)($d7bdfb9eb0fdf311$export$be92b6f5f03c0fe9, _extends({
    asChild: true
  }, rovingFocusGroupScope, {
    orientation: context.orientation,
    dir: context.dir,
    loop
  }), /* @__PURE__ */ (0, import_react76.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
    role: "tablist",
    "aria-orientation": context.orientation
  }, listProps, {
    ref: forwardedRef
  })));
});
var $69cb30bb0017df05$var$TRIGGER_NAME = "TabsTrigger";
var $69cb30bb0017df05$export$8114b9fdfdf9f3ba = /* @__PURE__ */ (0, import_react76.forwardRef)((props, forwardedRef) => {
  const { __scopeTabs, value, disabled = false, ...triggerProps } = props;
  const context = $69cb30bb0017df05$var$useTabsContext($69cb30bb0017df05$var$TRIGGER_NAME, __scopeTabs);
  const rovingFocusGroupScope = $69cb30bb0017df05$var$useRovingFocusGroupScope(__scopeTabs);
  const triggerId = $69cb30bb0017df05$var$makeTriggerId(context.baseId, value);
  const contentId = $69cb30bb0017df05$var$makeContentId(context.baseId, value);
  const isSelected = value === context.value;
  return /* @__PURE__ */ (0, import_react76.createElement)($d7bdfb9eb0fdf311$export$6d08773d2e66f8f2, _extends({
    asChild: true
  }, rovingFocusGroupScope, {
    focusable: !disabled,
    active: isSelected
  }), /* @__PURE__ */ (0, import_react76.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.button, _extends({
    type: "button",
    role: "tab",
    "aria-selected": isSelected,
    "aria-controls": contentId,
    "data-state": isSelected ? "active" : "inactive",
    "data-disabled": disabled ? "" : void 0,
    disabled,
    id: triggerId
  }, triggerProps, {
    ref: forwardedRef,
    onMouseDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onMouseDown, (event) => {
      if (!disabled && event.button === 0 && event.ctrlKey === false)
        context.onValueChange(value);
      else
        event.preventDefault();
    }),
    onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event) => {
      if ([
        " ",
        "Enter"
      ].includes(event.key))
        context.onValueChange(value);
    }),
    onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onFocus, () => {
      const isAutomaticActivation = context.activationMode !== "manual";
      if (!isSelected && !disabled && isAutomaticActivation)
        context.onValueChange(value);
    })
  })));
});
var $69cb30bb0017df05$var$CONTENT_NAME = "TabsContent";
var $69cb30bb0017df05$export$bd905d70e8fd2ebb = /* @__PURE__ */ (0, import_react76.forwardRef)((props, forwardedRef) => {
  const { __scopeTabs, value, forceMount, children, ...contentProps } = props;
  const context = $69cb30bb0017df05$var$useTabsContext($69cb30bb0017df05$var$CONTENT_NAME, __scopeTabs);
  const triggerId = $69cb30bb0017df05$var$makeTriggerId(context.baseId, value);
  const contentId = $69cb30bb0017df05$var$makeContentId(context.baseId, value);
  const isSelected = value === context.value;
  const isMountAnimationPreventedRef = (0, import_react76.useRef)(isSelected);
  (0, import_react76.useEffect)(() => {
    const rAF = requestAnimationFrame(
      () => isMountAnimationPreventedRef.current = false
    );
    return () => cancelAnimationFrame(rAF);
  }, []);
  return /* @__PURE__ */ (0, import_react76.createElement)(
    $921a889cee6df7e8$export$99c2b779aa4e8b8b,
    {
      present: forceMount || isSelected
    },
    ({ present }) => /* @__PURE__ */ (0, import_react76.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
      "data-state": isSelected ? "active" : "inactive",
      "data-orientation": context.orientation,
      role: "tabpanel",
      "aria-labelledby": triggerId,
      hidden: !present,
      id: contentId,
      tabIndex: 0
    }, contentProps, {
      ref: forwardedRef,
      style: {
        ...props.style,
        animationDuration: isMountAnimationPreventedRef.current ? "0s" : void 0
      }
    }), present && children)
  );
});
function $69cb30bb0017df05$var$makeTriggerId(baseId, value) {
  return `${baseId}-trigger-${value}`;
}
function $69cb30bb0017df05$var$makeContentId(baseId, value) {
  return `${baseId}-content-${value}`;
}
var $69cb30bb0017df05$export$be92b6f5f03c0fe9 = $69cb30bb0017df05$export$b2539bed5023c21c;
var $69cb30bb0017df05$export$54c2e3dc7acea9f5 = $69cb30bb0017df05$export$9712d22edc0d78c1;
var $69cb30bb0017df05$export$41fb9f06171c75f4 = $69cb30bb0017df05$export$8114b9fdfdf9f3ba;
var $69cb30bb0017df05$export$7c6e2c02157bb7d2 = $69cb30bb0017df05$export$bd905d70e8fd2ebb;

// components/Sidebar/SidebarTabTriggers.tsx
var import_jsx_runtime84 = __toESM(require_jsx_runtime(), 1);
var SidebarTabTriggers = ({
  children,
  ...rest
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime84.jsx)($69cb30bb0017df05$export$54c2e3dc7acea9f5, { className: "sidebar-triggers", ...rest, children });
};
SidebarTabTriggers.displayName = "SidebarTabTriggers";

// components/Sidebar/SidebarTabTrigger.tsx
init_define_import_meta_env();
var import_jsx_runtime85 = __toESM(require_jsx_runtime(), 1);
var SidebarTabTrigger = ({
  children,
  tab,
  onSelect,
  ...rest
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime85.jsx)($69cb30bb0017df05$export$41fb9f06171c75f4, { value: tab, asChild: true, onSelect, children: /* @__PURE__ */ (0, import_jsx_runtime85.jsx)(
    "button",
    {
      type: "button",
      className: `excalidraw-button sidebar-tab-trigger`,
      ...rest,
      children
    }
  ) });
};
SidebarTabTrigger.displayName = "SidebarTabTrigger";

// components/Sidebar/SidebarTabs.tsx
init_define_import_meta_env();
var import_jsx_runtime86 = __toESM(require_jsx_runtime(), 1);
var SidebarTabs = ({
  children,
  ...rest
}) => {
  const appState = useUIAppState();
  const setAppState = useExcalidrawSetAppState();
  if (!appState.openSidebar) {
    return null;
  }
  const { name } = appState.openSidebar;
  return /* @__PURE__ */ (0, import_jsx_runtime86.jsx)(
    $69cb30bb0017df05$export$be92b6f5f03c0fe9,
    {
      className: "sidebar-tabs-root",
      value: appState.openSidebar.tab,
      onValueChange: (tab) => setAppState((state) => ({
        ...state,
        openSidebar: { ...state.openSidebar, name, tab }
      })),
      ...rest,
      children
    }
  );
};
SidebarTabs.displayName = "SidebarTabs";

// components/Sidebar/SidebarTab.tsx
init_define_import_meta_env();
var import_jsx_runtime87 = __toESM(require_jsx_runtime(), 1);
var SidebarTab = ({
  tab,
  children,
  ...rest
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime87.jsx)($69cb30bb0017df05$export$7c6e2c02157bb7d2, { ...rest, value: tab, children });
};
SidebarTab.displayName = "SidebarTab";

// components/Sidebar/Sidebar.tsx
var import_jsx_runtime88 = __toESM(require_jsx_runtime(), 1);
var import_react78 = __toESM(require_react(), 1);
var isSidebarDockedAtom = atom2(false);
var SidebarInner = (0, import_react77.forwardRef)(
  ({
    name,
    children,
    onDock,
    docked,
    className,
    ...rest
  }, ref) => {
    if (define_import_meta_env_default.DEV && onDock && docked == null) {
      console.warn(
        "Sidebar: `docked` must be set when `onDock` is supplied for the sidebar to be user-dockable. To hide this message, either pass `docked` or remove `onDock`"
      );
    }
    const setAppState = useExcalidrawSetAppState();
    const setIsSidebarDockedAtom = useSetAtom(isSidebarDockedAtom, jotaiScope);
    (0, import_react77.useLayoutEffect)(() => {
      setIsSidebarDockedAtom(!!docked);
      return () => {
        setIsSidebarDockedAtom(false);
      };
    }, [setIsSidebarDockedAtom, docked]);
    const headerPropsRef = (0, import_react77.useRef)(
      {}
    );
    headerPropsRef.current.onCloseRequest = () => {
      setAppState({ openSidebar: null });
    };
    headerPropsRef.current.onDock = (isDocked) => onDock?.(isDocked);
    headerPropsRef.current = updateObject(headerPropsRef.current, {
      docked,
      // explicit prop to rerender on update
      shouldRenderDockButton: !!onDock && docked != null
    });
    const islandRef = (0, import_react77.useRef)(null);
    (0, import_react77.useImperativeHandle)(ref, () => {
      return islandRef.current;
    });
    const device = useDevice();
    const closeLibrary = (0, import_react77.useCallback)(() => {
      const isDialogOpen = !!document.querySelector(".Dialog");
      if (isDialogOpen) {
        return;
      }
      setAppState({ openSidebar: null });
    }, [setAppState]);
    useOutsideClick(
      islandRef,
      (0, import_react77.useCallback)(
        (event) => {
          if (event.target.closest(".sidebar-trigger")) {
            return;
          }
          if (!docked || !device.editor.canFitSidebar) {
            closeLibrary();
          }
        },
        [closeLibrary, docked, device.editor.canFitSidebar]
      )
    );
    (0, import_react77.useEffect)(() => {
      const handleKeyDown = (event) => {
        if (event.key === KEYS.ESCAPE && (!docked || !device.editor.canFitSidebar)) {
          closeLibrary();
        }
      };
      document.addEventListener("keydown" /* KEYDOWN */, handleKeyDown);
      return () => {
        document.removeEventListener("keydown" /* KEYDOWN */, handleKeyDown);
      };
    }, [closeLibrary, docked, device.editor.canFitSidebar]);
    return /* @__PURE__ */ (0, import_jsx_runtime88.jsx)(
      Island,
      {
        ...rest,
        className: clsx_m_default("sidebar", { "sidebar--docked": docked }, className),
        ref: islandRef,
        children: /* @__PURE__ */ (0, import_jsx_runtime88.jsx)(SidebarPropsContext.Provider, { value: headerPropsRef.current, children })
      }
    );
  }
);
SidebarInner.displayName = "SidebarInner";
var Sidebar = Object.assign(
  (0, import_react77.forwardRef)((props, ref) => {
    const appState = useUIAppState();
    const { onStateChange } = props;
    const refPrevOpenSidebar = (0, import_react77.useRef)(appState.openSidebar);
    (0, import_react77.useEffect)(() => {
      if (
        // closing sidebar
        (!appState.openSidebar && refPrevOpenSidebar?.current?.name === props.name || // opening current sidebar
        appState.openSidebar?.name === props.name && refPrevOpenSidebar?.current?.name !== props.name || // switching tabs or switching to a different sidebar
        refPrevOpenSidebar.current?.name === props.name) && appState.openSidebar !== refPrevOpenSidebar.current
      ) {
        onStateChange?.(
          appState.openSidebar?.name !== props.name ? null : appState.openSidebar
        );
      }
      refPrevOpenSidebar.current = appState.openSidebar;
    }, [appState.openSidebar, onStateChange, props.name]);
    const [mounted, setMounted] = (0, import_react77.useState)(false);
    (0, import_react77.useLayoutEffect)(() => {
      setMounted(true);
      return () => setMounted(false);
    }, []);
    const shouldRender = mounted && appState.openSidebar?.name === props.name;
    if (!shouldRender) {
      return null;
    }
    return /* @__PURE__ */ (0, import_react78.createElement)(SidebarInner, { ...props, ref, key: props.name });
  }),
  {
    Header: SidebarHeader,
    TabTriggers: SidebarTabTriggers,
    TabTrigger: SidebarTabTrigger,
    Tabs: SidebarTabs,
    Tab: SidebarTab,
    Trigger: SidebarTrigger
  }
);
Sidebar.displayName = "Sidebar";

// components/main-menu/MainMenu.tsx
init_define_import_meta_env();

// components/main-menu/DefaultItems.tsx
var DefaultItems_exports = {};
__export(DefaultItems_exports, {
  ChangeCanvasBackground: () => ChangeCanvasBackground,
  ClearCanvas: () => ClearCanvas,
  Export: () => Export,
  Help: () => Help,
  LiveCollaborationTrigger: () => LiveCollaborationTrigger,
  LoadScene: () => LoadScene,
  SaveAsImage: () => SaveAsImage,
  SaveToActiveFile: () => SaveToActiveFile,
  Socials: () => Socials,
  ToggleTheme: () => ToggleTheme
});
init_define_import_meta_env();

// components/ActiveConfirmDialog.tsx
init_define_import_meta_env();
var import_jsx_runtime89 = __toESM(require_jsx_runtime(), 1);
var activeConfirmDialogAtom = atom2(null);
var ActiveConfirmDialog = () => {
  const [activeConfirmDialog, setActiveConfirmDialog] = useAtom(
    activeConfirmDialogAtom,
    jotaiScope
  );
  const actionManager = useExcalidrawActionManager();
  if (!activeConfirmDialog) {
    return null;
  }
  if (activeConfirmDialog === "clearCanvas") {
    return /* @__PURE__ */ (0, import_jsx_runtime89.jsx)(
      ConfirmDialog_default,
      {
        onConfirm: () => {
          actionManager.executeAction(actionClearCanvas);
          setActiveConfirmDialog(null);
        },
        onCancel: () => setActiveConfirmDialog(null),
        title: t("clearCanvasDialog.title"),
        children: /* @__PURE__ */ (0, import_jsx_runtime89.jsxs)("p", { className: "clear-canvas__content", children: [
          " ",
          t("alerts.clearReset")
        ] })
      }
    );
  }
  return null;
};

// components/OverwriteConfirm/OverwriteConfirmState.ts
init_define_import_meta_env();
var overwriteConfirmStateAtom = atom2({
  active: false
});
async function openConfirmModal({
  title,
  description,
  actionLabel,
  color
}) {
  return new Promise((resolve) => {
    jotaiStore.set(overwriteConfirmStateAtom, {
      active: true,
      onConfirm: () => resolve(true),
      onClose: () => resolve(false),
      onReject: () => resolve(false),
      title,
      description,
      actionLabel,
      color
    });
  });
}

// components/main-menu/DefaultItems.tsx
var import_jsx_runtime90 = __toESM(require_jsx_runtime(), 1);
var LoadScene = () => {
  const { t: t4 } = useI18n();
  const actionManager = useExcalidrawActionManager();
  const elements = useExcalidrawElements();
  if (!actionManager.isActionEnabled(actionLoadScene)) {
    return null;
  }
  const handleSelect = async () => {
    if (!elements.length || await openConfirmModal({
      title: t4("overwriteConfirm.modal.loadFromFile.title"),
      actionLabel: t4("overwriteConfirm.modal.loadFromFile.button"),
      color: "warning",
      description: /* @__PURE__ */ (0, import_jsx_runtime90.jsx)(
        Trans_default,
        {
          i18nKey: "overwriteConfirm.modal.loadFromFile.description",
          bold: (text) => /* @__PURE__ */ (0, import_jsx_runtime90.jsx)("strong", { children: text }),
          br: () => /* @__PURE__ */ (0, import_jsx_runtime90.jsx)("br", {})
        }
      )
    })) {
      actionManager.executeAction(actionLoadScene);
    }
  };
  return /* @__PURE__ */ (0, import_jsx_runtime90.jsx)(
    DropdownMenuItem_default,
    {
      icon: LoadIcon,
      onSelect: handleSelect,
      "data-testid": "load-button",
      shortcut: getShortcutFromShortcutName("loadScene"),
      "aria-label": t4("buttons.load"),
      children: t4("buttons.load")
    }
  );
};
LoadScene.displayName = "LoadScene";
var SaveToActiveFile = () => {
  const { t: t4 } = useI18n();
  const actionManager = useExcalidrawActionManager();
  if (!actionManager.isActionEnabled(actionSaveToActiveFile)) {
    return null;
  }
  return /* @__PURE__ */ (0, import_jsx_runtime90.jsx)(
    DropdownMenuItem_default,
    {
      shortcut: getShortcutFromShortcutName("saveScene"),
      "data-testid": "save-button",
      onSelect: () => actionManager.executeAction(actionSaveToActiveFile),
      icon: save,
      "aria-label": `${t4("buttons.save")}`,
      children: `${t4("buttons.save")}`
    }
  );
};
SaveToActiveFile.displayName = "SaveToActiveFile";
var SaveAsImage = () => {
  const setAppState = useExcalidrawSetAppState();
  const { t: t4 } = useI18n();
  return /* @__PURE__ */ (0, import_jsx_runtime90.jsx)(
    DropdownMenuItem_default,
    {
      icon: ExportImageIcon,
      "data-testid": "image-export-button",
      onSelect: () => setAppState({ openDialog: { name: "imageExport" } }),
      shortcut: getShortcutFromShortcutName("imageExport"),
      "aria-label": t4("buttons.exportImage"),
      children: t4("buttons.exportImage")
    }
  );
};
SaveAsImage.displayName = "SaveAsImage";
var Help = () => {
  const { t: t4 } = useI18n();
  const actionManager = useExcalidrawActionManager();
  return /* @__PURE__ */ (0, import_jsx_runtime90.jsx)(
    DropdownMenuItem_default,
    {
      "data-testid": "help-menu-item",
      icon: HelpIcon,
      onSelect: () => actionManager.executeAction(actionShortcuts),
      shortcut: "?",
      "aria-label": t4("helpDialog.title"),
      children: t4("helpDialog.title")
    }
  );
};
Help.displayName = "Help";
var ClearCanvas = () => {
  const { t: t4 } = useI18n();
  const setActiveConfirmDialog = useSetAtom(
    activeConfirmDialogAtom,
    jotaiScope
  );
  const actionManager = useExcalidrawActionManager();
  if (!actionManager.isActionEnabled(actionClearCanvas)) {
    return null;
  }
  return /* @__PURE__ */ (0, import_jsx_runtime90.jsx)(
    DropdownMenuItem_default,
    {
      icon: TrashIcon,
      onSelect: () => setActiveConfirmDialog("clearCanvas"),
      "data-testid": "clear-canvas-button",
      "aria-label": t4("buttons.clearReset"),
      children: t4("buttons.clearReset")
    }
  );
};
ClearCanvas.displayName = "ClearCanvas";
var ToggleTheme = () => {
  const { t: t4 } = useI18n();
  const appState = useUIAppState();
  const actionManager = useExcalidrawActionManager();
  if (!actionManager.isActionEnabled(actionToggleTheme)) {
    return null;
  }
  return /* @__PURE__ */ (0, import_jsx_runtime90.jsx)(
    DropdownMenuItem_default,
    {
      onSelect: (event) => {
        event.preventDefault();
        return actionManager.executeAction(actionToggleTheme);
      },
      icon: appState.theme === "dark" ? SunIcon : MoonIcon,
      "data-testid": "toggle-dark-mode",
      shortcut: getShortcutFromShortcutName("toggleTheme"),
      "aria-label": appState.theme === "dark" ? t4("buttons.lightMode") : t4("buttons.darkMode"),
      children: appState.theme === "dark" ? t4("buttons.lightMode") : t4("buttons.darkMode")
    }
  );
};
ToggleTheme.displayName = "ToggleTheme";
var ChangeCanvasBackground = () => {
  const { t: t4 } = useI18n();
  const appState = useUIAppState();
  const actionManager = useExcalidrawActionManager();
  const appProps = useAppProps();
  if (appState.viewModeEnabled || !appProps.UIOptions.canvasActions.changeViewBackgroundColor) {
    return null;
  }
  return /* @__PURE__ */ (0, import_jsx_runtime90.jsxs)("div", { style: { marginTop: "0.5rem" }, children: [
    /* @__PURE__ */ (0, import_jsx_runtime90.jsx)(
      "div",
      {
        "data-testid": "canvas-background-label",
        style: { fontSize: ".75rem", marginBottom: ".5rem" },
        children: t4("labels.canvasBackground")
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime90.jsx)("div", { style: { padding: "0 0.625rem" }, children: actionManager.renderAction("changeViewBackgroundColor") })
  ] });
};
ChangeCanvasBackground.displayName = "ChangeCanvasBackground";
var Export = () => {
  const { t: t4 } = useI18n();
  const setAppState = useExcalidrawSetAppState();
  return /* @__PURE__ */ (0, import_jsx_runtime90.jsx)(
    DropdownMenuItem_default,
    {
      icon: ExportIcon,
      onSelect: () => {
        setAppState({ openDialog: { name: "jsonExport" } });
      },
      "data-testid": "json-export-button",
      "aria-label": t4("buttons.export"),
      children: t4("buttons.export")
    }
  );
};
Export.displayName = "Export";
var Socials = () => {
  const { t: t4 } = useI18n();
  return /* @__PURE__ */ (0, import_jsx_runtime90.jsxs)(import_jsx_runtime90.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime90.jsx)(
      DropdownMenuItemLink_default,
      {
        icon: GithubIcon,
        href: "https://github.com/excalidraw/excalidraw",
        "aria-label": "GitHub",
        children: "GitHub"
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime90.jsx)(
      DropdownMenuItemLink_default,
      {
        icon: XBrandIcon,
        href: "https://x.com/excalidraw",
        "aria-label": "X",
        children: t4("labels.followUs")
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime90.jsx)(
      DropdownMenuItemLink_default,
      {
        icon: DiscordIcon,
        href: "https://discord.gg/UexuTaE",
        "aria-label": "Discord",
        children: t4("labels.discordChat")
      }
    )
  ] });
};
Socials.displayName = "Socials";
var LiveCollaborationTrigger = ({
  onSelect,
  isCollaborating
}) => {
  const { t: t4 } = useI18n();
  return /* @__PURE__ */ (0, import_jsx_runtime90.jsx)(
    DropdownMenuItem_default,
    {
      "data-testid": "collab-button",
      icon: usersIcon,
      className: clsx_m_default({
        "active-collab": isCollaborating
      }),
      onSelect,
      children: t4("labels.liveCollaboration")
    }
  );
};
LiveCollaborationTrigger.displayName = "LiveCollaborationTrigger";

// components/hoc/withInternalFallback.tsx
init_define_import_meta_env();
var import_react79 = __toESM(require_react(), 1);
var import_jsx_runtime91 = __toESM(require_jsx_runtime(), 1);
var withInternalFallback = (componentName, Component) => {
  const renderAtom = atom2(0);
  const WrapperComponent = (props) => {
    const { jotaiScope: jotaiScope2 } = useTunnels();
    const [, setCounter] = useAtom(renderAtom, jotaiScope2);
    const metaRef = (0, import_react79.useRef)({
      // flag set on initial render to tell the fallback component to skip the
      // render until mount counter are initialized. This is because the counter
      // is initialized in an effect, and thus we could end rendering both
      // components at the same time until counter is initialized.
      preferHost: false,
      counter: 0
    });
    (0, import_react79.useLayoutEffect)(() => {
      const meta = metaRef.current;
      setCounter((c3) => {
        const next = c3 + 1;
        meta.counter = next;
        return next;
      });
      return () => {
        setCounter((c3) => {
          const next = c3 - 1;
          meta.counter = next;
          if (!next) {
            meta.preferHost = false;
          }
          return next;
        });
      };
    }, [setCounter]);
    if (!props.__fallback) {
      metaRef.current.preferHost = true;
    }
    if (
      // either before the counters are initialized
      !metaRef.current.counter && props.__fallback && metaRef.current.preferHost || // or after the counters are initialized, and both are rendered
      // (this is the default when host renders as well)
      metaRef.current.counter > 1 && props.__fallback
    ) {
      return null;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(Component, { ...props });
  };
  WrapperComponent.displayName = componentName;
  return WrapperComponent;
};

// components/main-menu/MainMenu.tsx
var import_jsx_runtime92 = __toESM(require_jsx_runtime(), 1);
var MainMenu = Object.assign(
  withInternalFallback(
    "MainMenu",
    ({
      children,
      onSelect
    }) => {
      const { MainMenuTunnel } = useTunnels();
      const device = useDevice();
      const appState = useUIAppState();
      const setAppState = useExcalidrawSetAppState();
      const onClickOutside = device.editor.isMobile ? void 0 : () => setAppState({ openMenu: null });
      return /* @__PURE__ */ (0, import_jsx_runtime92.jsx)(MainMenuTunnel.In, { children: /* @__PURE__ */ (0, import_jsx_runtime92.jsxs)(DropdownMenu_default, { open: appState.openMenu === "canvas", children: [
        /* @__PURE__ */ (0, import_jsx_runtime92.jsx)(
          DropdownMenu_default.Trigger,
          {
            onToggle: () => {
              setAppState({
                openMenu: appState.openMenu === "canvas" ? null : "canvas"
              });
            },
            "data-testid": "main-menu-trigger",
            className: "main-menu-trigger",
            children: HamburgerMenuIcon
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime92.jsxs)(
          DropdownMenu_default.Content,
          {
            onClickOutside,
            onSelect: composeEventHandlers(onSelect, () => {
              setAppState({ openMenu: null });
            }),
            children: [
              children,
              device.editor.isMobile && appState.collaborators.size > 0 && /* @__PURE__ */ (0, import_jsx_runtime92.jsxs)("fieldset", { className: "UserList-Wrapper", children: [
                /* @__PURE__ */ (0, import_jsx_runtime92.jsx)("legend", { children: t("labels.collaborators") }),
                /* @__PURE__ */ (0, import_jsx_runtime92.jsx)(
                  UserList,
                  {
                    mobile: true,
                    collaborators: appState.collaborators,
                    userToFollow: appState.userToFollow?.socketId || null
                  }
                )
              ] })
            ]
          }
        )
      ] }) });
    }
  ),
  {
    Trigger: DropdownMenu_default.Trigger,
    Item: DropdownMenu_default.Item,
    ItemLink: DropdownMenu_default.ItemLink,
    ItemCustom: DropdownMenu_default.ItemCustom,
    Group: DropdownMenu_default.Group,
    Separator: DropdownMenu_default.Separator,
    DefaultItems: DefaultItems_exports
  }
);
var MainMenu_default = MainMenu;

// components/OverwriteConfirm/OverwriteConfirm.tsx
init_define_import_meta_env();

// components/OverwriteConfirm/OverwriteConfirmActions.tsx
init_define_import_meta_env();
var import_jsx_runtime93 = __toESM(require_jsx_runtime(), 1);
var Action = ({
  title,
  children,
  actionLabel,
  onClick
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime93.jsxs)("div", { className: "OverwriteConfirm__Actions__Action", children: [
    /* @__PURE__ */ (0, import_jsx_runtime93.jsx)("h4", { children: title }),
    /* @__PURE__ */ (0, import_jsx_runtime93.jsx)("div", { className: "OverwriteConfirm__Actions__Action__content", children }),
    /* @__PURE__ */ (0, import_jsx_runtime93.jsx)(
      FilledButton,
      {
        variant: "outlined",
        color: "muted",
        label: actionLabel,
        size: "large",
        fullWidth: true,
        onClick
      }
    )
  ] });
};
var ExportToImage = () => {
  const { t: t4 } = useI18n();
  const actionManager = useExcalidrawActionManager();
  const setAppState = useExcalidrawSetAppState();
  return /* @__PURE__ */ (0, import_jsx_runtime93.jsx)(
    Action,
    {
      title: t4("overwriteConfirm.action.exportToImage.title"),
      actionLabel: t4("overwriteConfirm.action.exportToImage.button"),
      onClick: () => {
        actionManager.executeAction(actionChangeExportEmbedScene, "ui", true);
        setAppState({ openDialog: { name: "imageExport" } });
      },
      children: t4("overwriteConfirm.action.exportToImage.description")
    }
  );
};
var SaveToDisk = () => {
  const { t: t4 } = useI18n();
  const actionManager = useExcalidrawActionManager();
  return /* @__PURE__ */ (0, import_jsx_runtime93.jsx)(
    Action,
    {
      title: t4("overwriteConfirm.action.saveToDisk.title"),
      actionLabel: t4("overwriteConfirm.action.saveToDisk.button"),
      onClick: () => {
        actionManager.executeAction(actionSaveFileToDisk, "ui");
      },
      children: t4("overwriteConfirm.action.saveToDisk.description")
    }
  );
};
var Actions = Object.assign(
  ({ children }) => {
    return /* @__PURE__ */ (0, import_jsx_runtime93.jsx)("div", { className: "OverwriteConfirm__Actions", children });
  },
  {
    ExportToImage,
    SaveToDisk
  }
);

// components/OverwriteConfirm/OverwriteConfirm.tsx
var import_jsx_runtime94 = __toESM(require_jsx_runtime(), 1);
var OverwriteConfirmDialog = Object.assign(
  withInternalFallback(
    "OverwriteConfirmDialog",
    ({ children }) => {
      const { OverwriteConfirmDialogTunnel } = useTunnels();
      const [overwriteConfirmState, setState] = useAtom(
        overwriteConfirmStateAtom,
        jotaiScope
      );
      if (!overwriteConfirmState.active) {
        return null;
      }
      const handleClose = () => {
        overwriteConfirmState.onClose();
        setState((state) => ({ ...state, active: false }));
      };
      const handleConfirm = () => {
        overwriteConfirmState.onConfirm();
        setState((state) => ({ ...state, active: false }));
      };
      return /* @__PURE__ */ (0, import_jsx_runtime94.jsx)(OverwriteConfirmDialogTunnel.In, { children: /* @__PURE__ */ (0, import_jsx_runtime94.jsx)(Dialog, { onCloseRequest: handleClose, title: false, size: 916, children: /* @__PURE__ */ (0, import_jsx_runtime94.jsxs)("div", { className: "OverwriteConfirm", children: [
        /* @__PURE__ */ (0, import_jsx_runtime94.jsx)("h3", { children: overwriteConfirmState.title }),
        /* @__PURE__ */ (0, import_jsx_runtime94.jsxs)(
          "div",
          {
            className: `OverwriteConfirm__Description OverwriteConfirm__Description--color-${overwriteConfirmState.color}`,
            children: [
              /* @__PURE__ */ (0, import_jsx_runtime94.jsx)("div", { className: "OverwriteConfirm__Description__icon", children: alertTriangleIcon }),
              /* @__PURE__ */ (0, import_jsx_runtime94.jsx)("div", { children: overwriteConfirmState.description }),
              /* @__PURE__ */ (0, import_jsx_runtime94.jsx)("div", { className: "OverwriteConfirm__Description__spacer" }),
              /* @__PURE__ */ (0, import_jsx_runtime94.jsx)(
                FilledButton,
                {
                  color: overwriteConfirmState.color,
                  size: "large",
                  label: overwriteConfirmState.actionLabel,
                  onClick: handleConfirm
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime94.jsx)(Actions, { children })
      ] }) }) });
    }
  ),
  {
    Actions,
    Action
  }
);

// components/DefaultSidebar.tsx
init_define_import_meta_env();
var import_jsx_runtime95 = __toESM(require_jsx_runtime(), 1);
var import_react80 = __toESM(require_react(), 1);
var DefaultSidebarTrigger = withInternalFallback(
  "DefaultSidebarTrigger",
  (props) => {
    const { DefaultSidebarTriggerTunnel } = useTunnels();
    return /* @__PURE__ */ (0, import_jsx_runtime95.jsx)(DefaultSidebarTriggerTunnel.In, { children: /* @__PURE__ */ (0, import_jsx_runtime95.jsx)(
      Sidebar.Trigger,
      {
        ...props,
        className: "default-sidebar-trigger",
        name: DEFAULT_SIDEBAR.name
      }
    ) });
  }
);
DefaultSidebarTrigger.displayName = "DefaultSidebarTrigger";
var DefaultTabTriggers = ({
  children,
  ...rest
}) => {
  const { DefaultSidebarTabTriggersTunnel } = useTunnels();
  return /* @__PURE__ */ (0, import_jsx_runtime95.jsx)(DefaultSidebarTabTriggersTunnel.In, { children: /* @__PURE__ */ (0, import_jsx_runtime95.jsx)(Sidebar.TabTriggers, { ...rest, children }) });
};
DefaultTabTriggers.displayName = "DefaultTabTriggers";
var DefaultSidebar = Object.assign(
  withInternalFallback(
    "DefaultSidebar",
    ({
      children,
      className,
      onDock,
      docked,
      ...rest
    }) => {
      const appState = useUIAppState();
      const setAppState = useExcalidrawSetAppState();
      const { DefaultSidebarTabTriggersTunnel } = useTunnels();
      return /* @__PURE__ */ (0, import_react80.createElement)(
        Sidebar,
        {
          ...rest,
          name: "default",
          key: "default",
          className: clsx_m_default("default-sidebar", className),
          docked: docked ?? appState.defaultSidebarDockedPreference,
          onDock: (
            // `onDock=false` disables docking.
            // if `docked` passed, but no onDock passed, disable manual docking.
            onDock === false || !onDock && docked != null ? void 0 : (
              // compose to allow the host app to listen on default behavior
              composeEventHandlers(onDock, (docked2) => {
                setAppState({ defaultSidebarDockedPreference: docked2 });
              })
            )
          )
        },
        /* @__PURE__ */ (0, import_jsx_runtime95.jsxs)(Sidebar.Tabs, { children: [
          /* @__PURE__ */ (0, import_jsx_runtime95.jsxs)(Sidebar.Header, { children: [
            rest.__fallback && /* @__PURE__ */ (0, import_jsx_runtime95.jsx)(
              "div",
              {
                style: {
                  color: "var(--color-primary)",
                  fontSize: "1.2em",
                  fontWeight: "bold",
                  textOverflow: "ellipsis",
                  overflow: "hidden",
                  whiteSpace: "nowrap",
                  paddingRight: "1em"
                },
                children: t("toolBar.library")
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime95.jsx)(DefaultSidebarTabTriggersTunnel.Out, {})
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime95.jsx)(Sidebar.Tab, { tab: LIBRARY_SIDEBAR_TAB, children: /* @__PURE__ */ (0, import_jsx_runtime95.jsx)(LibraryMenu, {}) }),
          children
        ] })
      );
    }
  ),
  {
    Trigger: DefaultSidebarTrigger,
    TabTriggers: DefaultTabTriggers
  }
);

// components/LaserPointerButton.tsx
init_define_import_meta_env();
var import_jsx_runtime96 = __toESM(require_jsx_runtime(), 1);
var DEFAULT_SIZE3 = "small";
var LaserPointerButton = (props) => {
  return /* @__PURE__ */ (0, import_jsx_runtime96.jsxs)(
    "label",
    {
      className: clsx_m_default(
        "ToolIcon ToolIcon__LaserPointer",
        `ToolIcon_size_${DEFAULT_SIZE3}`,
        {
          "is-mobile": props.isMobile
        }
      ),
      title: `${props.title}`,
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime96.jsx)(
          "input",
          {
            className: "ToolIcon_type_checkbox",
            type: "checkbox",
            name: props.name,
            onChange: props.onChange,
            checked: props.checked,
            "aria-label": props.title,
            "data-testid": "toolbar-LaserPointer"
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime96.jsx)("div", { className: "ToolIcon__icon", children: laserPointerToolIcon })
      ]
    }
  );
};

// components/MagicSettings.tsx
init_define_import_meta_env();
var import_react83 = __toESM(require_react(), 1);

// components/TextField.tsx
init_define_import_meta_env();
var import_react81 = __toESM(require_react(), 1);
var import_jsx_runtime97 = __toESM(require_jsx_runtime(), 1);
var TextField = (0, import_react81.forwardRef)(
  ({
    onChange,
    label,
    fullWidth,
    placeholder,
    readonly,
    selectOnRender,
    onKeyDown,
    isRedacted = false,
    ...rest
  }, ref) => {
    const innerRef = (0, import_react81.useRef)(null);
    (0, import_react81.useImperativeHandle)(ref, () => innerRef.current);
    (0, import_react81.useLayoutEffect)(() => {
      if (selectOnRender) {
        innerRef.current?.select();
      }
    }, [selectOnRender]);
    const [isTemporarilyUnredacted, setIsTemporarilyUnredacted] = (0, import_react81.useState)(false);
    return /* @__PURE__ */ (0, import_jsx_runtime97.jsxs)(
      "div",
      {
        className: clsx_m_default("ExcTextField", {
          "ExcTextField--fullWidth": fullWidth
        }),
        onClick: () => {
          innerRef.current?.focus();
        },
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime97.jsx)("div", { className: "ExcTextField__label", children: label }),
          /* @__PURE__ */ (0, import_jsx_runtime97.jsxs)(
            "div",
            {
              className: clsx_m_default("ExcTextField__input", {
                "ExcTextField__input--readonly": readonly
              }),
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime97.jsx)(
                  "input",
                  {
                    className: clsx_m_default({
                      "is-redacted": "value" in rest && rest.value && isRedacted && !isTemporarilyUnredacted
                    }),
                    readOnly: readonly,
                    value: "value" in rest ? rest.value : void 0,
                    defaultValue: "defaultValue" in rest ? rest.defaultValue : void 0,
                    placeholder,
                    ref: innerRef,
                    onChange: (event) => onChange?.(event.target.value),
                    onKeyDown
                  }
                ),
                isRedacted && /* @__PURE__ */ (0, import_jsx_runtime97.jsx)(
                  Button,
                  {
                    onSelect: () => setIsTemporarilyUnredacted(!isTemporarilyUnredacted),
                    style: { border: 0, userSelect: "none" },
                    children: isTemporarilyUnredacted ? eyeClosedIcon : eyeIcon
                  }
                )
              ]
            }
          )
        ]
      }
    );
  }
);

// components/InlineIcon.tsx
init_define_import_meta_env();
var import_jsx_runtime98 = __toESM(require_jsx_runtime(), 1);
var InlineIcon = ({ icon }) => {
  return /* @__PURE__ */ (0, import_jsx_runtime98.jsx)(
    "span",
    {
      style: {
        width: "1em",
        margin: "0 0.5ex 0 0.5ex",
        display: "inline-block",
        lineHeight: 0,
        verticalAlign: "middle"
      },
      children: icon
    }
  );
};

// components/Paragraph.tsx
init_define_import_meta_env();
var import_jsx_runtime99 = __toESM(require_jsx_runtime(), 1);
var Paragraph = (props) => {
  return /* @__PURE__ */ (0, import_jsx_runtime99.jsx)("p", { className: "excalidraw__paragraph", style: props.style, children: props.children });
};

// components/TTDDialog/TTDDialogTabs.tsx
init_define_import_meta_env();
var import_react82 = __toESM(require_react(), 1);
var import_jsx_runtime100 = __toESM(require_jsx_runtime(), 1);
var TTDDialogTabs = (props) => {
  const setAppState = useExcalidrawSetAppState();
  const rootRef = (0, import_react82.useRef)(null);
  const minHeightRef = (0, import_react82.useRef)(0);
  return /* @__PURE__ */ (0, import_jsx_runtime100.jsx)(
    $69cb30bb0017df05$export$be92b6f5f03c0fe9,
    {
      ref: rootRef,
      className: "ttd-dialog-tabs-root",
      value: props.tab,
      onValueChange: (tab) => {
        if (!tab) {
          return;
        }
        const modalContentNode = rootRef.current?.closest(".Modal__content");
        if (modalContentNode) {
          const currHeight = modalContentNode.offsetHeight || 0;
          if (currHeight > minHeightRef.current) {
            minHeightRef.current = currHeight;
            modalContentNode.style.minHeight = `min(${minHeightRef.current}px, 100%)`;
          }
        }
        if (props.dialog === "settings" && isMemberOf(["text-to-diagram", "diagram-to-code"], tab)) {
          setAppState({
            openDialog: { name: props.dialog, tab, source: "settings" }
          });
        } else if (props.dialog === "ttd" && isMemberOf(["text-to-diagram", "mermaid"], tab)) {
          setAppState({
            openDialog: { name: props.dialog, tab }
          });
        }
      },
      children: props.children
    }
  );
};
TTDDialogTabs.displayName = "TTDDialogTabs";
var TTDDialogTabs_default = TTDDialogTabs;

// components/TTDDialog/TTDDialogTab.tsx
init_define_import_meta_env();
var import_jsx_runtime101 = __toESM(require_jsx_runtime(), 1);
var TTDDialogTab = ({
  tab,
  children,
  ...rest
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime101.jsx)($69cb30bb0017df05$export$7c6e2c02157bb7d2, { ...rest, value: tab, children });
};
TTDDialogTab.displayName = "TTDDialogTab";

// components/MagicSettings.tsx
var import_jsx_runtime102 = __toESM(require_jsx_runtime(), 1);
var MagicSettings = (props) => {
  const [keyInputValue, setKeyInputValue] = (0, import_react83.useState)(props.openAIKey || "");
  const [shouldPersist, setShouldPersist] = (0, import_react83.useState)(
    props.isPersisted
  );
  const appState = useUIAppState();
  const onConfirm = () => {
    props.onConfirm(keyInputValue.trim(), shouldPersist);
  };
  if (appState.openDialog?.name !== "settings") {
    return null;
  }
  return /* @__PURE__ */ (0, import_jsx_runtime102.jsx)(
    Dialog,
    {
      onCloseRequest: () => {
        props.onClose();
        props.onConfirm(keyInputValue.trim(), shouldPersist);
      },
      title: /* @__PURE__ */ (0, import_jsx_runtime102.jsxs)("div", { style: { display: "flex" }, children: [
        "Wireframe to Code (AI)",
        " ",
        /* @__PURE__ */ (0, import_jsx_runtime102.jsx)(
          "div",
          {
            style: {
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              padding: "0.1rem 0.5rem",
              marginLeft: "1rem",
              fontSize: 14,
              borderRadius: "12px",
              color: "#000",
              background: "pink"
            },
            children: "Experimental"
          }
        )
      ] }),
      className: "MagicSettings",
      autofocus: false,
      children: /* @__PURE__ */ (0, import_jsx_runtime102.jsx)(TTDDialogTabs_default, { dialog: "settings", tab: appState.openDialog.tab, children: /* @__PURE__ */ (0, import_jsx_runtime102.jsxs)(
        TTDDialogTab,
        {
          tab: "diagram-to-code",
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime102.jsxs)(Paragraph, { children: [
              "For the diagram-to-code feature we use",
              " ",
              /* @__PURE__ */ (0, import_jsx_runtime102.jsx)(InlineIcon, { icon: OpenAIIcon }),
              "OpenAI."
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime102.jsxs)(Paragraph, { children: [
              "While the OpenAI API is in beta, its use is strictly limited \u2014 as such we require you use your own API key. You can create an",
              " ",
              /* @__PURE__ */ (0, import_jsx_runtime102.jsx)(
                "a",
                {
                  href: "https://platform.openai.com/login?launch",
                  rel: "noopener noreferrer",
                  target: "_blank",
                  children: "OpenAI account"
                }
              ),
              ", add a small credit (5 USD minimum), and",
              " ",
              /* @__PURE__ */ (0, import_jsx_runtime102.jsx)(
                "a",
                {
                  href: "https://platform.openai.com/api-keys",
                  rel: "noopener noreferrer",
                  target: "_blank",
                  children: "generate your own API key"
                }
              ),
              "."
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime102.jsx)(Paragraph, { children: "Your OpenAI key does not leave the browser, and you can also set your own limit in your OpenAI account dashboard if needed." }),
            /* @__PURE__ */ (0, import_jsx_runtime102.jsx)(
              TextField,
              {
                isRedacted: true,
                value: keyInputValue,
                placeholder: "Paste your API key here",
                label: "OpenAI API key",
                onChange: (value) => {
                  setKeyInputValue(value);
                  props.onChange(value.trim(), shouldPersist);
                },
                selectOnRender: true,
                onKeyDown: (event) => event.key === KEYS.ENTER && onConfirm()
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime102.jsx)(Paragraph, { children: "By default, your API token is not persisted anywhere so you'll need to insert it again after reload. But, you can persist locally in your browser below." }),
            /* @__PURE__ */ (0, import_jsx_runtime102.jsx)(CheckboxItem, { checked: shouldPersist, onChange: setShouldPersist, children: "Persist API key in browser storage" }),
            /* @__PURE__ */ (0, import_jsx_runtime102.jsxs)(Paragraph, { children: [
              "Once API key is set, you can use the ",
              /* @__PURE__ */ (0, import_jsx_runtime102.jsx)(InlineIcon, { icon: MagicIcon }),
              " ",
              "tool to wrap your elements in a frame that will then allow you to turn it into code. This dialog can be accessed using the",
              " ",
              /* @__PURE__ */ (0, import_jsx_runtime102.jsx)("b", { children: "AI Settings" }),
              " ",
              /* @__PURE__ */ (0, import_jsx_runtime102.jsx)(InlineIcon, { icon: OpenAIIcon }),
              "."
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime102.jsx)(
              FilledButton,
              {
                className: "MagicSettings__confirm",
                size: "large",
                label: "Confirm",
                onClick: onConfirm
              }
            )
          ]
        }
      ) })
    }
  );
};

// components/TTDDialog/TTDDialog.tsx
init_define_import_meta_env();

// components/TTDDialog/MermaidToExcalidraw.tsx
init_define_import_meta_env();
var import_react87 = __toESM(require_react(), 1);

// components/TTDDialog/common.ts
init_define_import_meta_env();

// index.tsx
init_define_import_meta_env();
var import_react85 = __toESM(require_react(), 1);

// components/InitializeApp.tsx
init_define_import_meta_env();
var import_react84 = __toESM(require_react(), 1);
var import_jsx_runtime103 = __toESM(require_jsx_runtime(), 1);
var InitializeApp = (props) => {
  const [loading, setLoading] = (0, import_react84.useState)(true);
  (0, import_react84.useEffect)(() => {
    const updateLang = async () => {
      await setLanguage(currentLang2);
      setLoading(false);
    };
    const currentLang2 = languages.find((lang) => lang.code === props.langCode) || defaultLang;
    updateLang();
  }, [props.langCode]);
  return loading ? /* @__PURE__ */ (0, import_jsx_runtime103.jsx)(LoadingMessage, { theme: props.theme }) : props.children;
};

// polyfill.ts
init_define_import_meta_env();
var polyfill = () => {
  if (!Array.prototype.at) {
    Object.defineProperty(Array.prototype, "at", {
      value: function(n4) {
        n4 = Math.trunc(n4) || 0;
        if (n4 < 0) {
          n4 += this.length;
        }
        if (n4 < 0 || n4 >= this.length) {
          return void 0;
        }
        return this[n4];
      },
      writable: true,
      enumerable: false,
      configurable: true
    });
  }
  if (!Element.prototype.replaceChildren) {
    Element.prototype.replaceChildren = function(...nodes) {
      this.innerHTML = "";
      this.append(...nodes);
    };
  }
};
var polyfill_default = polyfill;

// components/footer/FooterCenter.tsx
init_define_import_meta_env();
var import_jsx_runtime104 = __toESM(require_jsx_runtime(), 1);
var FooterCenter = ({ children }) => {
  const { FooterCenterTunnel } = useTunnels();
  const appState = useUIAppState();
  return /* @__PURE__ */ (0, import_jsx_runtime104.jsx)(FooterCenterTunnel.In, { children: /* @__PURE__ */ (0, import_jsx_runtime104.jsx)(
    "div",
    {
      className: clsx_m_default("footer-center zen-mode-transition", {
        "layer-ui__wrapper__footer-left--transition-bottom": appState.zenModeEnabled
      }),
      children
    }
  ) });
};
var FooterCenter_default = FooterCenter;
FooterCenter.displayName = "FooterCenter";

// components/welcome-screen/WelcomeScreen.tsx
init_define_import_meta_env();

// components/welcome-screen/WelcomeScreen.Center.tsx
init_define_import_meta_env();

// components/ExcalidrawLogo.tsx
init_define_import_meta_env();
var import_jsx_runtime105 = __toESM(require_jsx_runtime(), 1);
var LogoIcon = () => /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(
  "svg",
  {
    viewBox: "0 0 40 40",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    className: "ExcalidrawLogo-icon",
    children: /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(
      "path",
      {
        d: "M39.9 32.889a.326.326 0 0 0-.279-.056c-2.094-3.083-4.774-6-7.343-8.833l-.419-.472a.212.212 0 0 0-.056-.139.586.586 0 0 0-.167-.111l-.084-.083-.056-.056c-.084-.167-.28-.278-.475-.167-.782.39-1.507.973-2.206 1.528-.92.722-1.842 1.445-2.708 2.25a8.405 8.405 0 0 0-.977 1.028c-.14.194-.028.361.14.444-.615.611-1.23 1.223-1.843 1.861a.315.315 0 0 0-.084.223c0 .083.056.166.111.194l1.09.833v.028c1.535 1.528 4.244 3.611 7.12 5.861.418.334.865.667 1.284 1 .195.223.39.473.558.695.084.11.28.139.391.055.056.056.14.111.196.167a.398.398 0 0 0 .167.056.255.255 0 0 0 .224-.111.394.394 0 0 0 .055-.167c.029 0 .028.028.056.028a.318.318 0 0 0 .224-.084l5.082-5.528a.309.309 0 0 0 0-.444Zm-14.63-1.917a.485.485 0 0 0 .111.14c.586.5 1.2 1 1.843 1.555l-2.569-1.945-.251-.166c-.056-.028-.112-.084-.168-.111l-.195-.167.056-.056.055-.055.112-.111c.866-.861 2.346-2.306 3.1-3.028-.81.805-2.43 3.167-2.095 3.944Zm8.767 6.89-2.122-1.612a44.713 44.713 0 0 0-2.625-2.5c1.145.861 2.122 1.611 2.262 1.75 1.117.972 1.06.806 1.815 1.445l.921.666a1.06 1.06 0 0 1-.251.25Zm.558.416-.056-.028c.084-.055.168-.111.252-.194l-.196.222ZM1.089 5.75c.055.361.14.722.195 1.056.335 1.833.67 3.5 1.284 4.75l.252.944c.084.361.223.806.363.917 1.424 1.25 3.602 3.11 5.947 4.889a.295.295 0 0 0 .363 0s0 .027.028.027a.254.254 0 0 0 .196.084.318.318 0 0 0 .223-.084c2.988-3.305 5.221-6.027 6.813-8.305.112-.111.14-.278.14-.417.111-.111.195-.25.307-.333.111-.111.111-.306 0-.39l-.028-.027c0-.055-.028-.139-.084-.167-.698-.666-1.2-1.138-1.731-1.638-.922-.862-1.871-1.75-3.881-3.75l-.028-.028c-.028-.028-.056-.056-.112-.056-.558-.194-1.703-.389-3.127-.639C6.087 2.223 3.21 1.723.614.944c0 0-.168 0-.196.028l-.083.084c-.028.027-.056.055-.224.11h.056-.056c.028.167.028.278.084.473 0 .055.112.5.112.555l.782 3.556Zm15.496 3.278-.335-.334c.084.112.196.195.335.334Zm-3.546 4.666-.056.056c0-.028.028-.056.056-.056Zm-2.038-10c.168.167.866.834 1.033.973-.726-.334-2.54-1.167-3.379-1.445.838.167 1.983.334 2.346.472ZM1.424 2.306c.419.722.754 3.222 1.089 5.666-.196-.778-.335-1.555-.503-2.278-.251-1.277-.503-2.416-.838-3.416.056 0 .14 0 .252.028Zm-.168-.584c-.112 0-.223-.028-.307-.028 0-.027 0-.055-.028-.055.14 0 .223.028.335.083Zm-1.089.222c0-.027 0-.027 0 0ZM39.453 1.333c.028-.11-.558-.61-.363-.639.42-.027.42-.666 0-.666-.558.028-1.144.166-1.675.25-.977.194-1.982.389-2.96.61-2.205.473-4.383.973-6.561 1.557-.67.194-1.424.333-2.066.666-.224.111-.196.333-.084.472-.056.028-.084.028-.14.056-.195.028-.363.056-.558.083-.168.028-.252.167-.224.334 0 .027.028.083.028.11-1.173 1.556-2.485 3.195-3.909 4.945-1.396 1.611-2.876 3.306-4.356 5.056-4.719 5.5-10.052 11.75-15.943 17.25a.268.268 0 0 0 0 .389c.028.027.056.055.084.055-.084.084-.168.14-.252.222-.056.056-.084.111-.084.167a.605.605 0 0 0-.111.139c-.112.111-.112.305.028.389.111.11.307.11.39-.028.029-.028.029-.056.056-.056a.44.44 0 0 1 .615 0c.335.362.67.723.977 1.028l-.698-.583c-.112-.111-.307-.083-.39.028-.113.11-.085.305.027.389l7.427 6.194c.056.056.112.056.196.056s.14-.028.195-.084l.168-.166c.028.027.083.027.111.027.084 0 .14-.027.196-.083 10.052-10.055 18.15-17.639 27.42-24.417.083-.055.111-.166.111-.25.112 0 .196-.083.251-.194 1.704-5.194 2.039-9.806 2.15-12.083v-.028c0-.028.028-.056.028-.083.028-.056.028-.084.028-.084a1.626 1.626 0 0 0-.111-1.028ZM21.472 9.5c.446-.5.893-1.028 1.34-1.5-2.876 3.778-7.65 9.583-14.408 16.5 4.607-5.083 9.242-10.333 13.068-15ZM5.193 35.778h.084-.084Zm3.462 3.194c-.027-.028-.027-.028 0-.028v.028Zm4.16-3.583c.224-.25.448-.472.699-.722 0 0 0 .027.028.027-.252.223-.475.445-.726.695Zm1.146-1.111c.14-.14.279-.334.446-.5l.028-.028c1.648-1.694 3.351-3.389 5.082-5.111l.028-.028c.419-.333.921-.694 1.368-1.028a379.003 379.003 0 0 0-6.952 6.695ZM24.794 6.472c-.921 1.195-1.954 2.778-2.82 4.028-2.736 3.944-11.532 13.583-11.727 13.75a1976.983 1976.983 0 0 1-8.042 7.639l-.167.167c-.14-.167-.14-.417.028-.556C14.49 19.861 22.03 10.167 25.074 5.917c-.084.194-.14.36-.28.555Zm4.83 5.695c-1.116-.64-1.646-1.64-1.34-2.611l.084-.334c.028-.083.084-.194.14-.277.307-.5.754-.917 1.257-1.167.027 0 .055 0 .083-.028-.028-.056-.028-.139-.028-.222.028-.167.14-.278.335-.278.335 0 1.369.306 1.76.639.111.083.223.194.335.305.14.167.363.445.474.667.056.028.112.306.196.445.056.222.111.472.084.694-.028.028 0 .194-.028.194a2.668 2.668 0 0 1-.363 1.028c-.028.028-.028.056-.056.084l-.028.027c-.14.223-.335.417-.53.556-.643.444-1.369.583-2.095.389 0 0-.195-.084-.28-.111Zm8.154-.834a39.098 39.098 0 0 1-.893 3.167c0 .028-.028.083 0 .111-.056 0-.084.028-.14.056-2.206 1.61-4.356 3.305-6.506 5.028 1.843-1.64 3.686-3.306 5.613-4.945.558-.5.949-1.139 1.06-1.861l.28-1.667v-.055c.14-.334.67-.195.586.166Z",
        fill: "currentColor"
      }
    )
  }
);
var LogoText = () => /* @__PURE__ */ (0, import_jsx_runtime105.jsxs)(
  "svg",
  {
    viewBox: "0 0 450 55",
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    className: "ExcalidrawLogo-text",
    children: [
      /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(
        "path",
        {
          d: "M429.27 96.74c2.47-1.39 4.78-3.02 6.83-4.95 1.43-1.35 2.73-2.86 3.81-4.51-.66.9-1.4 1.77-2.23 2.59-2.91 2.84-5.72 5.09-8.42 6.87h.01ZM343.6 69.36c.33 3.13.58 6.27.79 9.4.09 1.37.18 2.75.25 4.12-.12-4.46-.27-8.93-.5-13.39-.11-2.08-.24-4.16-.4-6.24-.06 1.79-.11 3.85-.13 6.11h-.01ZM378.47 98.34c.01-.37.07-1.13.01-6.51-.11 1.9-.22 3.81-.31 5.71-.07 1.42-.22 2.91-.16 4.35.39.03.78.07 1.17.1-.92-.85-.76-2.01-.72-3.66l.01.01ZM344.09 86.12c-.09-2.41-.22-4.83-.39-7.24v12.21c.15-.05.32-.09.47-.14.05-1.61-.03-3.23-.09-4.83h.01ZM440.69 66.79c-.22-.34-.45-.67-.69-.99-3.71-4.87-9.91-7.14-15.65-8.55-1.05-.26-2.12-.49-3.18-.71 2.29.59 4.48 1.26 6.64 2.02 7.19 2.54 10.57 5.41 12.88 8.23ZM305.09 72.46l1.2 3.6c.84 2.53 1.67 5.06 2.46 7.61.24.78.5 1.57.73 2.36.22-.04.44-.08.67-.12a776.9 776.9 0 0 1-5.01-13.57c-.02.04-.03.09-.05.13v-.01ZM345.49 90.25v.31c1.48-.42 3.05-.83 4.66-1.2-1.56.25-3.12.52-4.66.89ZM371.02 90.22c0-.57-.04-1.14-.11-1.71-.06-.02-.12-.04-.19-.05-.21-.05-.43-.08-.65-.11.42.16.74.88.95 1.87ZM398.93 54.23c-.13 0-.27-.01-.4-.02l.03.4c.11-.15.23-.27.37-.38ZM401.57 62.28v-.15c-1.22-.24-2.86-.61-3.23-1.25-.09-.15-.18-.51-.27-.98-.09.37-.2.73-.33 1.09 1.24.56 2.52.98 3.83 1.29ZM421.73 88.68c-2.97 1.65-6.28 3.12-9.69 3.68v.18c4.72-.14 11.63-3.85 16.33-8.38-2.04 1.75-4.33 3.24-6.63 4.53l-.01-.01ZM411.28 80.92c-.05-1.2-.09-2.4-.15-3.6-.21 5.66-.46 11.38-.47 14.51.24-.02.48-.04.71-.07.15-3.61.05-7.23-.09-10.83v-.01Z",
          transform: "translate(-144.023 -51.76)"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(
        "path",
        {
          d: "M425.38 67.41c-3.5-1.45-7.19-2.57-14.06-3.62.09 1.97.06 4.88-.03 8.12.03.04.06.09.06.15.19 1.36.28 2.73.37 4.1.25 3.77.39 7.55.41 11.33 0 1.38-.01 2.76-.07 4.13 1.4-.25 2.78-.65 4.12-1.15 4.07-1.5 7.94-3.78 11.28-6.54 2.33-1.92 5.13-4.49 5.88-7.58.63-3.53-2.45-6.68-7.97-8.96l.01.02ZM411.35 92.53v-.06l-.34.03c.11.01.22.03.34.03ZM314.26 64.06c-.23-.59-.47-1.17-.7-1.75.57 1.62 1.11 3.25 1.6 4.9l.15.54 2.35 6.05c.32.82.66 1.64.98 2.46-1.38-4.1-2.83-8.17-4.39-12.2h.01ZM156.82 103.07c-.18.13-.38.23-.58.33 1.32-.03 2.66-.2 3.93-.34.86-.09 1.72-.22 2.58-.33-2.12.1-4.12.17-5.94.34h.01ZM210.14 68.88s.03.04.05.07c.18-.31.39-.64.58-.96-.21.3-.42.6-.64.89h.01ZM201.65 82.8c-.5.77-1.02 1.56-1.49 2.37 1.11-1.55 2.21-3.1 3.2-4.59-.23.23-.49.51-.75.79-.32.47-.65.95-.96 1.43ZM194.03 98.66c-.33-.4-.65-.84-1.05-1.17-.24-.2-.07-.49.17-.56-.23-.26-.42-.5-.63-.75 1.51-2.55 3.93-5.87 6.4-9.28-.17-.08-.29-.28-.2-.49.04-.09.09-.17.13-.26-1.21 1.78-2.42 3.55-3.61 5.33-.87 1.31-1.74 2.64-2.54 4-.29.5-.63 1.04-.87 1.61.81.65 1.63 1.27 2.47 1.88-.09-.11-.18-.21-.27-.32v.01ZM307.79 82.93c-1-3.17-2.05-6.32-3.1-9.48-1.62 4.08-3.69 9.17-6.16 15.19 3.32-1.04 6.77-1.87 10.27-2.5-.32-1.08-.67-2.15-1.01-3.21ZM149.5 80.7c.05-1.71.04-3.43 0-5.14-.1 2.26-.16 4.51-.22 6.77-.02.73-.03 1.46-.04 2.19.14-1.27.2-2.55.24-3.82h.02ZM228.98 98.3c.39 1.25.91 3.03.94 3.91.06-.03.12-.07.17-.1.08-1.29-.55-2.65-1.11-3.81ZM307.72 53.36c.81.5 1.53 1.04 2.07 1.49-.38-.8-.78-1.58-1.21-2.35-.17.03-.34.06-.51.11-.43.12-.86.26-1.29.41.35-.01.53.1.94.34ZM283.69 96.14c3.91-7.25 6.89-13.35 8.88-18.15l1.1-2.66c-1.27 2.64-2.56 5.27-3.83 7.9-1.53 3.15-3.06 6.31-4.58 9.47-.87 1.81-1.76 3.62-2.54 5.47.04.02.07.04.11.07.05.05.1.09.15.14.05-.73.27-1.48.71-2.24ZM289.92 103.23s-.04.01-.05.03c0-.02.04-.03.05-.04.05-.05.11-.1.16-.15l.21-.21c-.55 0-1.5-.27-2.55-.72.4.26.8.51 1.22.74.24.13.48.26.73.37.05.02.1.03.14.05a.27.27 0 0 1 .08-.07h.01ZM269.23 68.49c-.39-.19-.82-.48-1.33-.87-3.06-1.56-6.31-2.78-9.36-2.35-3.5.49-5.7 1.11-7.74 2.44 5.71-2.6 12.82-2.07 18.44.79l-.01-.01ZM177.87 53.69l1.06.03c-.96-.22-2-.25-2.89-.3-4.95-.26-9.99.33-14.86 1.19-2.44.43-4.88.95-7.28 1.59 9.09-1.76 15.69-2.77 23.97-2.51ZM219.85 55.51c-.18.12-.36.27-.56.45-.45.53-.86 1.11-1.26 1.66-1.91 2.61-3.71 5.31-5.57 7.95l-.12.18 8.05-10.11c-.18-.05-.36-.1-.55-.13h.01ZM510.71 54.1c.12-.15.29-.3.53-.45.69-.4 3.72-.63 5.87-.74-.36-.02-.73-.04-1.09-.05-1.84-.03-3.67.09-5.49.35.05.3.12.59.18.88v.01ZM510.76 86.02c1.37-3.07 2.49-6.27 3.57-9.46.55-1.64 1.12-3.3 1.6-4.97-1.59 4.01-3.67 9.14-6.2 15.3.24-.08.5-.14.74-.22.1-.22.19-.44.29-.65ZM566.95 75.76c.11-.02.23.03.31.11-.05-.13-.09-.26-.14-.39-.05.09-.11.18-.17.28ZM511.33 86.41c3.08-.89 6.24-1.62 9.46-2.14-1.51-3.98-2.98-7.96-4.39-11.87-.05.15-.09.31-.14.46-1.02 3.32-2.15 6.61-3.39 9.85-.48 1.25-.98 2.49-1.53 3.7h-.01ZM578.24 74.45c.11-.44.23-.87.35-1.31-.31.7-.64 1.39-.97 2.08.09.21.19.4.28.61.12-.46.23-.92.35-1.38h-.01ZM520.62 53.11c-.09 0-.18-.01-.28-.02.38.34.29 1.08.93 2.53l6.65 17.15c2.2 5.68 4.69 11.36 7.41 16.87l1.06 2.17c-2.95-7.05-5.92-14.08-8.87-21.13-1.58-3.79-3.16-7.59-4.7-11.4-.78-1.92-1.73-3.89-2.25-5.91-.03-.1 0-.19.04-.26h.01ZM578.78 77.87c1.45-5.77 3.07-10.43 3.58-13.36.05-.34.16-.88.31-1.55-.67 1.79-1.37 3.56-2.08 5.33-.12.43-.23.86-.35 1.29-.65 2.43-1.29 4.86-1.9 7.3.14.33.29.65.43 1l.01-.01ZM545.3 94.66c.02-.44.03-.83.05-1.12.02-1.01.05-2.02.11-3.02.03-6.66-.46-14.33-1.46-22.8-.13-.42-.27-1.24-.56-2.89 0-.02 0-.04-.01-.06.62 6.61.95 13.25 1.32 19.87.17 3.08.33 6.16.52 9.23.02.25.03.52.04.78l-.01.01ZM580.77 102.81c.13.2.27.38.37.49.27-.11.53-.22.8-.32-.43.09-.82.05-1.17-.16v-.01ZM530.48 104.07h.33c-.36-.13-.71-.32-1.04-.56.14.24.3.47.45.7.06-.08.14-.13.26-.13v-.01ZM542.63 58.82c.06.23.11.47.15.71.14-.33.36-.62.7-.86-.28.05-.57.11-.85.15ZM583.81 57.87c.15-.7.29-1.41.42-2.11-.14.45-.28.9-.42 1.34-.46 1.44-.89 2.89-1.31 4.34.44-1.19.88-2.37 1.31-3.57ZM523.62 91.48c-4.66 1.17-9.05 2.89-14.02 5.27 4.65-1.84 9.48-3.29 14.28-4.63-.09-.22-.17-.41-.26-.64ZM460.64 78.3c-.04-2.9-.11-5.81-.28-8.71-.1-1.68-.17-3.43-.5-5.09-.07.02-.14.03-.2.05.3 6.54.45 12.17.51 17.12.17-.07.34-.14.51-.2 0-1.06-.01-2.11-.03-3.17h-.01ZM470.63 63.24c-3.38-.26-6.81.32-10.1 1.1.41 2.01.47 4.14.57 6.18.18 3.55.25 7.11.27 10.67 3.31-1.38 6.5-3.12 9.3-5.35 1.96-1.56 3.86-3.41 5.02-5.66.73-1.41 1.19-3.22.26-4.65-1.09-1.7-3.46-2.14-5.32-2.29ZM460.29 63.68c1-.24 2.01-.46 3.04-.65-1.15.16-2.37.38-3.71.69v.13c.07-.02.15-.04.22-.05.11-.13.3-.18.45-.11v-.01ZM457.24 100.96c.43-.03.86-.07 1.29-.11.14-.49.27-.99.38-1.49-.44.7-1 1.23-1.67 1.6ZM482.88 104.98c-.18.23-.36.38-.55.47.14.09.27.19.4.28a70.76 70.76 0 0 0 4.37-4.63c.76-.89 1.52-1.81 2.19-2.77-.3-.27-.61-.53-.92-.79-.07 1.94-4.62 6.32-5.49 7.45v-.01Z",
          transform: "translate(-144.023 -51.76)"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(
        "path",
        {
          d: "M474.36 63.31c-.4-.16-.84-.27-1.29-.37 1.56.42 3.08 1.22 3.76 2.74.62 1.4.32 2.95-.28 4.32.7-1.22.94-2.34.74-3.47-.24-1.33-1.19-2.54-2.93-3.21v-.01ZM477.34 89.18c-1.2-.81-2.4-1.62-3.6-2.42-.14.1-.26.19-.4.29 1.4.67 2.73 1.39 4 2.13ZM465.88 93.85c.37.25.74.5 1.1.75.46.32.92.65 1.38.97-1.57-1.2-2.01-1.61-2.49-1.72h.01ZM574.92 90.06c-2.28-5.21-4.93-11.13-5.67-12.26-.1-.15-1.57-3.01-1.63-3.08 0 0-.01.02-.02.02.4 1.37 1.09 2.69 1.65 3.99 2.14 4.95 4.36 9.86 6.67 14.73.6 1.26 1.21 2.52 1.83 3.78-.75-2.01-1.64-4.45-2.83-7.18ZM448.73 65.29c.1.2.22.38.34.57.22-.02.43-.06.65-.08v-.08c-.14-.05-.25 0-.99-.41ZM460.16 94.81c-.02.31-.06.59-.1.89-.03 1.71-.33 3.43-.79 5.07.15-.02.3-.03.45-.05.01-.04.02-.08.03-.11.09-.34.15-.69.2-1.03.17-1.07.25-2.16.33-3.24.05-.69.08-1.39.12-2.08-.27.1-.27.26-.24.57v-.02Z",
          transform: "translate(-144.023 -51.76)"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(
        "path",
        {
          d: "m328.67 98.12-3.22-6.58c-1.29-2.63-2.53-5.29-3.72-7.97-.25-.85-.52-1.69-.79-2.53-.81-2.57-1.67-5.12-2.55-7.67-1.92-5.53-3.9-11.08-6.32-16.41-.72-1.58-1.46-3.44-2.63-4.79-.03-.17-.16-.29-.34-.36a.282.282 0 0 0-.23-.04c-.06-.01-.12 0-.18.01-.74.06-1.5.38-2.19.61-2.22.77-4.4 1.64-6.63 2.38-.03-.08-.06-.16-.09-.25-.15-.42-.82-.24-.67.19.03.09.07.19.1.28l-.18.06c-.36.11-.28.6 0 .68.18 1.18.63 2.36.98 3.49.03.09.06.17.08.26-.08.23-.17.46-.24.64-.37.98-.79 1.94-1.21 2.9-1.27 2.89-2.62 5.75-3.98 8.6-3.18 6.67-6.44 13.31-9.64 19.97-1.08 2.25-2.2 4.5-3.15 6.81-.13.32.24.5.5.37 1.34 1.33 2.84 2.5 4.4 3.57.65.44 1.31.87 2.01 1.24.4.22.86.48 1.33.5.24.01.35-.19.33-.37.11-.1.21-.21.28-.28.41-.41.81-.84 1.2-1.26.85-.92 1.69-1.87 2.5-2.84 6.31-2.34 12.6-4.31 18.71-5.84 2.14 5.3 3.43 8.43 3.97 9.58.55 1.05 1.15 1.88 1.82 2.52 1.32.56 6.96-.03 9.23-1.96.87-1.28 1.19-2.67.93-4.15-.09-.5-.22-.95-.4-1.33l-.01-.03Zm-20.09-45.61c.43.77.83 1.56 1.21 2.35-.54-.45-1.27-.99-2.07-1.49-.42-.24-.6-.35-.94-.34.43-.15.85-.29 1.29-.41.17-.05.34-.08.51-.11Zm-25.86 45.66c.78-1.85 1.67-3.66 2.54-5.47 1.51-3.16 3.05-6.31 4.58-9.47 1.28-2.63 2.56-5.26 3.83-7.9l-1.1 2.66c-1.99 4.79-4.97 10.9-8.88 18.15-.43.76-.66 1.51-.71 2.24-.05-.05-.1-.09-.15-.14a.259.259 0 0 0-.11-.07Zm6.24 4.71c-.42-.23-.82-.48-1.22-.74 1.05.45 2 .72 2.55.72l-.21.21c-.05.05-.11.1-.16.15-.01.01-.04.03-.05.04 0-.02.03-.02.05-.03a.27.27 0 0 0-.08.07c-.05-.02-.1-.03-.14-.05-.25-.1-.49-.24-.73-.37h-.01Zm15.73-29.43c1.05 3.15 2.1 6.31 3.1 9.48.34 1.06.69 2.13 1.01 3.21-3.5.63-6.95 1.46-10.27 2.5 2.48-6.03 4.54-11.11 6.16-15.19Zm4.79 12.57c-.23-.79-.49-1.58-.73-2.36-.79-2.54-1.63-5.08-2.46-7.61l-1.2-3.6c.02-.04.04-.09.05-.13 1.6 4.45 3.28 9 5.01 13.57l-.67.12v.01Zm5.83-18.27-.15-.54c-.49-1.64-1.03-3.28-1.6-4.9.23.58.47 1.17.7 1.75 1.56 4.03 3.01 8.1 4.39 12.2-.33-.82-.67-1.64-.98-2.46l-2.35-6.05h-.01ZM390.43 79.37c-.13-10.43-.22-17.5-.24-19.97-.24-1.6.21-2.88-.65-3.65-.14-.13-.32-.23-.52-.32h.03c.45 0 .45-.69 0-.7-1.75-.03-3.5-.04-5.25-.14-1.38-.08-2.76-.21-4.15-.31-.07 0-.12.01-.17.04-.21-.07-.47.03-.45.31l.03.45c-.11.14-.19.3-.22.5-.21 1.26-.32 13.67-.36 23.59-.32 5.79-.67 11.57-.97 17.36-.09 1.73-.29 3.54-.21 5.3-.39.02-.38.64.04.69v.12c.05.44.74.45.7 0v-.06c1.1.09 2.2.21 3.3.3 1.14.19 2.44.2 3.29.17 1.73-.05 2.92-.05 3.8-.37.45-.05.9-.11 1.35-.17.44-.06.25-.73-.19-.67h-.01c.24-.32.45-.72.62-1.25.66-1.84.41-6.36.34-11.33l-.13-9.9.02.01Zm-12.26 18.17c.09-1.91.2-3.81.31-5.71.06 5.38 0 6.14-.01 6.51-.05 1.65-.21 2.81.72 3.66-.39-.04-.78-.07-1.17-.1-.06-1.44.09-2.93.16-4.35l-.01-.01ZM588.97 53.85c-2.06-.25-3.17-.51-3.76-.6a.3.3 0 0 1 .04-.08c.22-.39-.39-.75-.6-.35-.56 1.02-.9 2.19-1.26 3.29-.61 1.88-1.17 3.78-1.72 5.68-.63 2.19-1.24 4.39-1.83 6.59-.81 2.03-1.67 4.05-2.61 6.03-1.7-3.64-3.11-6.04-4.03-7.57-2.26-3.74-2.85-5.48-3.57-6.08l.31-.09c.43-.12.25-.8-.19-.67-1.06.3-2.12.6-3.17.95-.93.32-1.85.69-2.76 1.07-.13.05-.19.16-.22.27-.04.02-.08.05-.11.07-.04-.06-.07-.12-.11-.18a.354.354 0 0 0-.48-.12c-.16.09-.22.32-.13.48l.33.54c0 .09.02.18.06.28.51 1.16.78 1.38.72 1.47-2.42 3.44-5.41 7.86-6.2 9.1-1.27 1.97-2.01 3.14-2.45 3.84l-.91-6.56-.43-4.1c-.19-1.85-.37-3.23-.53-4.13-.19-1.1-.3-2.15-.45-3.16-.2-1.36-.29-2.06-.47-2.42h.04c.45.02.45-.68 0-.7-3.43-.16-6.81.94-10.17 1.48-.24-.22-.73-.04-.58.32.24.59.33 1.25.43 1.87.17 1.06.29 2.13.4 3.2.32 3.09.53 6.2.74 9.3.44 6.75.77 13.51 1.17 20.26.11 1.95.13 3.96.46 5.89.05.3.37.31.55.14.74 1.71 2.87 1.27 6.13 1.27 1.34 0 2.39.04 2.99-.11.02.32.48.53.63.18 3.61-8.26 7.41-16.46 12.05-24.2.03-.05.04-.1.05-.15.3.73.64 1.45.94 2.16.97 2.26 1.97 4.52 2.98 6.76 2.26 5.03 4.54 10.07 7.09 14.96.47.9.94 1.79 1.47 2.65.2.32.4.67.66.96-.18.25 0 .68.34.54.91-.38 1.82-.75 2.76-1.07 1.04-.35 2.11-.65 3.17-.95.39-.11.28-.66-.07-.68.62-.4.95-.96.87-1.91-.3-3.34.72-7.47.86-8.52l2.14-11.43c1.75-10.74 3.13-17.51 3.23-20.86.02-.49.08-2.84.13-3.24.17-1.25.48-1-4.96-1.65l.03-.02Zm-46.19 5.67c-.04-.24-.09-.48-.15-.71l.85-.15c-.34.24-.56.53-.7.86Zm1.95 25.12c-.36-6.63-.7-13.26-1.32-19.87 0 .02 0 .04.01.06.29 1.65.44 2.47.56 2.89 1 8.46 1.5 16.14 1.46 22.8-.06.99-.1 2-.11 3.02-.01.29-.03.68-.05 1.12-.01-.26-.03-.53-.04-.78-.19-3.08-.35-6.16-.52-9.23l.01-.01Zm36.4 18.66c-.11-.11-.24-.29-.37-.49.35.21.74.26 1.17.16-.27.11-.53.22-.8.32v.01Zm-.89-33.72c.12-.43.23-.86.35-1.29.71-1.77 1.41-3.55 2.08-5.33-.15.68-.26 1.22-.31 1.55-.5 2.94-2.13 7.59-3.58 13.36-.15-.35-.29-.66-.43-1 .61-2.44 1.25-4.87 1.9-7.3l-.01.01Zm3.56-12.48c.14-.44.28-.89.42-1.34-.13.7-.27 1.41-.42 2.11-.43 1.19-.86 2.38-1.31 3.57.42-1.45.85-2.9 1.31-4.34Zm-5.22 16.05c-.11.44-.23.87-.35 1.31-.12.46-.23.92-.35 1.38-.1-.22-.19-.4-.28-.61.34-.69.66-1.38.97-2.08h.01Zm-11.64 2.62c.06-.1.12-.19.17-.28.05.13.09.26.14.39a.398.398 0 0 0-.31-.11Zm2.3 2.98c-.56-1.3-1.25-2.63-1.65-3.99 0 0 .01-.02.02-.02.06.08 1.52 2.93 1.63 3.08.73 1.13 3.38 7.04 5.67 12.26 1.2 2.73 2.08 5.17 2.83 7.18-.62-1.25-1.23-2.51-1.83-3.78-2.31-4.87-4.53-9.78-6.67-14.73ZM275.92 87.03c-1.06-2.18-1.13-3.45-2.44-2.93-1.52.57-2.94 1.3-4.5 2.1-1.4.72-2.68 1.44-3.92 2.12.01-.25-.24-.5-.51-.34-4.8 2.93-12.41 4.7-17.28 1.31-1.98-1.77-3.32-4.15-3.97-5.78-.29-.95-.49-1.94-.63-2.93-.14-3.34 1.58-6.53 3.9-9.12.8-.79 1.68-1.51 2.66-2.12 3.7-2.3 8.22-3.07 12.51-2.51 2.71.35 5.32 1.24 7.71 2.55.39.22.75-.39.35-.6-.18-.1-.37-.18-.55-.27.56.27 1.03.33 1.51.19l-.48.39c-.15.11-.23.3-.13.48.09.15.33.24.48.13 1.3-.97 2.46-2.09 3.45-3.37.37-.29.64-.6.65-.97v-.02c.08-.33-.03-.7-.21-1.08-.31-.87-.98-2.01-2.19-3.26-2.43-2.52-3.79-3.45-5.68-4.26-1.14-.49-3.12-1.06-4.42-1.23-3.28-.42-10.64-1.21-18.18 4.11-7.74 5.46-11.94 12.3-12.23 20.61-.08 2.06.04 3.98.34 5.71.74 4.18 2.57 8 5.44 11.34 4.26 4.99 9.76 7.52 16.34 7.52 4.85 0 9.69-1.77 14.89-4.62.23-.12.45-.23.68-.35 2.19-1.1 4.37-2.23 6.46-3.5.49-.3 1.03-.61 1.5-.98 1.47-.87 1.11-1.12.49-2.95-.39-1.14-.76-2.7-2.06-5.36l.02-.01Zm-17.38-21.76c3.05-.42 6.31.79 9.36 2.35.51.39.94.68 1.33.87-5.61-2.86-12.72-3.39-18.44-.79 2.05-1.33 4.24-1.95 7.74-2.44l.01.01ZM443.67 72.67c-.4-2.2-1.15-4.33-2.37-6.22-1.49-2.32-3.58-4.19-5.91-5.64-6.17-3.81-13.75-5.11-20.83-6.01-3.23-.41-6.47-.69-9.72-.92l-1.39-.12c-.85-.07-1.52-.1-2.05-.1-1.08-.06-2.17-.12-3.25-.17-.08 0-.14.02-.19.05-.1.05-.18.14-.16.3.27 2.55-.01 5.12-.92 7.52-.15.38.4.56.62.28 1.32.59 2.68 1.05 4.08 1.37 0 2.78-.14 7.58-.33 12.91 0 0 0 .02-.01.03-.61 3.66-.79 7.42-1 11.12-.23 4.01-.43 8.03-.44 12.05 0 .64 0 1.28.03 1.93.02.31 0 .68.15.96.06.11.14.16.24.17-.2.17-.21.54.11.59 3.83.67 7.78.71 11.68.25 2.3-.19 4.87-.65 7.65-1.56 1.85-.54 3.67-1.18 5.43-1.91 7.2-3.02 14.31-8.07 17.35-15.53.76-1.86 1.17-3.8 1.31-5.75.3-1.93.28-3.82-.09-5.58l.01-.02Zm-19.32-15.42c5.74 1.41 11.94 3.68 15.65 8.55.25.32.47.65.69.99-2.3-2.82-5.68-5.69-12.88-8.23-2.16-.76-4.35-1.43-6.64-2.02 1.06.21 2.13.45 3.18.71Zm-25.82-3.04c.13 0 .27.01.4.02-.14.1-.26.23-.37.38 0-.13-.02-.26-.03-.4Zm34.82 22.17c-.75 3.09-3.55 5.66-5.88 7.58-3.35 2.76-7.21 5.03-11.28 6.54-1.33.49-2.71.9-4.12 1.15.06-1.38.08-2.76.07-4.13-.02-3.78-.16-7.56-.41-11.33-.09-1.37-.18-2.74-.37-4.1 0-.06-.03-.11-.06-.15.09-3.25.12-6.16.03-8.12 6.86 1.05 10.56 2.17 14.06 3.62 5.52 2.28 8.59 5.44 7.97 8.96l-.01-.02Zm-22 16.15c-.12 0-.23-.02-.34-.03l.34-.03v.06Zm-.69-.7c0-3.13.26-8.84.47-14.51.06 1.2.11 2.41.15 3.6.15 3.6.25 7.23.09 10.83-.24.03-.48.05-.71.07v.01Zm-12.33-30.94c.37.63 2.01 1.01 3.23 1.25v.15c-1.31-.31-2.59-.73-3.83-1.29.12-.36.23-.72.33-1.09.08.48.18.84.27.98Zm13.7 31.65v-.18c3.41-.56 6.71-2.02 9.69-3.68 2.31-1.28 4.59-2.78 6.63-4.53-4.69 4.53-11.61 8.24-16.33 8.38l.01.01Zm24.07-.75c-2.05 1.93-4.37 3.56-6.83 4.95 2.7-1.78 5.52-4.03 8.42-6.87.82-.82 1.56-1.69 2.23-2.59-1.08 1.65-2.38 3.16-3.81 4.51h-.01ZM187.16 92.14c-.79-2.47-2.1-7.12-3.1-6.87-.19-.01-2.09.77-4.08 1.54-3.06 1.18-5.91 2.13-10.09 2.82-2.74.42-5.87 1.01-10.61 1.06.04-3.34.05-6.01.05-7.99 7.97-.65 12.33-2.11 16.37-3.55 1.11-.39 2.69-1.01 2.63-1.8-.08-.35-.55-1.39-1.17-2.61-.47-1.16-.98-2.31-1.61-3.38-.42-.71-1.04-1.69-1.86-2.06-.11-.08-.22-.13-.29-.12-.02 0-.04 0-.07.01-.19-.04-.39-.05-.6-.01-.17.03-.24.15-.25.28-.04.02-.09.04-.14.05-4.33 1.48-8.85 2.33-13.24 3.61a499.1 499.1 0 0 0-.31-8.19c4.51-.99 8.88-1.38 13.11-1.82 3.68-.38 6.28.12 7.47.34.59.11.9.16 1.16.18h.1c-.1.37.44.66.62.28.02-.04.03-.08.05-.13.15.2.53.22.62-.1.17-.58.19-1.21.21-1.81v-.36c.03-.15.05-.3.07-.45.52-2.47.33-5.09-.64-7.44-.11-.27-.44-.28-.6-.14-.08-.21-.15-.42-.24-.62-.19-.41-.79-.05-.6.35.03.07.05.15.09.22-.98-.42-2.15-.54-3.17-.63-2.17-.19-4.37-.14-6.54 0-5.7.35-11.4 1.3-16.91 2.79-2.08.56-4.13 1.22-6.14 2-4.54 1.05-3.79 1.51-2.17 6.07.18.51.46 1.68.54 1.94.82 2.47 1.08 2.13 3.1 2.13s0 .05 0 .08h.52c-.48 2.66-.51 5.45-.62 8.13-.15 3.48-.22 6.96-.28 10.45 0 .41-.01.82-.02 1.23-.16.29-.33.57-.51.85-.05.38-.09.77-.14 1.18-.42 3.52-.59 6.48-.52 8.8v.34c.02.47.05.76.06.87.16 1.57-.26 3.47 1.35 3.79 1.61.32 3.5.55 4.85.55.11 0 .22-.02.33-.02 1.79.24 3.67.05 5.45-.12 2.85-.28 5.69-.7 8.51-1.19 3.03-.53 6.05-1.14 9.04-1.86 2.4-.58 4.82-1.19 7.13-2.06.51-.19 1.73-.57 2.46-1.14 1.81-.68 2.18-1 1.57-2.67-.23-.62-.48-1.49-.91-2.78l-.03-.02Zm-11.12-38.71c.89.05 1.93.08 2.89.3-.33 0-.68-.02-1.06-.03-8.28-.26-14.88.75-23.97 2.51 2.41-.64 4.85-1.16 7.28-1.59 4.87-.86 9.91-1.45 14.86-1.19Zm-26.53 22.13c.03 1.71.04 3.43 0 5.14-.04 1.27-.11 2.55-.24 3.82 0-.73.02-1.46.04-2.19.05-2.26.12-4.51.22-6.77h-.02Zm6.73 27.85c.2-.1.4-.21.58-.33 1.82-.17 3.82-.24 5.94-.34-.86.11-1.72.24-2.58.33-1.27.14-2.61.31-3.93.34h-.01ZM534.48 85.44c-3.52-8.38-7.07-16.75-10.5-25.17-.63-1.54-1.25-3.09-1.86-4.65-.31-.8-.65-1.6-.87-2.43-.04-.17-.17-.24-.31-.25.1-.2 0-.51-.29-.53-1.59-.08-3.18-.22-4.78-.25-1.96-.03-3.91.13-5.84.42-.31.05-.31.38-.13.56-.03.06-.05.14-.04.22.23 1.54.63 3.06 1.16 4.53.13.35.27.7.41 1.06l-2.68 6.18c-.11.03-.2.09-.25.22-.67 1.9-1.52 3.73-2.34 5.56a536.85 536.85 0 0 1-3.9 8.45c-2.64 5.64-5.34 11.25-7.91 16.93-.44.97-.88 1.94-1.29 2.93-.2.48-.47 1-.55 1.52v.05c-.02.12.02.26.16.34 1.19.73 2.41 1.41 3.66 2.05 1.2.62 2.45 1.25 3.76 1.61.43.12.62-.55.19-.67-1.13-.31-2.2-.83-3.24-1.36 1.09.36 2.1.69 2.75.93 2.82 1.01 2.38 1.1 4.3-3.75 2.1-1.09 4.34-1.96 6.53-2.79 4.35-1.64 8.8-3.03 13.27-4.29.82 2.01 1.77 3.97 2.72 5.92.35.83.62 1.45.79 1.82.22.42.45.8.69 1.15.17.33.33.67.5 1 .42.8.84 1.63 1.4 2.35.23.29.6 0 .55-.31 1.53-.02 3.06-.07 4.58-.27.92-.12 1.82-.32 2.71-.54 1.39-.27 3.85-1.11 3.74-1.42-.67-1.96-1.55-3.87-2.34-5.78-1.57-3.78-3.16-7.56-4.75-11.33v-.01Zm-11.65-26.16c1.54 3.81 3.12 7.6 4.7 11.4 2.94 7.05 5.91 14.09 8.87 21.13l-1.06-2.17c-2.71-5.51-5.2-11.19-7.41-16.87l-6.65-17.15c-.65-1.45-.55-2.19-.93-2.53.09 0 .18.01.28.02a.29.29 0 0 0-.04.26c.52 2.02 1.47 3.98 2.25 5.91h-.01Zm-6.58 13.58c.05-.15.09-.31.14-.46 1.41 3.92 2.88 7.9 4.39 11.87-3.22.52-6.38 1.25-9.46 2.14.55-1.22 1.05-2.46 1.53-3.7 1.24-3.24 2.37-6.53 3.39-9.85h.01Zm-.23-20c.36 0 .73.03 1.09.05-2.15.1-5.18.33-5.87.74-.24.15-.41.3-.53.45-.06-.29-.13-.58-.18-.88 1.82-.26 3.65-.39 5.49-.35v-.01Zm-.09 18.72c-.49 1.67-1.05 3.33-1.6 4.97-1.07 3.19-2.19 6.38-3.57 9.46-.09.21-.19.43-.29.65-.25.07-.5.14-.74.22 2.53-6.16 4.61-11.29 6.2-15.3Zm-6.34 25.16c4.97-2.38 9.37-4.1 14.02-5.27l.26.64c-4.8 1.35-9.63 2.8-14.28 4.63Zm20.17 6.76c.33.23.68.42 1.04.56h-.33c-.12 0-.21.06-.26.13-.15-.23-.31-.45-.45-.7v.01ZM226.57 91.75c-3.55-4.74-6.68-9.11-9.31-12.99 9.2-15.25 10.05-17.81 10.35-18.38.17-.34 1.09-2.27.64-2.53-1.13-.65-1.03-.65-2.97-1.71-1.19-.65-3.04-1.61-4.53-2.12-1.71-.59-1.24-.36-3 2.77-.06.1-.11.2-.17.3-.75 1.02-1.48 2.05-2.2 3.09-1.88 2.71-3.73 5.45-5.69 8.1-3.68-4.91-6.88-8.76-9.51-11.43-.15-.15-.3-.29-.46-.42-1.27-1.28-7.24 3.53-7.93 5.58-.09.09-.19.16-.28.25-.27.26.03.64.33.58.19.65.5 1.29.94 1.91 3.85 5.06 7.19 9.76 9.94 14-1.23 2.61-3.06 5-4.67 7.38l-2.28 3.33c-.5.66-.93 1.23-1.29 1.69-.67.93-2.09 2.61-2.3 3.87-.51.85-1.16 1.84-1.29 2.83-.06.44.61.63.67.19.01-.08.04-.15.06-.22 1.36 1.08 2.76 2.11 4.19 3.11 1.3.91 2.62 1.85 4.04 2.56.21.1.4 0 .48-.17.24.07.48.14.72.2.44.1.62-.57.19-.67-2.02-.48-3.77-1.57-5.23-3.02-.47-.46-.9-.96-1.32-1.46 1.74 1.35 4.2 2.89 5.89 4.14 1.39 1.03 2.85-2.27 4.22-4.2 1.86-2.64 3.96-5.86 5.52-8.29l10.39 14.51c.67.81 1.14 1.21 1.57 1.36-.05.24.12.51.41.4 1.53-.58 3.05-1.19 4.54-1.87 1.52-.69 3.06-1.45 4.36-2.5a.28.28 0 0 0 .12-.23c1.66-1.1.81-1.74-1.41-4.91-1.13-1.58-1.71-2.36-3.7-5.01l-.03-.02Zm2.41 6.54c.56 1.15 1.19 2.52 1.11 3.81-.06.04-.12.07-.17.1-.03-.88-.55-2.66-.94-3.91Zm-16.51-32.73c1.86-2.65 3.65-5.35 5.57-7.95.4-.55.81-1.13 1.26-1.66.19-.18.38-.33.56-.45.18.03.36.08.55.13l-8.05 10.11.12-.18h-.01ZM192.7 95.48c.79-1.37 1.66-2.69 2.54-4 1.19-1.79 2.4-3.56 3.61-5.33-.04.09-.09.17-.13.26-.1.22.03.41.2.49-2.47 3.42-4.89 6.73-6.4 9.28.21.24.4.48.63.75-.24.07-.4.36-.17.56.4.33.72.77 1.05 1.17.09.11.18.21.27.32-.84-.61-1.66-1.24-2.47-1.88.24-.57.58-1.11.87-1.61v-.01Zm7.46-10.32c.47-.81.98-1.59 1.49-2.37.31-.48.64-.95.96-1.43.26-.29.52-.56.75-.79-.99 1.48-2.09 3.03-3.2 4.59Zm10.03-16.22s-.03-.05-.05-.07c.22-.29.43-.59.64-.89-.2.32-.4.65-.58.96h-.01ZM371.54 87.96c-.01-.08-.01-.16-.03-.23-.06-.38-.58-.29-.66.03-.3-.05-.6-.08-.81-.11-1.14-.15-2.29-.19-3.44-.2 1.04-.09 2.09-.18 3.14-.23.45-.02.45-.72 0-.7-6.57.35-13.14 1.23-19.65 2.11-1.53.21-3.05.42-4.57.68-.01 0-.02.01-.04.01-.04-3.33-.13-6.66-.24-9.99-.19-5.7-.4-11.41-.88-17.1-.13-1.51-.23-3.07-.49-4.58 0-.25 0-.48-.02-.68-.06-1.19-.04-2.61-.68-2.78-.16-.07-.72-.16-1.5-.24.22-.17.16-.62-.2-.63-1.19-.04-2.39.09-3.57.23-1.2.14-2.41.32-3.59.6-.16-.1-.41-.06-.5.12-.06.02-.13.03-.19.05-.35.1-.29.55-.03.66-.26.6-.19 2.27-.21 3-.02.66-.66 33.73-.9 40.3-.03.65.06 1.12.04 1.45-.16 3.05.87 4.96 6.34 3.93 1.09-.08 2.75-.77 5.36-1.43 4.13-1.04 5.78-1.52 6.2-1.65 6.43-1.69 6.78-1.97 11.72-2.43.55-.05 4.8-.38 6.03-.3.64.04 1.19.07 1.65.1.09 0 .16-.03.24-.05.1.27.56.33.66-.02.39-1.32.61-2.71.78-4.08.2-1.61.29-3.24.15-4.86.24.03.52-.23.38-.53-.09-.2-.27-.33-.49-.43v-.02Zm-.63.56c.07.57.11 1.14.11 1.71-.21-.99-.53-1.71-.95-1.87.22.03.44.06.65.11.06.01.12.04.19.05Zm-25.41 1.73c1.54-.36 3.1-.64 4.66-.89-1.61.37-3.18.77-4.66 1.2v-.31Zm-.86-7.37c-.07-1.37-.16-2.75-.25-4.12-.21-3.13-.45-6.27-.79-9.4.02-2.25.08-4.31.13-6.11.16 2.08.29 4.16.4 6.24.23 4.46.38 8.93.5 13.39h.01Zm-.94-4c.16 2.41.29 4.83.39 7.24.06 1.6.14 3.22.09 4.83-.15.05-.32.09-.47.14V78.88h-.01ZM483.72 92.83c-3.05-2.28-6.22-4.4-9.38-6.51 8.86-6.49 13.49-12.95 13.73-19.23.04-.76 0-1.5-.13-2.2-.67-3.82-3.5-6.68-8.39-8.48.13.04.27.08.4.13 3.92 1.39 7.74 4.23 8.5 8.56.34 1.95-.05 3.96-.98 5.69-.21.4.39.75.6.35 1.86-3.46 1.46-7.55-.97-10.63-3.53-4.47-9.76-5.88-15.16-6.16-2.32-.12-4.64-.04-6.95.19-6 .32-12.71 1.68-17.63 3.21-.37.11-.67.23-.92.35-.2-.17-.62.02-.57.37v.03c-.64.68-.18 1.64.48 3.21.38.91.67 1.89 1.15 2.58.32.76.68 1.51 1.13 2.19.14.21.38.19.53.07.19-.02.38-.05.57-.08v1.57c-.06.06-.1.13-.11.23-.27 4.18-.34 8.38-.48 12.57l-.3 9.03c-.24 3.91-.44 6.77-.46 7.26-.05.88-.11 1.95.07 2.81-.01.22-.02.43-.04.65 0 .11-.02.23-.03.35 0 .05-.03.27-.01.16-.05.4.5.59.64.28.05.04.12.08.2.08 1.75.13 3.5.28 5.25.3 1.69.02 3.38-.12 5.06-.32.08.23.36.39.55.15.06-.08.11-.17.16-.26.18-.09.24-.32.18-.48.05-.2.1-.4.13-.6.16-.86.25-1.74.33-2.62.11-1.17.17-2.34.23-3.51.15-.01.32-.03.52-.04.36-.03 1.73-.15 2.06-.15.39 0 .7-.02.95-.04 1.76 1.11 3.45 2.35 5.14 3.55 2.83 2.01 5.64 4.04 8.47 6.04 1.42 1 2.85 2 4.29 2.97.1.06.19.07.27.04.08 0 .17-.02.25-.1 1.61-1.56 3.15-3.18 4.6-4.88.75-.88 1.49-1.78 2.15-2.73.01.01.03.02.04.03.34.3.83-.2.49-.49-2.16-1.9-4.34-3.76-6.64-5.48l.03-.01Zm-6.38-3.65a55.72 55.72 0 0 0-4-2.13c.14-.1.26-.19.4-.29 1.2.81 2.4 1.61 3.6 2.42Zm-20.1 11.78c.67-.37 1.23-.91 1.67-1.6-.11.5-.24 1-.38 1.49-.43.04-.86.08-1.29.11Zm2.38-37.24c1.34-.31 2.56-.52 3.71-.69-1.03.19-2.04.41-3.04.65-.14-.07-.34-.02-.45.11-.07.02-.15.04-.22.05v-.13.01Zm.04.84c.07-.02.14-.03.2-.05.34 1.66.41 3.41.5 5.09.17 2.9.24 5.81.28 8.71l.03 3.17c-.17.07-.34.14-.51.2-.06-4.96-.21-10.58-.51-17.12h.01Zm16.04 5.62c-1.16 2.25-3.06 4.1-5.02 5.66-2.8 2.23-5.99 3.97-9.3 5.35-.01-3.56-.09-7.12-.27-10.67-.1-2.04-.16-4.16-.57-6.18 3.3-.78 6.72-1.36 10.1-1.1 1.85.14 4.23.59 5.32 2.29.92 1.43.46 3.24-.26 4.65Zm.85-.18c.6-1.37.9-2.92.28-4.32-.67-1.52-2.2-2.32-3.76-2.74.46.1.89.21 1.29.37 1.74.67 2.69 1.88 2.93 3.21.2 1.13-.05 2.25-.74 3.47V70Zm-27.47-4.14c-.12-.19-.23-.38-.34-.57.74.42.85.36.99.41v.08c-.22.03-.43.06-.65.08Zm11.21 30.46c-.08 1.08-.16 2.17-.33 3.24-.05.35-.11.69-.2 1.03 0 .04-.02.07-.03.11-.15.02-.3.04-.45.05.45-1.64.76-3.36.79-5.07.03-.29.08-.57.1-.89-.03-.31-.03-.47.24-.57-.04.69-.07 1.39-.12 2.08v.02Zm5.6-2.47c.48.11.92.52 2.49 1.72-.46-.32-.92-.65-1.38-.97-.37-.25-.73-.5-1.1-.75h-.01Zm21.23 7.24a70.76 70.76 0 0 1-4.37 4.63c-.14-.09-.27-.19-.4-.28.19-.09.37-.24.55-.47.87-1.14 5.43-5.51 5.49-7.45.31.26.62.53.92.79-.67.97-1.42 1.88-2.19 2.77v.01Z",
          fill: "currentColor",
          transform: "translate(-144.023 -51.76)"
        }
      )
    ]
  }
);
var ExcalidrawLogo = ({
  style,
  size = "small",
  withText
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime105.jsxs)("div", { className: `ExcalidrawLogo is-${size}`, style, children: [
    /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(LogoIcon, {}),
    withText && /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(LogoText, {})
  ] });
};

// components/welcome-screen/WelcomeScreen.Center.tsx
var import_jsx_runtime106 = __toESM(require_jsx_runtime(), 1);
var WelcomeScreenMenuItemContent = ({
  icon,
  shortcut,
  children
}) => {
  const device = useDevice();
  return /* @__PURE__ */ (0, import_jsx_runtime106.jsxs)(import_jsx_runtime106.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime106.jsx)("div", { className: "welcome-screen-menu-item__icon", children: icon }),
    /* @__PURE__ */ (0, import_jsx_runtime106.jsx)("div", { className: "welcome-screen-menu-item__text", children }),
    shortcut && !device.editor.isMobile && /* @__PURE__ */ (0, import_jsx_runtime106.jsx)("div", { className: "welcome-screen-menu-item__shortcut", children: shortcut })
  ] });
};
WelcomeScreenMenuItemContent.displayName = "WelcomeScreenMenuItemContent";
var WelcomeScreenMenuItem = ({
  onSelect,
  children,
  icon,
  shortcut,
  className = "",
  ...props
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime106.jsx)(
    "button",
    {
      ...props,
      type: "button",
      className: `welcome-screen-menu-item ${className}`,
      onClick: onSelect,
      children: /* @__PURE__ */ (0, import_jsx_runtime106.jsx)(WelcomeScreenMenuItemContent, { icon, shortcut, children })
    }
  );
};
WelcomeScreenMenuItem.displayName = "WelcomeScreenMenuItem";
var WelcomeScreenMenuItemLink = ({
  children,
  href,
  icon,
  shortcut,
  className = "",
  ...props
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime106.jsx)(
    "a",
    {
      ...props,
      className: `welcome-screen-menu-item ${className}`,
      href,
      target: "_blank",
      rel: "noreferrer",
      children: /* @__PURE__ */ (0, import_jsx_runtime106.jsx)(WelcomeScreenMenuItemContent, { icon, shortcut, children })
    }
  );
};
WelcomeScreenMenuItemLink.displayName = "WelcomeScreenMenuItemLink";
var Center = ({ children }) => {
  const { WelcomeScreenCenterTunnel } = useTunnels();
  return /* @__PURE__ */ (0, import_jsx_runtime106.jsx)(WelcomeScreenCenterTunnel.In, { children: /* @__PURE__ */ (0, import_jsx_runtime106.jsx)("div", { className: "welcome-screen-center", children: children || /* @__PURE__ */ (0, import_jsx_runtime106.jsxs)(import_jsx_runtime106.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime106.jsx)(Logo, {}),
    /* @__PURE__ */ (0, import_jsx_runtime106.jsx)(Heading, { children: t("welcomeScreen.defaults.center_heading") }),
    /* @__PURE__ */ (0, import_jsx_runtime106.jsxs)(Menu, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime106.jsx)(MenuItemLoadScene, {}),
      /* @__PURE__ */ (0, import_jsx_runtime106.jsx)(MenuItemHelp, {})
    ] })
  ] }) }) });
};
Center.displayName = "Center";
var Logo = ({ children }) => {
  return /* @__PURE__ */ (0, import_jsx_runtime106.jsx)("div", { className: "welcome-screen-center__logo virgil welcome-screen-decor", children: children || /* @__PURE__ */ (0, import_jsx_runtime106.jsx)(ExcalidrawLogo, { withText: true }) });
};
Logo.displayName = "Logo";
var Heading = ({ children }) => {
  return /* @__PURE__ */ (0, import_jsx_runtime106.jsx)("div", { className: "welcome-screen-center__heading welcome-screen-decor virgil", children });
};
Heading.displayName = "Heading";
var Menu = ({ children }) => {
  return /* @__PURE__ */ (0, import_jsx_runtime106.jsx)("div", { className: "welcome-screen-menu", children });
};
Menu.displayName = "Menu";
var MenuItemHelp = () => {
  const actionManager = useExcalidrawActionManager();
  return /* @__PURE__ */ (0, import_jsx_runtime106.jsx)(
    WelcomeScreenMenuItem,
    {
      onSelect: () => actionManager.executeAction(actionShortcuts),
      shortcut: "?",
      icon: HelpIcon,
      children: t("helpDialog.title")
    }
  );
};
MenuItemHelp.displayName = "MenuItemHelp";
var MenuItemLoadScene = () => {
  const appState = useUIAppState();
  const actionManager = useExcalidrawActionManager();
  if (appState.viewModeEnabled) {
    return null;
  }
  return /* @__PURE__ */ (0, import_jsx_runtime106.jsx)(
    WelcomeScreenMenuItem,
    {
      onSelect: () => actionManager.executeAction(actionLoadScene),
      shortcut: getShortcutFromShortcutName("loadScene"),
      icon: LoadIcon,
      children: t("buttons.load")
    }
  );
};
MenuItemLoadScene.displayName = "MenuItemLoadScene";
var MenuItemLiveCollaborationTrigger = ({
  onSelect
}) => {
  const { t: t4 } = useI18n();
  return /* @__PURE__ */ (0, import_jsx_runtime106.jsx)(WelcomeScreenMenuItem, { shortcut: null, onSelect, icon: usersIcon, children: t4("labels.liveCollaboration") });
};
MenuItemLiveCollaborationTrigger.displayName = "MenuItemLiveCollaborationTrigger";
Center.Logo = Logo;
Center.Heading = Heading;
Center.Menu = Menu;
Center.MenuItem = WelcomeScreenMenuItem;
Center.MenuItemLink = WelcomeScreenMenuItemLink;
Center.MenuItemHelp = MenuItemHelp;
Center.MenuItemLoadScene = MenuItemLoadScene;
Center.MenuItemLiveCollaborationTrigger = MenuItemLiveCollaborationTrigger;

// components/welcome-screen/WelcomeScreen.Hints.tsx
init_define_import_meta_env();
var import_jsx_runtime107 = __toESM(require_jsx_runtime(), 1);
var MenuHint = ({ children }) => {
  const { WelcomeScreenMenuHintTunnel } = useTunnels();
  return /* @__PURE__ */ (0, import_jsx_runtime107.jsx)(WelcomeScreenMenuHintTunnel.In, { children: /* @__PURE__ */ (0, import_jsx_runtime107.jsxs)("div", { className: "virgil welcome-screen-decor welcome-screen-decor-hint welcome-screen-decor-hint--menu", children: [
    WelcomeScreenMenuArrow,
    /* @__PURE__ */ (0, import_jsx_runtime107.jsx)("div", { className: "welcome-screen-decor-hint__label", children: children || t("welcomeScreen.defaults.menuHint") })
  ] }) });
};
MenuHint.displayName = "MenuHint";
var ToolbarHint = ({ children }) => {
  const { WelcomeScreenToolbarHintTunnel } = useTunnels();
  return /* @__PURE__ */ (0, import_jsx_runtime107.jsx)(WelcomeScreenToolbarHintTunnel.In, { children: /* @__PURE__ */ (0, import_jsx_runtime107.jsxs)("div", { className: "virgil welcome-screen-decor welcome-screen-decor-hint welcome-screen-decor-hint--toolbar", children: [
    /* @__PURE__ */ (0, import_jsx_runtime107.jsx)("div", { className: "welcome-screen-decor-hint__label", children: children || t("welcomeScreen.defaults.toolbarHint") }),
    WelcomeScreenTopToolbarArrow
  ] }) });
};
ToolbarHint.displayName = "ToolbarHint";
var HelpHint = ({ children }) => {
  const { WelcomeScreenHelpHintTunnel } = useTunnels();
  return /* @__PURE__ */ (0, import_jsx_runtime107.jsx)(WelcomeScreenHelpHintTunnel.In, { children: /* @__PURE__ */ (0, import_jsx_runtime107.jsxs)("div", { className: "virgil welcome-screen-decor welcome-screen-decor-hint welcome-screen-decor-hint--help", children: [
    /* @__PURE__ */ (0, import_jsx_runtime107.jsx)("div", { children: children || t("welcomeScreen.defaults.helpHint") }),
    WelcomeScreenHelpArrow
  ] }) });
};
HelpHint.displayName = "HelpHint";

// components/welcome-screen/WelcomeScreen.tsx
var import_jsx_runtime108 = __toESM(require_jsx_runtime(), 1);
var WelcomeScreen = (props) => {
  return /* @__PURE__ */ (0, import_jsx_runtime108.jsx)(import_jsx_runtime108.Fragment, { children: props.children || /* @__PURE__ */ (0, import_jsx_runtime108.jsxs)(import_jsx_runtime108.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime108.jsx)(Center, {}),
    /* @__PURE__ */ (0, import_jsx_runtime108.jsx)(MenuHint, {}),
    /* @__PURE__ */ (0, import_jsx_runtime108.jsx)(ToolbarHint, {}),
    /* @__PURE__ */ (0, import_jsx_runtime108.jsx)(HelpHint, {})
  ] }) });
};
WelcomeScreen.displayName = "WelcomeScreen";
WelcomeScreen.Center = Center;
WelcomeScreen.Hints = { MenuHint, ToolbarHint, HelpHint };
var WelcomeScreen_default = WelcomeScreen;

// components/live-collaboration/LiveCollaborationTrigger.tsx
init_define_import_meta_env();
var import_jsx_runtime109 = __toESM(require_jsx_runtime(), 1);
var LiveCollaborationTrigger2 = ({
  isCollaborating,
  onSelect,
  ...rest
}) => {
  const appState = useUIAppState();
  const showIconOnly = appState.width < 830;
  return /* @__PURE__ */ (0, import_jsx_runtime109.jsxs)(
    Button,
    {
      ...rest,
      className: clsx_m_default("collab-button", { active: isCollaborating }),
      type: "button",
      onSelect,
      style: { position: "relative", width: showIconOnly ? void 0 : "auto" },
      title: t("labels.liveCollaboration"),
      children: [
        showIconOnly ? share : t("labels.share"),
        appState.collaborators.size > 0 && /* @__PURE__ */ (0, import_jsx_runtime109.jsx)("div", { className: "CollabButton-collaborators", children: appState.collaborators.size })
      ]
    }
  );
};
var LiveCollaborationTrigger_default = LiveCollaborationTrigger2;
LiveCollaborationTrigger2.displayName = "LiveCollaborationTrigger";

// components/TTDDialog/TTDDialogTrigger.tsx
init_define_import_meta_env();
var import_jsx_runtime110 = __toESM(require_jsx_runtime(), 1);
var TTDDialogTrigger = ({
  children,
  icon
}) => {
  const { TTDDialogTriggerTunnel } = useTunnels();
  const setAppState = useExcalidrawSetAppState();
  return /* @__PURE__ */ (0, import_jsx_runtime110.jsx)(TTDDialogTriggerTunnel.In, { children: /* @__PURE__ */ (0, import_jsx_runtime110.jsxs)(
    DropdownMenu_default.Item,
    {
      onSelect: () => {
        trackEvent("ai", "dialog open", "ttd");
        setAppState({ openDialog: { name: "ttd", tab: "text-to-diagram" } });
      },
      icon: icon ?? brainIcon,
      children: [
        children ?? t("labels.textToDiagram"),
        /* @__PURE__ */ (0, import_jsx_runtime110.jsx)(DropdownMenu_default.Item.Badge, { children: "AI" })
      ]
    }
  ) });
};
TTDDialogTrigger.displayName = "TTDDialogTrigger";

// data/transform.ts
init_define_import_meta_env();
var DEFAULT_LINEAR_ELEMENT_PROPS = {
  width: 100,
  height: 0
};
var DEFAULT_DIMENSION = 100;
var bindTextToContainer = (container, textProps, elementsMap) => {
  const textElement = newTextElement({
    x: 0,
    y: 0,
    textAlign: TEXT_ALIGN.CENTER,
    verticalAlign: VERTICAL_ALIGN.MIDDLE,
    ...textProps,
    containerId: container.id,
    strokeColor: textProps.strokeColor || container.strokeColor
  });
  Object.assign(container, {
    boundElements: (container.boundElements || []).concat({
      type: "text",
      id: textElement.id
    })
  });
  redrawTextBoundingBox(textElement, container, elementsMap);
  return [container, textElement];
};
var bindLinearElementToElement = (linearElement, start2, end, elementStore, elementsMap) => {
  let startBoundElement;
  let endBoundElement;
  Object.assign(linearElement, {
    startBinding: linearElement?.startBinding || null,
    endBinding: linearElement.endBinding || null
  });
  if (start2) {
    const width = start2?.width ?? DEFAULT_DIMENSION;
    const height = start2?.height ?? DEFAULT_DIMENSION;
    let existingElement;
    if (start2.id) {
      existingElement = elementStore.getElement(start2.id);
      if (!existingElement) {
        console.error(`No element for start binding with id ${start2.id} found`);
      }
    }
    const startX = start2.x || linearElement.x - width;
    const startY = start2.y || linearElement.y - height / 2;
    const startType = existingElement ? existingElement.type : start2.type;
    if (startType) {
      if (startType === "text") {
        let text = "";
        if (existingElement && existingElement.type === "text") {
          text = existingElement.text;
        } else if (start2.type === "text") {
          text = start2.text;
        }
        if (!text) {
          console.error(
            `No text found for start binding text element for ${linearElement.id}`
          );
        }
        startBoundElement = newTextElement({
          x: startX,
          y: startY,
          type: "text",
          ...existingElement,
          ...start2,
          text
        });
        Object.assign(startBoundElement, {
          x: start2.x || linearElement.x - startBoundElement.width,
          y: start2.y || linearElement.y - startBoundElement.height / 2
        });
      } else {
        switch (startType) {
          case "rectangle":
          case "ellipse":
          case "diamond": {
            startBoundElement = newElement({
              x: startX,
              y: startY,
              width,
              height,
              ...existingElement,
              ...start2,
              type: startType
            });
            break;
          }
          default: {
            assertNever(
              linearElement,
              `Unhandled element start type "${start2.type}"`,
              true
            );
          }
        }
      }
      bindLinearElement(
        linearElement,
        startBoundElement,
        "start",
        elementsMap
      );
    }
  }
  if (end) {
    const height = end?.height ?? DEFAULT_DIMENSION;
    const width = end?.width ?? DEFAULT_DIMENSION;
    let existingElement;
    if (end.id) {
      existingElement = elementStore.getElement(end.id);
      if (!existingElement) {
        console.error(`No element for end binding with id ${end.id} found`);
      }
    }
    const endX = end.x || linearElement.x + linearElement.width;
    const endY = end.y || linearElement.y - height / 2;
    const endType = existingElement ? existingElement.type : end.type;
    if (endType) {
      if (endType === "text") {
        let text = "";
        if (existingElement && existingElement.type === "text") {
          text = existingElement.text;
        } else if (end.type === "text") {
          text = end.text;
        }
        if (!text) {
          console.error(
            `No text found for end binding text element for ${linearElement.id}`
          );
        }
        endBoundElement = newTextElement({
          x: endX,
          y: endY,
          type: "text",
          ...existingElement,
          ...end,
          text
        });
        Object.assign(endBoundElement, {
          y: end.y || linearElement.y - endBoundElement.height / 2
        });
      } else {
        switch (endType) {
          case "rectangle":
          case "ellipse":
          case "diamond": {
            endBoundElement = newElement({
              x: endX,
              y: endY,
              width,
              height,
              ...existingElement,
              ...end,
              type: endType
            });
            break;
          }
          default: {
            assertNever(
              linearElement,
              `Unhandled element end type "${endType}"`,
              true
            );
          }
        }
      }
      bindLinearElement(
        linearElement,
        endBoundElement,
        "end",
        elementsMap
      );
    }
  }
  const endPointIndex = linearElement.points.length - 1;
  const delta = 0.5;
  const newPoints = cloneJSON(linearElement.points);
  if (linearElement.points[endPointIndex][0] > linearElement.points[endPointIndex - 1][0]) {
    newPoints[0][0] = delta;
    newPoints[endPointIndex][0] -= delta;
  }
  if (linearElement.points[endPointIndex][0] < linearElement.points[endPointIndex - 1][0]) {
    newPoints[0][0] = -delta;
    newPoints[endPointIndex][0] += delta;
  }
  if (linearElement.points[endPointIndex][1] > linearElement.points[endPointIndex - 1][1]) {
    newPoints[0][1] = delta;
    newPoints[endPointIndex][1] -= delta;
  }
  if (linearElement.points[endPointIndex][1] < linearElement.points[endPointIndex - 1][1]) {
    newPoints[0][1] = -delta;
    newPoints[endPointIndex][1] += delta;
  }
  Object.assign(linearElement, { points: newPoints });
  return {
    linearElement,
    startBoundElement,
    endBoundElement
  };
};
var ElementStore = class {
  excalidrawElements = /* @__PURE__ */ new Map();
  add = (ele) => {
    if (!ele) {
      return;
    }
    this.excalidrawElements.set(ele.id, ele);
  };
  getElements = () => {
    return Array.from(this.excalidrawElements.values());
  };
  getElementsMap = () => {
    return toBrandedType(this.excalidrawElements);
  };
  getElement = (id) => {
    return this.excalidrawElements.get(id);
  };
};
var convertToExcalidrawElements = (elementsSkeleton, opts) => {
  if (!elementsSkeleton) {
    return [];
  }
  const elements = cloneJSON(elementsSkeleton);
  const elementStore = new ElementStore();
  const elementsWithIds = /* @__PURE__ */ new Map();
  const oldToNewElementIdMap = /* @__PURE__ */ new Map();
  for (const element of elements) {
    let excalidrawElement;
    const originalId = element.id;
    if (opts?.regenerateIds !== false) {
      Object.assign(element, { id: randomId() });
    }
    switch (element.type) {
      case "rectangle":
      case "ellipse":
      case "diamond": {
        const width = element?.label?.text && element.width === void 0 ? 0 : element?.width || DEFAULT_DIMENSION;
        const height = element?.label?.text && element.height === void 0 ? 0 : element?.height || DEFAULT_DIMENSION;
        excalidrawElement = newElement({
          ...element,
          width,
          height
        });
        break;
      }
      case "line": {
        const width = element.width || DEFAULT_LINEAR_ELEMENT_PROPS.width;
        const height = element.height || DEFAULT_LINEAR_ELEMENT_PROPS.height;
        excalidrawElement = newLinearElement({
          width,
          height,
          points: [
            [0, 0],
            [width, height]
          ],
          ...element
        });
        break;
      }
      case "arrow": {
        const width = element.width || DEFAULT_LINEAR_ELEMENT_PROPS.width;
        const height = element.height || DEFAULT_LINEAR_ELEMENT_PROPS.height;
        excalidrawElement = newLinearElement({
          width,
          height,
          endArrowhead: "arrow",
          points: [
            [0, 0],
            [width, height]
          ],
          ...element
        });
        Object.assign(
          excalidrawElement,
          getSizeFromPoints(excalidrawElement.points)
        );
        break;
      }
      case "text": {
        const fontFamily = element?.fontFamily || DEFAULT_FONT_FAMILY;
        const fontSize = element?.fontSize || DEFAULT_FONT_SIZE;
        const lineHeight = element?.lineHeight || getDefaultLineHeight(fontFamily);
        const text = element.text ?? "";
        const normalizedText = normalizeText(text);
        const metrics = measureText(
          normalizedText,
          getFontString({ fontFamily, fontSize }),
          lineHeight
        );
        excalidrawElement = newTextElement({
          width: metrics.width,
          height: metrics.height,
          fontFamily,
          fontSize,
          ...element
        });
        break;
      }
      case "image": {
        excalidrawElement = newImageElement({
          width: element?.width || DEFAULT_DIMENSION,
          height: element?.height || DEFAULT_DIMENSION,
          ...element
        });
        break;
      }
      case "frame": {
        excalidrawElement = newFrameElement({
          x: 0,
          y: 0,
          ...element
        });
        break;
      }
      case "magicframe": {
        excalidrawElement = newMagicFrameElement({
          x: 0,
          y: 0,
          ...element
        });
        break;
      }
      case "freedraw":
      case "iframe":
      case "embeddable": {
        excalidrawElement = element;
        break;
      }
      default: {
        excalidrawElement = element;
        assertNever(
          element,
          `Unhandled element type "${element.type}"`,
          true
        );
      }
    }
    const existingElement = elementStore.getElement(excalidrawElement.id);
    if (existingElement) {
      console.error(`Duplicate id found for ${excalidrawElement.id}`);
    } else {
      elementStore.add(excalidrawElement);
      elementsWithIds.set(excalidrawElement.id, element);
      if (originalId) {
        oldToNewElementIdMap.set(originalId, excalidrawElement.id);
      }
    }
  }
  const elementsMap = elementStore.getElementsMap();
  for (const [id, element] of elementsWithIds) {
    const excalidrawElement = elementStore.getElement(id);
    switch (element.type) {
      case "rectangle":
      case "ellipse":
      case "diamond":
      case "arrow": {
        if (element.label?.text) {
          let [container, text] = bindTextToContainer(
            excalidrawElement,
            element?.label,
            elementsMap
          );
          elementStore.add(container);
          elementStore.add(text);
          if (container.type === "arrow") {
            const originalStart = element.type === "arrow" ? element?.start : void 0;
            const originalEnd = element.type === "arrow" ? element?.end : void 0;
            if (originalStart && originalStart.id) {
              const newStartId = oldToNewElementIdMap.get(originalStart.id);
              if (newStartId) {
                Object.assign(originalStart, { id: newStartId });
              }
            }
            if (originalEnd && originalEnd.id) {
              const newEndId = oldToNewElementIdMap.get(originalEnd.id);
              if (newEndId) {
                Object.assign(originalEnd, { id: newEndId });
              }
            }
            const { linearElement, startBoundElement, endBoundElement } = bindLinearElementToElement(
              container,
              originalStart,
              originalEnd,
              elementStore,
              elementsMap
            );
            container = linearElement;
            elementStore.add(linearElement);
            elementStore.add(startBoundElement);
            elementStore.add(endBoundElement);
          }
        } else {
          switch (element.type) {
            case "arrow": {
              const { start: start2, end } = element;
              if (start2 && start2.id) {
                const newStartId = oldToNewElementIdMap.get(start2.id);
                Object.assign(start2, { id: newStartId });
              }
              if (end && end.id) {
                const newEndId = oldToNewElementIdMap.get(end.id);
                Object.assign(end, { id: newEndId });
              }
              const { linearElement, startBoundElement, endBoundElement } = bindLinearElementToElement(
                excalidrawElement,
                start2,
                end,
                elementStore,
                elementsMap
              );
              elementStore.add(linearElement);
              elementStore.add(startBoundElement);
              elementStore.add(endBoundElement);
              break;
            }
          }
        }
        break;
      }
    }
  }
  for (const [id, element] of elementsWithIds) {
    if (element.type !== "frame" && element.type !== "magicframe") {
      continue;
    }
    const frame = elementStore.getElement(id);
    if (!frame) {
      throw new Error(`Excalidraw element with id ${id} doesn't exist`);
    }
    const childrenElements = [];
    element.children.forEach((id2) => {
      const newElementId = oldToNewElementIdMap.get(id2);
      if (!newElementId) {
        throw new Error(`Element with ${id2} wasn't mapped correctly`);
      }
      const elementInFrame = elementStore.getElement(newElementId);
      if (!elementInFrame) {
        throw new Error(`Frame element with id ${newElementId} doesn't exist`);
      }
      Object.assign(elementInFrame, { frameId: frame.id });
      elementInFrame?.boundElements?.forEach((boundElement) => {
        const ele = elementStore.getElement(boundElement.id);
        if (!ele) {
          throw new Error(
            `Bound element with id ${boundElement.id} doesn't exist`
          );
        }
        Object.assign(ele, { frameId: frame.id });
        childrenElements.push(ele);
      });
      childrenElements.push(elementInFrame);
    });
    let [minX, minY, maxX, maxY] = getCommonBounds(childrenElements);
    const PADDING = 10;
    minX = minX - PADDING;
    minY = minY - PADDING;
    maxX = maxX + PADDING;
    maxY = maxY + PADDING;
    const width = Math.max(frame?.width, maxX - minX);
    const height = Math.max(frame?.height, maxY - minY);
    Object.assign(frame, { x: minX, y: minY, width, height });
  }
  return elementStore.getElements();
};

// index.tsx
var import_jsx_runtime111 = __toESM(require_jsx_runtime(), 1);
polyfill_default();
var ExcalidrawBase = (props) => {
  const {
    onChange,
    initialData,
    excalidrawAPI,
    isCollaborating = false,
    onPointerUpdate,
    renderTopRightUI,
    langCode = defaultLang.code,
    viewModeEnabled,
    zenModeEnabled,
    gridModeEnabled,
    libraryReturnUrl,
    theme,
    name,
    renderCustomStats,
    onPaste,
    detectScroll = true,
    handleKeyboardGlobally = false,
    onLibraryChange,
    autoFocus = false,
    generateIdForFile,
    onLinkOpen,
    onPointerDown,
    onPointerUp,
    onScrollChange,
    children,
    validateEmbeddable,
    renderEmbeddable,
    aiEnabled
  } = props;
  const canvasActions = props.UIOptions?.canvasActions;
  const UIOptions = {
    ...props.UIOptions,
    canvasActions: {
      ...DEFAULT_UI_OPTIONS.canvasActions,
      ...canvasActions
    },
    tools: {
      image: props.UIOptions?.tools?.image ?? true
    }
  };
  if (canvasActions?.export) {
    UIOptions.canvasActions.export.saveFileToDisk = canvasActions.export?.saveFileToDisk ?? DEFAULT_UI_OPTIONS.canvasActions.export.saveFileToDisk;
  }
  if (UIOptions.canvasActions.toggleTheme === null && typeof theme === "undefined") {
    UIOptions.canvasActions.toggleTheme = true;
  }
  (0, import_react85.useEffect)(() => {
    const importPolyfill = async () => {
      await import("./roundRect-T5BX56ZF.js");
    };
    importPolyfill();
    const handleTouchMove = (event) => {
      if (typeof event.scale === "number" && event.scale !== 1) {
        event.preventDefault();
      }
    };
    document.addEventListener("touchmove", handleTouchMove, {
      passive: false
    });
    return () => {
      document.removeEventListener("touchmove", handleTouchMove);
    };
  }, []);
  return /* @__PURE__ */ (0, import_jsx_runtime111.jsx)(Provider, { unstable_createStore: () => jotaiStore, scope: jotaiScope, children: /* @__PURE__ */ (0, import_jsx_runtime111.jsx)(InitializeApp, { langCode, theme, children: /* @__PURE__ */ (0, import_jsx_runtime111.jsx)(
    App_default,
    {
      onChange,
      initialData,
      excalidrawAPI,
      isCollaborating,
      onPointerUpdate,
      renderTopRightUI,
      langCode,
      viewModeEnabled,
      zenModeEnabled,
      gridModeEnabled,
      libraryReturnUrl,
      theme,
      name,
      renderCustomStats,
      UIOptions,
      onPaste,
      detectScroll,
      handleKeyboardGlobally,
      onLibraryChange,
      autoFocus,
      generateIdForFile,
      onLinkOpen,
      onPointerDown,
      onPointerUp,
      onScrollChange,
      validateEmbeddable,
      renderEmbeddable,
      aiEnabled: aiEnabled !== false,
      children
    }
  ) }) });
};
var areEqual = (prevProps, nextProps) => {
  if (prevProps.children !== nextProps.children) {
    return false;
  }
  const {
    initialData: prevInitialData,
    UIOptions: prevUIOptions = {},
    ...prev
  } = prevProps;
  const {
    initialData: nextInitialData,
    UIOptions: nextUIOptions = {},
    ...next
  } = nextProps;
  const prevUIOptionsKeys = Object.keys(prevUIOptions);
  const nextUIOptionsKeys = Object.keys(nextUIOptions);
  if (prevUIOptionsKeys.length !== nextUIOptionsKeys.length) {
    return false;
  }
  const isUIOptionsSame = prevUIOptionsKeys.every((key) => {
    if (key === "canvasActions") {
      const canvasOptionKeys = Object.keys(
        prevUIOptions.canvasActions
      );
      return canvasOptionKeys.every((key2) => {
        if (key2 === "export" && prevUIOptions?.canvasActions?.export && nextUIOptions?.canvasActions?.export) {
          return prevUIOptions.canvasActions.export.saveFileToDisk === nextUIOptions.canvasActions.export.saveFileToDisk;
        }
        return prevUIOptions?.canvasActions?.[key2] === nextUIOptions?.canvasActions?.[key2];
      });
    }
    return prevUIOptions[key] === nextUIOptions[key];
  });
  return isUIOptionsSame && isShallowEqual(prev, next);
};
var Excalidraw = import_react85.default.memo(ExcalidrawBase, areEqual);
Excalidraw.displayName = "Excalidraw";

// components/TTDDialog/common.ts
var resetPreview = ({
  canvasRef,
  setError
}) => {
  const canvasNode = canvasRef.current;
  if (!canvasNode) {
    return;
  }
  const parent = canvasNode.parentElement;
  if (!parent) {
    return;
  }
  parent.style.background = "";
  setError(null);
  canvasNode.replaceChildren();
};
var convertMermaidToExcalidraw = async ({
  canvasRef,
  mermaidToExcalidrawLib,
  mermaidDefinition,
  setError,
  data
}) => {
  const canvasNode = canvasRef.current;
  const parent = canvasNode?.parentElement;
  if (!canvasNode || !parent) {
    return;
  }
  if (!mermaidDefinition) {
    resetPreview({ canvasRef, setError });
    return;
  }
  try {
    const api = await mermaidToExcalidrawLib.api;
    let ret;
    try {
      ret = await api.parseMermaidToExcalidraw(mermaidDefinition, {
        fontSize: DEFAULT_FONT_SIZE
      });
    } catch (err) {
      ret = await api.parseMermaidToExcalidraw(
        mermaidDefinition.replace(/"/g, "'"),
        {
          fontSize: DEFAULT_FONT_SIZE
        }
      );
    }
    const { elements, files } = ret;
    setError(null);
    data.current = {
      elements: convertToExcalidrawElements(elements, {
        regenerateIds: true
      }),
      files
    };
    const canvas2 = await exportToCanvas2({
      elements: data.current.elements,
      files: data.current.files,
      exportPadding: DEFAULT_EXPORT_PADDING,
      maxWidthOrHeight: Math.max(parent.offsetWidth, parent.offsetHeight) * window.devicePixelRatio
    });
    await canvasToBlob(canvas2);
    parent.style.background = "var(--default-bg-color)";
    canvasNode.replaceChildren(canvas2);
  } catch (err) {
    parent.style.background = "var(--default-bg-color)";
    if (mermaidDefinition) {
      setError(err);
    }
    throw err;
  }
};
var saveMermaidDataToStorage = (mermaidDefinition) => {
  EditorLocalStorage.set(
    EDITOR_LS_KEYS.MERMAID_TO_EXCALIDRAW,
    mermaidDefinition
  );
};
var insertToEditor = ({
  app,
  data,
  text,
  shouldSaveMermaidDataToStorage
}) => {
  const { elements: newElements, files } = data.current;
  if (!newElements.length) {
    return;
  }
  app.addElementsFromPasteOrLibrary({
    elements: newElements,
    files,
    position: "center",
    fitToContent: true
  });
  app.setOpenDialog(null);
  if (shouldSaveMermaidDataToStorage && text) {
    saveMermaidDataToStorage(text);
  }
};

// components/TTDDialog/TTDDialogPanels.tsx
init_define_import_meta_env();
var import_jsx_runtime112 = __toESM(require_jsx_runtime(), 1);
var TTDDialogPanels = ({ children }) => {
  return /* @__PURE__ */ (0, import_jsx_runtime112.jsx)("div", { className: "ttd-dialog-panels", children });
};

// components/TTDDialog/TTDDialogPanel.tsx
init_define_import_meta_env();
var import_jsx_runtime113 = __toESM(require_jsx_runtime(), 1);
var TTDDialogPanel = ({
  label,
  children,
  panelAction,
  panelActionDisabled = false,
  onTextSubmitInProgess,
  renderTopRight,
  renderSubmitShortcut,
  renderBottomRight
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime113.jsxs)("div", { className: "ttd-dialog-panel", children: [
    /* @__PURE__ */ (0, import_jsx_runtime113.jsxs)("div", { className: "ttd-dialog-panel__header", children: [
      /* @__PURE__ */ (0, import_jsx_runtime113.jsx)("label", { children: label }),
      renderTopRight?.()
    ] }),
    children,
    /* @__PURE__ */ (0, import_jsx_runtime113.jsxs)(
      "div",
      {
        className: clsx_m_default("ttd-dialog-panel-button-container", {
          invisible: !panelAction
        }),
        style: { display: "flex", alignItems: "center" },
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime113.jsxs)(
            Button,
            {
              className: "ttd-dialog-panel-button",
              onSelect: panelAction ? panelAction.action : () => {
              },
              disabled: panelActionDisabled || onTextSubmitInProgess,
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime113.jsxs)("div", { className: clsx_m_default({ invisible: onTextSubmitInProgess }), children: [
                  panelAction?.label,
                  panelAction?.icon && /* @__PURE__ */ (0, import_jsx_runtime113.jsx)("span", { children: panelAction.icon })
                ] }),
                onTextSubmitInProgess && /* @__PURE__ */ (0, import_jsx_runtime113.jsx)(Spinner_default, {})
              ]
            }
          ),
          !panelActionDisabled && !onTextSubmitInProgess && renderSubmitShortcut?.(),
          renderBottomRight?.()
        ]
      }
    )
  ] });
};

// components/TTDDialog/TTDDialogInput.tsx
init_define_import_meta_env();
var import_react86 = __toESM(require_react(), 1);
var import_jsx_runtime114 = __toESM(require_jsx_runtime(), 1);
var TTDDialogInput = ({
  input,
  placeholder,
  onChange,
  onKeyboardSubmit
}) => {
  const ref = (0, import_react86.useRef)(null);
  const callbackRef = (0, import_react86.useRef)(onKeyboardSubmit);
  callbackRef.current = onKeyboardSubmit;
  (0, import_react86.useEffect)(() => {
    if (!callbackRef.current) {
      return;
    }
    const textarea = ref.current;
    if (textarea) {
      const handleKeyDown = (event) => {
        if (event[KEYS.CTRL_OR_CMD] && event.key === KEYS.ENTER) {
          event.preventDefault();
          callbackRef.current?.();
        }
      };
      textarea.addEventListener("keydown" /* KEYDOWN */, handleKeyDown);
      return () => {
        textarea.removeEventListener("keydown" /* KEYDOWN */, handleKeyDown);
      };
    }
  }, []);
  return /* @__PURE__ */ (0, import_jsx_runtime114.jsx)(
    "textarea",
    {
      className: "ttd-dialog-input",
      onChange,
      value: input,
      placeholder,
      autoFocus: true,
      ref
    }
  );
};

// components/TTDDialog/TTDDialogOutput.tsx
init_define_import_meta_env();
var import_jsx_runtime115 = __toESM(require_jsx_runtime(), 1);
var ErrorComp = ({ error }) => {
  return /* @__PURE__ */ (0, import_jsx_runtime115.jsxs)(
    "div",
    {
      "data-testid": "ttd-dialog-output-error",
      className: "ttd-dialog-output-error",
      children: [
        "Error! ",
        /* @__PURE__ */ (0, import_jsx_runtime115.jsx)("p", { children: error })
      ]
    }
  );
};
var TTDDialogOutput = ({
  error,
  canvasRef,
  loaded
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime115.jsxs)("div", { className: "ttd-dialog-output-wrapper", children: [
    error && /* @__PURE__ */ (0, import_jsx_runtime115.jsx)(ErrorComp, { error: error.message }),
    loaded ? /* @__PURE__ */ (0, import_jsx_runtime115.jsx)(
      "div",
      {
        ref: canvasRef,
        style: { opacity: error ? "0.15" : 1 },
        className: "ttd-dialog-output-canvas-container"
      }
    ) : /* @__PURE__ */ (0, import_jsx_runtime115.jsx)(Spinner_default, { size: "2rem" })
  ] });
};

// components/TTDDialog/TTDDialogSubmitShortcut.tsx
init_define_import_meta_env();
var import_jsx_runtime116 = __toESM(require_jsx_runtime(), 1);
var TTDDialogSubmitShortcut = () => {
  return /* @__PURE__ */ (0, import_jsx_runtime116.jsxs)("div", { className: "ttd-dialog-submit-shortcut", children: [
    /* @__PURE__ */ (0, import_jsx_runtime116.jsx)("div", { className: "ttd-dialog-submit-shortcut__key", children: getShortcutKey("CtrlOrCmd") }),
    /* @__PURE__ */ (0, import_jsx_runtime116.jsx)("div", { className: "ttd-dialog-submit-shortcut__key", children: getShortcutKey("Enter") })
  ] });
};

// components/TTDDialog/MermaidToExcalidraw.tsx
var import_jsx_runtime117 = __toESM(require_jsx_runtime(), 1);
var MERMAID_EXAMPLE = "flowchart TD\n A[Christmas] -->|Get money| B(Go shopping)\n B --> C{Let me think}\n C -->|One| D[Laptop]\n C -->|Two| E[iPhone]\n C -->|Three| F[Car]";
var debouncedSaveMermaidDefinition = debounce(saveMermaidDataToStorage, 300);
var MermaidToExcalidraw = ({
  mermaidToExcalidrawLib
}) => {
  const [text, setText] = (0, import_react87.useState)(
    () => EditorLocalStorage.get(EDITOR_LS_KEYS.MERMAID_TO_EXCALIDRAW) || MERMAID_EXAMPLE
  );
  const deferredText = (0, import_react87.useDeferredValue)(text.trim());
  const [error, setError] = (0, import_react87.useState)(null);
  const canvasRef = (0, import_react87.useRef)(null);
  const data = (0, import_react87.useRef)({ elements: [], files: null });
  const app = useApp();
  (0, import_react87.useEffect)(() => {
    convertMermaidToExcalidraw({
      canvasRef,
      data,
      mermaidToExcalidrawLib,
      setError,
      mermaidDefinition: deferredText
    }).catch(() => {
    });
    debouncedSaveMermaidDefinition(deferredText);
  }, [deferredText, mermaidToExcalidrawLib]);
  (0, import_react87.useEffect)(
    () => () => {
      debouncedSaveMermaidDefinition.flush();
    },
    []
  );
  const onInsertToEditor = () => {
    insertToEditor({
      app,
      data,
      text,
      shouldSaveMermaidDataToStorage: true
    });
  };
  return /* @__PURE__ */ (0, import_jsx_runtime117.jsxs)(import_jsx_runtime117.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime117.jsx)("div", { className: "ttd-dialog-desc", children: /* @__PURE__ */ (0, import_jsx_runtime117.jsx)(
      Trans_default,
      {
        i18nKey: "mermaid.description",
        flowchartLink: (el) => /* @__PURE__ */ (0, import_jsx_runtime117.jsx)("a", { href: "https://mermaid.js.org/syntax/flowchart.html", children: el }),
        sequenceLink: (el) => /* @__PURE__ */ (0, import_jsx_runtime117.jsx)("a", { href: "https://mermaid.js.org/syntax/sequenceDiagram.html", children: el }),
        classLink: (el) => /* @__PURE__ */ (0, import_jsx_runtime117.jsx)("a", { href: "https://mermaid.js.org/syntax/classDiagram.html", children: el })
      }
    ) }),
    /* @__PURE__ */ (0, import_jsx_runtime117.jsxs)(TTDDialogPanels, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime117.jsx)(TTDDialogPanel, { label: t("mermaid.syntax"), children: /* @__PURE__ */ (0, import_jsx_runtime117.jsx)(
        TTDDialogInput,
        {
          input: text,
          placeholder: "Write Mermaid diagram defintion here...",
          onChange: (event) => setText(event.target.value),
          onKeyboardSubmit: () => {
            onInsertToEditor();
          }
        }
      ) }),
      /* @__PURE__ */ (0, import_jsx_runtime117.jsx)(
        TTDDialogPanel,
        {
          label: t("mermaid.preview"),
          panelAction: {
            action: () => {
              onInsertToEditor();
            },
            label: t("mermaid.button"),
            icon: ArrowRightIcon
          },
          renderSubmitShortcut: () => /* @__PURE__ */ (0, import_jsx_runtime117.jsx)(TTDDialogSubmitShortcut, {}),
          children: /* @__PURE__ */ (0, import_jsx_runtime117.jsx)(
            TTDDialogOutput,
            {
              canvasRef,
              loaded: mermaidToExcalidrawLib.loaded,
              error
            }
          )
        }
      )
    ] })
  ] });
};
var MermaidToExcalidraw_default = MermaidToExcalidraw;

// components/TTDDialog/TTDDialog.tsx
var import_react88 = __toESM(require_react(), 1);

// components/TTDDialog/TTDDialogTabTriggers.tsx
init_define_import_meta_env();
var import_jsx_runtime118 = __toESM(require_jsx_runtime(), 1);
var TTDDialogTabTriggers = ({
  children,
  ...rest
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime118.jsx)($69cb30bb0017df05$export$54c2e3dc7acea9f5, { className: "ttd-dialog-triggers", ...rest, children });
};
TTDDialogTabTriggers.displayName = "TTDDialogTabTriggers";

// components/TTDDialog/TTDDialogTabTrigger.tsx
init_define_import_meta_env();
var import_jsx_runtime119 = __toESM(require_jsx_runtime(), 1);
var TTDDialogTabTrigger = ({
  children,
  tab,
  onSelect,
  ...rest
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime119.jsx)($69cb30bb0017df05$export$41fb9f06171c75f4, { value: tab, asChild: true, onSelect, children: /* @__PURE__ */ (0, import_jsx_runtime119.jsx)("button", { type: "button", className: "ttd-dialog-tab-trigger", ...rest, children }) });
};
TTDDialogTabTrigger.displayName = "TTDDialogTabTrigger";

// components/TTDDialog/TTDDialog.tsx
var import_jsx_runtime120 = __toESM(require_jsx_runtime(), 1);
var MIN_PROMPT_LENGTH = 3;
var MAX_PROMPT_LENGTH = 1e3;
var rateLimitsAtom = atom2(null);
var ttdGenerationAtom = atom2(null);
var TTDDialog = (props) => {
  const appState = useUIAppState();
  if (appState.openDialog?.name !== "ttd") {
    return null;
  }
  return /* @__PURE__ */ (0, import_jsx_runtime120.jsx)(TTDDialogBase, { ...props, tab: appState.openDialog.tab });
};
var TTDDialogBase = withInternalFallback(
  "TTDDialogBase",
  ({
    tab,
    ...rest
  }) => {
    const app = useApp();
    const setAppState = useExcalidrawSetAppState();
    const someRandomDivRef = (0, import_react88.useRef)(null);
    const [ttdGeneration, setTtdGeneration] = useAtom(ttdGenerationAtom);
    const [text, setText] = (0, import_react88.useState)(ttdGeneration?.prompt ?? "");
    const prompt = text.trim();
    const handleTextChange = (event) => {
      setText(event.target.value);
      setTtdGeneration((s4) => ({
        generatedResponse: s4?.generatedResponse ?? null,
        prompt: event.target.value
      }));
    };
    const [onTextSubmitInProgess, setOnTextSubmitInProgess] = (0, import_react88.useState)(false);
    const [rateLimits, setRateLimits] = useAtom(rateLimitsAtom);
    const onGenerate = async () => {
      if (prompt.length > MAX_PROMPT_LENGTH || prompt.length < MIN_PROMPT_LENGTH || onTextSubmitInProgess || rateLimits?.rateLimitRemaining === 0 || // means this is not a text-to-diagram dialog (needed for TS only)
      "__fallback" in rest) {
        if (prompt.length < MIN_PROMPT_LENGTH) {
          setError(
            new Error(
              `Prompt is too short (min ${MIN_PROMPT_LENGTH} characters)`
            )
          );
        }
        if (prompt.length > MAX_PROMPT_LENGTH) {
          setError(
            new Error(
              `Prompt is too long (max ${MAX_PROMPT_LENGTH} characters)`
            )
          );
        }
        return;
      }
      try {
        setOnTextSubmitInProgess(true);
        trackEvent("ai", "generate", "ttd");
        const { generatedResponse, error: error2, rateLimit, rateLimitRemaining } = await rest.onTextSubmit(prompt);
        if (typeof generatedResponse === "string") {
          setTtdGeneration((s4) => ({
            generatedResponse,
            prompt: s4?.prompt ?? null
          }));
        }
        if (isFiniteNumber(rateLimit) && isFiniteNumber(rateLimitRemaining)) {
          setRateLimits({ rateLimit, rateLimitRemaining });
        }
        if (error2) {
          setError(error2);
          return;
        }
        if (!generatedResponse) {
          setError(new Error("Generation failed"));
          return;
        }
        try {
          await convertMermaidToExcalidraw({
            canvasRef: someRandomDivRef,
            data,
            mermaidToExcalidrawLib,
            setError,
            mermaidDefinition: generatedResponse
          });
          trackEvent("ai", "mermaid parse success", "ttd");
        } catch (error3) {
          console.info(
            `%cTTD mermaid render errror: ${error3.message}`,
            "color: red"
          );
          console.info(
            `>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
TTD mermaid definition render errror: ${error3.message}`,
            "color: yellow"
          );
          trackEvent("ai", "mermaid parse failed", "ttd");
          setError(
            new Error(
              "Generated an invalid diagram :(. You may also try a different prompt."
            )
          );
        }
      } catch (error2) {
        let message = error2.message;
        if (!message || message === "Failed to fetch") {
          message = "Request failed";
        }
        setError(new Error(message));
      } finally {
        setOnTextSubmitInProgess(false);
      }
    };
    const refOnGenerate = (0, import_react88.useRef)(onGenerate);
    refOnGenerate.current = onGenerate;
    const [mermaidToExcalidrawLib, setMermaidToExcalidrawLib] = (0, import_react88.useState)({
      loaded: false,
      api: import("./dist-YQP5HP65.js")
    });
    (0, import_react88.useEffect)(() => {
      const fn = async () => {
        await mermaidToExcalidrawLib.api;
        setMermaidToExcalidrawLib((prev) => ({ ...prev, loaded: true }));
      };
      fn();
    }, [mermaidToExcalidrawLib.api]);
    const data = (0, import_react88.useRef)({ elements: [], files: null });
    const [error, setError] = (0, import_react88.useState)(null);
    return /* @__PURE__ */ (0, import_jsx_runtime120.jsx)(
      Dialog,
      {
        className: "ttd-dialog",
        onCloseRequest: () => {
          app.setOpenDialog(null);
        },
        size: 1200,
        title: false,
        ...rest,
        autofocus: false,
        children: /* @__PURE__ */ (0, import_jsx_runtime120.jsxs)(TTDDialogTabs_default, { dialog: "ttd", tab, children: [
          "__fallback" in rest && rest.__fallback ? /* @__PURE__ */ (0, import_jsx_runtime120.jsx)("p", { className: "dialog-mermaid-title", children: t("mermaid.title") }) : /* @__PURE__ */ (0, import_jsx_runtime120.jsxs)(TTDDialogTabTriggers, { children: [
            /* @__PURE__ */ (0, import_jsx_runtime120.jsx)(TTDDialogTabTrigger, { tab: "text-to-diagram", children: /* @__PURE__ */ (0, import_jsx_runtime120.jsxs)("div", { style: { display: "flex", alignItems: "center" }, children: [
              t("labels.textToDiagram"),
              /* @__PURE__ */ (0, import_jsx_runtime120.jsx)(
                "div",
                {
                  style: {
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                    padding: "1px 6px",
                    marginLeft: "10px",
                    fontSize: 10,
                    borderRadius: "12px",
                    background: "pink",
                    color: "#000"
                  },
                  children: "AI Beta"
                }
              )
            ] }) }),
            /* @__PURE__ */ (0, import_jsx_runtime120.jsx)(TTDDialogTabTrigger, { tab: "mermaid", children: "Mermaid" })
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime120.jsx)(TTDDialogTab, { className: "ttd-dialog-content", tab: "mermaid", children: /* @__PURE__ */ (0, import_jsx_runtime120.jsx)(
            MermaidToExcalidraw_default,
            {
              mermaidToExcalidrawLib
            }
          ) }),
          !("__fallback" in rest) && /* @__PURE__ */ (0, import_jsx_runtime120.jsxs)(TTDDialogTab, { className: "ttd-dialog-content", tab: "text-to-diagram", children: [
            /* @__PURE__ */ (0, import_jsx_runtime120.jsx)("div", { className: "ttd-dialog-desc", children: "Currently we use Mermaid as a middle step, so you'll get best results if you describe a diagram, workflow, flow chart, and similar." }),
            /* @__PURE__ */ (0, import_jsx_runtime120.jsxs)(TTDDialogPanels, { children: [
              /* @__PURE__ */ (0, import_jsx_runtime120.jsx)(
                TTDDialogPanel,
                {
                  label: t("labels.prompt"),
                  panelAction: {
                    action: onGenerate,
                    label: "Generate",
                    icon: ArrowRightIcon
                  },
                  onTextSubmitInProgess,
                  panelActionDisabled: prompt.length > MAX_PROMPT_LENGTH || rateLimits?.rateLimitRemaining === 0,
                  renderTopRight: () => {
                    if (!rateLimits) {
                      return null;
                    }
                    return /* @__PURE__ */ (0, import_jsx_runtime120.jsxs)(
                      "div",
                      {
                        className: "ttd-dialog-rate-limit",
                        style: {
                          fontSize: 12,
                          marginLeft: "auto",
                          color: rateLimits.rateLimitRemaining === 0 ? "var(--color-danger)" : void 0
                        },
                        children: [
                          rateLimits.rateLimitRemaining,
                          " requests left today"
                        ]
                      }
                    );
                  },
                  renderSubmitShortcut: () => /* @__PURE__ */ (0, import_jsx_runtime120.jsx)(TTDDialogSubmitShortcut, {}),
                  renderBottomRight: () => {
                    if (typeof ttdGeneration?.generatedResponse === "string") {
                      return /* @__PURE__ */ (0, import_jsx_runtime120.jsxs)(
                        "div",
                        {
                          className: "excalidraw-link",
                          style: { marginLeft: "auto", fontSize: 14 },
                          onClick: () => {
                            if (typeof ttdGeneration?.generatedResponse === "string") {
                              saveMermaidDataToStorage(
                                ttdGeneration.generatedResponse
                              );
                              setAppState({
                                openDialog: { name: "ttd", tab: "mermaid" }
                              });
                            }
                          },
                          children: [
                            "View as Mermaid",
                            /* @__PURE__ */ (0, import_jsx_runtime120.jsx)(InlineIcon, { icon: ArrowRightIcon })
                          ]
                        }
                      );
                    }
                    const ratio = prompt.length / MAX_PROMPT_LENGTH;
                    if (ratio > 0.8) {
                      return /* @__PURE__ */ (0, import_jsx_runtime120.jsxs)(
                        "div",
                        {
                          style: {
                            marginLeft: "auto",
                            fontSize: 12,
                            fontFamily: "monospace",
                            color: ratio > 1 ? "var(--color-danger)" : void 0
                          },
                          children: [
                            "Length: ",
                            prompt.length,
                            "/",
                            MAX_PROMPT_LENGTH
                          ]
                        }
                      );
                    }
                    return null;
                  },
                  children: /* @__PURE__ */ (0, import_jsx_runtime120.jsx)(
                    TTDDialogInput,
                    {
                      onChange: handleTextChange,
                      input: text,
                      placeholder: "Describe what you want to see...",
                      onKeyboardSubmit: () => {
                        refOnGenerate.current();
                      }
                    }
                  )
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime120.jsx)(
                TTDDialogPanel,
                {
                  label: "Preview",
                  panelAction: {
                    action: () => {
                      console.info("Panel action clicked");
                      insertToEditor({ app, data });
                    },
                    label: "Insert",
                    icon: ArrowRightIcon
                  },
                  children: /* @__PURE__ */ (0, import_jsx_runtime120.jsx)(
                    TTDDialogOutput,
                    {
                      canvasRef: someRandomDivRef,
                      error,
                      loaded: mermaidToExcalidrawLib.loaded
                    }
                  )
                }
              )
            ] })
          ] })
        ] })
      }
    );
  }
);

// components/LayerUI.tsx
var import_jsx_runtime121 = __toESM(require_jsx_runtime(), 1);
var DefaultMainMenu = ({ UIOptions }) => {
  return /* @__PURE__ */ (0, import_jsx_runtime121.jsxs)(MainMenu_default, { __fallback: true, children: [
    /* @__PURE__ */ (0, import_jsx_runtime121.jsx)(MainMenu_default.DefaultItems.LoadScene, {}),
    /* @__PURE__ */ (0, import_jsx_runtime121.jsx)(MainMenu_default.DefaultItems.SaveToActiveFile, {}),
    UIOptions.canvasActions.export && /* @__PURE__ */ (0, import_jsx_runtime121.jsx)(MainMenu_default.DefaultItems.Export, {}),
    UIOptions.canvasActions.saveAsImage && /* @__PURE__ */ (0, import_jsx_runtime121.jsx)(MainMenu_default.DefaultItems.SaveAsImage, {}),
    /* @__PURE__ */ (0, import_jsx_runtime121.jsx)(MainMenu_default.DefaultItems.Help, {}),
    /* @__PURE__ */ (0, import_jsx_runtime121.jsx)(MainMenu_default.DefaultItems.ClearCanvas, {}),
    /* @__PURE__ */ (0, import_jsx_runtime121.jsx)(MainMenu_default.Separator, {}),
    /* @__PURE__ */ (0, import_jsx_runtime121.jsx)(MainMenu_default.Group, { title: "Excalidraw links", children: /* @__PURE__ */ (0, import_jsx_runtime121.jsx)(MainMenu_default.DefaultItems.Socials, {}) }),
    /* @__PURE__ */ (0, import_jsx_runtime121.jsx)(MainMenu_default.Separator, {}),
    /* @__PURE__ */ (0, import_jsx_runtime121.jsx)(MainMenu_default.DefaultItems.ToggleTheme, {}),
    /* @__PURE__ */ (0, import_jsx_runtime121.jsx)(MainMenu_default.DefaultItems.ChangeCanvasBackground, {})
  ] });
};
var DefaultOverwriteConfirmDialog = () => {
  return /* @__PURE__ */ (0, import_jsx_runtime121.jsxs)(OverwriteConfirmDialog, { __fallback: true, children: [
    /* @__PURE__ */ (0, import_jsx_runtime121.jsx)(OverwriteConfirmDialog.Actions.SaveToDisk, {}),
    /* @__PURE__ */ (0, import_jsx_runtime121.jsx)(OverwriteConfirmDialog.Actions.ExportToImage, {})
  ] });
};
var LayerUI = ({
  actionManager,
  appState,
  files,
  setAppState,
  elements,
  canvas: canvas2,
  onLockToggle,
  onHandToolToggle,
  onPenModeToggle,
  showExitZenModeBtn,
  renderTopRightUI,
  renderCustomStats,
  UIOptions,
  onExportImage,
  renderWelcomeScreen,
  children,
  app,
  isCollaborating,
  openAIKey,
  isOpenAIKeyPersisted,
  onOpenAIAPIKeyChange,
  onMagicSettingsConfirm
}) => {
  const device = useDevice();
  const tunnels = useInitializeTunnels();
  const [eyeDropperState, setEyeDropperState] = useAtom(
    activeEyeDropperAtom,
    jotaiScope
  );
  const renderJSONExportDialog = () => {
    if (!UIOptions.canvasActions.export) {
      return null;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime121.jsx)(
      JSONExportDialog,
      {
        elements,
        appState,
        files,
        actionManager,
        exportOpts: UIOptions.canvasActions.export,
        canvas: canvas2,
        setAppState
      }
    );
  };
  const renderImageExportDialog = () => {
    if (!UIOptions.canvasActions.saveAsImage || appState.openDialog?.name !== "imageExport") {
      return null;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime121.jsx)(
      ImageExportDialog,
      {
        elements,
        appState,
        files,
        actionManager,
        onExportImage,
        onCloseRequest: () => setAppState({ openDialog: null }),
        name: app.getName()
      }
    );
  };
  const renderCanvasActions = () => /* @__PURE__ */ (0, import_jsx_runtime121.jsxs)("div", { style: { position: "relative" }, children: [
    /* @__PURE__ */ (0, import_jsx_runtime121.jsx)(tunnels.MainMenuTunnel.Out, {}),
    renderWelcomeScreen && /* @__PURE__ */ (0, import_jsx_runtime121.jsx)(tunnels.WelcomeScreenMenuHintTunnel.Out, {})
  ] });
  const renderSelectedShapeActions = () => /* @__PURE__ */ (0, import_jsx_runtime121.jsx)(
    Section,
    {
      heading: "selectedShapeActions",
      className: clsx_m_default("selected-shape-actions zen-mode-transition", {
        "transition-left": appState.zenModeEnabled
      }),
      children: /* @__PURE__ */ (0, import_jsx_runtime121.jsx)(
        Island,
        {
          className: CLASSES.SHAPE_ACTIONS_MENU,
          padding: 2,
          style: {
            // we want to make sure this doesn't overflow so subtracting the
            // approximate height of hamburgerMenu + footer
            maxHeight: `${appState.height - 166}px`
          },
          children: /* @__PURE__ */ (0, import_jsx_runtime121.jsx)(
            SelectedShapeActions,
            {
              appState,
              elementsMap: app.scene.getNonDeletedElementsMap(),
              renderAction: actionManager.renderAction
            }
          )
        }
      )
    }
  );
  const renderFixedSideContainer = () => {
    const shouldRenderSelectedShapeActions = showSelectedShapeActions(
      appState,
      elements
    );
    return /* @__PURE__ */ (0, import_jsx_runtime121.jsx)(FixedSideContainer, { side: "top", children: /* @__PURE__ */ (0, import_jsx_runtime121.jsxs)("div", { className: "App-menu App-menu_top", children: [
      /* @__PURE__ */ (0, import_jsx_runtime121.jsxs)(Stack_default.Col, { gap: 6, className: clsx_m_default("App-menu_top__left"), children: [
        renderCanvasActions(),
        shouldRenderSelectedShapeActions && renderSelectedShapeActions()
      ] }),
      !appState.viewModeEnabled && /* @__PURE__ */ (0, import_jsx_runtime121.jsx)(Section, { heading: "shapes", className: "shapes-section", children: (heading) => /* @__PURE__ */ (0, import_jsx_runtime121.jsxs)("div", { style: { position: "relative" }, children: [
        renderWelcomeScreen && /* @__PURE__ */ (0, import_jsx_runtime121.jsx)(tunnels.WelcomeScreenToolbarHintTunnel.Out, {}),
        /* @__PURE__ */ (0, import_jsx_runtime121.jsx)(Stack_default.Col, { gap: 4, align: "start", children: /* @__PURE__ */ (0, import_jsx_runtime121.jsxs)(
          Stack_default.Row,
          {
            gap: 1,
            className: clsx_m_default("App-toolbar-container", {
              "zen-mode": appState.zenModeEnabled
            }),
            children: [
              /* @__PURE__ */ (0, import_jsx_runtime121.jsxs)(
                Island,
                {
                  padding: 1,
                  className: clsx_m_default("App-toolbar", {
                    "zen-mode": appState.zenModeEnabled
                  }),
                  children: [
                    /* @__PURE__ */ (0, import_jsx_runtime121.jsx)(
                      HintViewer,
                      {
                        appState,
                        isMobile: device.editor.isMobile,
                        device,
                        app
                      }
                    ),
                    heading,
                    /* @__PURE__ */ (0, import_jsx_runtime121.jsxs)(Stack_default.Row, { gap: 1, children: [
                      /* @__PURE__ */ (0, import_jsx_runtime121.jsx)(
                        PenModeButton,
                        {
                          zenModeEnabled: appState.zenModeEnabled,
                          checked: appState.penMode,
                          onChange: () => onPenModeToggle(null),
                          title: t("toolBar.penMode"),
                          penDetected: appState.penDetected
                        }
                      ),
                      /* @__PURE__ */ (0, import_jsx_runtime121.jsx)(
                        LockButton,
                        {
                          checked: appState.activeTool.locked,
                          onChange: onLockToggle,
                          title: t("toolBar.lock")
                        }
                      ),
                      /* @__PURE__ */ (0, import_jsx_runtime121.jsx)("div", { className: "App-toolbar__divider" }),
                      /* @__PURE__ */ (0, import_jsx_runtime121.jsx)(
                        HandButton,
                        {
                          checked: isHandToolActive(appState),
                          onChange: () => onHandToolToggle(),
                          title: t("toolBar.hand"),
                          isMobile: true
                        }
                      ),
                      /* @__PURE__ */ (0, import_jsx_runtime121.jsx)(
                        ShapesSwitcher,
                        {
                          appState,
                          activeTool: appState.activeTool,
                          UIOptions,
                          app
                        }
                      )
                    ] })
                  ]
                }
              ),
              isCollaborating && /* @__PURE__ */ (0, import_jsx_runtime121.jsx)(
                Island,
                {
                  style: {
                    marginLeft: 8,
                    alignSelf: "center",
                    height: "fit-content"
                  },
                  children: /* @__PURE__ */ (0, import_jsx_runtime121.jsx)(
                    LaserPointerButton,
                    {
                      title: t("toolBar.laser"),
                      checked: appState.activeTool.type === TOOL_TYPE.laser,
                      onChange: () => app.setActiveTool({ type: TOOL_TYPE.laser }),
                      isMobile: true
                    }
                  )
                }
              )
            ]
          }
        ) })
      ] }) }),
      /* @__PURE__ */ (0, import_jsx_runtime121.jsxs)(
        "div",
        {
          className: clsx_m_default(
            "layer-ui__wrapper__top-right zen-mode-transition",
            {
              "transition-right": appState.zenModeEnabled
            }
          ),
          children: [
            appState.collaborators.size > 0 && /* @__PURE__ */ (0, import_jsx_runtime121.jsx)(
              UserList,
              {
                collaborators: appState.collaborators,
                userToFollow: appState.userToFollow?.socketId || null
              }
            ),
            renderTopRightUI?.(device.editor.isMobile, appState),
            !appState.viewModeEnabled && // hide button when sidebar docked
            (!isSidebarDocked || appState.openSidebar?.name !== DEFAULT_SIDEBAR.name) && /* @__PURE__ */ (0, import_jsx_runtime121.jsx)(tunnels.DefaultSidebarTriggerTunnel.Out, {})
          ]
        }
      )
    ] }) });
  };
  const renderSidebars = () => {
    return /* @__PURE__ */ (0, import_jsx_runtime121.jsx)(
      DefaultSidebar,
      {
        __fallback: true,
        onDock: (docked) => {
          trackEvent(
            "sidebar",
            `toggleDock (${docked ? "dock" : "undock"})`,
            `(${device.editor.isMobile ? "mobile" : "desktop"})`
          );
        }
      }
    );
  };
  const isSidebarDocked = useAtomValue(isSidebarDockedAtom, jotaiScope);
  const layerUIJSX = /* @__PURE__ */ (0, import_jsx_runtime121.jsxs)(import_jsx_runtime121.Fragment, { children: [
    children,
    /* @__PURE__ */ (0, import_jsx_runtime121.jsx)(DefaultMainMenu, { UIOptions }),
    /* @__PURE__ */ (0, import_jsx_runtime121.jsx)(
      DefaultSidebar.Trigger,
      {
        __fallback: true,
        icon: LibraryIcon,
        title: capitalizeString(t("toolBar.library")),
        onToggle: (open) => {
          if (open) {
            trackEvent(
              "sidebar",
              `${DEFAULT_SIDEBAR.name} (open)`,
              `button (${device.editor.isMobile ? "mobile" : "desktop"})`
            );
          }
        },
        tab: DEFAULT_SIDEBAR.defaultTab,
        children: t("toolBar.library")
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime121.jsx)(DefaultOverwriteConfirmDialog, {}),
    appState.openDialog?.name === "ttd" && /* @__PURE__ */ (0, import_jsx_runtime121.jsx)(TTDDialog, { __fallback: true }),
    appState.isLoading && /* @__PURE__ */ (0, import_jsx_runtime121.jsx)(LoadingMessage, { delay: 250 }),
    appState.errorMessage && /* @__PURE__ */ (0, import_jsx_runtime121.jsx)(ErrorDialog, { onClose: () => setAppState({ errorMessage: null }), children: appState.errorMessage }),
    eyeDropperState && !device.editor.isMobile && /* @__PURE__ */ (0, import_jsx_runtime121.jsx)(
      EyeDropper,
      {
        colorPickerType: eyeDropperState.colorPickerType,
        onCancel: () => {
          setEyeDropperState(null);
        },
        onChange: (colorPickerType, color, selectedElements, { altKey }) => {
          if (colorPickerType !== "elementBackground" && colorPickerType !== "elementStroke") {
            return;
          }
          if (selectedElements.length) {
            for (const element of selectedElements) {
              mutateElement(
                element,
                {
                  [altKey && eyeDropperState.swapPreviewOnAlt ? colorPickerType === "elementBackground" ? "strokeColor" : "backgroundColor" : colorPickerType === "elementBackground" ? "backgroundColor" : "strokeColor"]: color
                },
                false
              );
              ShapeCache.delete(element);
            }
            Scene_default.getScene(selectedElements[0])?.informMutation();
          } else if (colorPickerType === "elementBackground") {
            setAppState({
              currentItemBackgroundColor: color
            });
          } else {
            setAppState({ currentItemStrokeColor: color });
          }
        },
        onSelect: (color, event) => {
          setEyeDropperState((state) => {
            return state?.keepOpenOnAlt && event.altKey ? state : null;
          });
          eyeDropperState?.onSelect?.(color, event);
        }
      }
    ),
    appState.openDialog?.name === "help" && /* @__PURE__ */ (0, import_jsx_runtime121.jsx)(
      HelpDialog,
      {
        onClose: () => {
          setAppState({ openDialog: null });
        }
      }
    ),
    appState.openDialog?.name === "settings" && /* @__PURE__ */ (0, import_jsx_runtime121.jsx)(
      MagicSettings,
      {
        openAIKey,
        isPersisted: isOpenAIKeyPersisted,
        onChange: onOpenAIAPIKeyChange,
        onConfirm: (apiKey, shouldPersist) => {
          const source = appState.openDialog?.name === "settings" ? appState.openDialog?.source : "settings";
          setAppState({ openDialog: null }, () => {
            onMagicSettingsConfirm(apiKey, shouldPersist, source);
          });
        },
        onClose: () => {
          setAppState({ openDialog: null });
        }
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime121.jsx)(ActiveConfirmDialog, {}),
    /* @__PURE__ */ (0, import_jsx_runtime121.jsx)(tunnels.OverwriteConfirmDialogTunnel.Out, {}),
    renderImageExportDialog(),
    renderJSONExportDialog(),
    appState.pasteDialog.shown && /* @__PURE__ */ (0, import_jsx_runtime121.jsx)(
      PasteChartDialog,
      {
        setAppState,
        appState,
        onClose: () => setAppState({
          pasteDialog: { shown: false, data: null }
        })
      }
    ),
    device.editor.isMobile && /* @__PURE__ */ (0, import_jsx_runtime121.jsx)(
      MobileMenu,
      {
        app,
        appState,
        elements,
        actionManager,
        renderJSONExportDialog,
        renderImageExportDialog,
        setAppState,
        onLockToggle,
        onHandToolToggle,
        onPenModeToggle,
        renderTopRightUI,
        renderCustomStats,
        renderSidebars,
        device,
        renderWelcomeScreen,
        UIOptions
      }
    ),
    !device.editor.isMobile && /* @__PURE__ */ (0, import_jsx_runtime121.jsxs)(import_jsx_runtime121.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime121.jsxs)(
        "div",
        {
          className: "layer-ui__wrapper",
          style: appState.openSidebar && isSidebarDocked && device.editor.canFitSidebar ? { width: `calc(100% - ${LIBRARY_SIDEBAR_WIDTH}px)` } : {},
          children: [
            renderWelcomeScreen && /* @__PURE__ */ (0, import_jsx_runtime121.jsx)(tunnels.WelcomeScreenCenterTunnel.Out, {}),
            renderFixedSideContainer(),
            /* @__PURE__ */ (0, import_jsx_runtime121.jsx)(
              Footer_default,
              {
                appState,
                actionManager,
                showExitZenModeBtn,
                renderWelcomeScreen
              }
            ),
            appState.showStats && /* @__PURE__ */ (0, import_jsx_runtime121.jsx)(
              Stats,
              {
                appState,
                setAppState,
                elements,
                onClose: () => {
                  actionManager.executeAction(actionToggleStats);
                },
                renderCustomStats
              }
            ),
            appState.scrolledOutside && /* @__PURE__ */ (0, import_jsx_runtime121.jsx)(
              "button",
              {
                className: "scroll-back-to-content",
                onClick: () => {
                  setAppState((appState2) => ({
                    ...calculateScrollCenter(elements, appState2)
                  }));
                },
                children: t("buttons.scrollBackToContent")
              }
            )
          ]
        }
      ),
      renderSidebars()
    ] })
  ] });
  return /* @__PURE__ */ (0, import_jsx_runtime121.jsx)(UIAppStateContext.Provider, { value: appState, children: /* @__PURE__ */ (0, import_jsx_runtime121.jsx)(Provider, { scope: tunnels.jotaiScope, children: /* @__PURE__ */ (0, import_jsx_runtime121.jsx)(TunnelsContext.Provider, { value: tunnels, children: layerUIJSX }) }) });
};
var stripIrrelevantAppStateProps = (appState) => {
  const {
    suggestedBindings,
    startBoundElement,
    cursorButton,
    scrollX,
    scrollY,
    ...ret
  } = appState;
  return ret;
};
var areEqual2 = (prevProps, nextProps) => {
  if (prevProps.children !== nextProps.children) {
    return false;
  }
  const { canvas: _pC, appState: prevAppState, ...prev } = prevProps;
  const { canvas: _nC, appState: nextAppState, ...next } = nextProps;
  return isShallowEqual(
    // asserting AppState because we're being passed the whole AppState
    // but resolve to only the UI-relevant props
    stripIrrelevantAppStateProps(prevAppState),
    stripIrrelevantAppStateProps(nextAppState),
    {
      selectedElementIds: isShallowEqual,
      selectedGroupIds: isShallowEqual
    }
  ) && isShallowEqual(prev, next);
};
var LayerUI_default = import_react89.default.memo(LayerUI, areEqual2);

// components/Toast.tsx
init_define_import_meta_env();
var import_react90 = __toESM(require_react(), 1);
var import_jsx_runtime122 = __toESM(require_jsx_runtime(), 1);
var DEFAULT_TOAST_TIMEOUT = 5e3;
var Toast = ({
  message,
  onClose,
  closable = false,
  // To prevent autoclose, pass duration as Infinity
  duration = DEFAULT_TOAST_TIMEOUT
}) => {
  const timerRef = (0, import_react90.useRef)(0);
  const shouldAutoClose = duration !== Infinity;
  const scheduleTimeout = (0, import_react90.useCallback)(() => {
    if (!shouldAutoClose) {
      return;
    }
    timerRef.current = window.setTimeout(() => onClose(), duration);
  }, [onClose, duration, shouldAutoClose]);
  (0, import_react90.useEffect)(() => {
    if (!shouldAutoClose) {
      return;
    }
    scheduleTimeout();
    return () => clearTimeout(timerRef.current);
  }, [scheduleTimeout, message, duration, shouldAutoClose]);
  const onMouseEnter = shouldAutoClose ? () => clearTimeout(timerRef?.current) : void 0;
  const onMouseLeave = shouldAutoClose ? scheduleTimeout : void 0;
  return /* @__PURE__ */ (0, import_jsx_runtime122.jsxs)(
    "div",
    {
      className: "Toast",
      onMouseEnter,
      onMouseLeave,
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime122.jsx)("p", { className: "Toast__message", children: message }),
        closable && /* @__PURE__ */ (0, import_jsx_runtime122.jsx)(
          ToolButton,
          {
            icon: CloseIcon,
            "aria-label": "close",
            type: "icon",
            onClick: onClose,
            className: "close"
          }
        )
      ]
    }
  );
};

// actions/actionToggleViewMode.tsx
init_define_import_meta_env();
var actionToggleViewMode = register({
  name: "viewMode",
  viewMode: true,
  trackEvent: {
    category: "canvas",
    predicate: (appState) => !appState.viewModeEnabled
  },
  perform(elements, appState) {
    return {
      appState: {
        ...appState,
        viewModeEnabled: !this.checked(appState)
      },
      commitToHistory: false
    };
  },
  checked: (appState) => appState.viewModeEnabled,
  predicate: (elements, appState, appProps) => {
    return typeof appProps.viewModeEnabled === "undefined";
  },
  contextItemLabel: "labels.viewMode",
  keyTest: (event) => !event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.R
});

// element/image.ts
init_define_import_meta_env();
var loadHTMLImageElement = (dataURL) => {
  return new Promise((resolve, reject) => {
    const image = new Image();
    image.onload = () => {
      resolve(image);
    };
    image.onerror = (error) => {
      reject(error);
    };
    image.src = dataURL;
  });
};
var updateImageCache = async ({
  fileIds,
  files,
  imageCache
}) => {
  const updatedFiles = /* @__PURE__ */ new Map();
  const erroredFiles = /* @__PURE__ */ new Map();
  await Promise.all(
    fileIds.reduce((promises, fileId) => {
      const fileData = files[fileId];
      if (fileData && !updatedFiles.has(fileId)) {
        updatedFiles.set(fileId, true);
        return promises.concat(
          (async () => {
            try {
              if (fileData.mimeType === MIME_TYPES.binary) {
                throw new Error("Only images can be added to ImageCache");
              }
              const imagePromise = loadHTMLImageElement(fileData.dataURL);
              const data = {
                image: imagePromise,
                mimeType: fileData.mimeType
              };
              imageCache.set(fileId, data);
              const image = await imagePromise;
              imageCache.set(fileId, { ...data, image });
            } catch (error) {
              erroredFiles.set(fileId, true);
            }
          })()
        );
      }
      return promises;
    }, [])
  );
  return {
    imageCache,
    /** includes errored files because they cache was updated nonetheless */
    updatedFiles,
    /** files that failed when creating HTMLImageElement */
    erroredFiles
  };
};
var getInitializedImageElements = (elements) => elements.filter(
  (element) => isInitializedImageElement(element)
);
var isHTMLSVGElement = (node) => {
  return node?.nodeName.toLowerCase() === "svg";
};
var normalizeSVG = async (SVGString) => {
  const doc = new DOMParser().parseFromString(SVGString, MIME_TYPES.svg);
  const svg = doc.querySelector("svg");
  const errorNode = doc.querySelector("parsererror");
  if (errorNode || !isHTMLSVGElement(svg)) {
    throw new Error(t("errors.invalidSVGString"));
  } else {
    if (!svg.hasAttribute("xmlns")) {
      svg.setAttribute("xmlns", SVG_NS);
    }
    if (!svg.hasAttribute("width") || !svg.hasAttribute("height")) {
      const viewBox = svg.getAttribute("viewBox");
      let width = svg.getAttribute("width") || "50";
      let height = svg.getAttribute("height") || "50";
      if (viewBox) {
        const match = viewBox.match(/\d+ +\d+ +(\d+) +(\d+)/);
        if (match) {
          [, width, height] = match;
        }
      }
      svg.setAttribute("width", width);
      svg.setAttribute("height", height);
    }
    return svg.outerHTML;
  }
};

// components/App.tsx
var import_lodash2 = __toESM(require_lodash(), 1);

// scene/Fonts.ts
init_define_import_meta_env();
var Fonts = class _Fonts {
  scene;
  onSceneUpdated;
  constructor({
    scene,
    onSceneUpdated
  }) {
    this.scene = scene;
    this.onSceneUpdated = onSceneUpdated;
  }
  // it's ok to track fonts across multiple instances only once, so let's use
  // a static member to reduce memory footprint
  static loadedFontFaces = /* @__PURE__ */ new Set();
  /**
   * if we load a (new) font, it's likely that text elements using it have
   * already been rendered using a fallback font. Thus, we want invalidate
   * their shapes and rerender. See #637.
   *
   * Invalidates text elements and rerenders scene, provided that at least one
   * of the supplied fontFaces has not already been processed.
   */
  onFontsLoaded = (fontFaces) => {
    if (
      // bail if all fonts with have been processed. We're checking just a
      // subset of the font properties (though it should be enough), so it
      // can technically bail on a false positive.
      fontFaces.every((fontFace) => {
        const sig = `${fontFace.family}-${fontFace.style}-${fontFace.weight}`;
        if (_Fonts.loadedFontFaces.has(sig)) {
          return true;
        }
        _Fonts.loadedFontFaces.add(sig);
        return false;
      })
    ) {
      return false;
    }
    let didUpdate = false;
    this.scene.mapElements((element) => {
      if (isTextElement(element) && !isBoundToContainer(element)) {
        ShapeCache.delete(element);
        didUpdate = true;
        return newElementWith(element, {
          ...refreshTextDimensions(
            element,
            getContainerElement(element, this.scene.getNonDeletedElementsMap()),
            this.scene.getNonDeletedElementsMap()
          )
        });
      }
      return element;
    });
    if (didUpdate) {
      this.onSceneUpdated();
    }
  };
  loadFontsForElements = async (elements) => {
    const fontFaces = await Promise.all(
      [
        ...new Set(
          elements.filter((element) => isTextElement(element)).map((element) => element.fontFamily)
        )
      ].map((fontFamily) => {
        const fontString = getFontString({
          fontFamily,
          fontSize: 16
        });
        if (!document.fonts?.check?.(fontString)) {
          return document.fonts?.load?.(fontString);
        }
        return void 0;
      })
    );
    this.onFontsLoaded(fontFaces.flat().filter(Boolean));
  };
};

// actions/actionFrame.ts
init_define_import_meta_env();
var isSingleFrameSelected = (appState, app) => {
  const selectedElements = app.scene.getSelectedElements(appState);
  return selectedElements.length === 1 && isFrameLikeElement(selectedElements[0]);
};
var actionSelectAllElementsInFrame = register({
  name: "selectAllElementsInFrame",
  trackEvent: { category: "canvas" },
  perform: (elements, appState, _, app) => {
    const selectedElement = app.scene.getSelectedElements(appState).at(0) || null;
    if (isFrameLikeElement(selectedElement)) {
      const elementsInFrame = getFrameChildren(
        getNonDeletedElements2(elements),
        selectedElement.id
      ).filter((element) => !(element.type === "text" && element.containerId));
      return {
        elements,
        appState: {
          ...appState,
          selectedElementIds: elementsInFrame.reduce((acc, element) => {
            acc[element.id] = true;
            return acc;
          }, {})
        },
        commitToHistory: false
      };
    }
    return {
      elements,
      appState,
      commitToHistory: false
    };
  },
  contextItemLabel: "labels.selectAllElementsInFrame",
  predicate: (elements, appState, _, app) => isSingleFrameSelected(appState, app)
});
var actionRemoveAllElementsFromFrame = register({
  name: "removeAllElementsFromFrame",
  trackEvent: { category: "history" },
  perform: (elements, appState, _, app) => {
    const selectedElement = app.scene.getSelectedElements(appState).at(0) || null;
    if (isFrameLikeElement(selectedElement)) {
      return {
        elements: removeAllElementsFromFrame(elements, selectedElement),
        appState: {
          ...appState,
          selectedElementIds: {
            [selectedElement.id]: true
          }
        },
        commitToHistory: true
      };
    }
    return {
      elements,
      appState,
      commitToHistory: false
    };
  },
  contextItemLabel: "labels.removeAllElementsFromFrame",
  predicate: (elements, appState, _, app) => isSingleFrameSelected(appState, app)
});
var actionupdateFrameRendering = register({
  name: "updateFrameRendering",
  viewMode: true,
  trackEvent: { category: "canvas" },
  perform: (elements, appState) => {
    return {
      elements,
      appState: {
        ...appState,
        frameRendering: {
          ...appState.frameRendering,
          enabled: !appState.frameRendering.enabled
        }
      },
      commitToHistory: false
    };
  },
  contextItemLabel: "labels.updateFrameRendering",
  checked: (appState) => appState.frameRendering.enabled
});
var actionSetFrameAsActiveTool = register({
  name: "setFrameAsActiveTool",
  trackEvent: { category: "toolbar" },
  perform: (elements, appState, _, app) => {
    const nextActiveTool = updateActiveTool(appState, {
      type: "frame"
    });
    setCursorForShape(app.interactiveCanvas, {
      ...appState,
      activeTool: nextActiveTool
    });
    return {
      elements,
      appState: {
        ...appState,
        activeTool: updateActiveTool(appState, {
          type: "frame"
        })
      },
      commitToHistory: false
    };
  },
  keyTest: (event) => !event[KEYS.CTRL_OR_CMD] && !event.shiftKey && !event.altKey && event.key.toLocaleLowerCase() === KEYS.F
});

// snapping.ts
init_define_import_meta_env();
var SNAP_DISTANCE = 8;
var VISIBLE_GAPS_LIMIT_PER_AXIS = 99999;
var getSnapDistance = (zoomValue) => {
  return SNAP_DISTANCE / zoomValue;
};
var SnapCache = class _SnapCache {
  static referenceSnapPoints = null;
  static visibleGaps = null;
  static setReferenceSnapPoints = (snapPoints) => {
    _SnapCache.referenceSnapPoints = snapPoints;
  };
  static getReferenceSnapPoints = () => {
    return _SnapCache.referenceSnapPoints;
  };
  static setVisibleGaps = (gaps) => {
    _SnapCache.visibleGaps = gaps;
  };
  static getVisibleGaps = () => {
    return _SnapCache.visibleGaps;
  };
  static destroy = () => {
    _SnapCache.referenceSnapPoints = null;
    _SnapCache.visibleGaps = null;
  };
};
var isSnappingEnabled = ({
  event,
  appState,
  selectedElements
}) => {
  if (event) {
    return appState.objectsSnapModeEnabled && !event[KEYS.CTRL_OR_CMD] || !appState.objectsSnapModeEnabled && event[KEYS.CTRL_OR_CMD] && appState.gridSize === null;
  }
  if (selectedElements.length === 1 && selectedElements[0].type === "arrow") {
    return false;
  }
  return appState.objectsSnapModeEnabled;
};
var areRoughlyEqual = (a4, b4, precision = 0.01) => {
  return Math.abs(a4 - b4) <= precision;
};
var getElementsCorners = (elements, elementsMap, {
  omitCenter,
  boundingBoxCorners,
  dragOffset
} = {
  omitCenter: false,
  boundingBoxCorners: false
}) => {
  let result = [];
  if (elements.length === 1) {
    const element = elements[0];
    let [x1, y1, x22, y22, cx, cy] = getElementAbsoluteCoords(
      element,
      elementsMap
    );
    if (dragOffset) {
      x1 += dragOffset.x;
      x22 += dragOffset.x;
      cx += dragOffset.x;
      y1 += dragOffset.y;
      y22 += dragOffset.y;
      cy += dragOffset.y;
    }
    const halfWidth = (x22 - x1) / 2;
    const halfHeight = (y22 - y1) / 2;
    if ((element.type === "diamond" || element.type === "ellipse") && !boundingBoxCorners) {
      const leftMid = rotatePoint(
        [x1, y1 + halfHeight],
        [cx, cy],
        element.angle
      );
      const topMid = rotatePoint([x1 + halfWidth, y1], [cx, cy], element.angle);
      const rightMid = rotatePoint(
        [x22, y1 + halfHeight],
        [cx, cy],
        element.angle
      );
      const bottomMid = rotatePoint(
        [x1 + halfWidth, y22],
        [cx, cy],
        element.angle
      );
      const center = [cx, cy];
      result = omitCenter ? [leftMid, topMid, rightMid, bottomMid] : [leftMid, topMid, rightMid, bottomMid, center];
    } else {
      const topLeft = rotatePoint([x1, y1], [cx, cy], element.angle);
      const topRight = rotatePoint([x22, y1], [cx, cy], element.angle);
      const bottomLeft = rotatePoint([x1, y22], [cx, cy], element.angle);
      const bottomRight = rotatePoint([x22, y22], [cx, cy], element.angle);
      const center = [cx, cy];
      result = omitCenter ? [topLeft, topRight, bottomLeft, bottomRight] : [topLeft, topRight, bottomLeft, bottomRight, center];
    }
  } else if (elements.length > 1) {
    const [minX, minY, maxX, maxY] = getDraggedElementsBounds(
      elements,
      dragOffset ?? { x: 0, y: 0 }
    );
    const width = maxX - minX;
    const height = maxY - minY;
    const topLeft = [minX, minY];
    const topRight = [maxX, minY];
    const bottomLeft = [minX, maxY];
    const bottomRight = [maxX, maxY];
    const center = [minX + width / 2, minY + height / 2];
    result = omitCenter ? [topLeft, topRight, bottomLeft, bottomRight] : [topLeft, topRight, bottomLeft, bottomRight, center];
  }
  return result.map((point2) => [round(point2[0]), round(point2[1])]);
};
var getReferenceElements = (elements, selectedElements, appState, elementsMap) => {
  const selectedFrames = selectedElements.filter((element) => isFrameLikeElement(element)).map((frame) => frame.id);
  return getVisibleAndNonSelectedElements(
    elements,
    selectedElements,
    appState,
    elementsMap
  ).filter(
    (element) => !(element.frameId && selectedFrames.includes(element.frameId))
  );
};
var getVisibleGaps = (elements, selectedElements, appState, elementsMap) => {
  const referenceElements = getReferenceElements(
    elements,
    selectedElements,
    appState,
    elementsMap
  );
  const referenceBounds = getMaximumGroups(referenceElements, elementsMap).filter(
    (elementsGroup) => !(elementsGroup.length === 1 && isBoundToContainer(elementsGroup[0]))
  ).map(
    (group) => getCommonBounds(group).map(
      (bound) => round(bound)
    )
  );
  const horizontallySorted = referenceBounds.sort((a4, b4) => a4[0] - b4[0]);
  const horizontalGaps = [];
  let c3 = 0;
  horizontal:
    for (let i4 = 0; i4 < horizontallySorted.length; i4++) {
      const startBounds = horizontallySorted[i4];
      for (let j = i4 + 1; j < horizontallySorted.length; j++) {
        if (++c3 > VISIBLE_GAPS_LIMIT_PER_AXIS) {
          break horizontal;
        }
        const endBounds = horizontallySorted[j];
        const [, startMinY, startMaxX, startMaxY] = startBounds;
        const [endMinX, endMinY, , endMaxY] = endBounds;
        if (startMaxX < endMinX && rangesOverlap([startMinY, startMaxY], [endMinY, endMaxY])) {
          horizontalGaps.push({
            startBounds,
            endBounds,
            startSide: [
              [startMaxX, startMinY],
              [startMaxX, startMaxY]
            ],
            endSide: [
              [endMinX, endMinY],
              [endMinX, endMaxY]
            ],
            length: endMinX - startMaxX,
            overlap: rangeIntersection(
              [startMinY, startMaxY],
              [endMinY, endMaxY]
            )
          });
        }
      }
    }
  const verticallySorted = referenceBounds.sort((a4, b4) => a4[1] - b4[1]);
  const verticalGaps = [];
  c3 = 0;
  vertical:
    for (let i4 = 0; i4 < verticallySorted.length; i4++) {
      const startBounds = verticallySorted[i4];
      for (let j = i4 + 1; j < verticallySorted.length; j++) {
        if (++c3 > VISIBLE_GAPS_LIMIT_PER_AXIS) {
          break vertical;
        }
        const endBounds = verticallySorted[j];
        const [startMinX, , startMaxX, startMaxY] = startBounds;
        const [endMinX, endMinY, endMaxX] = endBounds;
        if (startMaxY < endMinY && rangesOverlap([startMinX, startMaxX], [endMinX, endMaxX])) {
          verticalGaps.push({
            startBounds,
            endBounds,
            startSide: [
              [startMinX, startMaxY],
              [startMaxX, startMaxY]
            ],
            endSide: [
              [endMinX, endMinY],
              [endMaxX, endMinY]
            ],
            length: endMinY - startMaxY,
            overlap: rangeIntersection(
              [startMinX, startMaxX],
              [endMinX, endMaxX]
            )
          });
        }
      }
    }
  return {
    horizontalGaps,
    verticalGaps
  };
};
var getGapSnaps = (selectedElements, dragOffset, appState, event, nearestSnapsX, nearestSnapsY, minOffset) => {
  if (!isSnappingEnabled({ appState, event, selectedElements })) {
    return [];
  }
  if (selectedElements.length === 0) {
    return [];
  }
  const visibleGaps = SnapCache.getVisibleGaps();
  if (visibleGaps) {
    const { horizontalGaps, verticalGaps } = visibleGaps;
    const [minX, minY, maxX, maxY] = getDraggedElementsBounds(
      selectedElements,
      dragOffset
    ).map((bound) => round(bound));
    const centerX = (minX + maxX) / 2;
    const centerY = (minY + maxY) / 2;
    for (const gap of horizontalGaps) {
      if (!rangesOverlap([minY, maxY], gap.overlap)) {
        continue;
      }
      const gapMidX = gap.startSide[0][0] + gap.length / 2;
      const centerOffset = round(gapMidX - centerX);
      const gapIsLargerThanSelection = gap.length > maxX - minX;
      if (gapIsLargerThanSelection && Math.abs(centerOffset) <= minOffset.x) {
        if (Math.abs(centerOffset) < minOffset.x) {
          nearestSnapsX.length = 0;
        }
        minOffset.x = Math.abs(centerOffset);
        const snap = {
          type: "gap",
          direction: "center_horizontal",
          gap,
          offset: centerOffset
        };
        nearestSnapsX.push(snap);
        continue;
      }
      const [, , endMaxX] = gap.endBounds;
      const distanceToEndElementX = minX - endMaxX;
      const sideOffsetRight = round(gap.length - distanceToEndElementX);
      if (Math.abs(sideOffsetRight) <= minOffset.x) {
        if (Math.abs(sideOffsetRight) < minOffset.x) {
          nearestSnapsX.length = 0;
        }
        minOffset.x = Math.abs(sideOffsetRight);
        const snap = {
          type: "gap",
          direction: "side_right",
          gap,
          offset: sideOffsetRight
        };
        nearestSnapsX.push(snap);
        continue;
      }
      const [startMinX, , ,] = gap.startBounds;
      const distanceToStartElementX = startMinX - maxX;
      const sideOffsetLeft = round(distanceToStartElementX - gap.length);
      if (Math.abs(sideOffsetLeft) <= minOffset.x) {
        if (Math.abs(sideOffsetLeft) < minOffset.x) {
          nearestSnapsX.length = 0;
        }
        minOffset.x = Math.abs(sideOffsetLeft);
        const snap = {
          type: "gap",
          direction: "side_left",
          gap,
          offset: sideOffsetLeft
        };
        nearestSnapsX.push(snap);
        continue;
      }
    }
    for (const gap of verticalGaps) {
      if (!rangesOverlap([minX, maxX], gap.overlap)) {
        continue;
      }
      const gapMidY = gap.startSide[0][1] + gap.length / 2;
      const centerOffset = round(gapMidY - centerY);
      const gapIsLargerThanSelection = gap.length > maxY - minY;
      if (gapIsLargerThanSelection && Math.abs(centerOffset) <= minOffset.y) {
        if (Math.abs(centerOffset) < minOffset.y) {
          nearestSnapsY.length = 0;
        }
        minOffset.y = Math.abs(centerOffset);
        const snap = {
          type: "gap",
          direction: "center_vertical",
          gap,
          offset: centerOffset
        };
        nearestSnapsY.push(snap);
        continue;
      }
      const [, startMinY, ,] = gap.startBounds;
      const distanceToStartElementY = startMinY - maxY;
      const sideOffsetTop = round(distanceToStartElementY - gap.length);
      if (Math.abs(sideOffsetTop) <= minOffset.y) {
        if (Math.abs(sideOffsetTop) < minOffset.y) {
          nearestSnapsY.length = 0;
        }
        minOffset.y = Math.abs(sideOffsetTop);
        const snap = {
          type: "gap",
          direction: "side_top",
          gap,
          offset: sideOffsetTop
        };
        nearestSnapsY.push(snap);
        continue;
      }
      const [, , , endMaxY] = gap.endBounds;
      const distanceToEndElementY = round(minY - endMaxY);
      const sideOffsetBottom = gap.length - distanceToEndElementY;
      if (Math.abs(sideOffsetBottom) <= minOffset.y) {
        if (Math.abs(sideOffsetBottom) < minOffset.y) {
          nearestSnapsY.length = 0;
        }
        minOffset.y = Math.abs(sideOffsetBottom);
        const snap = {
          type: "gap",
          direction: "side_bottom",
          gap,
          offset: sideOffsetBottom
        };
        nearestSnapsY.push(snap);
        continue;
      }
    }
  }
};
var getReferenceSnapPoints = (elements, selectedElements, appState, elementsMap) => {
  const referenceElements = getReferenceElements(
    elements,
    selectedElements,
    appState,
    elementsMap
  );
  return getMaximumGroups(referenceElements, elementsMap).filter(
    (elementsGroup) => !(elementsGroup.length === 1 && isBoundToContainer(elementsGroup[0]))
  ).flatMap((elementGroup) => getElementsCorners(elementGroup, elementsMap));
};
var getPointSnaps = (selectedElements, selectionSnapPoints, appState, event, nearestSnapsX, nearestSnapsY, minOffset) => {
  if (!isSnappingEnabled({ appState, event, selectedElements }) || selectedElements.length === 0 && selectionSnapPoints.length === 0) {
    return [];
  }
  const referenceSnapPoints = SnapCache.getReferenceSnapPoints();
  if (referenceSnapPoints) {
    for (const thisSnapPoint of selectionSnapPoints) {
      for (const otherSnapPoint of referenceSnapPoints) {
        const offsetX = otherSnapPoint[0] - thisSnapPoint[0];
        const offsetY = otherSnapPoint[1] - thisSnapPoint[1];
        if (Math.abs(offsetX) <= minOffset.x) {
          if (Math.abs(offsetX) < minOffset.x) {
            nearestSnapsX.length = 0;
          }
          nearestSnapsX.push({
            type: "point",
            points: [thisSnapPoint, otherSnapPoint],
            offset: offsetX
          });
          minOffset.x = Math.abs(offsetX);
        }
        if (Math.abs(offsetY) <= minOffset.y) {
          if (Math.abs(offsetY) < minOffset.y) {
            nearestSnapsY.length = 0;
          }
          nearestSnapsY.push({
            type: "point",
            points: [thisSnapPoint, otherSnapPoint],
            offset: offsetY
          });
          minOffset.y = Math.abs(offsetY);
        }
      }
    }
  }
};
var snapDraggedElements = (elements, dragOffset, appState, event, elementsMap) => {
  const selectedElements = getSelectedElements(elements, appState);
  if (!isSnappingEnabled({ appState, event, selectedElements }) || selectedElements.length === 0) {
    return {
      snapOffset: {
        x: 0,
        y: 0
      },
      snapLines: []
    };
  }
  dragOffset.x = round(dragOffset.x);
  dragOffset.y = round(dragOffset.y);
  const nearestSnapsX = [];
  const nearestSnapsY = [];
  const snapDistance = getSnapDistance(appState.zoom.value);
  const minOffset = {
    x: snapDistance,
    y: snapDistance
  };
  const selectionPoints = getElementsCorners(selectedElements, elementsMap, {
    dragOffset
  });
  getPointSnaps(
    selectedElements,
    selectionPoints,
    appState,
    event,
    nearestSnapsX,
    nearestSnapsY,
    minOffset
  );
  getGapSnaps(
    selectedElements,
    dragOffset,
    appState,
    event,
    nearestSnapsX,
    nearestSnapsY,
    minOffset
  );
  const snapOffset = {
    x: nearestSnapsX[0]?.offset ?? 0,
    y: nearestSnapsY[0]?.offset ?? 0
  };
  minOffset.x = 0;
  minOffset.y = 0;
  nearestSnapsX.length = 0;
  nearestSnapsY.length = 0;
  const newDragOffset = {
    x: round(dragOffset.x + snapOffset.x),
    y: round(dragOffset.y + snapOffset.y)
  };
  getPointSnaps(
    selectedElements,
    getElementsCorners(selectedElements, elementsMap, {
      dragOffset: newDragOffset
    }),
    appState,
    event,
    nearestSnapsX,
    nearestSnapsY,
    minOffset
  );
  getGapSnaps(
    selectedElements,
    newDragOffset,
    appState,
    event,
    nearestSnapsX,
    nearestSnapsY,
    minOffset
  );
  const pointSnapLines = createPointSnapLines(nearestSnapsX, nearestSnapsY);
  const gapSnapLines = createGapSnapLines(
    selectedElements,
    newDragOffset,
    [...nearestSnapsX, ...nearestSnapsY].filter(
      (snap) => snap.type === "gap"
    )
  );
  return {
    snapOffset,
    snapLines: [...pointSnapLines, ...gapSnapLines]
  };
};
var round = (x3) => {
  const decimalPlaces = 6;
  return Math.round(x3 * 10 ** decimalPlaces) / 10 ** decimalPlaces;
};
var dedupePoints = (points) => {
  const map = /* @__PURE__ */ new Map();
  for (const point2 of points) {
    const key = point2.join(",");
    if (!map.has(key)) {
      map.set(key, point2);
    }
  }
  return Array.from(map.values());
};
var createPointSnapLines = (nearestSnapsX, nearestSnapsY) => {
  const snapsX = {};
  const snapsY = {};
  if (nearestSnapsX.length > 0) {
    for (const snap of nearestSnapsX) {
      if (snap.type === "point") {
        const key = round(snap.points[0][0]);
        if (!snapsX[key]) {
          snapsX[key] = [];
        }
        snapsX[key].push(
          ...snap.points.map(
            (point2) => [round(point2[0]), round(point2[1])]
          )
        );
      }
    }
  }
  if (nearestSnapsY.length > 0) {
    for (const snap of nearestSnapsY) {
      if (snap.type === "point") {
        const key = round(snap.points[0][1]);
        if (!snapsY[key]) {
          snapsY[key] = [];
        }
        snapsY[key].push(
          ...snap.points.map(
            (point2) => [round(point2[0]), round(point2[1])]
          )
        );
      }
    }
  }
  return Object.entries(snapsX).map(([key, points]) => {
    return {
      type: "points",
      points: dedupePoints(
        points.map((point2) => {
          return [Number(key), point2[1]];
        }).sort((a4, b4) => a4[1] - b4[1])
      )
    };
  }).concat(
    Object.entries(snapsY).map(([key, points]) => {
      return {
        type: "points",
        points: dedupePoints(
          points.map((point2) => {
            return [point2[0], Number(key)];
          }).sort((a4, b4) => a4[0] - b4[0])
        )
      };
    })
  );
};
var dedupeGapSnapLines = (gapSnapLines) => {
  const map = /* @__PURE__ */ new Map();
  for (const gapSnapLine of gapSnapLines) {
    const key = gapSnapLine.points.flat().map((point2) => [round(point2)]).join(",");
    if (!map.has(key)) {
      map.set(key, gapSnapLine);
    }
  }
  return Array.from(map.values());
};
var createGapSnapLines = (selectedElements, dragOffset, gapSnaps) => {
  const [minX, minY, maxX, maxY] = getDraggedElementsBounds(
    selectedElements,
    dragOffset
  );
  const gapSnapLines = [];
  for (const gapSnap of gapSnaps) {
    const [startMinX, startMinY, startMaxX, startMaxY] = gapSnap.gap.startBounds;
    const [endMinX, endMinY, endMaxX, endMaxY] = gapSnap.gap.endBounds;
    const verticalIntersection = rangeIntersection(
      [minY, maxY],
      gapSnap.gap.overlap
    );
    const horizontalGapIntersection = rangeIntersection(
      [minX, maxX],
      gapSnap.gap.overlap
    );
    switch (gapSnap.direction) {
      case "center_horizontal": {
        if (verticalIntersection) {
          const gapLineY = (verticalIntersection[0] + verticalIntersection[1]) / 2;
          gapSnapLines.push(
            {
              type: "gap",
              direction: "horizontal",
              points: [
                [gapSnap.gap.startSide[0][0], gapLineY],
                [minX, gapLineY]
              ]
            },
            {
              type: "gap",
              direction: "horizontal",
              points: [
                [maxX, gapLineY],
                [gapSnap.gap.endSide[0][0], gapLineY]
              ]
            }
          );
        }
        break;
      }
      case "center_vertical": {
        if (horizontalGapIntersection) {
          const gapLineX = (horizontalGapIntersection[0] + horizontalGapIntersection[1]) / 2;
          gapSnapLines.push(
            {
              type: "gap",
              direction: "vertical",
              points: [
                [gapLineX, gapSnap.gap.startSide[0][1]],
                [gapLineX, minY]
              ]
            },
            {
              type: "gap",
              direction: "vertical",
              points: [
                [gapLineX, maxY],
                [gapLineX, gapSnap.gap.endSide[0][1]]
              ]
            }
          );
        }
        break;
      }
      case "side_right": {
        if (verticalIntersection) {
          const gapLineY = (verticalIntersection[0] + verticalIntersection[1]) / 2;
          gapSnapLines.push(
            {
              type: "gap",
              direction: "horizontal",
              points: [
                [startMaxX, gapLineY],
                [endMinX, gapLineY]
              ]
            },
            {
              type: "gap",
              direction: "horizontal",
              points: [
                [endMaxX, gapLineY],
                [minX, gapLineY]
              ]
            }
          );
        }
        break;
      }
      case "side_left": {
        if (verticalIntersection) {
          const gapLineY = (verticalIntersection[0] + verticalIntersection[1]) / 2;
          gapSnapLines.push(
            {
              type: "gap",
              direction: "horizontal",
              points: [
                [maxX, gapLineY],
                [startMinX, gapLineY]
              ]
            },
            {
              type: "gap",
              direction: "horizontal",
              points: [
                [startMaxX, gapLineY],
                [endMinX, gapLineY]
              ]
            }
          );
        }
        break;
      }
      case "side_top": {
        if (horizontalGapIntersection) {
          const gapLineX = (horizontalGapIntersection[0] + horizontalGapIntersection[1]) / 2;
          gapSnapLines.push(
            {
              type: "gap",
              direction: "vertical",
              points: [
                [gapLineX, maxY],
                [gapLineX, startMinY]
              ]
            },
            {
              type: "gap",
              direction: "vertical",
              points: [
                [gapLineX, startMaxY],
                [gapLineX, endMinY]
              ]
            }
          );
        }
        break;
      }
      case "side_bottom": {
        if (horizontalGapIntersection) {
          const gapLineX = (horizontalGapIntersection[0] + horizontalGapIntersection[1]) / 2;
          gapSnapLines.push(
            {
              type: "gap",
              direction: "vertical",
              points: [
                [gapLineX, startMaxY],
                [gapLineX, endMinY]
              ]
            },
            {
              type: "gap",
              direction: "vertical",
              points: [
                [gapLineX, endMaxY],
                [gapLineX, minY]
              ]
            }
          );
        }
        break;
      }
    }
  }
  return dedupeGapSnapLines(
    gapSnapLines.map((gapSnapLine) => {
      return {
        ...gapSnapLine,
        points: gapSnapLine.points.map(
          (point2) => [round(point2[0]), round(point2[1])]
        )
      };
    })
  );
};
var snapResizingElements = (selectedElements, selectedOriginalElements, appState, event, dragOffset, transformHandle) => {
  if (!isSnappingEnabled({ event, selectedElements, appState }) || selectedElements.length === 0 || selectedElements.length === 1 && !areRoughlyEqual(selectedElements[0].angle, 0)) {
    return {
      snapOffset: { x: 0, y: 0 },
      snapLines: []
    };
  }
  let [minX, minY, maxX, maxY] = getCommonBounds(selectedOriginalElements);
  if (transformHandle) {
    if (transformHandle.includes("e")) {
      maxX += dragOffset.x;
    } else if (transformHandle.includes("w")) {
      minX += dragOffset.x;
    }
    if (transformHandle.includes("n")) {
      minY += dragOffset.y;
    } else if (transformHandle.includes("s")) {
      maxY += dragOffset.y;
    }
  }
  const selectionSnapPoints = [];
  if (transformHandle) {
    switch (transformHandle) {
      case "e": {
        selectionSnapPoints.push([maxX, minY], [maxX, maxY]);
        break;
      }
      case "w": {
        selectionSnapPoints.push([minX, minY], [minX, maxY]);
        break;
      }
      case "n": {
        selectionSnapPoints.push([minX, minY], [maxX, minY]);
        break;
      }
      case "s": {
        selectionSnapPoints.push([minX, maxY], [maxX, maxY]);
        break;
      }
      case "ne": {
        selectionSnapPoints.push([maxX, minY]);
        break;
      }
      case "nw": {
        selectionSnapPoints.push([minX, minY]);
        break;
      }
      case "se": {
        selectionSnapPoints.push([maxX, maxY]);
        break;
      }
      case "sw": {
        selectionSnapPoints.push([minX, maxY]);
        break;
      }
    }
  }
  const snapDistance = getSnapDistance(appState.zoom.value);
  const minOffset = {
    x: snapDistance,
    y: snapDistance
  };
  const nearestSnapsX = [];
  const nearestSnapsY = [];
  getPointSnaps(
    selectedOriginalElements,
    selectionSnapPoints,
    appState,
    event,
    nearestSnapsX,
    nearestSnapsY,
    minOffset
  );
  const snapOffset = {
    x: nearestSnapsX[0]?.offset ?? 0,
    y: nearestSnapsY[0]?.offset ?? 0
  };
  minOffset.x = 0;
  minOffset.y = 0;
  nearestSnapsX.length = 0;
  nearestSnapsY.length = 0;
  const [x1, y1, x22, y22] = getCommonBounds(selectedElements).map(
    (bound) => round(bound)
  );
  const corners = [
    [x1, y1],
    [x1, y22],
    [x22, y1],
    [x22, y22]
  ];
  getPointSnaps(
    selectedElements,
    corners,
    appState,
    event,
    nearestSnapsX,
    nearestSnapsY,
    minOffset
  );
  const pointSnapLines = createPointSnapLines(nearestSnapsX, nearestSnapsY);
  return {
    snapOffset,
    snapLines: pointSnapLines
  };
};
var snapNewElement = (draggingElement, appState, event, origin, dragOffset, elementsMap) => {
  if (!isSnappingEnabled({ event, selectedElements: [draggingElement], appState })) {
    return {
      snapOffset: { x: 0, y: 0 },
      snapLines: []
    };
  }
  const selectionSnapPoints = [
    [origin.x + dragOffset.x, origin.y + dragOffset.y]
  ];
  const snapDistance = getSnapDistance(appState.zoom.value);
  const minOffset = {
    x: snapDistance,
    y: snapDistance
  };
  const nearestSnapsX = [];
  const nearestSnapsY = [];
  getPointSnaps(
    [draggingElement],
    selectionSnapPoints,
    appState,
    event,
    nearestSnapsX,
    nearestSnapsY,
    minOffset
  );
  const snapOffset = {
    x: nearestSnapsX[0]?.offset ?? 0,
    y: nearestSnapsY[0]?.offset ?? 0
  };
  minOffset.x = 0;
  minOffset.y = 0;
  nearestSnapsX.length = 0;
  nearestSnapsY.length = 0;
  const corners = getElementsCorners([draggingElement], elementsMap, {
    boundingBoxCorners: true,
    omitCenter: true
  });
  getPointSnaps(
    [draggingElement],
    corners,
    appState,
    event,
    nearestSnapsX,
    nearestSnapsY,
    minOffset
  );
  const pointSnapLines = createPointSnapLines(nearestSnapsX, nearestSnapsY);
  return {
    snapOffset,
    snapLines: pointSnapLines
  };
};
var getSnapLinesAtPointer = (elements, appState, pointer, event, elementsMap) => {
  if (!isSnappingEnabled({ event, selectedElements: [], appState })) {
    return {
      originOffset: { x: 0, y: 0 },
      snapLines: []
    };
  }
  const referenceElements = getVisibleAndNonSelectedElements(
    elements,
    [],
    appState,
    elementsMap
  );
  const snapDistance = getSnapDistance(appState.zoom.value);
  const minOffset = {
    x: snapDistance,
    y: snapDistance
  };
  const horizontalSnapLines = [];
  const verticalSnapLines = [];
  for (const referenceElement of referenceElements) {
    const corners = getElementsCorners([referenceElement], elementsMap);
    for (const corner of corners) {
      const offsetX = corner[0] - pointer.x;
      if (Math.abs(offsetX) <= Math.abs(minOffset.x)) {
        if (Math.abs(offsetX) < Math.abs(minOffset.x)) {
          verticalSnapLines.length = 0;
        }
        verticalSnapLines.push({
          type: "pointer",
          points: [corner, [corner[0], pointer.y]],
          direction: "vertical"
        });
        minOffset.x = offsetX;
      }
      const offsetY = corner[1] - pointer.y;
      if (Math.abs(offsetY) <= Math.abs(minOffset.y)) {
        if (Math.abs(offsetY) < Math.abs(minOffset.y)) {
          horizontalSnapLines.length = 0;
        }
        horizontalSnapLines.push({
          type: "pointer",
          points: [corner, [pointer.x, corner[1]]],
          direction: "horizontal"
        });
        minOffset.y = offsetY;
      }
    }
  }
  return {
    originOffset: {
      x: verticalSnapLines.length > 0 ? verticalSnapLines[0].points[0][0] - pointer.x : 0,
      y: horizontalSnapLines.length > 0 ? horizontalSnapLines[0].points[0][1] - pointer.y : 0
    },
    snapLines: [...verticalSnapLines, ...horizontalSnapLines]
  };
};
var isActiveToolNonLinearSnappable = (activeToolType) => {
  return activeToolType === TOOL_TYPE.rectangle || activeToolType === TOOL_TYPE.ellipse || activeToolType === TOOL_TYPE.diamond || activeToolType === TOOL_TYPE.frame || activeToolType === TOOL_TYPE.magicframe || activeToolType === TOOL_TYPE.image;
};

// components/BraveMeasureTextError.tsx
init_define_import_meta_env();
var import_jsx_runtime123 = __toESM(require_jsx_runtime(), 1);
var BraveMeasureTextError = () => {
  return /* @__PURE__ */ (0, import_jsx_runtime123.jsxs)("div", { "data-testid": "brave-measure-text-error", children: [
    /* @__PURE__ */ (0, import_jsx_runtime123.jsx)("p", { children: /* @__PURE__ */ (0, import_jsx_runtime123.jsx)(
      Trans_default,
      {
        i18nKey: "errors.brave_measure_text_error.line1",
        bold: (el) => /* @__PURE__ */ (0, import_jsx_runtime123.jsx)("span", { style: { fontWeight: 600 }, children: el })
      }
    ) }),
    /* @__PURE__ */ (0, import_jsx_runtime123.jsx)("p", { children: /* @__PURE__ */ (0, import_jsx_runtime123.jsx)(
      Trans_default,
      {
        i18nKey: "errors.brave_measure_text_error.line2",
        bold: (el) => /* @__PURE__ */ (0, import_jsx_runtime123.jsx)("span", { style: { fontWeight: 600 }, children: el })
      }
    ) }),
    /* @__PURE__ */ (0, import_jsx_runtime123.jsx)("p", { children: /* @__PURE__ */ (0, import_jsx_runtime123.jsx)(
      Trans_default,
      {
        i18nKey: "errors.brave_measure_text_error.line3",
        link: (el) => /* @__PURE__ */ (0, import_jsx_runtime123.jsx)("a", { href: "http://docs.excalidraw.com/docs/@excalidraw/excalidraw/faq#turning-off-aggresive-block-fingerprinting-in-brave-browser", children: el })
      }
    ) }),
    /* @__PURE__ */ (0, import_jsx_runtime123.jsx)("p", { children: /* @__PURE__ */ (0, import_jsx_runtime123.jsx)(
      Trans_default,
      {
        i18nKey: "errors.brave_measure_text_error.line4",
        issueLink: (el) => /* @__PURE__ */ (0, import_jsx_runtime123.jsx)("a", { href: "https://github.com/excalidraw/excalidraw/issues/new", children: el }),
        discordLink: (el) => /* @__PURE__ */ (0, import_jsx_runtime123.jsxs)("a", { href: "https://discord.gg/UexuTaE", children: [
          el,
          "."
        ] })
      }
    ) })
  ] });
};
var BraveMeasureTextError_default = BraveMeasureTextError;

// components/canvases/index.tsx
init_define_import_meta_env();

// components/canvases/InteractiveCanvas.tsx
init_define_import_meta_env();
var import_react92 = __toESM(require_react(), 1);

// reactUtils.ts
init_define_import_meta_env();
var import_react_dom8 = __toESM(require_react_dom(), 1);
var import_react91 = __toESM(require_react(), 1);
var withBatchedUpdates = (func) => (event) => {
  (0, import_react_dom8.unstable_batchedUpdates)(func, event);
};
var withBatchedUpdatesThrottled = (func) => {
  return throttleRAF((event) => {
    (0, import_react_dom8.unstable_batchedUpdates)(func, event);
  });
};
var isRenderThrottlingEnabled = (() => {
  let IS_REACT_18_AND_UP;
  try {
    const version = import_react91.version.split(".");
    IS_REACT_18_AND_UP = Number(version[0]) > 17;
  } catch {
    IS_REACT_18_AND_UP = false;
  }
  let hasWarned = false;
  return () => {
    if (window.EXCALIDRAW_THROTTLE_RENDER === true) {
      if (!IS_REACT_18_AND_UP) {
        if (!hasWarned) {
          hasWarned = true;
          console.warn(
            "Excalidraw: render throttling is disabled on React versions < 18."
          );
        }
        return false;
      }
      return true;
    }
    return false;
  };
})();

// components/canvases/InteractiveCanvas.tsx
var import_jsx_runtime124 = __toESM(require_jsx_runtime(), 1);
var InteractiveCanvas = (props) => {
  const isComponentMounted = (0, import_react92.useRef)(false);
  (0, import_react92.useEffect)(() => {
    if (!isComponentMounted.current) {
      isComponentMounted.current = true;
      return;
    }
    const cursorButton = {};
    const pointerViewportCoords = {};
    const remoteSelectedElementIds = {};
    const pointerUsernames = {};
    const pointerUserStates = {};
    props.appState.collaborators.forEach((user, socketId) => {
      if (user.selectedElementIds) {
        for (const id of Object.keys(user.selectedElementIds)) {
          if (!(id in remoteSelectedElementIds)) {
            remoteSelectedElementIds[id] = [];
          }
          remoteSelectedElementIds[id].push(socketId);
        }
      }
      if (!user.pointer) {
        return;
      }
      if (user.username) {
        pointerUsernames[socketId] = user.username;
      }
      if (user.userState) {
        pointerUserStates[socketId] = user.userState;
      }
      pointerViewportCoords[socketId] = sceneCoordsToViewportCoords(
        {
          sceneX: user.pointer.x,
          sceneY: user.pointer.y
        },
        props.appState
      );
      cursorButton[socketId] = user.button;
    });
    const selectionColor = props.containerRef?.current && getComputedStyle(props.containerRef.current).getPropertyValue(
      "--color-selection"
    ) || "#6965db";
    renderInteractiveScene(
      {
        canvas: props.canvas,
        elementsMap: props.elementsMap,
        visibleElements: props.visibleElements,
        selectedElements: props.selectedElements,
        scale: window.devicePixelRatio,
        appState: props.appState,
        renderConfig: {
          remotePointerViewportCoords: pointerViewportCoords,
          remotePointerButton: cursorButton,
          remoteSelectedElementIds,
          remotePointerUsernames: pointerUsernames,
          remotePointerUserStates: pointerUserStates,
          selectionColor,
          renderScrollbars: false
        },
        callback: props.renderInteractiveSceneCallback
      },
      isRenderThrottlingEnabled()
    );
  });
  return /* @__PURE__ */ (0, import_jsx_runtime124.jsx)(
    "canvas",
    {
      className: "excalidraw__canvas interactive",
      style: {
        width: props.appState.width,
        height: props.appState.height,
        cursor: props.appState.viewModeEnabled ? CURSOR_TYPE.GRAB : CURSOR_TYPE.AUTO
      },
      width: props.appState.width * props.scale,
      height: props.appState.height * props.scale,
      ref: props.handleCanvasRef,
      onContextMenu: props.onContextMenu,
      onPointerMove: props.onPointerMove,
      onPointerUp: props.onPointerUp,
      onPointerCancel: props.onPointerCancel,
      onTouchMove: props.onTouchMove,
      onPointerDown: props.onPointerDown,
      onDoubleClick: props.appState.viewModeEnabled ? void 0 : props.onDoubleClick,
      children: t("labels.drawingCanvas")
    }
  );
};
var getRelevantAppStateProps = (appState) => ({
  zoom: appState.zoom,
  scrollX: appState.scrollX,
  scrollY: appState.scrollY,
  width: appState.width,
  height: appState.height,
  viewModeEnabled: appState.viewModeEnabled,
  editingGroupId: appState.editingGroupId,
  editingLinearElement: appState.editingLinearElement,
  selectedElementIds: appState.selectedElementIds,
  frameToHighlight: appState.frameToHighlight,
  offsetLeft: appState.offsetLeft,
  offsetTop: appState.offsetTop,
  theme: appState.theme,
  pendingImageElementId: appState.pendingImageElementId,
  selectionElement: appState.selectionElement,
  selectedGroupIds: appState.selectedGroupIds,
  selectedLinearElement: appState.selectedLinearElement,
  multiElement: appState.multiElement,
  isBindingEnabled: appState.isBindingEnabled,
  suggestedBindings: appState.suggestedBindings,
  isRotating: appState.isRotating,
  elementsToHighlight: appState.elementsToHighlight,
  collaborators: appState.collaborators,
  // Necessary for collab. sessions
  activeEmbeddable: appState.activeEmbeddable,
  snapLines: appState.snapLines,
  zenModeEnabled: appState.zenModeEnabled
});
var areEqual3 = (prevProps, nextProps) => {
  if (prevProps.selectionNonce !== nextProps.selectionNonce || prevProps.versionNonce !== nextProps.versionNonce || prevProps.scale !== nextProps.scale || // we need to memoize on elementsMap because they may have renewed
  // even if versionNonce didn't change (e.g. we filter elements out based
  // on appState)
  prevProps.elementsMap !== nextProps.elementsMap || prevProps.visibleElements !== nextProps.visibleElements || prevProps.selectedElements !== nextProps.selectedElements) {
    return false;
  }
  return isShallowEqual(
    // asserting AppState because we're being passed the whole AppState
    // but resolve to only the InteractiveCanvas-relevant props
    getRelevantAppStateProps(prevProps.appState),
    getRelevantAppStateProps(nextProps.appState)
  );
};
var InteractiveCanvas_default = import_react92.default.memo(InteractiveCanvas, areEqual3);

// components/canvases/StaticCanvas.tsx
init_define_import_meta_env();
var import_react93 = __toESM(require_react(), 1);
var import_jsx_runtime125 = __toESM(require_jsx_runtime(), 1);
var StaticCanvas = (props) => {
  const wrapperRef = (0, import_react93.useRef)(null);
  const isComponentMounted = (0, import_react93.useRef)(false);
  (0, import_react93.useEffect)(() => {
    const wrapper = wrapperRef.current;
    if (!wrapper) {
      return;
    }
    const canvas2 = props.canvas;
    if (!isComponentMounted.current) {
      isComponentMounted.current = true;
      wrapper.replaceChildren(canvas2);
      canvas2.classList.add("excalidraw__canvas", "static");
    }
    const widthString = `${props.appState.width}px`;
    const heightString = `${props.appState.height}px`;
    if (canvas2.style.width !== widthString) {
      canvas2.style.width = widthString;
    }
    if (canvas2.style.height !== heightString) {
      canvas2.style.height = heightString;
    }
    const scaledWidth = props.appState.width * props.scale;
    const scaledHeight = props.appState.height * props.scale;
    if (canvas2.width !== scaledWidth) {
      canvas2.width = scaledWidth;
    }
    if (canvas2.height !== scaledHeight) {
      canvas2.height = scaledHeight;
    }
    renderStaticScene(
      {
        canvas: canvas2,
        rc: props.rc,
        scale: props.scale,
        elementsMap: props.elementsMap,
        allElementsMap: props.allElementsMap,
        visibleElements: props.visibleElements,
        appState: props.appState,
        renderConfig: props.renderConfig
      },
      isRenderThrottlingEnabled()
    );
  });
  return /* @__PURE__ */ (0, import_jsx_runtime125.jsx)("div", { className: "excalidraw__canvas-wrapper", ref: wrapperRef });
};
var getRelevantAppStateProps2 = (appState) => ({
  zoom: appState.zoom,
  scrollX: appState.scrollX,
  scrollY: appState.scrollY,
  width: appState.width,
  height: appState.height,
  viewModeEnabled: appState.viewModeEnabled,
  offsetLeft: appState.offsetLeft,
  offsetTop: appState.offsetTop,
  theme: appState.theme,
  pendingImageElementId: appState.pendingImageElementId,
  shouldCacheIgnoreZoom: appState.shouldCacheIgnoreZoom,
  viewBackgroundColor: appState.viewBackgroundColor,
  exportScale: appState.exportScale,
  selectedElementsAreBeingDragged: appState.selectedElementsAreBeingDragged,
  gridSize: appState.gridSize,
  frameRendering: appState.frameRendering,
  selectedElementIds: appState.selectedElementIds,
  frameToHighlight: appState.frameToHighlight,
  editingGroupId: appState.editingGroupId
});
var areEqual4 = (prevProps, nextProps) => {
  if (prevProps.versionNonce !== nextProps.versionNonce || prevProps.scale !== nextProps.scale || // we need to memoize on elementsMap because they may have renewed
  // even if versionNonce didn't change (e.g. we filter elements out based
  // on appState)
  prevProps.elementsMap !== nextProps.elementsMap || prevProps.visibleElements !== nextProps.visibleElements) {
    return false;
  }
  return isShallowEqual(
    // asserting AppState because we're being passed the whole AppState
    // but resolve to only the StaticCanvas-relevant props
    getRelevantAppStateProps2(prevProps.appState),
    getRelevantAppStateProps2(nextProps.appState)
  ) && isShallowEqual(prevProps.renderConfig, nextProps.renderConfig);
};
var StaticCanvas_default = import_react93.default.memo(StaticCanvas, areEqual4);

// scene/Renderer.ts
init_define_import_meta_env();
var Renderer = class {
  scene;
  constructor(scene) {
    this.scene = scene;
  }
  getRenderableElements = (() => {
    const getVisibleCanvasElements = ({
      elementsMap,
      zoom,
      offsetLeft,
      offsetTop,
      scrollX,
      scrollY,
      height,
      width
    }) => {
      const visibleElements = [];
      for (const element of elementsMap.values()) {
        if (isElementInViewport(
          element,
          width,
          height,
          {
            zoom,
            offsetLeft,
            offsetTop,
            scrollX,
            scrollY
          },
          elementsMap
        )) {
          visibleElements.push(element);
        }
      }
      return visibleElements;
    };
    const getRenderableElements = ({
      elements,
      editingElement,
      pendingImageElementId
    }) => {
      const elementsMap = toBrandedType(/* @__PURE__ */ new Map());
      for (const element of elements) {
        if (isImageElement(element)) {
          if (
            // => not placed on canvas yet (but in elements array)
            pendingImageElementId === element.id
          ) {
            continue;
          }
        }
        if (!editingElement || editingElement.type !== "text" || element.id !== editingElement.id) {
          elementsMap.set(element.id, element);
        }
      }
      return elementsMap;
    };
    return memoize(
      ({
        zoom,
        offsetLeft,
        offsetTop,
        scrollX,
        scrollY,
        height,
        width,
        editingElement,
        pendingImageElementId,
        // unused but serves we cache on it to invalidate elements if they
        // get mutated
        versionNonce: _versionNonce
      }) => {
        const elements = this.scene.getNonDeletedElements();
        const elementsMap = getRenderableElements({
          elements,
          editingElement,
          pendingImageElementId
        });
        const visibleElements = getVisibleCanvasElements({
          elementsMap,
          zoom,
          offsetLeft,
          offsetTop,
          scrollX,
          scrollY,
          height,
          width
        });
        return { elementsMap, visibleElements };
      }
    );
  })();
  // NOTE Doesn't destroy everything (scene, rc, etc.) because it may not be
  // safe to break TS contract here (for upstream cases)
  destroy() {
    cancelRender();
    this.getRenderableElements.clear();
  }
};

// components/SVGLayer.tsx
init_define_import_meta_env();
var import_react94 = __toESM(require_react(), 1);
var import_jsx_runtime126 = __toESM(require_jsx_runtime(), 1);
var SVGLayer = ({ trails }) => {
  const svgRef = (0, import_react94.useRef)(null);
  (0, import_react94.useEffect)(() => {
    if (svgRef.current) {
      for (const trail of trails) {
        trail.start(svgRef.current);
      }
    }
    return () => {
      for (const trail of trails) {
        trail.stop();
      }
    };
  }, trails);
  return /* @__PURE__ */ (0, import_jsx_runtime126.jsx)("div", { className: "SVGLayer", children: /* @__PURE__ */ (0, import_jsx_runtime126.jsx)("svg", { ref: svgRef }) });
};

// emitter.ts
init_define_import_meta_env();
var Emitter = class {
  subscribers = [];
  /**
   * Attaches subscriber
   *
   * @returns unsubscribe function
   */
  on(...handlers) {
    const _handlers = handlers.flat().filter((item) => typeof item === "function");
    this.subscribers.push(..._handlers);
    return () => this.off(_handlers);
  }
  once(...handlers) {
    const _handlers = handlers.flat().filter((item) => typeof item === "function");
    _handlers.push(() => detach());
    const detach = this.on(..._handlers);
    return detach;
  }
  off(...handlers) {
    const _handlers = handlers.flat();
    this.subscribers = this.subscribers.filter(
      (handler) => !_handlers.includes(handler)
    );
  }
  trigger(...payload) {
    for (const handler of this.subscribers) {
      handler(...payload);
    }
    return this;
  }
  clear() {
    this.subscribers = [];
  }
};

// element/ElementCanvasButtons.tsx
init_define_import_meta_env();
var import_jsx_runtime127 = __toESM(require_jsx_runtime(), 1);
var CONTAINER_PADDING = 5;
var getContainerCoords2 = (element, appState, elementsMap) => {
  const [x1, y1] = getElementAbsoluteCoords(element, elementsMap);
  const { x: viewportX, y: viewportY } = sceneCoordsToViewportCoords(
    { sceneX: x1 + element.width, sceneY: y1 },
    appState
  );
  const x3 = viewportX - appState.offsetLeft + 10;
  const y3 = viewportY - appState.offsetTop;
  return { x: x3, y: y3 };
};
var ElementCanvasButtons = ({
  children,
  element,
  elementsMap
}) => {
  const appState = useExcalidrawAppState();
  if (appState.contextMenu || appState.draggingElement || appState.resizingElement || appState.isRotating || appState.openMenu || appState.viewModeEnabled) {
    return null;
  }
  const { x: x3, y: y3 } = getContainerCoords2(element, appState, elementsMap);
  return /* @__PURE__ */ (0, import_jsx_runtime127.jsx)(
    "div",
    {
      className: "excalidraw-canvas-buttons",
      style: {
        top: `${y3}px`,
        left: `${x3}px`,
        // width: CONTAINER_WIDTH,
        padding: CONTAINER_PADDING
      },
      children
    }
  );
};

// data/magic.ts
init_define_import_meta_env();
var SYSTEM_PROMPT = `You are a skilled front-end developer who builds interactive prototypes from wireframes, and is an expert at CSS Grid and Flex design.
Your role is to transform low-fidelity wireframes into working front-end HTML code.

YOU MUST FOLLOW FOLLOWING RULES:

- Use HTML, CSS, JavaScript to build a responsive, accessible, polished prototype
- Leverage Tailwind for styling and layout (import as script <script src="https://cdn.tailwindcss.com"><\/script>)
- Inline JavaScript when needed
- Fetch dependencies from CDNs when needed (using unpkg or skypack)
- Source images from Unsplash or create applicable placeholders
- Interpret annotations as intended vs literal UI
- Fill gaps using your expertise in UX and business logic
- generate primarily for desktop UI, but make it responsive.
- Use grid and flexbox wherever applicable.
- Convert the wireframe in its entirety, don't omit elements if possible.

If the wireframes, diagrams, or text is unclear or unreadable, refer to provided text for clarification.

Your goal is a production-ready prototype that brings the wireframes to life.

Please output JUST THE HTML file containing your best attempt at implementing the provided wireframes.`;
async function diagramToHTML({
  image,
  apiKey,
  text,
  theme = "light"
}) {
  const body = {
    model: "gpt-4-vision-preview",
    // 4096 are max output tokens allowed for `gpt-4-vision-preview` currently
    max_tokens: 4096,
    temperature: 0.1,
    messages: [
      {
        role: "system",
        content: SYSTEM_PROMPT
      },
      {
        role: "user",
        content: [
          {
            type: "image_url",
            image_url: {
              url: image,
              detail: "high"
            }
          },
          {
            type: "text",
            text: `Above is the reference wireframe. Please make a new website based on these and return just the HTML file. Also, please make it for the ${theme} theme. What follows are the wireframe's text annotations (if any)...`
          },
          {
            type: "text",
            text
          }
        ]
      }
    ]
  };
  let result;
  const resp = await fetch("https://api.openai.com/v1/chat/completions", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${apiKey}`
    },
    body: JSON.stringify(body)
  });
  if (resp.ok) {
    const json = await resp.json();
    result = { ...json, ok: true };
  } else {
    const json = await resp.json();
    result = { ...json, ok: false };
  }
  return result;
}

// components/MagicButton.tsx
init_define_import_meta_env();
var import_jsx_runtime128 = __toESM(require_jsx_runtime(), 1);
var DEFAULT_SIZE4 = "small";
var ElementCanvasButton = (props) => {
  return /* @__PURE__ */ (0, import_jsx_runtime128.jsxs)(
    "label",
    {
      className: clsx_m_default(
        "ToolIcon ToolIcon__MagicButton",
        `ToolIcon_size_${DEFAULT_SIZE4}`,
        {
          "is-mobile": props.isMobile
        }
      ),
      title: `${props.title}`,
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime128.jsx)(
          "input",
          {
            className: "ToolIcon_type_checkbox",
            type: "checkbox",
            name: props.name,
            onChange: props.onChange,
            checked: props.checked,
            "aria-label": props.title
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime128.jsx)("div", { className: "ToolIcon__icon", children: props.icon })
      ]
    }
  );
};

// components/FollowMode/FollowMode.tsx
init_define_import_meta_env();
var import_jsx_runtime129 = __toESM(require_jsx_runtime(), 1);
var FollowMode = ({
  height,
  width,
  userToFollow,
  onDisconnect
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime129.jsx)("div", { className: "follow-mode", style: { width, height }, children: /* @__PURE__ */ (0, import_jsx_runtime129.jsxs)("div", { className: "follow-mode__badge", children: [
    /* @__PURE__ */ (0, import_jsx_runtime129.jsxs)("div", { className: "follow-mode__badge__label", children: [
      "Following",
      " ",
      /* @__PURE__ */ (0, import_jsx_runtime129.jsx)(
        "span",
        {
          className: "follow-mode__badge__username",
          title: userToFollow.username,
          children: userToFollow.username
        }
      )
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime129.jsx)("button", { onClick: onDisconnect, className: "follow-mode__disconnect-btn", children: CloseIcon })
  ] }) });
};
var FollowMode_default = FollowMode;

// animation-frame-handler.ts
init_define_import_meta_env();
var AnimationFrameHandler = class {
  targets = /* @__PURE__ */ new WeakMap();
  rafIds = /* @__PURE__ */ new WeakMap();
  register(key, callback) {
    this.targets.set(key, { callback, stopped: true });
  }
  start(key) {
    const target = this.targets.get(key);
    if (!target) {
      return;
    }
    if (this.rafIds.has(key)) {
      return;
    }
    this.targets.set(key, { ...target, stopped: false });
    this.scheduleFrame(key);
  }
  stop(key) {
    const target = this.targets.get(key);
    if (target && !target.stopped) {
      this.targets.set(key, { ...target, stopped: true });
    }
    this.cancelFrame(key);
  }
  constructFrame(key) {
    return (timestamp) => {
      const target = this.targets.get(key);
      if (!target) {
        return;
      }
      const shouldAbort = this.onFrame(target, timestamp);
      if (!target.stopped && !shouldAbort) {
        this.scheduleFrame(key);
      } else {
        this.cancelFrame(key);
      }
    };
  }
  scheduleFrame(key) {
    const rafId = requestAnimationFrame(this.constructFrame(key));
    this.rafIds.set(key, rafId);
  }
  cancelFrame(key) {
    if (this.rafIds.has(key)) {
      const rafId = this.rafIds.get(key);
      cancelAnimationFrame(rafId);
    }
    this.rafIds.delete(key);
  }
  onFrame(target, timestamp) {
    const shouldAbort = target.callback(timestamp);
    return shouldAbort ?? false;
  }
};

// animated-trail.ts
init_define_import_meta_env();

// ../../node_modules/@excalidraw/laser-pointer/dist/esm.js
init_define_import_meta_env();
function $parcel$export(e3, n4, v3, s4) {
  Object.defineProperty(e3, n4, { get: v3, set: s4, enumerable: true, configurable: true });
}
var $94cfa2cfccc8cc22$exports = {};
$parcel$export($94cfa2cfccc8cc22$exports, "LaserPointer", () => $94cfa2cfccc8cc22$export$6531021b3bf36eae);
function $8cd7efb5af385306$export$e16d8520af44a096([ax, ay, ar], [bx, by, br]) {
  return [
    ax + bx,
    ay + by,
    ar + br
  ];
}
function $8cd7efb5af385306$export$f93b5905241a7cca([ax, ay, ar], [bx, by, br]) {
  return [
    ax - bx,
    ay - by,
    ar - br
  ];
}
function $8cd7efb5af385306$export$1c8884ee32bdf443([x3, y3, r3], s4) {
  return [
    x3 * s4,
    y3 * s4,
    r3 * s4
  ];
}
function $8cd7efb5af385306$export$1991ecd29cc92c6b([x3, y3, r3]) {
  return [
    x3 / Math.sqrt(x3 ** 2 + y3 ** 2),
    y3 / Math.sqrt(x3 ** 2 + y3 ** 2),
    r3
  ];
}
function $8cd7efb5af385306$export$855df823ceb9b81b([x3, y3, r3], rad) {
  return [
    Math.cos(rad) * x3 - Math.sin(rad) * y3,
    Math.sin(rad) * x3 + Math.cos(rad) * y3,
    r3
  ];
}
function $8cd7efb5af385306$export$92d8e23769117a5e(a4, b4, t4) {
  return $8cd7efb5af385306$export$e16d8520af44a096(a4, $8cd7efb5af385306$export$1c8884ee32bdf443($8cd7efb5af385306$export$f93b5905241a7cca(b4, a4), t4));
}
function $8cd7efb5af385306$export$944b09d2ad10b378(p3, p1, p22) {
  return Math.atan2(p22[1] - p3[1], p22[0] - p3[0]) - Math.atan2(p1[1] - p3[1], p1[0] - p3[0]);
}
function $8cd7efb5af385306$export$3c05aaf71f141f73(a4) {
  return Math.atan2(Math.sin(a4), Math.cos(a4));
}
function $8cd7efb5af385306$export$1b9bab504faa9305([x3, y3]) {
  return Math.sqrt(x3 ** 2 + y3 ** 2);
}
function $8cd7efb5af385306$export$6c4a311cc157c764([ax, ay], [bx, by]) {
  return Math.sqrt((bx - ax) ** 2 + (by - ay) ** 2);
}
function $8cd7efb5af385306$export$ccb1b4dfbd3f36a7(ps) {
  if (ps.length < 2)
    return 0;
  let len = 0;
  for (let i4 = 1; i4 <= ps.length - 1; i4++)
    len += $8cd7efb5af385306$export$6c4a311cc157c764(ps[i4 - 1], ps[i4]);
  len += $8cd7efb5af385306$export$6c4a311cc157c764(ps[ps.length - 2], ps[ps.length - 1]);
  return len;
}
var $8cd7efb5af385306$export$7d15b64cf5a3a4c4 = (v3, min, max) => Math.max(min, Math.min(max, v3));
function $8cd7efb5af385306$export$548cc43590159af6(p3, p1, p22) {
  const sMag = $8cd7efb5af385306$export$6c4a311cc157c764(p1, p22);
  if (sMag === 0)
    return $8cd7efb5af385306$export$6c4a311cc157c764(p3, p1);
  const u3 = $8cd7efb5af385306$export$7d15b64cf5a3a4c4(((p3[0] - p1[0]) * (p22[0] - p1[0]) + (p3[1] - p1[1]) * (p22[1] - p1[1])) / sMag ** 2, 0, 1);
  const pi = [
    p1[0] + u3 * (p22[0] - p1[0]),
    p1[1] + u3 * (p22[1] - p1[1]),
    p3[2]
  ];
  return $8cd7efb5af385306$export$6c4a311cc157c764(pi, p3);
}
function $34bab0059f842ce6$export$ef693d1572e64fb8(points, epsilon) {
  if (epsilon === 0)
    return points;
  if (points.length <= 2)
    return points;
  const first = points[0];
  const last = points[points.length - 1];
  const [maxDistance, maxIndex] = points.reduce(([maxDistance2, maxIndex2], point2, index2) => {
    const distance5 = (0, $8cd7efb5af385306$export$548cc43590159af6)(point2, first, last);
    return distance5 > maxDistance2 ? [
      distance5,
      index2
    ] : [
      maxDistance2,
      maxIndex2
    ];
  }, [
    0,
    -1
  ]);
  if (maxDistance >= epsilon) {
    const maxIndexPoint = points[maxIndex];
    return [
      ...$34bab0059f842ce6$export$ef693d1572e64fb8([
        first,
        ...points.slice(1, maxIndex),
        maxIndexPoint
      ], epsilon).slice(0, -1),
      maxIndexPoint,
      ...$34bab0059f842ce6$export$ef693d1572e64fb8([
        maxIndexPoint,
        ...points.slice(maxIndex, -1),
        last
      ], epsilon).slice(1)
    ];
  } else
    return [
      first,
      last
    ];
}
var $94cfa2cfccc8cc22$export$6531021b3bf36eae = class _$94cfa2cfccc8cc22$export$6531021b3bf36eae {
  static {
    this.defaults = {
      size: 2,
      streamline: 0.45,
      simplify: 0.1,
      simplifyPhase: "output",
      keepHead: false,
      sizeMapping: () => 1
    };
  }
  static {
    this.constants = {
      cornerDetectionMaxAngle: 75,
      cornerDetectionVariance: (s4) => s4 > 35 ? 0.5 : 1,
      maxTailLength: 50
    };
  }
  constructor(options) {
    this.originalPoints = [];
    this.stablePoints = [];
    this.tailPoints = [];
    this.isFresh = true;
    this.options = Object.assign({}, _$94cfa2cfccc8cc22$export$6531021b3bf36eae.defaults, options);
  }
  get lastPoint() {
    return this.tailPoints[this.tailPoints.length - 1] ?? this.stablePoints[this.stablePoints.length - 1];
  }
  addPoint(point2) {
    const lastPoint = this.originalPoints[this.originalPoints.length - 1];
    if (lastPoint && lastPoint[0] === point2[0] && lastPoint[1] === point2[1])
      return;
    this.originalPoints.push(point2);
    if (this.isFresh) {
      this.isFresh = false;
      this.stablePoints.push(point2);
      return;
    }
    if (this.options.streamline > 0)
      point2 = $8cd7efb5af385306$export$92d8e23769117a5e(this.lastPoint, point2, 1 - this.options.streamline);
    this.tailPoints.push(point2);
    if ($8cd7efb5af385306$export$ccb1b4dfbd3f36a7(this.tailPoints) > _$94cfa2cfccc8cc22$export$6531021b3bf36eae.constants.maxTailLength)
      this.stabilizeTail();
  }
  close() {
    this.stabilizeTail();
  }
  stabilizeTail() {
    if (this.options.simplify > 0 && this.options.simplifyPhase == "tail")
      throw new Error("Not implemented yet");
    else {
      this.stablePoints.push(...this.tailPoints);
      this.tailPoints = [];
    }
  }
  getSize(sizeOverride, pressure, index2, totalLength, runningLength) {
    return (sizeOverride ?? this.options.size) * this.options.sizeMapping({
      pressure,
      runningLength,
      currentIndex: index2,
      totalLength
    });
  }
  getStrokeOutline(sizeOverride) {
    if (this.isFresh)
      return [];
    let points = [
      ...this.stablePoints,
      ...this.tailPoints
    ];
    if (this.options.simplify > 0 && this.options.simplifyPhase === "input")
      points = (0, $34bab0059f842ce6$export$ef693d1572e64fb8)(points, this.options.simplify);
    const len = points.length;
    if (len === 0)
      return [];
    if (len === 1) {
      const c3 = points[0];
      const size = this.getSize(sizeOverride, c3[2], 0, len, 0);
      if (size < 0.5)
        return [];
      const ps = [];
      for (let theta = 0; theta <= Math.PI * 2; theta += Math.PI / 16)
        ps.push($8cd7efb5af385306$export$e16d8520af44a096(c3, $8cd7efb5af385306$export$1c8884ee32bdf443($8cd7efb5af385306$export$855df823ceb9b81b([
          1,
          0,
          0
        ], theta), size)));
      ps.push($8cd7efb5af385306$export$e16d8520af44a096(c3, $8cd7efb5af385306$export$1c8884ee32bdf443([
        1,
        0,
        0
      ], this.getSize(sizeOverride, c3[2], 0, len, 0))));
      return ps;
    }
    if (len === 2) {
      const c3 = points[0];
      const n4 = points[1];
      const cSize = this.getSize(sizeOverride, c3[2], 0, len, 0);
      const nSize = this.getSize(sizeOverride, n4[2], 0, len, 0);
      if (cSize < 0.5 || nSize < 0.5)
        return [];
      const ps = [];
      const pAngle = $8cd7efb5af385306$export$944b09d2ad10b378(c3, [
        c3[0],
        c3[1] - 100,
        c3[2]
      ], n4);
      for (let theta = pAngle; theta <= Math.PI + pAngle; theta += Math.PI / 16)
        ps.push($8cd7efb5af385306$export$e16d8520af44a096(c3, $8cd7efb5af385306$export$1c8884ee32bdf443($8cd7efb5af385306$export$855df823ceb9b81b([
          1,
          0,
          0
        ], theta), cSize)));
      for (let theta = Math.PI + pAngle; theta <= Math.PI * 2 + pAngle; theta += Math.PI / 16)
        ps.push($8cd7efb5af385306$export$e16d8520af44a096(n4, $8cd7efb5af385306$export$1c8884ee32bdf443($8cd7efb5af385306$export$855df823ceb9b81b([
          1,
          0,
          0
        ], theta), nSize)));
      ps.push(ps[0]);
      return ps;
    }
    const forwardPoints = [];
    const backwardPoints = [];
    let speed = 0;
    let prevSpeed = 0;
    let visibleStartIndex = 0;
    let runningLength = 0;
    for (let i4 = 1; i4 < len - 1; i4++) {
      const p3 = points[i4 - 1], c3 = points[i4], n4 = points[i4 + 1];
      let pressure = c3[2];
      const d3 = $8cd7efb5af385306$export$6c4a311cc157c764(p3, c3);
      runningLength += d3;
      speed = prevSpeed + (d3 - prevSpeed) * 0.2;
      const cSize = this.getSize(sizeOverride, pressure, i4, len, runningLength);
      if (cSize === 0) {
        visibleStartIndex = i4 + 1;
        continue;
      }
      const dirPC = $8cd7efb5af385306$export$1991ecd29cc92c6b($8cd7efb5af385306$export$f93b5905241a7cca(p3, c3));
      const dirNC = $8cd7efb5af385306$export$1991ecd29cc92c6b($8cd7efb5af385306$export$f93b5905241a7cca(n4, c3));
      const p1dirPC = $8cd7efb5af385306$export$855df823ceb9b81b(dirPC, Math.PI / 2);
      const p2dirPC = $8cd7efb5af385306$export$855df823ceb9b81b(dirPC, -Math.PI / 2);
      const p1dirNC = $8cd7efb5af385306$export$855df823ceb9b81b(dirNC, Math.PI / 2);
      const p2dirNC = $8cd7efb5af385306$export$855df823ceb9b81b(dirNC, -Math.PI / 2);
      const p1PC = $8cd7efb5af385306$export$e16d8520af44a096(c3, $8cd7efb5af385306$export$1c8884ee32bdf443(p1dirPC, cSize));
      const p2PC = $8cd7efb5af385306$export$e16d8520af44a096(c3, $8cd7efb5af385306$export$1c8884ee32bdf443(p2dirPC, cSize));
      const p1NC = $8cd7efb5af385306$export$e16d8520af44a096(c3, $8cd7efb5af385306$export$1c8884ee32bdf443(p1dirNC, cSize));
      const p2NC = $8cd7efb5af385306$export$e16d8520af44a096(c3, $8cd7efb5af385306$export$1c8884ee32bdf443(p2dirNC, cSize));
      const ftdir = $8cd7efb5af385306$export$e16d8520af44a096(p1dirPC, p2dirNC);
      const btdir = $8cd7efb5af385306$export$e16d8520af44a096(p2dirPC, p1dirNC);
      const paPC = $8cd7efb5af385306$export$e16d8520af44a096(c3, $8cd7efb5af385306$export$1c8884ee32bdf443($8cd7efb5af385306$export$1b9bab504faa9305(ftdir) === 0 ? dirPC : $8cd7efb5af385306$export$1991ecd29cc92c6b(ftdir), cSize));
      const paNC = $8cd7efb5af385306$export$e16d8520af44a096(c3, $8cd7efb5af385306$export$1c8884ee32bdf443($8cd7efb5af385306$export$1b9bab504faa9305(btdir) === 0 ? dirNC : $8cd7efb5af385306$export$1991ecd29cc92c6b(btdir), cSize));
      const cAngle = $8cd7efb5af385306$export$3c05aaf71f141f73($8cd7efb5af385306$export$944b09d2ad10b378(c3, p3, n4));
      const D_ANGLE = _$94cfa2cfccc8cc22$export$6531021b3bf36eae.constants.cornerDetectionMaxAngle / 180 * Math.PI * _$94cfa2cfccc8cc22$export$6531021b3bf36eae.constants.cornerDetectionVariance(speed);
      if (Math.abs(cAngle) < D_ANGLE) {
        const tAngle = Math.abs($8cd7efb5af385306$export$3c05aaf71f141f73(Math.PI - cAngle));
        if (tAngle === 0)
          continue;
        if (cAngle < 0) {
          backwardPoints.push(p2PC, paNC);
          for (let theta = 0; theta <= tAngle; theta += tAngle / 4)
            forwardPoints.push($8cd7efb5af385306$export$e16d8520af44a096(c3, $8cd7efb5af385306$export$855df823ceb9b81b($8cd7efb5af385306$export$1c8884ee32bdf443(p1dirPC, cSize), theta)));
          for (let theta = tAngle; theta >= 0; theta -= tAngle / 4)
            backwardPoints.push($8cd7efb5af385306$export$e16d8520af44a096(c3, $8cd7efb5af385306$export$855df823ceb9b81b($8cd7efb5af385306$export$1c8884ee32bdf443(p1dirPC, cSize), theta)));
          backwardPoints.push(paNC, p1NC);
        } else {
          forwardPoints.push(p1PC, paPC);
          for (let theta = 0; theta <= tAngle; theta += tAngle / 4)
            backwardPoints.push($8cd7efb5af385306$export$e16d8520af44a096(c3, $8cd7efb5af385306$export$855df823ceb9b81b($8cd7efb5af385306$export$1c8884ee32bdf443(p1dirPC, -cSize), -theta)));
          for (let theta = tAngle; theta >= 0; theta -= tAngle / 4)
            forwardPoints.push($8cd7efb5af385306$export$e16d8520af44a096(c3, $8cd7efb5af385306$export$855df823ceb9b81b($8cd7efb5af385306$export$1c8884ee32bdf443(p1dirPC, -cSize), -theta)));
          forwardPoints.push(paPC, p2NC);
        }
      } else {
        forwardPoints.push(paPC);
        backwardPoints.push(paNC);
      }
      prevSpeed = speed;
    }
    if (visibleStartIndex >= len - 2) {
      if (this.options.keepHead) {
        const c3 = points[len - 1];
        const ps = [];
        for (let theta = 0; theta <= Math.PI * 2; theta += Math.PI / 16)
          ps.push($8cd7efb5af385306$export$e16d8520af44a096(c3, $8cd7efb5af385306$export$1c8884ee32bdf443($8cd7efb5af385306$export$855df823ceb9b81b([
            1,
            0,
            0
          ], theta), this.options.size)));
        ps.push($8cd7efb5af385306$export$e16d8520af44a096(c3, $8cd7efb5af385306$export$1c8884ee32bdf443([
          1,
          0,
          0
        ], this.options.size)));
        return ps;
      } else
        return [];
    }
    const first = points[visibleStartIndex];
    const second = points[visibleStartIndex + 1];
    const penultimate = points[len - 2];
    const ultimate = points[len - 1];
    const dirFS = $8cd7efb5af385306$export$1991ecd29cc92c6b($8cd7efb5af385306$export$f93b5905241a7cca(second, first));
    const dirPU = $8cd7efb5af385306$export$1991ecd29cc92c6b($8cd7efb5af385306$export$f93b5905241a7cca(penultimate, ultimate));
    const ppdirFS = $8cd7efb5af385306$export$855df823ceb9b81b(dirFS, -Math.PI / 2);
    const ppdirPU = $8cd7efb5af385306$export$855df823ceb9b81b(dirPU, Math.PI / 2);
    const startCapSize = this.getSize(sizeOverride, first[2], 0, len, 0);
    const startCap = [];
    const endCapSize = this.options.keepHead ? this.options.size : this.getSize(sizeOverride, penultimate[2], len - 2, len, runningLength);
    const endCap = [];
    if (startCapSize > 1) {
      for (let theta = 0; theta <= Math.PI; theta += Math.PI / 16)
        startCap.unshift($8cd7efb5af385306$export$e16d8520af44a096(first, $8cd7efb5af385306$export$855df823ceb9b81b($8cd7efb5af385306$export$1c8884ee32bdf443(ppdirFS, startCapSize), -theta)));
      startCap.unshift($8cd7efb5af385306$export$e16d8520af44a096(first, $8cd7efb5af385306$export$1c8884ee32bdf443(ppdirFS, -startCapSize)));
    } else
      startCap.push(first);
    for (let theta = 0; theta <= Math.PI * 3; theta += Math.PI / 16)
      endCap.push($8cd7efb5af385306$export$e16d8520af44a096(ultimate, $8cd7efb5af385306$export$855df823ceb9b81b($8cd7efb5af385306$export$1c8884ee32bdf443(ppdirPU, -endCapSize), -theta)));
    const strokeOutline = [
      ...startCap,
      ...forwardPoints,
      ...endCap.reverse(),
      ...backwardPoints.reverse()
    ];
    if (startCap.length > 0)
      strokeOutline.push(startCap[0]);
    if (this.options.simplify > 0 && this.options.simplifyPhase === "output")
      return (0, $34bab0059f842ce6$export$ef693d1572e64fb8)(strokeOutline, this.options.simplify);
    return strokeOutline;
  }
};

// animated-trail.ts
var AnimatedTrail = class {
  constructor(animationFrameHandler, app, options) {
    this.animationFrameHandler = animationFrameHandler;
    this.app = app;
    this.options = options;
    this.animationFrameHandler.register(this, this.onFrame.bind(this));
    this.trailElement = document.createElementNS(SVG_NS, "path");
  }
  currentTrail;
  pastTrails = [];
  container;
  trailElement;
  get hasCurrentTrail() {
    return !!this.currentTrail;
  }
  hasLastPoint(x3, y3) {
    if (this.currentTrail) {
      const len = this.currentTrail.originalPoints.length;
      return this.currentTrail.originalPoints[len - 1][0] === x3 && this.currentTrail.originalPoints[len - 1][1] === y3;
    }
    return false;
  }
  start(container) {
    if (container) {
      this.container = container;
    }
    if (this.trailElement.parentNode !== this.container && this.container) {
      this.container.appendChild(this.trailElement);
    }
    this.animationFrameHandler.start(this);
  }
  stop() {
    this.animationFrameHandler.stop(this);
    if (this.trailElement.parentNode === this.container) {
      this.container?.removeChild(this.trailElement);
    }
  }
  startPath(x3, y3) {
    this.currentTrail = new $94cfa2cfccc8cc22$export$6531021b3bf36eae(this.options);
    this.currentTrail.addPoint([x3, y3, performance.now()]);
    this.update();
  }
  addPointToPath(x3, y3) {
    if (this.currentTrail) {
      this.currentTrail.addPoint([x3, y3, performance.now()]);
      this.update();
    }
  }
  endPath() {
    if (this.currentTrail) {
      this.currentTrail.close();
      this.currentTrail.options.keepHead = false;
      this.pastTrails.push(this.currentTrail);
      this.currentTrail = void 0;
      this.update();
    }
  }
  update() {
    this.start();
  }
  onFrame() {
    const paths = [];
    for (const trail of this.pastTrails) {
      paths.push(this.drawTrail(trail, this.app.state));
    }
    if (this.currentTrail) {
      const currentPath = this.drawTrail(this.currentTrail, this.app.state);
      paths.push(currentPath);
    }
    this.pastTrails = this.pastTrails.filter((trail) => {
      return trail.getStrokeOutline().length !== 0;
    });
    if (paths.length === 0) {
      this.stop();
    }
    const svgPaths = paths.join(" ").trim();
    this.trailElement.setAttribute("d", svgPaths);
    this.trailElement.setAttribute(
      "fill",
      (this.options.fill ?? (() => "black"))(this)
    );
  }
  drawTrail(trail, state) {
    const stroke = trail.getStrokeOutline(trail.options.size / state.zoom.value).map(([x3, y3]) => {
      const result = sceneCoordsToViewportCoords(
        { sceneX: x3, sceneY: y3 },
        state
      );
      return [result.x, result.y];
    });
    return getSvgPathFromStroke(stroke, true);
  }
};

// laser-trails.ts
init_define_import_meta_env();
var LaserTrails = class {
  constructor(animationFrameHandler, app) {
    this.animationFrameHandler = animationFrameHandler;
    this.app = app;
    this.animationFrameHandler.register(this, this.onFrame.bind(this));
    this.localTrail = new AnimatedTrail(animationFrameHandler, app, {
      ...this.getTrailOptions(),
      fill: () => "red"
    });
  }
  localTrail;
  collabTrails = /* @__PURE__ */ new Map();
  container;
  getTrailOptions() {
    return {
      simplify: 0,
      streamline: 0.4,
      sizeMapping: (c3) => {
        const DECAY_TIME = 1e3;
        const DECAY_LENGTH = 50;
        const t4 = Math.max(
          0,
          1 - (performance.now() - c3.pressure) / DECAY_TIME
        );
        const l4 = (DECAY_LENGTH - Math.min(DECAY_LENGTH, c3.totalLength - c3.currentIndex)) / DECAY_LENGTH;
        return Math.min(easeOut(l4), easeOut(t4));
      }
    };
  }
  startPath(x3, y3) {
    this.localTrail.startPath(x3, y3);
  }
  addPointToPath(x3, y3) {
    this.localTrail.addPointToPath(x3, y3);
  }
  endPath() {
    this.localTrail.endPath();
  }
  start(container) {
    this.container = container;
    this.animationFrameHandler.start(this);
    this.localTrail.start(container);
  }
  stop() {
    this.animationFrameHandler.stop(this);
    this.localTrail.stop();
  }
  onFrame() {
    this.updateCollabTrails();
  }
  updateCollabTrails() {
    if (!this.container || this.app.state.collaborators.size === 0) {
      return;
    }
    for (const [key, collabolator] of this.app.state.collaborators.entries()) {
      let trail;
      if (!this.collabTrails.has(key)) {
        trail = new AnimatedTrail(this.animationFrameHandler, this.app, {
          ...this.getTrailOptions(),
          fill: () => getClientColor(key)
        });
        trail.start(this.container);
        this.collabTrails.set(key, trail);
      } else {
        trail = this.collabTrails.get(key);
      }
      if (collabolator.pointer && collabolator.pointer.tool === "laser") {
        if (collabolator.button === "down" && !trail.hasCurrentTrail) {
          trail.startPath(collabolator.pointer.x, collabolator.pointer.y);
        }
        if (collabolator.button === "down" && trail.hasCurrentTrail && !trail.hasLastPoint(collabolator.pointer.x, collabolator.pointer.y)) {
          trail.addPointToPath(collabolator.pointer.x, collabolator.pointer.y);
        }
        if (collabolator.button === "up" && trail.hasCurrentTrail) {
          trail.addPointToPath(collabolator.pointer.x, collabolator.pointer.y);
          trail.endPath();
        }
      }
    }
    for (const key of this.collabTrails.keys()) {
      if (!this.app.state.collaborators.has(key)) {
        const trail = this.collabTrails.get(key);
        trail.stop();
        this.collabTrails.delete(key);
      }
    }
  }
};

// element/textWysiwyg.tsx
init_define_import_meta_env();
var getTransform = (width, height, angle, appState, maxWidth, maxHeight) => {
  const { zoom } = appState;
  const degree = 180 * angle / Math.PI;
  let translateX = width * (zoom.value - 1) / 2;
  let translateY = height * (zoom.value - 1) / 2;
  if (width > maxWidth && zoom.value !== 1) {
    translateX = maxWidth * (zoom.value - 1) / 2;
  }
  if (height > maxHeight && zoom.value !== 1) {
    translateY = maxHeight * (zoom.value - 1) / 2;
  }
  return `translate(${translateX}px, ${translateY}px) scale(${zoom.value}) rotate(${degree}deg)`;
};
var textWysiwyg = ({
  id,
  onChange,
  onSubmit,
  getViewportCoords,
  element,
  canvas: canvas2,
  excalidrawContainer,
  app
}) => {
  const textPropertiesUpdated = (updatedTextElement, editable2) => {
    if (!editable2.style.fontFamily || !editable2.style.fontSize) {
      return false;
    }
    const currentFont = editable2.style.fontFamily.replace(/"/g, "");
    if (getFontFamilyString({ fontFamily: updatedTextElement.fontFamily }) !== currentFont) {
      return true;
    }
    if (`${updatedTextElement.fontSize}px` !== editable2.style.fontSize) {
      return true;
    }
    return false;
  };
  const updateWysiwygStyle = () => {
    const appState = app.state;
    const updatedTextElement = Scene_default.getScene(element)?.getElement(id);
    if (!updatedTextElement) {
      return;
    }
    const { textAlign, verticalAlign } = updatedTextElement;
    const elementsMap = app.scene.getNonDeletedElementsMap();
    if (updatedTextElement && isTextElement(updatedTextElement)) {
      let coordX = updatedTextElement.x;
      let coordY = updatedTextElement.y;
      const container = getContainerElement(
        updatedTextElement,
        app.scene.getNonDeletedElementsMap()
      );
      let maxWidth = updatedTextElement.width;
      let maxHeight = updatedTextElement.height;
      let textElementWidth = updatedTextElement.width;
      const textElementHeight = updatedTextElement.height;
      if (container && updatedTextElement.containerId) {
        if (isArrowElement(container)) {
          const boundTextCoords = LinearElementEditor.getBoundTextElementPosition(
            container,
            updatedTextElement,
            elementsMap
          );
          coordX = boundTextCoords.x;
          coordY = boundTextCoords.y;
        }
        const propertiesUpdated = textPropertiesUpdated(
          updatedTextElement,
          editable
        );
        let originalContainerData;
        if (propertiesUpdated) {
          originalContainerData = updateOriginalContainerCache(
            container.id,
            container.height
          );
        } else {
          originalContainerData = originalContainerCache[container.id];
          if (!originalContainerData) {
            originalContainerData = updateOriginalContainerCache(
              container.id,
              container.height
            );
          }
        }
        maxWidth = getBoundTextMaxWidth(container, updatedTextElement);
        maxHeight = getBoundTextMaxHeight(
          container,
          updatedTextElement
        );
        if (!isArrowElement(container) && textElementHeight > maxHeight) {
          const targetContainerHeight = computeContainerDimensionForBoundText(
            textElementHeight,
            container.type
          );
          mutateElement(container, { height: targetContainerHeight });
          return;
        } else if (
          // autoshrink container height until original container height
          // is reached when text is removed
          !isArrowElement(container) && container.height > originalContainerData.height && textElementHeight < maxHeight
        ) {
          const targetContainerHeight = computeContainerDimensionForBoundText(
            textElementHeight,
            container.type
          );
          mutateElement(container, { height: targetContainerHeight });
        } else {
          const { y: y3 } = computeBoundTextPosition(
            container,
            updatedTextElement,
            elementsMap
          );
          coordY = y3;
        }
      }
      const [viewportX, viewportY] = getViewportCoords(coordX, coordY);
      const initialSelectionStart = editable.selectionStart;
      const initialSelectionEnd = editable.selectionEnd;
      const initialLength = editable.value.length;
      if (initialSelectionStart === initialSelectionEnd && initialSelectionEnd !== initialLength) {
        const diff = initialLength - initialSelectionEnd;
        editable.selectionStart = editable.value.length - diff;
        editable.selectionEnd = editable.value.length - diff;
      }
      if (!container) {
        maxWidth = (appState.width - 8 - viewportX) / appState.zoom.value;
        textElementWidth = Math.min(textElementWidth, maxWidth);
      } else {
        textElementWidth += 0.5;
      }
      let lineHeight = updatedTextElement.lineHeight;
      if (isSafari) {
        lineHeight = detectLineHeight({
          ...updatedTextElement,
          fontSize: Math.round(updatedTextElement.fontSize)
        });
      }
      const editorMaxHeight = (appState.height - viewportY) / appState.zoom.value;
      Object.assign(editable.style, {
        font: getFontString(updatedTextElement),
        // must be defined *after* font \_()_/
        lineHeight,
        width: `${textElementWidth}px`,
        height: `${textElementHeight}px`,
        left: `${viewportX}px`,
        top: `${viewportY}px`,
        transform: getTransform(
          textElementWidth,
          textElementHeight,
          getTextElementAngle(updatedTextElement, container),
          appState,
          maxWidth,
          editorMaxHeight
        ),
        textAlign,
        verticalAlign,
        color: updatedTextElement.strokeColor,
        opacity: updatedTextElement.opacity / 100,
        filter: "var(--theme-filter)",
        maxHeight: `${editorMaxHeight}px`
      });
      editable.scrollTop = 0;
      if (isTestEnv()) {
        editable.style.fontFamily = getFontFamilyString(updatedTextElement);
      }
      mutateElement(updatedTextElement, { x: coordX, y: coordY });
    }
  };
  const editable = document.createElement("textarea");
  editable.dir = "auto";
  editable.tabIndex = 0;
  editable.dataset.type = "wysiwyg";
  editable.wrap = "off";
  editable.classList.add("excalidraw-wysiwyg");
  let whiteSpace = "pre";
  let wordBreak = "normal";
  if (isBoundToContainer(element)) {
    whiteSpace = "pre-wrap";
    wordBreak = "break-word";
  }
  Object.assign(editable.style, {
    position: "absolute",
    display: "inline-block",
    minHeight: "1em",
    backfaceVisibility: "hidden",
    margin: 0,
    padding: 0,
    border: 0,
    outline: 0,
    resize: "none",
    background: "transparent",
    overflow: "hidden",
    // must be specified because in dark mode canvas creates a stacking context
    zIndex: "var(--zIndex-wysiwyg)",
    wordBreak,
    // prevent line wrapping (`whitespace: nowrap` doesn't work on FF)
    whiteSpace,
    overflowWrap: "break-word",
    boxSizing: "content-box"
  });
  editable.value = element.originalText;
  updateWysiwygStyle();
  if (onChange) {
    editable.onpaste = async (event) => {
      const clipboardData = await parseClipboard(event, true);
      if (!clipboardData.text) {
        return;
      }
      const data = normalizeText(clipboardData.text);
      if (!data) {
        return;
      }
      const container = getContainerElement(
        element,
        app.scene.getNonDeletedElementsMap()
      );
      const font = getFontString({
        fontSize: app.state.currentItemFontSize,
        fontFamily: app.state.currentItemFontFamily
      });
      if (container) {
        const boundTextElement = getBoundTextElement(
          container,
          app.scene.getNonDeletedElementsMap()
        );
        const wrappedText = wrapText(
          `${editable.value}${data}`,
          font,
          getBoundTextMaxWidth(container, boundTextElement)
        );
        const width = getTextWidth(wrappedText, font);
        editable.style.width = `${width}px`;
      }
    };
    editable.oninput = () => {
      onChange(normalizeText(editable.value));
    };
  }
  editable.onkeydown = (event) => {
    if (!event.shiftKey && actionZoomIn.keyTest(event)) {
      event.preventDefault();
      app.actionManager.executeAction(actionZoomIn);
      updateWysiwygStyle();
    } else if (!event.shiftKey && actionZoomOut.keyTest(event)) {
      event.preventDefault();
      app.actionManager.executeAction(actionZoomOut);
      updateWysiwygStyle();
    } else if (actionDecreaseFontSize.keyTest(event)) {
      app.actionManager.executeAction(actionDecreaseFontSize);
    } else if (actionIncreaseFontSize.keyTest(event)) {
      app.actionManager.executeAction(actionIncreaseFontSize);
    } else if (event.key === KEYS.ESCAPE) {
      event.preventDefault();
      submittedViaKeyboard = true;
      handleSubmit();
    } else if (event.key === KEYS.ENTER && event[KEYS.CTRL_OR_CMD]) {
      event.preventDefault();
      if (event.isComposing || event.keyCode === 229) {
        return;
      }
      submittedViaKeyboard = true;
      handleSubmit();
    } else if (event.key === KEYS.TAB || event[KEYS.CTRL_OR_CMD] && (event.code === CODES.BRACKET_LEFT || event.code === CODES.BRACKET_RIGHT)) {
      event.preventDefault();
      if (event.isComposing) {
        return;
      } else if (event.shiftKey || event.code === CODES.BRACKET_LEFT) {
        outdent();
      } else {
        indent();
      }
      editable.dispatchEvent(new Event("input"));
    }
  };
  const TAB_SIZE = 4;
  const TAB = " ".repeat(TAB_SIZE);
  const RE_LEADING_TAB = new RegExp(`^ {1,${TAB_SIZE}}`);
  const indent = () => {
    const { selectionStart, selectionEnd } = editable;
    const linesStartIndices = getSelectedLinesStartIndices();
    let value = editable.value;
    linesStartIndices.forEach((startIndex) => {
      const startValue = value.slice(0, startIndex);
      const endValue = value.slice(startIndex);
      value = `${startValue}${TAB}${endValue}`;
    });
    editable.value = value;
    editable.selectionStart = selectionStart + TAB_SIZE;
    editable.selectionEnd = selectionEnd + TAB_SIZE * linesStartIndices.length;
  };
  const outdent = () => {
    const { selectionStart, selectionEnd } = editable;
    const linesStartIndices = getSelectedLinesStartIndices();
    const removedTabs = [];
    let value = editable.value;
    linesStartIndices.forEach((startIndex) => {
      const tabMatch = value.slice(startIndex, startIndex + TAB_SIZE).match(RE_LEADING_TAB);
      if (tabMatch) {
        const startValue = value.slice(0, startIndex);
        const endValue = value.slice(startIndex + tabMatch[0].length);
        value = `${startValue}${endValue}`;
        removedTabs.push(startIndex);
      }
    });
    editable.value = value;
    if (removedTabs.length) {
      if (selectionStart > removedTabs[removedTabs.length - 1]) {
        editable.selectionStart = Math.max(
          selectionStart - TAB_SIZE,
          removedTabs[removedTabs.length - 1]
        );
      } else {
        editable.selectionStart = selectionStart;
      }
      editable.selectionEnd = Math.max(
        editable.selectionStart,
        selectionEnd - TAB_SIZE * removedTabs.length
      );
    }
  };
  const getSelectedLinesStartIndices = () => {
    let { selectionStart, selectionEnd, value } = editable;
    const startOffset = value.slice(0, selectionStart).match(/[^\n]*$/)[0].length;
    selectionStart = selectionStart - startOffset;
    const selected = value.slice(selectionStart, selectionEnd);
    return selected.split("\n").reduce(
      (startIndices, line2, idx, lines) => startIndices.concat(
        idx ? (
          // curr line index is prev line's start + prev line's length + \n
          startIndices[idx - 1] + lines[idx - 1].length + 1
        ) : (
          // first selected line
          selectionStart
        )
      ),
      []
    ).reverse();
  };
  const stopEvent = (event) => {
    event.preventDefault();
    event.stopPropagation();
  };
  let submittedViaKeyboard = false;
  const handleSubmit = () => {
    cleanup();
    const updateElement = Scene_default.getScene(element)?.getElement(
      element.id
    );
    if (!updateElement) {
      return;
    }
    let text = editable.value;
    const container = getContainerElement(
      updateElement,
      app.scene.getNonDeletedElementsMap()
    );
    if (container) {
      text = updateElement.text;
      if (editable.value.trim()) {
        const boundTextElementId = getBoundTextElementId(container);
        if (!boundTextElementId || boundTextElementId !== element.id) {
          mutateElement(container, {
            boundElements: (container.boundElements || []).concat({
              type: "text",
              id: element.id
            })
          });
        } else if (isArrowElement(container)) {
          bumpVersion(container);
        }
      } else {
        mutateElement(container, {
          boundElements: container.boundElements?.filter(
            (ele) => !isTextElement(
              ele
            )
          )
        });
      }
      redrawTextBoundingBox(
        updateElement,
        container,
        app.scene.getNonDeletedElementsMap()
      );
    }
    onSubmit({
      text,
      viaKeyboard: submittedViaKeyboard,
      originalText: editable.value
    });
  };
  const cleanup = () => {
    if (isDestroyed) {
      return;
    }
    isDestroyed = true;
    editable.onblur = null;
    editable.oninput = null;
    editable.onkeydown = null;
    if (observer) {
      observer.disconnect();
    }
    window.removeEventListener("resize", updateWysiwygStyle);
    window.removeEventListener("wheel", stopEvent, true);
    window.removeEventListener("pointerdown", onPointerDown);
    window.removeEventListener("pointerup", bindBlurEvent);
    window.removeEventListener("blur", handleSubmit);
    window.removeEventListener("beforeunload", handleSubmit);
    unbindUpdate();
    editable.remove();
  };
  const bindBlurEvent = (event) => {
    window.removeEventListener("pointerup", bindBlurEvent);
    const target = event?.target;
    const isTargetPickerTrigger = target instanceof HTMLElement && target.classList.contains("active-color");
    setTimeout(() => {
      editable.onblur = handleSubmit;
      if (isTargetPickerTrigger) {
        const callback = (mutationList, observer3) => {
          const radixIsRemoved = mutationList.find(
            (mutation) => mutation.removedNodes.length > 0 && mutation.removedNodes[0].dataset?.radixPopperContentWrapper !== void 0
          );
          if (radixIsRemoved) {
            setTimeout(() => {
              editable.focus();
            });
            observer3.disconnect();
          }
        };
        const observer2 = new MutationObserver(callback);
        observer2.observe(document.querySelector(".excalidraw-container"), {
          childList: true
        });
      }
      if (!isTargetPickerTrigger) {
        editable.focus();
      }
    });
  };
  const onPointerDown = (event) => {
    const isTargetPickerTrigger = event.target instanceof HTMLElement && event.target.classList.contains("active-color");
    if ((event.target instanceof HTMLElement || event.target instanceof SVGElement) && event.target.closest(`.${CLASSES.SHAPE_ACTIONS_MENU}`) && !isWritableElement(event.target) || isTargetPickerTrigger) {
      editable.onblur = null;
      window.addEventListener("pointerup", bindBlurEvent);
      window.addEventListener("blur", handleSubmit);
    }
  };
  const unbindUpdate = Scene_default.getScene(element).addCallback(() => {
    updateWysiwygStyle();
    const isColorPickerActive = !!document.activeElement?.closest(
      ".color-picker-content"
    );
    if (!isColorPickerActive) {
      editable.focus();
    }
  });
  let isDestroyed = false;
  editable.select();
  bindBlurEvent();
  let observer = null;
  if (canvas2 && "ResizeObserver" in window) {
    observer = new window.ResizeObserver(() => {
      updateWysiwygStyle();
    });
    observer.observe(canvas2);
  } else {
    window.addEventListener("resize", updateWysiwygStyle);
  }
  window.addEventListener("pointerdown", onPointerDown);
  window.addEventListener("wheel", stopEvent, {
    passive: false,
    capture: true
  });
  window.addEventListener("beforeunload", handleSubmit);
  excalidrawContainer?.querySelector(".excalidraw-textEditorContainer").appendChild(editable);
};

// components/App.tsx
var import_jsx_runtime130 = __toESM(require_jsx_runtime(), 1);
var AppContext = import_react95.default.createContext(null);
var AppPropsContext = import_react95.default.createContext(null);
var deviceContextInitialValue = {
  viewport: {
    isMobile: false,
    isLandscape: false
  },
  editor: {
    isMobile: false,
    canFitSidebar: false
  },
  isTouchScreen: false
};
var DeviceContext = import_react95.default.createContext(deviceContextInitialValue);
DeviceContext.displayName = "DeviceContext";
var ExcalidrawContainerContext = import_react95.default.createContext({ container: null, id: null });
ExcalidrawContainerContext.displayName = "ExcalidrawContainerContext";
var ExcalidrawElementsContext = import_react95.default.createContext([]);
ExcalidrawElementsContext.displayName = "ExcalidrawElementsContext";
var ExcalidrawAppStateContext = import_react95.default.createContext({
  ...getDefaultAppState(),
  width: 0,
  height: 0,
  offsetLeft: 0,
  offsetTop: 0
});
ExcalidrawAppStateContext.displayName = "ExcalidrawAppStateContext";
var ExcalidrawSetAppStateContext = import_react95.default.createContext(() => {
  console.warn("Uninitialized ExcalidrawSetAppStateContext context!");
});
ExcalidrawSetAppStateContext.displayName = "ExcalidrawSetAppStateContext";
var ExcalidrawActionManagerContext = import_react95.default.createContext(
  null
);
ExcalidrawActionManagerContext.displayName = "ExcalidrawActionManagerContext";
var useApp = () => (0, import_react95.useContext)(AppContext);
var useAppProps = () => (0, import_react95.useContext)(AppPropsContext);
var useDevice = () => (0, import_react95.useContext)(DeviceContext);
var useExcalidrawContainer = () => (0, import_react95.useContext)(ExcalidrawContainerContext);
var useExcalidrawElements = () => (0, import_react95.useContext)(ExcalidrawElementsContext);
var useExcalidrawAppState = () => (0, import_react95.useContext)(ExcalidrawAppStateContext);
var useExcalidrawSetAppState = () => (0, import_react95.useContext)(ExcalidrawSetAppStateContext);
var useExcalidrawActionManager = () => (0, import_react95.useContext)(ExcalidrawActionManagerContext);
var supportsResizeObserver = typeof window !== "undefined" && "ResizeObserver" in window;
var didTapTwice = false;
var tappedTwiceTimer = 0;
var isHoldingSpace = false;
var isPanning = false;
var isDraggingScrollBar = false;
var currentScrollBars = { horizontal: null, vertical: null };
var touchTimeout = 0;
var invalidateContextMenu = false;
var YOUTUBE_VIDEO_STATES = /* @__PURE__ */ new Map();
var IS_PLAIN_PASTE = false;
var IS_PLAIN_PASTE_TIMER = 0;
var PLAIN_PASTE_TOAST_SHOWN = false;
var lastPointerUp = null;
var gesture = {
  pointers: /* @__PURE__ */ new Map(),
  lastCenter: null,
  initialDistance: null,
  initialScale: null
};
var App = class _App extends import_react95.default.Component {
  canvas;
  interactiveCanvas = null;
  rc;
  unmounted = false;
  actionManager;
  device = deviceContextInitialValue;
  excalidrawContainerRef = import_react95.default.createRef();
  scene;
  renderer;
  fonts;
  resizeObserver;
  nearestScrollableContainer;
  library;
  libraryItemsFromStorage;
  id;
  history;
  excalidrawContainerValue;
  files = {};
  imageCache = /* @__PURE__ */ new Map();
  iFrameRefs = /* @__PURE__ */ new Map();
  /**
   * Indicates whether the embeddable's url has been validated for rendering.
   * If value not set, indicates that the validation is pending.
   * Initially or on url change the flag is not reset so that we can guarantee
   * the validation came from a trusted source (the editor).
   **/
  embedsValidationStatus = /* @__PURE__ */ new Map();
  /** embeds that have been inserted to DOM (as a perf optim, we don't want to
   * insert to DOM before user initially scrolls to them) */
  initializedEmbeds = /* @__PURE__ */ new Set();
  elementsPendingErasure = /* @__PURE__ */ new Set();
  hitLinkElement;
  lastPointerDownEvent = null;
  lastPointerUpEvent = null;
  lastPointerMoveEvent = null;
  lastViewportPosition = { x: 0, y: 0 };
  animationFrameHandler = new AnimationFrameHandler();
  laserTrails = new LaserTrails(this.animationFrameHandler, this);
  eraserTrail = new AnimatedTrail(this.animationFrameHandler, this, {
    streamline: 0.2,
    size: 5,
    keepHead: true,
    sizeMapping: (c3) => {
      const DECAY_TIME = 200;
      const DECAY_LENGTH = 10;
      const t4 = Math.max(0, 1 - (performance.now() - c3.pressure) / DECAY_TIME);
      const l4 = (DECAY_LENGTH - Math.min(DECAY_LENGTH, c3.totalLength - c3.currentIndex)) / DECAY_LENGTH;
      return Math.min(easeOut(l4), easeOut(t4));
    },
    fill: () => this.state.theme === THEME.LIGHT ? "rgba(0, 0, 0, 0.2)" : "rgba(255, 255, 255, 0.2)"
  });
  onChangeEmitter = new Emitter();
  onPointerDownEmitter = new Emitter();
  onPointerUpEmitter = new Emitter();
  onUserFollowEmitter = new Emitter();
  onScrollChangeEmitter = new Emitter();
  missingPointerEventCleanupEmitter = new Emitter();
  onRemoveEventListenersEmitter = new Emitter();
  constructor(props) {
    super(props);
    const defaultAppState2 = getDefaultAppState();
    const {
      excalidrawAPI,
      viewModeEnabled = false,
      zenModeEnabled = false,
      gridModeEnabled = false,
      objectsSnapModeEnabled = false,
      theme = defaultAppState2.theme,
      name = `${t("labels.untitled")}-${getDateTime()}`
    } = props;
    this.state = {
      ...defaultAppState2,
      theme,
      isLoading: true,
      ...this.getCanvasOffsets(),
      viewModeEnabled,
      zenModeEnabled,
      objectsSnapModeEnabled,
      gridSize: gridModeEnabled ? GRID_SIZE : null,
      name,
      width: window.innerWidth,
      height: window.innerHeight
    };
    this.id = nanoid();
    this.library = new library_default(this);
    this.actionManager = new ActionManager(
      this.syncActionResult,
      () => this.state,
      () => this.scene.getElementsIncludingDeleted(),
      this
    );
    this.scene = new Scene_default();
    this.canvas = document.createElement("canvas");
    this.rc = rough_default.canvas(this.canvas);
    this.renderer = new Renderer(this.scene);
    if (excalidrawAPI) {
      const api = {
        updateScene: this.updateScene,
        updateLibrary: this.library.updateLibrary,
        addFiles: this.addFiles,
        resetScene: this.resetScene,
        getSceneElementsIncludingDeleted: this.getSceneElementsIncludingDeleted,
        history: {
          clear: this.resetHistory
        },
        scrollToContent: this.scrollToContent,
        getSceneElements: this.getSceneElements,
        getAppState: () => this.state,
        getFiles: () => this.files,
        getName: this.getName,
        registerAction: (action) => {
          this.actionManager.registerAction(action);
        },
        refresh: this.refresh,
        setToast: this.setToast,
        id: this.id,
        setActiveTool: this.setActiveTool,
        setCursor: this.setCursor,
        resetCursor: this.resetCursor,
        updateFrameRendering: this.updateFrameRendering,
        toggleSidebar: this.toggleSidebar,
        onChange: (cb) => this.onChangeEmitter.on(cb),
        onPointerDown: (cb) => this.onPointerDownEmitter.on(cb),
        onPointerUp: (cb) => this.onPointerUpEmitter.on(cb),
        onScrollChange: (cb) => this.onScrollChangeEmitter.on(cb),
        onUserFollow: (cb) => this.onUserFollowEmitter.on(cb)
      };
      if (typeof excalidrawAPI === "function") {
        excalidrawAPI(api);
      } else {
        console.error("excalidrawAPI should be a function!");
      }
    }
    this.excalidrawContainerValue = {
      container: this.excalidrawContainerRef.current,
      id: this.id
    };
    this.fonts = new Fonts({
      scene: this.scene,
      onSceneUpdated: this.onSceneUpdated
    });
    this.history = new history_default();
    this.actionManager.registerAll(actions);
    this.actionManager.registerAction(createUndoAction(this.history));
    this.actionManager.registerAction(createRedoAction(this.history));
  }
  onWindowMessage(event) {
    if (event.origin !== "https://player.vimeo.com" && event.origin !== "https://www.youtube.com") {
      return;
    }
    let data = null;
    try {
      data = JSON.parse(event.data);
    } catch (e3) {
    }
    if (!data) {
      return;
    }
    switch (event.origin) {
      case "https://player.vimeo.com":
        if (data.method === "paused") {
          let source = null;
          const iframes = document.body.querySelectorAll(
            "iframe.excalidraw__embeddable"
          );
          if (!iframes) {
            break;
          }
          for (const iframe of iframes) {
            if (iframe.contentWindow === event.source) {
              source = iframe.contentWindow;
            }
          }
          source?.postMessage(
            JSON.stringify({
              method: data.value ? "play" : "pause",
              value: true
            }),
            "*"
          );
        }
        break;
      case "https://www.youtube.com":
        if (data.event === "infoDelivery" && data.info && data.id && typeof data.info.playerState === "number") {
          const id = data.id;
          const playerState = data.info.playerState;
          if (Object.values(YOUTUBE_STATES).includes(playerState)) {
            YOUTUBE_VIDEO_STATES.set(
              id,
              playerState
            );
          }
        }
        break;
    }
  }
  cacheEmbeddableRef(element, ref) {
    if (ref) {
      this.iFrameRefs.set(element.id, ref);
    }
  }
  getHTMLIFrameElement(element) {
    return this.iFrameRefs.get(element.id);
  }
  handleEmbeddableCenterClick(element) {
    if (this.state.activeEmbeddable?.element === element && this.state.activeEmbeddable?.state === "active") {
      return;
    }
    setTimeout(() => {
      this.setState({
        activeEmbeddable: { element, state: "active" },
        selectedElementIds: { [element.id]: true },
        draggingElement: null,
        selectionElement: null
      });
    }, 100);
    if (isIframeElement(element)) {
      return;
    }
    const iframe = this.getHTMLIFrameElement(element);
    if (!iframe?.contentWindow) {
      return;
    }
    if (iframe.src.includes("youtube")) {
      const state = YOUTUBE_VIDEO_STATES.get(element.id);
      if (!state) {
        YOUTUBE_VIDEO_STATES.set(element.id, YOUTUBE_STATES.UNSTARTED);
        iframe.contentWindow.postMessage(
          JSON.stringify({
            event: "listening",
            id: element.id
          }),
          "*"
        );
      }
      switch (state) {
        case YOUTUBE_STATES.PLAYING:
        case YOUTUBE_STATES.BUFFERING:
          iframe.contentWindow?.postMessage(
            JSON.stringify({
              event: "command",
              func: "pauseVideo",
              args: ""
            }),
            "*"
          );
          break;
        default:
          iframe.contentWindow?.postMessage(
            JSON.stringify({
              event: "command",
              func: "playVideo",
              args: ""
            }),
            "*"
          );
      }
    }
    if (iframe.src.includes("player.vimeo.com")) {
      iframe.contentWindow.postMessage(
        JSON.stringify({
          method: "paused"
          //video play/pause in onWindowMessage handler
        }),
        "*"
      );
    }
  }
  isIframeLikeElementCenter(el, event, sceneX, sceneY) {
    return el && !event.altKey && !event.shiftKey && !event.metaKey && !event.ctrlKey && (this.state.activeEmbeddable?.element !== el || this.state.activeEmbeddable?.state === "hover" || !this.state.activeEmbeddable) && sceneX >= el.x + el.width / 3 && sceneX <= el.x + 2 * el.width / 3 && sceneY >= el.y + el.height / 3 && sceneY <= el.y + 2 * el.height / 3;
  }
  updateEmbedValidationStatus = (element, status) => {
    this.embedsValidationStatus.set(element.id, status);
    ShapeCache.delete(element);
  };
  updateEmbeddables = () => {
    const iframeLikes = /* @__PURE__ */ new Set();
    let updated = false;
    this.scene.getNonDeletedElements().filter((element) => {
      if (isEmbeddableElement(element)) {
        iframeLikes.add(element.id);
        if (!this.embedsValidationStatus.has(element.id)) {
          updated = true;
          const validated = embeddableURLValidator(
            element.link,
            this.props.validateEmbeddable
          );
          this.updateEmbedValidationStatus(element, validated);
        }
      } else if (isIframeElement(element)) {
        iframeLikes.add(element.id);
      }
      return false;
    });
    if (updated) {
      this.scene.informMutation();
    }
    this.iFrameRefs.forEach((ref, id) => {
      if (!iframeLikes.has(id)) {
        this.iFrameRefs.delete(id);
      }
    });
  };
  renderEmbeddables() {
    const scale = this.state.zoom.value;
    const normalizedWidth = this.state.width;
    const normalizedHeight = this.state.height;
    const embeddableElements = this.scene.getNonDeletedElements().filter(
      (el) => isEmbeddableElement(el) && this.embedsValidationStatus.get(el.id) === true || isIframeElement(el)
    );
    return /* @__PURE__ */ (0, import_jsx_runtime130.jsx)(import_jsx_runtime130.Fragment, { children: embeddableElements.map((el) => {
      const { x: x3, y: y3 } = sceneCoordsToViewportCoords(
        { sceneX: el.x, sceneY: el.y },
        this.state
      );
      const isVisible = isElementInViewport(
        el,
        normalizedWidth,
        normalizedHeight,
        this.state,
        this.scene.getNonDeletedElementsMap()
      );
      const hasBeenInitialized = this.initializedEmbeds.has(el.id);
      if (isVisible && !hasBeenInitialized) {
        this.initializedEmbeds.add(el.id);
      }
      const shouldRender = isVisible || hasBeenInitialized;
      if (!shouldRender) {
        return null;
      }
      let src;
      if (isIframeElement(el)) {
        src = null;
        const data = (el.customData?.generationData ?? this.magicGenerations.get(el.id)) || {
          status: "error",
          message: "No generation data",
          code: "ERR_NO_GENERATION_DATA"
        };
        if (data.status === "done") {
          const html = data.html;
          src = {
            intrinsicSize: { w: el.width, h: el.height },
            type: "document",
            srcdoc: () => {
              return html;
            }
          };
        } else if (data.status === "pending") {
          src = {
            intrinsicSize: { w: el.width, h: el.height },
            type: "document",
            srcdoc: () => {
              return createSrcDoc(`
                    <style>
                      html, body {
                        width: 100%;
                        height: 100%;
                        color: ${this.state.theme === "dark" ? "white" : "black"};
                      }
                      body {
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        flex-direction: column;
                        gap: 1rem;
                      }

                      .Spinner {
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        margin-left: auto;
                        margin-right: auto;
                      }

                      .Spinner svg {
                        animation: rotate 1.6s linear infinite;
                        transform-origin: center center;
                        width: 40px;
                        height: 40px;
                      }

                      .Spinner circle {
                        stroke: currentColor;
                        animation: dash 1.6s linear 0s infinite;
                        stroke-linecap: round;
                      }

                      @keyframes rotate {
                        100% {
                          transform: rotate(360deg);
                        }
                      }

                      @keyframes dash {
                        0% {
                          stroke-dasharray: 1, 300;
                          stroke-dashoffset: 0;
                        }
                        50% {
                          stroke-dasharray: 150, 300;
                          stroke-dashoffset: -200;
                        }
                        100% {
                          stroke-dasharray: 1, 300;
                          stroke-dashoffset: -280;
                        }
                      }
                    </style>
                    <div class="Spinner">
                      <svg
                        viewBox="0 0 100 100"
                      >
                        <circle
                          cx="50"
                          cy="50"
                          r="46"
                          stroke-width="8"
                          fill="none"
                          stroke-miter-limit="10"
                        />
                      </svg>
                    </div>
                    <div>Generating...</div>
                  `);
            }
          };
        } else {
          let message;
          if (data.code === "ERR_GENERATION_INTERRUPTED") {
            message = "Generation was interrupted...";
          } else {
            message = data.message || "Generation failed";
          }
          src = {
            intrinsicSize: { w: el.width, h: el.height },
            type: "document",
            srcdoc: () => {
              return createSrcDoc(`
                    <style>
                    html, body {
                      height: 100%;
                    }
                      body {
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                        justify-content: center;
                        color: ${COLOR_PALETTE.red[3]};
                      }
                      h1, h3 {
                        margin-top: 0;
                        margin-bottom: 0.5rem;
                      }
                    </style>
                    <h1>Error!</h1>
                    <h3>${message}</h3>
                  `);
            }
          };
        }
      } else {
        src = getEmbedLink(toValidURL(el.link || ""));
      }
      const isActive = this.state.activeEmbeddable?.element === el && this.state.activeEmbeddable?.state === "active";
      const isHovered = this.state.activeEmbeddable?.element === el && this.state.activeEmbeddable?.state === "hover";
      return /* @__PURE__ */ (0, import_jsx_runtime130.jsx)(
        "div",
        {
          className: clsx_m_default("excalidraw__embeddable-container", {
            "is-hovered": isHovered
          }),
          style: {
            transform: isVisible ? `translate(${x3 - this.state.offsetLeft}px, ${y3 - this.state.offsetTop}px) scale(${scale})` : "none",
            display: isVisible ? "block" : "none",
            opacity: getRenderOpacity(
              el,
              getContainingFrame(el),
              this.elementsPendingErasure
            ),
            ["--embeddable-radius"]: `${getCornerRadius(
              Math.min(el.width, el.height),
              el
            )}px`
          },
          children: /* @__PURE__ */ (0, import_jsx_runtime130.jsxs)(
            "div",
            {
              className: "excalidraw__embeddable-container__inner",
              style: {
                width: isVisible ? `${el.width}px` : 0,
                height: isVisible ? `${el.height}px` : 0,
                transform: isVisible ? `rotate(${el.angle}rad)` : "none",
                pointerEvents: isActive ? POINTER_EVENTS.enabled : POINTER_EVENTS.disabled
              },
              children: [
                isHovered && /* @__PURE__ */ (0, import_jsx_runtime130.jsx)("div", { className: "excalidraw__embeddable-hint", children: t("buttons.embeddableInteractionButton") }),
                /* @__PURE__ */ (0, import_jsx_runtime130.jsx)(
                  "div",
                  {
                    className: "excalidraw__embeddable__outer",
                    style: {
                      padding: `${el.strokeWidth}px`
                    },
                    children: (isEmbeddableElement(el) ? this.props.renderEmbeddable?.(el, this.state) : null) ?? /* @__PURE__ */ (0, import_jsx_runtime130.jsx)(
                      "iframe",
                      {
                        ref: (ref) => this.cacheEmbeddableRef(el, ref),
                        className: "excalidraw__embeddable",
                        srcDoc: src?.type === "document" ? src.srcdoc(this.state.theme) : void 0,
                        src: src?.type !== "document" ? src?.link ?? "" : void 0,
                        scrolling: "no",
                        referrerPolicy: "no-referrer-when-downgrade",
                        title: "Excalidraw Embedded Content",
                        allow: "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture",
                        allowFullScreen: true,
                        sandbox: "allow-same-origin allow-scripts allow-forms allow-popups allow-popups-to-escape-sandbox allow-presentation allow-downloads"
                      }
                    )
                  }
                )
              ]
            }
          )
        },
        el.id
      );
    }) });
  }
  getFrameNameDOMId = (frameElement) => {
    return `${this.id}-frame-name-${frameElement.id}`;
  };
  frameNameBoundsCache = {
    get: (frameElement) => {
      let bounds = this.frameNameBoundsCache._cache.get(frameElement.id);
      if (!bounds || bounds.zoom !== this.state.zoom.value || bounds.versionNonce !== frameElement.versionNonce) {
        const frameNameDiv = document.getElementById(
          this.getFrameNameDOMId(frameElement)
        );
        if (frameNameDiv) {
          const box = frameNameDiv.getBoundingClientRect();
          const boxSceneTopLeft = viewportCoordsToSceneCoords(
            { clientX: box.x, clientY: box.y },
            this.state
          );
          const boxSceneBottomRight = viewportCoordsToSceneCoords(
            { clientX: box.right, clientY: box.bottom },
            this.state
          );
          bounds = {
            x: boxSceneTopLeft.x,
            y: boxSceneTopLeft.y,
            width: boxSceneBottomRight.x - boxSceneTopLeft.x,
            height: boxSceneBottomRight.y - boxSceneTopLeft.y,
            angle: 0,
            zoom: this.state.zoom.value,
            versionNonce: frameElement.versionNonce
          };
          this.frameNameBoundsCache._cache.set(frameElement.id, bounds);
          return bounds;
        }
        return null;
      }
      return bounds;
    },
    /**
     * @private
     */
    _cache: /* @__PURE__ */ new Map()
  };
  renderFrameNames = () => {
    if (!this.state.frameRendering.enabled || !this.state.frameRendering.name) {
      return null;
    }
    const isDarkTheme = this.state.theme === "dark";
    let frameIndex = 0;
    let magicFrameIndex = 0;
    return this.scene.getNonDeletedFramesLikes().map((f3) => {
      if (isFrameElement(f3)) {
        frameIndex++;
      } else {
        magicFrameIndex++;
      }
      if (!isElementInViewport(
        f3,
        this.canvas.width / window.devicePixelRatio,
        this.canvas.height / window.devicePixelRatio,
        {
          offsetLeft: this.state.offsetLeft,
          offsetTop: this.state.offsetTop,
          scrollX: this.state.scrollX,
          scrollY: this.state.scrollY,
          zoom: this.state.zoom
        },
        this.scene.getNonDeletedElementsMap()
      )) {
        return null;
      }
      const { x: x1, y: y1 } = sceneCoordsToViewportCoords(
        { sceneX: f3.x, sceneY: f3.y },
        this.state
      );
      const FRAME_NAME_EDIT_PADDING = 6;
      const reset = () => {
        mutateElement(f3, { name: f3.name?.trim() || null });
        this.setState({ editingFrame: null });
      };
      let frameNameJSX;
      const frameName = getFrameLikeTitle(
        f3,
        isFrameElement(f3) ? frameIndex : magicFrameIndex
      );
      if (f3.id === this.state.editingFrame) {
        const frameNameInEdit = frameName;
        frameNameJSX = /* @__PURE__ */ (0, import_jsx_runtime130.jsx)(
          "input",
          {
            autoFocus: true,
            value: frameNameInEdit,
            onChange: (e3) => {
              mutateElement(f3, {
                name: e3.target.value
              });
            },
            onFocus: (e3) => e3.target.select(),
            onBlur: () => reset(),
            onKeyDown: (event) => {
              if (event.key === KEYS.ESCAPE || event.key === KEYS.ENTER) {
                reset();
              }
            },
            style: {
              background: this.state.viewBackgroundColor,
              filter: isDarkTheme ? THEME_FILTER : "none",
              zIndex: 2,
              border: "none",
              display: "block",
              padding: `${FRAME_NAME_EDIT_PADDING}px`,
              borderRadius: 4,
              boxShadow: "inset 0 0 0 1px var(--color-primary)",
              fontFamily: "Assistant",
              fontSize: "14px",
              transform: `translate(-${FRAME_NAME_EDIT_PADDING}px, ${FRAME_NAME_EDIT_PADDING}px)`,
              color: "var(--color-gray-80)",
              overflow: "hidden",
              maxWidth: `${document.body.clientWidth - x1 - FRAME_NAME_EDIT_PADDING}px`
            },
            size: frameNameInEdit.length + 1 || 1,
            dir: "auto",
            autoComplete: "off",
            autoCapitalize: "off",
            autoCorrect: "off"
          }
        );
      } else {
        frameNameJSX = frameName;
      }
      return /* @__PURE__ */ (0, import_jsx_runtime130.jsx)(
        "div",
        {
          id: this.getFrameNameDOMId(f3),
          style: {
            position: "absolute",
            // Positioning from bottom so that we don't to either
            // calculate text height or adjust using transform (which)
            // messes up input position when editing the frame name.
            // This makes the positioning deterministic and we can calculate
            // the same position when rendering to canvas / svg.
            bottom: `${this.state.height + FRAME_STYLE.nameOffsetY - y1 + this.state.offsetTop}px`,
            left: `${x1 - this.state.offsetLeft}px`,
            zIndex: 2,
            fontSize: FRAME_STYLE.nameFontSize,
            color: isDarkTheme ? FRAME_STYLE.nameColorDarkTheme : FRAME_STYLE.nameColorLightTheme,
            lineHeight: FRAME_STYLE.nameLineHeight,
            width: "max-content",
            maxWidth: `${f3.width}px`,
            overflow: f3.id === this.state.editingFrame ? "visible" : "hidden",
            whiteSpace: "nowrap",
            textOverflow: "ellipsis",
            cursor: CURSOR_TYPE.MOVE,
            pointerEvents: this.state.viewModeEnabled ? POINTER_EVENTS.disabled : POINTER_EVENTS.enabled
          },
          onPointerDown: (event) => this.handleCanvasPointerDown(event),
          onWheel: (event) => this.handleWheel(event),
          onContextMenu: this.handleCanvasContextMenu,
          onDoubleClick: () => {
            this.setState({
              editingFrame: f3.id
            });
          },
          children: frameNameJSX
        },
        f3.id
      );
    });
  };
  toggleOverscrollBehavior(event) {
    document.documentElement.style.overscrollBehaviorX = event.type === "pointerenter" ? "none" : "auto";
  }
  render() {
    const selectedElements = this.scene.getSelectedElements(this.state);
    const { renderTopRightUI, renderCustomStats } = this.props;
    const versionNonce = this.scene.getVersionNonce();
    const { elementsMap, visibleElements } = this.renderer.getRenderableElements({
      versionNonce,
      zoom: this.state.zoom,
      offsetLeft: this.state.offsetLeft,
      offsetTop: this.state.offsetTop,
      scrollX: this.state.scrollX,
      scrollY: this.state.scrollY,
      height: this.state.height,
      width: this.state.width,
      editingElement: this.state.editingElement,
      pendingImageElementId: this.state.pendingImageElementId
    });
    const allElementsMap = this.scene.getNonDeletedElementsMap();
    const shouldBlockPointerEvents = !(this.state.editingElement && isLinearElement(this.state.editingElement)) && (this.state.selectionElement || this.state.draggingElement || this.state.resizingElement || this.state.activeTool.type === "laser" && // technically we can just test on this once we make it more safe
    this.state.cursorButton === "down" || this.state.editingElement && !isTextElement(this.state.editingElement));
    const firstSelectedElement = selectedElements[0];
    return /* @__PURE__ */ (0, import_jsx_runtime130.jsx)(
      "div",
      {
        className: clsx_m_default("excalidraw excalidraw-container", {
          "excalidraw--view-mode": this.state.viewModeEnabled,
          "excalidraw--mobile": this.device.editor.isMobile
        }),
        style: {
          ["--ui-pointerEvents"]: shouldBlockPointerEvents ? POINTER_EVENTS.disabled : POINTER_EVENTS.enabled
        },
        ref: this.excalidrawContainerRef,
        onDrop: this.handleAppOnDrop,
        tabIndex: 0,
        onKeyDown: this.props.handleKeyboardGlobally ? void 0 : this.onKeyDown,
        onPointerEnter: this.toggleOverscrollBehavior,
        onPointerLeave: this.toggleOverscrollBehavior,
        children: /* @__PURE__ */ (0, import_jsx_runtime130.jsx)(AppContext.Provider, { value: this, children: /* @__PURE__ */ (0, import_jsx_runtime130.jsx)(AppPropsContext.Provider, { value: this.props, children: /* @__PURE__ */ (0, import_jsx_runtime130.jsx)(
          ExcalidrawContainerContext.Provider,
          {
            value: this.excalidrawContainerValue,
            children: /* @__PURE__ */ (0, import_jsx_runtime130.jsx)(DeviceContext.Provider, { value: this.device, children: /* @__PURE__ */ (0, import_jsx_runtime130.jsx)(ExcalidrawSetAppStateContext.Provider, { value: this.setAppState, children: /* @__PURE__ */ (0, import_jsx_runtime130.jsx)(ExcalidrawAppStateContext.Provider, { value: this.state, children: /* @__PURE__ */ (0, import_jsx_runtime130.jsxs)(
              ExcalidrawElementsContext.Provider,
              {
                value: this.scene.getNonDeletedElements(),
                children: [
                  /* @__PURE__ */ (0, import_jsx_runtime130.jsxs)(
                    ExcalidrawActionManagerContext.Provider,
                    {
                      value: this.actionManager,
                      children: [
                        /* @__PURE__ */ (0, import_jsx_runtime130.jsx)(
                          LayerUI_default,
                          {
                            canvas: this.canvas,
                            appState: this.state,
                            files: this.files,
                            setAppState: this.setAppState,
                            actionManager: this.actionManager,
                            elements: this.scene.getNonDeletedElements(),
                            onLockToggle: this.toggleLock,
                            onPenModeToggle: this.togglePenMode,
                            onHandToolToggle: this.onHandToolToggle,
                            langCode: getLanguage().code,
                            renderTopRightUI,
                            renderCustomStats,
                            showExitZenModeBtn: typeof this.props?.zenModeEnabled === "undefined" && this.state.zenModeEnabled,
                            UIOptions: this.props.UIOptions,
                            onExportImage: this.onExportImage,
                            renderWelcomeScreen: !this.state.isLoading && this.state.showWelcomeScreen && this.state.activeTool.type === "selection" && !this.state.zenModeEnabled && !this.scene.getElementsIncludingDeleted().length,
                            app: this,
                            isCollaborating: this.props.isCollaborating,
                            openAIKey: this.OPENAI_KEY,
                            isOpenAIKeyPersisted: this.OPENAI_KEY_IS_PERSISTED,
                            onOpenAIAPIKeyChange: this.onOpenAIKeyChange,
                            onMagicSettingsConfirm: this.onMagicSettingsConfirm,
                            children: this.props.children
                          }
                        ),
                        /* @__PURE__ */ (0, import_jsx_runtime130.jsx)("div", { className: "excalidraw-textEditorContainer" }),
                        /* @__PURE__ */ (0, import_jsx_runtime130.jsx)("div", { className: "excalidraw-contextMenuContainer" }),
                        /* @__PURE__ */ (0, import_jsx_runtime130.jsx)("div", { className: "excalidraw-eye-dropper-container" }),
                        /* @__PURE__ */ (0, import_jsx_runtime130.jsx)(
                          SVGLayer,
                          {
                            trails: [this.laserTrails, this.eraserTrail]
                          }
                        ),
                        selectedElements.length === 1 && this.state.showHyperlinkPopup && /* @__PURE__ */ (0, import_jsx_runtime130.jsx)(
                          Hyperlink,
                          {
                            element: firstSelectedElement,
                            elementsMap: allElementsMap,
                            setAppState: this.setAppState,
                            onLinkOpen: this.props.onLinkOpen,
                            setToast: this.setToast,
                            updateEmbedValidationStatus: this.updateEmbedValidationStatus
                          },
                          firstSelectedElement.id
                        ),
                        this.props.aiEnabled !== false && selectedElements.length === 1 && isMagicFrameElement(firstSelectedElement) && /* @__PURE__ */ (0, import_jsx_runtime130.jsx)(
                          ElementCanvasButtons,
                          {
                            element: firstSelectedElement,
                            elementsMap,
                            children: /* @__PURE__ */ (0, import_jsx_runtime130.jsx)(
                              ElementCanvasButton,
                              {
                                title: t("labels.convertToCode"),
                                icon: MagicIcon,
                                checked: false,
                                onChange: () => this.onMagicFrameGenerate(
                                  firstSelectedElement,
                                  "button"
                                )
                              }
                            )
                          }
                        ),
                        selectedElements.length === 1 && isIframeElement(firstSelectedElement) && firstSelectedElement.customData?.generationData?.status === "done" && /* @__PURE__ */ (0, import_jsx_runtime130.jsxs)(
                          ElementCanvasButtons,
                          {
                            element: firstSelectedElement,
                            elementsMap,
                            children: [
                              /* @__PURE__ */ (0, import_jsx_runtime130.jsx)(
                                ElementCanvasButton,
                                {
                                  title: t("labels.copySource"),
                                  icon: copyIcon,
                                  checked: false,
                                  onChange: () => this.onIframeSrcCopy(firstSelectedElement)
                                }
                              ),
                              /* @__PURE__ */ (0, import_jsx_runtime130.jsx)(
                                ElementCanvasButton,
                                {
                                  title: "Enter fullscreen",
                                  icon: fullscreenIcon,
                                  checked: false,
                                  onChange: () => {
                                    const iframe = this.getHTMLIFrameElement(
                                      firstSelectedElement
                                    );
                                    if (iframe) {
                                      try {
                                        iframe.requestFullscreen();
                                        this.setState({
                                          activeEmbeddable: {
                                            element: firstSelectedElement,
                                            state: "active"
                                          },
                                          selectedElementIds: {
                                            [firstSelectedElement.id]: true
                                          },
                                          draggingElement: null,
                                          selectionElement: null
                                        });
                                      } catch (err) {
                                        console.warn(err);
                                        this.setState({
                                          errorMessage: "Couldn't enter fullscreen"
                                        });
                                      }
                                    }
                                  }
                                }
                              )
                            ]
                          }
                        ),
                        this.state.toast !== null && /* @__PURE__ */ (0, import_jsx_runtime130.jsx)(
                          Toast,
                          {
                            message: this.state.toast.message,
                            onClose: () => this.setToast(null),
                            duration: this.state.toast.duration,
                            closable: this.state.toast.closable
                          }
                        ),
                        this.state.contextMenu && /* @__PURE__ */ (0, import_jsx_runtime130.jsx)(
                          ContextMenu,
                          {
                            items: this.state.contextMenu.items,
                            top: this.state.contextMenu.top,
                            left: this.state.contextMenu.left,
                            actionManager: this.actionManager,
                            onClose: (callback) => {
                              this.setState({ contextMenu: null }, () => {
                                this.focusContainer();
                                callback?.();
                              });
                            }
                          }
                        ),
                        /* @__PURE__ */ (0, import_jsx_runtime130.jsx)(
                          StaticCanvas_default,
                          {
                            canvas: this.canvas,
                            rc: this.rc,
                            elementsMap,
                            allElementsMap,
                            visibleElements,
                            versionNonce,
                            selectionNonce: this.state.selectionElement?.versionNonce,
                            scale: window.devicePixelRatio,
                            appState: this.state,
                            renderConfig: {
                              imageCache: this.imageCache,
                              isExporting: false,
                              renderGrid: true,
                              canvasBackgroundColor: this.state.viewBackgroundColor,
                              embedsValidationStatus: this.embedsValidationStatus,
                              elementsPendingErasure: this.elementsPendingErasure
                            }
                          }
                        ),
                        /* @__PURE__ */ (0, import_jsx_runtime130.jsx)(
                          InteractiveCanvas_default,
                          {
                            containerRef: this.excalidrawContainerRef,
                            canvas: this.interactiveCanvas,
                            elementsMap,
                            visibleElements,
                            selectedElements,
                            versionNonce,
                            selectionNonce: this.state.selectionElement?.versionNonce,
                            scale: window.devicePixelRatio,
                            appState: this.state,
                            renderInteractiveSceneCallback: this.renderInteractiveSceneCallback,
                            handleCanvasRef: this.handleInteractiveCanvasRef,
                            onContextMenu: this.handleCanvasContextMenu,
                            onPointerMove: this.handleCanvasPointerMove,
                            onPointerUp: this.handleCanvasPointerUp,
                            onPointerCancel: this.removePointer,
                            onTouchMove: this.handleTouchMove,
                            onPointerDown: this.handleCanvasPointerDown,
                            onDoubleClick: this.handleCanvasDoubleClick
                          }
                        ),
                        this.state.userToFollow && /* @__PURE__ */ (0, import_jsx_runtime130.jsx)(
                          FollowMode_default,
                          {
                            width: this.state.width,
                            height: this.state.height,
                            userToFollow: this.state.userToFollow,
                            onDisconnect: this.maybeUnfollowRemoteUser
                          }
                        ),
                        this.renderFrameNames()
                      ]
                    }
                  ),
                  this.renderEmbeddables()
                ]
              }
            ) }) }) })
          }
        ) }) })
      }
    );
  }
  focusContainer = () => {
    this.excalidrawContainerRef.current?.focus();
  };
  getSceneElementsIncludingDeleted = () => {
    return this.scene.getElementsIncludingDeleted();
  };
  getSceneElements = () => {
    return this.scene.getNonDeletedElements();
  };
  onInsertElements = (elements) => {
    this.addElementsFromPasteOrLibrary({
      elements,
      position: "center",
      files: null
    });
  };
  onExportImage = async (type, elements, opts) => {
    trackEvent("export", type, "ui");
    const fileHandle = await exportCanvas(
      type,
      elements,
      this.state,
      this.files,
      {
        exportBackground: this.state.exportBackground,
        name: this.getName(),
        viewBackgroundColor: this.state.viewBackgroundColor,
        exportingFrame: opts.exportingFrame
      }
    ).catch(muteFSAbortError).catch((error) => {
      console.error(error);
      this.setState({ errorMessage: error.message });
    });
    if (this.state.exportEmbedScene && fileHandle && isImageFileHandle(fileHandle)) {
      this.setState({ fileHandle });
    }
  };
  magicGenerations = /* @__PURE__ */ new Map();
  updateMagicGeneration = ({
    frameElement,
    data
  }) => {
    if (data.status === "pending") {
      mutateElement(
        frameElement,
        { customData: { generationData: void 0 } },
        false
      );
    } else {
      mutateElement(
        frameElement,
        { customData: { generationData: data } },
        false
      );
    }
    this.magicGenerations.set(frameElement.id, data);
    this.onSceneUpdated();
  };
  getTextFromElements(elements) {
    const text = elements.reduce((acc, element) => {
      if (isTextElement(element)) {
        acc.push(element.text);
      }
      return acc;
    }, []).join("\n\n");
    return text;
  }
  async onMagicFrameGenerate(magicFrame, source) {
    if (!this.OPENAI_KEY) {
      this.setState({
        openDialog: {
          name: "settings",
          tab: "diagram-to-code",
          source: "generation"
        }
      });
      trackEvent("ai", "generate (missing key)", "d2c");
      return;
    }
    const magicFrameChildren = getElementsOverlappingFrame(
      this.scene.getNonDeletedElements(),
      magicFrame
    ).filter((el) => !isMagicFrameElement(el));
    if (!magicFrameChildren.length) {
      if (source === "button") {
        this.setState({ errorMessage: "Cannot generate from an empty frame" });
        trackEvent("ai", "generate (no-children)", "d2c");
      } else {
        this.setActiveTool({ type: "magicframe" });
      }
      return;
    }
    const frameElement = this.insertIframeElement({
      sceneX: magicFrame.x + magicFrame.width + 30,
      sceneY: magicFrame.y,
      width: magicFrame.width,
      height: magicFrame.height
    });
    if (!frameElement) {
      return;
    }
    this.updateMagicGeneration({
      frameElement,
      data: { status: "pending" }
    });
    this.setState({
      selectedElementIds: { [frameElement.id]: true }
    });
    const blob = await exportToBlob({
      elements: this.scene.getNonDeletedElements(),
      appState: {
        ...this.state,
        exportBackground: true,
        viewBackgroundColor: this.state.viewBackgroundColor
      },
      exportingFrame: magicFrame,
      files: this.files
    });
    const dataURL = await getDataURL(blob);
    const textFromFrameChildren = this.getTextFromElements(magicFrameChildren);
    trackEvent("ai", "generate (start)", "d2c");
    const result = await diagramToHTML({
      image: dataURL,
      apiKey: this.OPENAI_KEY,
      text: textFromFrameChildren,
      theme: this.state.theme
    });
    if (!result.ok) {
      trackEvent("ai", "generate (failed)", "d2c");
      console.error(result.error);
      this.updateMagicGeneration({
        frameElement,
        data: {
          status: "error",
          code: "ERR_OAI",
          message: result.error?.message || "Unknown error during generation"
        }
      });
      return;
    }
    trackEvent("ai", "generate (success)", "d2c");
    if (result.choices[0].message.content == null) {
      this.updateMagicGeneration({
        frameElement,
        data: {
          status: "error",
          code: "ERR_OAI",
          message: "Nothing genereated :("
        }
      });
      return;
    }
    const message = result.choices[0].message.content;
    const html = message.slice(
      message.indexOf("<!DOCTYPE html>"),
      message.indexOf("</html>") + "</html>".length
    );
    this.updateMagicGeneration({
      frameElement,
      data: { status: "done", html }
    });
  }
  onIframeSrcCopy(element) {
    if (element.customData?.generationData?.status === "done") {
      copyTextToSystemClipboard(element.customData.generationData.html);
      this.setToast({
        message: "copied to clipboard",
        closable: false,
        duration: 1500
      });
    }
  }
  OPENAI_KEY = EditorLocalStorage.get(
    EDITOR_LS_KEYS.OAI_API_KEY
  );
  OPENAI_KEY_IS_PERSISTED = EditorLocalStorage.has(EDITOR_LS_KEYS.OAI_API_KEY) || false;
  onOpenAIKeyChange = (openAIKey, shouldPersist) => {
    this.OPENAI_KEY = openAIKey || null;
    if (shouldPersist) {
      const didPersist = EditorLocalStorage.set(
        EDITOR_LS_KEYS.OAI_API_KEY,
        openAIKey
      );
      this.OPENAI_KEY_IS_PERSISTED = didPersist;
    } else {
      this.OPENAI_KEY_IS_PERSISTED = false;
    }
  };
  onMagicSettingsConfirm = (apiKey, shouldPersist, source) => {
    this.OPENAI_KEY = apiKey || null;
    this.onOpenAIKeyChange(this.OPENAI_KEY, shouldPersist);
    if (source === "settings") {
      return;
    }
    const selectedElements = this.scene.getSelectedElements({
      selectedElementIds: this.state.selectedElementIds
    });
    if (apiKey) {
      if (selectedElements.length) {
        this.onMagicframeToolSelect();
      } else {
        this.setActiveTool({ type: "magicframe" });
      }
    } else if (!isMagicFrameElement(selectedElements[0])) {
      this.setActiveTool({ type: "magicframe" });
    }
  };
  onMagicframeToolSelect = () => {
    if (!this.OPENAI_KEY) {
      this.setState({
        openDialog: {
          name: "settings",
          tab: "diagram-to-code",
          source: "tool"
        }
      });
      trackEvent("ai", "tool-select (missing key)", "d2c");
      return;
    }
    const selectedElements = this.scene.getSelectedElements({
      selectedElementIds: this.state.selectedElementIds
    });
    if (selectedElements.length === 0) {
      this.setActiveTool({ type: TOOL_TYPE.magicframe });
      trackEvent("ai", "tool-select (empty-selection)", "d2c");
    } else {
      const selectedMagicFrame = selectedElements.length === 1 && isMagicFrameElement(selectedElements[0]) && selectedElements[0];
      if (!selectedMagicFrame && selectedElements.some((el) => isFrameLikeElement(el) || el.frameId)) {
        this.setActiveTool({ type: TOOL_TYPE.magicframe });
        return;
      }
      trackEvent("ai", "tool-select (existing selection)", "d2c");
      let frame;
      if (selectedMagicFrame) {
        frame = selectedMagicFrame;
      } else {
        const [minX, minY, maxX, maxY] = getCommonBounds(selectedElements);
        const padding = 50;
        frame = newMagicFrameElement({
          ...FRAME_STYLE,
          x: minX - padding,
          y: minY - padding,
          width: maxX - minX + padding * 2,
          height: maxY - minY + padding * 2,
          opacity: 100,
          locked: false
        });
        this.scene.addNewElement(frame);
        for (const child of selectedElements) {
          mutateElement(child, { frameId: frame.id });
        }
        this.setState({
          selectedElementIds: { [frame.id]: true }
        });
      }
      this.onMagicFrameGenerate(frame, "upstream");
    }
  };
  openEyeDropper = ({ type }) => {
    jotaiStore.set(activeEyeDropperAtom, {
      swapPreviewOnAlt: true,
      colorPickerType: type === "stroke" ? "elementStroke" : "elementBackground",
      onSelect: (color, event) => {
        const shouldUpdateStrokeColor = type === "background" && event.altKey || type === "stroke" && !event.altKey;
        const selectedElements = this.scene.getSelectedElements(this.state);
        if (!selectedElements.length || this.state.activeTool.type !== "selection") {
          if (shouldUpdateStrokeColor) {
            this.syncActionResult({
              appState: { ...this.state, currentItemStrokeColor: color },
              commitToHistory: true
            });
          } else {
            this.syncActionResult({
              appState: { ...this.state, currentItemBackgroundColor: color },
              commitToHistory: true
            });
          }
        } else {
          this.updateScene({
            elements: this.scene.getElementsIncludingDeleted().map((el) => {
              if (this.state.selectedElementIds[el.id]) {
                return newElementWith(el, {
                  [shouldUpdateStrokeColor ? "strokeColor" : "backgroundColor"]: color
                });
              }
              return el;
            })
          });
        }
      },
      keepOpenOnAlt: false
    });
  };
  syncActionResult = withBatchedUpdates(
    (actionResult) => {
      if (this.unmounted || actionResult === false) {
        return;
      }
      let editingElement = null;
      if (actionResult.elements) {
        actionResult.elements.forEach((element) => {
          if (this.state.editingElement?.id === element.id && this.state.editingElement !== element && isNonDeletedElement(element)) {
            editingElement = element;
          }
        });
        this.scene.replaceAllElements(actionResult.elements);
        if (actionResult.commitToHistory) {
          this.history.resumeRecording();
        }
      }
      if (actionResult.files) {
        this.files = actionResult.replaceFiles ? actionResult.files : { ...this.files, ...actionResult.files };
        this.addNewImagesToImageCache();
      }
      if (actionResult.appState || editingElement || this.state.contextMenu) {
        if (actionResult.commitToHistory) {
          this.history.resumeRecording();
        }
        let viewModeEnabled = actionResult?.appState?.viewModeEnabled || false;
        let zenModeEnabled = actionResult?.appState?.zenModeEnabled || false;
        let gridSize = actionResult?.appState?.gridSize || null;
        const theme = actionResult?.appState?.theme || this.props.theme || THEME.LIGHT;
        const name = actionResult?.appState?.name ?? this.state.name;
        const errorMessage = actionResult?.appState?.errorMessage ?? this.state.errorMessage;
        if (typeof this.props.viewModeEnabled !== "undefined") {
          viewModeEnabled = this.props.viewModeEnabled;
        }
        if (typeof this.props.zenModeEnabled !== "undefined") {
          zenModeEnabled = this.props.zenModeEnabled;
        }
        if (typeof this.props.gridModeEnabled !== "undefined") {
          gridSize = this.props.gridModeEnabled ? GRID_SIZE : null;
        }
        editingElement = editingElement || actionResult.appState?.editingElement || null;
        if (editingElement?.isDeleted) {
          editingElement = null;
        }
        this.setState(
          (state) => {
            return Object.assign(actionResult.appState || {}, {
              // NOTE this will prevent opening context menu using an action
              // or programmatically from the host, so it will need to be
              // rewritten later
              contextMenu: null,
              editingElement,
              viewModeEnabled,
              zenModeEnabled,
              gridSize,
              theme,
              name,
              errorMessage
            });
          },
          () => {
            if (actionResult.syncHistory) {
              this.history.setCurrentState(
                this.state,
                this.scene.getElementsIncludingDeleted()
              );
            }
          }
        );
      }
    }
  );
  // Lifecycle
  onBlur = withBatchedUpdates(() => {
    isHoldingSpace = false;
    this.setState({ isBindingEnabled: true });
  });
  onUnload = () => {
    this.onBlur();
  };
  disableEvent = (event) => {
    event.preventDefault();
  };
  resetHistory = () => {
    this.history.clear();
  };
  /**
   * Resets scene & history.
   * ! Do not use to clear scene user action !
   */
  resetScene = withBatchedUpdates(
    (opts) => {
      this.scene.replaceAllElements([]);
      this.setState((state) => ({
        ...getDefaultAppState(),
        isLoading: opts?.resetLoadingState ? false : state.isLoading,
        theme: this.state.theme
      }));
      this.resetHistory();
    }
  );
  initializeScene = async () => {
    if ("launchQueue" in window && "LaunchParams" in window) {
      window.launchQueue.setConsumer(
        async (launchParams) => {
          if (!launchParams.files.length) {
            return;
          }
          const fileHandle = launchParams.files[0];
          const blob = await fileHandle.getFile();
          this.loadFileToCanvas(
            new File([blob], blob.name || "", { type: blob.type }),
            fileHandle
          );
        }
      );
    }
    if (this.props.theme) {
      this.setState({ theme: this.props.theme });
    }
    if (!this.state.isLoading) {
      this.setState({ isLoading: true });
    }
    let initialData = null;
    try {
      initialData = await this.props.initialData || null;
      if (initialData?.libraryItems) {
        this.library.updateLibrary({
          libraryItems: initialData.libraryItems,
          merge: true
        }).catch((error) => {
          console.error(error);
        });
      }
    } catch (error) {
      console.error(error);
      initialData = {
        appState: {
          errorMessage: error.message || "Encountered an error during importing or restoring scene data"
        }
      };
    }
    const scene = restore(initialData, null, null, { repairBindings: true });
    scene.appState = {
      ...scene.appState,
      theme: this.props.theme || scene.appState.theme,
      // we're falling back to current (pre-init) state when deciding
      // whether to open the library, to handle a case where we
      // update the state outside of initialData (e.g. when loading the app
      // with a library install link, which should auto-open the library)
      openSidebar: scene.appState?.openSidebar || this.state.openSidebar,
      activeTool: scene.appState.activeTool.type === "image" ? { ...scene.appState.activeTool, type: "selection" } : scene.appState.activeTool,
      isLoading: false,
      toast: this.state.toast
    };
    if (initialData?.scrollToContent) {
      scene.appState = {
        ...scene.appState,
        ...calculateScrollCenter(scene.elements, {
          ...scene.appState,
          width: this.state.width,
          height: this.state.height,
          offsetTop: this.state.offsetTop,
          offsetLeft: this.state.offsetLeft
        })
      };
    }
    this.fonts.loadFontsForElements(scene.elements);
    this.resetHistory();
    this.syncActionResult({
      ...scene,
      commitToHistory: true
    });
  };
  isMobileBreakpoint = (width, height) => {
    return width < MQ_MAX_WIDTH_PORTRAIT || height < MQ_MAX_HEIGHT_LANDSCAPE && width < MQ_MAX_WIDTH_LANDSCAPE;
  };
  refreshViewportBreakpoints = () => {
    const container = this.excalidrawContainerRef.current;
    if (!container) {
      return;
    }
    const { clientWidth: viewportWidth, clientHeight: viewportHeight } = document.body;
    const prevViewportState = this.device.viewport;
    const nextViewportState = updateObject(prevViewportState, {
      isLandscape: viewportWidth > viewportHeight,
      isMobile: this.isMobileBreakpoint(viewportWidth, viewportHeight)
    });
    if (prevViewportState !== nextViewportState) {
      this.device = { ...this.device, viewport: nextViewportState };
      return true;
    }
    return false;
  };
  refreshEditorBreakpoints = () => {
    const container = this.excalidrawContainerRef.current;
    if (!container) {
      return;
    }
    const { width: editorWidth, height: editorHeight } = container.getBoundingClientRect();
    const sidebarBreakpoint = this.props.UIOptions.dockedSidebarBreakpoint != null ? this.props.UIOptions.dockedSidebarBreakpoint : MQ_RIGHT_SIDEBAR_MIN_WIDTH;
    const prevEditorState = this.device.editor;
    const nextEditorState = updateObject(prevEditorState, {
      isMobile: this.isMobileBreakpoint(editorWidth, editorHeight),
      canFitSidebar: editorWidth > sidebarBreakpoint
    });
    if (prevEditorState !== nextEditorState) {
      this.device = { ...this.device, editor: nextEditorState };
      return true;
    }
    return false;
  };
  async componentDidMount() {
    this.unmounted = false;
    this.excalidrawContainerValue.container = this.excalidrawContainerRef.current;
    if (define_import_meta_env_default.MODE === ENV.TEST || define_import_meta_env_default.DEV) {
      const setState = this.setState.bind(this);
      Object.defineProperties(window.h, {
        state: {
          configurable: true,
          get: () => {
            return this.state;
          }
        },
        setState: {
          configurable: true,
          value: (...args) => {
            return this.setState(...args);
          }
        },
        app: {
          configurable: true,
          value: this
        },
        history: {
          configurable: true,
          value: this.history
        }
      });
    }
    this.scene.addCallback(this.onSceneUpdated);
    this.addEventListeners();
    if (this.props.autoFocus && this.excalidrawContainerRef.current) {
      this.focusContainer();
    }
    if (
      // bounding rects don't work in tests so updating
      // the state on init would result in making the test enviro run
      // in mobile breakpoint (0 width/height), making everything fail
      !isTestEnv()
    ) {
      this.refreshViewportBreakpoints();
      this.refreshEditorBreakpoints();
    }
    if (supportsResizeObserver && this.excalidrawContainerRef.current) {
      this.resizeObserver = new ResizeObserver(() => {
        this.refreshEditorBreakpoints();
        this.updateDOMRect();
      });
      this.resizeObserver?.observe(this.excalidrawContainerRef.current);
    }
    const searchParams = new URLSearchParams(window.location.search.slice(1));
    if (searchParams.has("web-share-target")) {
      this.restoreFileFromShare();
    } else {
      this.updateDOMRect(this.initializeScene);
    }
    if (isBrave() && !isMeasureTextSupported()) {
      this.setState({
        errorMessage: /* @__PURE__ */ (0, import_jsx_runtime130.jsx)(BraveMeasureTextError_default, {})
      });
    }
  }
  componentWillUnmount() {
    this.renderer.destroy();
    this.scene = new Scene_default();
    this.renderer = new Renderer(this.scene);
    this.files = {};
    this.imageCache.clear();
    this.resizeObserver?.disconnect();
    this.unmounted = true;
    this.removeEventListeners();
    this.scene.destroy();
    this.library.destroy();
    this.laserTrails.stop();
    this.eraserTrail.stop();
    this.onChangeEmitter.clear();
    ShapeCache.destroy();
    SnapCache.destroy();
    clearTimeout(touchTimeout);
    isSomeElementSelected.clearCache();
    selectGroupsForSelectedElements.clearCache();
    touchTimeout = 0;
    document.documentElement.style.overscrollBehaviorX = "";
  }
  onResize = withBatchedUpdates(() => {
    this.scene.getElementsIncludingDeleted().forEach((element) => ShapeCache.delete(element));
    this.refreshViewportBreakpoints();
    this.updateDOMRect();
    if (!supportsResizeObserver) {
      this.refreshEditorBreakpoints();
    }
    this.setState({});
  });
  /** generally invoked only if fullscreen was invoked programmatically */
  onFullscreenChange = () => {
    if (
      // points to the iframe element we fullscreened
      !document.fullscreenElement && this.state.activeEmbeddable?.state === "active"
    ) {
      this.setState({
        activeEmbeddable: null
      });
    }
  };
  removeEventListeners() {
    this.onRemoveEventListenersEmitter.trigger();
  }
  addEventListeners() {
    this.removeEventListeners();
    if (this.props.handleKeyboardGlobally) {
      this.onRemoveEventListenersEmitter.once(
        addEventListener(document, "keydown" /* KEYDOWN */, this.onKeyDown, false)
      );
    }
    this.onRemoveEventListenersEmitter.once(
      addEventListener(
        this.excalidrawContainerRef.current,
        "wheel" /* WHEEL */,
        this.onWheel,
        { passive: false }
      ),
      addEventListener(window, "message" /* MESSAGE */, this.onWindowMessage, false),
      addEventListener(document, "pointerup" /* POINTER_UP */, this.removePointer),
      // #3553
      addEventListener(document, "copy" /* COPY */, this.onCopy),
      addEventListener(document, "keyup" /* KEYUP */, this.onKeyUp, { passive: true }),
      addEventListener(
        document,
        "mousemove" /* MOUSE_MOVE */,
        this.updateCurrentCursorPosition
      ),
      // rerender text elements on font load to fix #637 && #1553
      addEventListener(document.fonts, "loadingdone", (event) => {
        const loadedFontFaces = event.fontfaces;
        this.fonts.onFontsLoaded(loadedFontFaces);
      }),
      // Safari-only desktop pinch zoom
      addEventListener(
        document,
        "gesturestart" /* GESTURE_START */,
        this.onGestureStart,
        false
      ),
      addEventListener(
        document,
        "gesturechange" /* GESTURE_CHANGE */,
        this.onGestureChange,
        false
      ),
      addEventListener(
        document,
        "gestureend" /* GESTURE_END */,
        this.onGestureEnd,
        false
      ),
      addEventListener(window, "focus" /* FOCUS */, () => {
        this.maybeCleanupAfterMissingPointerUp(null);
      })
    );
    if (this.state.viewModeEnabled) {
      return;
    }
    this.onRemoveEventListenersEmitter.once(
      addEventListener(
        document,
        "fullscreenchange" /* FULLSCREENCHANGE */,
        this.onFullscreenChange
      ),
      addEventListener(document, "paste" /* PASTE */, this.pasteFromClipboard),
      addEventListener(document, "cut" /* CUT */, this.onCut),
      addEventListener(window, "resize" /* RESIZE */, this.onResize, false),
      addEventListener(window, "unload" /* UNLOAD */, this.onUnload, false),
      addEventListener(window, "blur" /* BLUR */, this.onBlur, false),
      addEventListener(
        this.excalidrawContainerRef.current,
        "dragover" /* DRAG_OVER */,
        this.disableEvent,
        false
      ),
      addEventListener(
        this.excalidrawContainerRef.current,
        "drop" /* DROP */,
        this.disableEvent,
        false
      )
    );
    if (this.props.detectScroll) {
      this.onRemoveEventListenersEmitter.once(
        addEventListener(
          getNearestScrollableContainer(this.excalidrawContainerRef.current),
          "scroll" /* SCROLL */,
          this.onScroll
        )
      );
    }
  }
  componentDidUpdate(prevProps, prevState) {
    this.updateEmbeddables();
    const elements = this.scene.getElementsIncludingDeleted();
    const elementsMap = this.scene.getNonDeletedElementsMap();
    if (!this.state.showWelcomeScreen && !elements.length) {
      this.setState({ showWelcomeScreen: true });
    }
    if (prevProps.UIOptions.dockedSidebarBreakpoint !== this.props.UIOptions.dockedSidebarBreakpoint) {
      this.refreshEditorBreakpoints();
    }
    const hasFollowedPersonLeft = prevState.userToFollow && !this.state.collaborators.has(prevState.userToFollow.socketId);
    if (hasFollowedPersonLeft) {
      this.maybeUnfollowRemoteUser();
    }
    if (prevState.zoom.value !== this.state.zoom.value || prevState.scrollX !== this.state.scrollX || prevState.scrollY !== this.state.scrollY) {
      this.props?.onScrollChange?.(
        this.state.scrollX,
        this.state.scrollY,
        this.state.zoom
      );
      this.onScrollChangeEmitter.trigger(
        this.state.scrollX,
        this.state.scrollY,
        this.state.zoom
      );
    }
    if (prevState.userToFollow !== this.state.userToFollow) {
      if (prevState.userToFollow) {
        this.onUserFollowEmitter.trigger({
          userToFollow: prevState.userToFollow,
          action: "UNFOLLOW"
        });
      }
      if (this.state.userToFollow) {
        this.onUserFollowEmitter.trigger({
          userToFollow: this.state.userToFollow,
          action: "FOLLOW"
        });
      }
    }
    if (Object.keys(this.state.selectedElementIds).length && isEraserActive(this.state)) {
      this.setState({
        activeTool: updateActiveTool(this.state, { type: "selection" })
      });
    }
    if (this.state.activeTool.type === "eraser" && prevState.theme !== this.state.theme) {
      setEraserCursor(this.interactiveCanvas, this.state.theme);
    }
    if (prevState.activeTool.type === "selection" && this.state.activeTool.type !== "selection" && this.state.showHyperlinkPopup) {
      this.setState({ showHyperlinkPopup: false });
    }
    if (prevProps.langCode !== this.props.langCode) {
      this.updateLanguage();
    }
    if (isEraserActive(prevState) && !isEraserActive(this.state)) {
      this.eraserTrail.endPath();
    }
    if (prevProps.viewModeEnabled !== this.props.viewModeEnabled) {
      this.setState({ viewModeEnabled: !!this.props.viewModeEnabled });
    }
    if (prevState.viewModeEnabled !== this.state.viewModeEnabled) {
      this.addEventListeners();
      this.deselectElements();
    }
    if (prevProps.zenModeEnabled !== this.props.zenModeEnabled) {
      this.setState({ zenModeEnabled: !!this.props.zenModeEnabled });
    }
    if (prevProps.theme !== this.props.theme && this.props.theme) {
      this.setState({ theme: this.props.theme });
    }
    if (prevProps.gridModeEnabled !== this.props.gridModeEnabled) {
      this.setState({
        gridSize: this.props.gridModeEnabled ? GRID_SIZE : null
      });
    }
    this.excalidrawContainerRef.current?.classList.toggle(
      "theme--dark",
      this.state.theme === "dark"
    );
    if (this.state.editingLinearElement && !this.state.selectedElementIds[this.state.editingLinearElement.elementId]) {
      setTimeout(() => {
        this.state.editingLinearElement && this.actionManager.executeAction(actionFinalize);
      });
    }
    if (this.state.editingElement?.isDeleted) {
      this.setState({ editingElement: null });
    }
    if (this.state.selectedLinearElement && !this.state.selectedElementIds[this.state.selectedLinearElement.elementId]) {
      this.setState({ selectedLinearElement: null });
    }
    const { multiElement } = prevState;
    if (prevState.activeTool !== this.state.activeTool && multiElement != null && isBindingEnabled(this.state) && isBindingElement(multiElement, false)) {
      maybeBindLinearElement(
        multiElement,
        this.state,
        this.scene,
        tupleToCoors(
          LinearElementEditor.getPointAtIndexGlobalCoordinates(
            multiElement,
            -1,
            elementsMap
          )
        ),
        elementsMap
      );
    }
    this.history.record(this.state, elements);
    if (!this.state.isLoading) {
      this.props.onChange?.(elements, this.state, this.files);
      this.onChangeEmitter.trigger(elements, this.state, this.files);
    }
  }
  renderInteractiveSceneCallback = ({
    atLeastOneVisibleElement,
    scrollBars,
    elementsMap
  }) => {
    if (scrollBars) {
      currentScrollBars = scrollBars;
    }
    const scrolledOutside = (
      // hide when editing text
      isTextElement(this.state.editingElement) ? false : !atLeastOneVisibleElement && elementsMap.size > 0
    );
    if (this.state.scrolledOutside !== scrolledOutside) {
      this.setState({ scrolledOutside });
    }
    this.scheduleImageRefresh();
  };
  onScroll = debounce(() => {
    const { offsetTop, offsetLeft } = this.getCanvasOffsets();
    this.setState((state) => {
      if (state.offsetLeft === offsetLeft && state.offsetTop === offsetTop) {
        return null;
      }
      return { offsetTop, offsetLeft };
    });
  }, SCROLL_TIMEOUT);
  // Copy/paste
  onCut = withBatchedUpdates((event) => {
    const isExcalidrawActive = this.excalidrawContainerRef.current?.contains(
      document.activeElement
    );
    if (!isExcalidrawActive || isWritableElement(event.target)) {
      return;
    }
    this.actionManager.executeAction(actionCut, "keyboard", event);
    event.preventDefault();
    event.stopPropagation();
  });
  onCopy = withBatchedUpdates((event) => {
    const isExcalidrawActive = this.excalidrawContainerRef.current?.contains(
      document.activeElement
    );
    if (!isExcalidrawActive || isWritableElement(event.target)) {
      return;
    }
    this.actionManager.executeAction(actionCopy, "keyboard", event);
    event.preventDefault();
    event.stopPropagation();
  });
  static resetTapTwice() {
    didTapTwice = false;
  }
  onTouchStart = (event) => {
    if (isIOS) {
      event.preventDefault();
    }
    if (!didTapTwice) {
      didTapTwice = true;
      clearTimeout(tappedTwiceTimer);
      tappedTwiceTimer = window.setTimeout(
        _App.resetTapTwice,
        TAP_TWICE_TIMEOUT
      );
      return;
    }
    if (didTapTwice && event.touches.length === 1) {
      const touch = event.touches[0];
      this.handleCanvasDoubleClick({
        clientX: touch.clientX,
        clientY: touch.clientY
      });
      didTapTwice = false;
      clearTimeout(tappedTwiceTimer);
    }
    if (event.touches.length === 2) {
      this.setState({
        selectedElementIds: makeNextSelectedElementIds({}, this.state),
        activeEmbeddable: null
      });
    }
  };
  onTouchEnd = (event) => {
    this.resetContextMenuTimer();
    if (event.touches.length > 0) {
      this.setState({
        previousSelectedElementIds: {},
        selectedElementIds: makeNextSelectedElementIds(
          this.state.previousSelectedElementIds,
          this.state
        )
      });
    } else {
      gesture.pointers.clear();
    }
  };
  pasteFromClipboard = withBatchedUpdates(
    async (event) => {
      const isPlainPaste = !!IS_PLAIN_PASTE;
      const target = document.activeElement;
      const isExcalidrawActive = this.excalidrawContainerRef.current?.contains(target);
      if (event && !isExcalidrawActive) {
        return;
      }
      const elementUnderCursor = document.elementFromPoint(
        this.lastViewportPosition.x,
        this.lastViewportPosition.y
      );
      if (event && (!(elementUnderCursor instanceof HTMLCanvasElement) || isWritableElement(target))) {
        return;
      }
      const { x: sceneX, y: sceneY } = viewportCoordsToSceneCoords(
        {
          clientX: this.lastViewportPosition.x,
          clientY: this.lastViewportPosition.y
        },
        this.state
      );
      let file2 = event?.clipboardData?.files[0];
      const data = await parseClipboard(event, isPlainPaste);
      if (!file2 && !isPlainPaste) {
        if (data.mixedContent) {
          return this.addElementsFromMixedContentPaste(data.mixedContent, {
            isPlainPaste,
            sceneX,
            sceneY
          });
        } else if (data.text) {
          const string = data.text.trim();
          if (string.startsWith("<svg") && string.endsWith("</svg>")) {
            file2 = SVGStringToFile(string);
          }
        }
      }
      if (isSupportedImageFile(file2) && !data.spreadsheet) {
        if (!this.isToolSupported("image")) {
          this.setState({ errorMessage: t("errors.imageToolNotSupported") });
          return;
        }
        const imageElement = this.createImageElement({ sceneX, sceneY });
        this.insertImageElement(imageElement, file2);
        this.initializeImageDimensions(imageElement);
        this.setState({
          selectedElementIds: makeNextSelectedElementIds(
            {
              [imageElement.id]: true
            },
            this.state
          )
        });
        return;
      }
      if (this.props.onPaste) {
        try {
          if (await this.props.onPaste(data, event) === false) {
            return;
          }
        } catch (error) {
          console.error(error);
        }
      }
      if (data.errorMessage) {
        this.setState({ errorMessage: data.errorMessage });
      } else if (data.spreadsheet && !isPlainPaste) {
        this.setState({
          pasteDialog: {
            data: data.spreadsheet,
            shown: true
          }
        });
      } else if (data.elements) {
        const elements = data.programmaticAPI ? convertToExcalidrawElements(
          data.elements
        ) : data.elements;
        this.addElementsFromPasteOrLibrary({
          elements,
          files: data.files || null,
          position: "cursor",
          retainSeed: isPlainPaste
        });
      } else if (data.text) {
        const nonEmptyLines = normalizeEOL(data.text).split(/\n+/).map((s4) => s4.trim()).filter(Boolean);
        const embbeddableUrls = nonEmptyLines.map((str) => maybeParseEmbedSrc(str)).filter((string) => {
          return embeddableURLValidator(string, this.props.validateEmbeddable) && (/^(http|https):\/\/[^\s/$.?#].[^\s]*$/.test(string) || getEmbedLink(string)?.type === "video");
        });
        if (!IS_PLAIN_PASTE && embbeddableUrls.length > 0 && // if there were non-embeddable text (lines) mixed in with embeddable
        // urls, ignore and paste as text
        embbeddableUrls.length === nonEmptyLines.length) {
          const embeddables = [];
          for (const url of embbeddableUrls) {
            const prevEmbeddable = embeddables[embeddables.length - 1];
            const embeddable = this.insertEmbeddableElement({
              sceneX: prevEmbeddable ? prevEmbeddable.x + prevEmbeddable.width + 20 : sceneX,
              sceneY,
              link: normalizeLink(url)
            });
            if (embeddable) {
              embeddables.push(embeddable);
            }
          }
          if (embeddables.length) {
            this.setState({
              selectedElementIds: Object.fromEntries(
                embeddables.map((embeddable) => [embeddable.id, true])
              )
            });
          }
          return;
        }
        this.addTextFromPaste(data.text, isPlainPaste);
      }
      this.setActiveTool({ type: "selection" });
      event?.preventDefault();
    }
  );
  addElementsFromPasteOrLibrary = (opts) => {
    const elements = restoreElements(opts.elements, null, void 0);
    const [minX, minY, maxX, maxY] = getCommonBounds(elements);
    const elementsCenterX = distance(minX, maxX) / 2;
    const elementsCenterY = distance(minY, maxY) / 2;
    const clientX = typeof opts.position === "object" ? opts.position.clientX : opts.position === "cursor" ? this.lastViewportPosition.x : this.state.width / 2 + this.state.offsetLeft;
    const clientY = typeof opts.position === "object" ? opts.position.clientY : opts.position === "cursor" ? this.lastViewportPosition.y : this.state.height / 2 + this.state.offsetTop;
    const { x: x3, y: y3 } = viewportCoordsToSceneCoords(
      { clientX, clientY },
      this.state
    );
    const dx = x3 - elementsCenterX;
    const dy = y3 - elementsCenterY;
    const [gridX, gridY] = getGridPoint(dx, dy, this.state.gridSize);
    const newElements = duplicateElements(
      elements.map((element) => {
        return newElementWith(element, {
          x: element.x + gridX - minX,
          y: element.y + gridY - minY
        });
      }),
      {
        randomizeSeed: !opts.retainSeed
      }
    );
    const allElements = [
      ...this.scene.getElementsIncludingDeleted(),
      ...newElements
    ];
    const topLayerFrame = this.getTopLayerFrameAtSceneCoords({ x: x3, y: y3 });
    if (topLayerFrame) {
      const eligibleElements = filterElementsEligibleAsFrameChildren(
        newElements,
        topLayerFrame
      );
      addElementsToFrame(allElements, eligibleElements, topLayerFrame);
    }
    this.scene.replaceAllElements(allElements);
    newElements.forEach((newElement2) => {
      if (isTextElement(newElement2) && isBoundToContainer(newElement2)) {
        const container = getContainerElement(
          newElement2,
          this.scene.getElementsMapIncludingDeleted()
        );
        redrawTextBoundingBox(
          newElement2,
          container,
          this.scene.getElementsMapIncludingDeleted()
        );
      }
    });
    if (opts.files) {
      this.files = { ...this.files, ...opts.files };
    }
    this.history.resumeRecording();
    const nextElementsToSelect = excludeElementsInFramesFromSelection(newElements);
    this.setState(
      {
        ...this.state,
        // keep sidebar (presumably the library) open if it's docked and
        // can fit.
        //
        // Note, we should close the sidebar only if we're dropping items
        // from library, not when pasting from clipboard. Alas.
        openSidebar: this.state.openSidebar && this.device.editor.canFitSidebar && jotaiStore.get(isSidebarDockedAtom) ? this.state.openSidebar : null,
        ...selectGroupsForSelectedElements(
          {
            editingGroupId: null,
            selectedElementIds: nextElementsToSelect.reduce(
              (acc, element) => {
                if (!isBoundToContainer(element)) {
                  acc[element.id] = true;
                }
                return acc;
              },
              {}
            )
          },
          this.scene.getNonDeletedElements(),
          this.state,
          this
        )
      },
      () => {
        if (opts.files) {
          this.addNewImagesToImageCache();
        }
      }
    );
    this.setActiveTool({ type: "selection" });
    if (opts.fitToContent) {
      this.scrollToContent(newElements, {
        fitToContent: true
      });
    }
  };
  // TODO rewrite this to paste both text & images at the same time if
  // pasted data contains both
  async addElementsFromMixedContentPaste(mixedContent, {
    isPlainPaste,
    sceneX,
    sceneY
  }) {
    if (!isPlainPaste && mixedContent.some((node) => node.type === "imageUrl") && this.isToolSupported("image")) {
      const imageURLs = mixedContent.filter((node) => node.type === "imageUrl").map((node) => node.value);
      const responses = await Promise.all(
        imageURLs.map(async (url) => {
          try {
            return { file: await ImageURLToFile(url) };
          } catch (error2) {
            return { errorMessage: error2.message };
          }
        })
      );
      let y3 = sceneY;
      let firstImageYOffsetDone = false;
      const nextSelectedIds = {};
      for (const response of responses) {
        if (response.file) {
          const imageElement = this.createImageElement({
            sceneX,
            sceneY: y3
          });
          const initializedImageElement = await this.insertImageElement(
            imageElement,
            response.file
          );
          if (initializedImageElement) {
            if (!firstImageYOffsetDone) {
              firstImageYOffsetDone = true;
              y3 -= initializedImageElement.height / 2;
            }
            mutateElement(initializedImageElement, { y: y3 }, false);
            y3 = imageElement.y + imageElement.height + 25;
            nextSelectedIds[imageElement.id] = true;
          }
        }
      }
      this.setState({
        selectedElementIds: makeNextSelectedElementIds(
          nextSelectedIds,
          this.state
        )
      });
      const error = responses.find((response) => !!response.errorMessage);
      if (error && error.errorMessage) {
        this.setState({ errorMessage: error.errorMessage });
      }
    } else {
      const textNodes = mixedContent.filter((node) => node.type === "text");
      if (textNodes.length) {
        this.addTextFromPaste(
          textNodes.map((node) => node.value).join("\n\n"),
          isPlainPaste
        );
      }
    }
  }
  addTextFromPaste(text, isPlainPaste = false) {
    const { x: x3, y: y3 } = viewportCoordsToSceneCoords(
      {
        clientX: this.lastViewportPosition.x,
        clientY: this.lastViewportPosition.y
      },
      this.state
    );
    const textElementProps = {
      x: x3,
      y: y3,
      strokeColor: this.state.currentItemStrokeColor,
      backgroundColor: this.state.currentItemBackgroundColor,
      fillStyle: this.state.currentItemFillStyle,
      strokeWidth: this.state.currentItemStrokeWidth,
      strokeStyle: this.state.currentItemStrokeStyle,
      roundness: null,
      roughness: this.state.currentItemRoughness,
      opacity: this.state.currentItemOpacity,
      text,
      fontSize: this.state.currentItemFontSize,
      fontFamily: this.state.currentItemFontFamily,
      textAlign: this.state.currentItemTextAlign,
      verticalAlign: DEFAULT_VERTICAL_ALIGN,
      locked: false
    };
    const LINE_GAP = 10;
    let currentY = y3;
    const lines = isPlainPaste ? [text] : text.split("\n");
    const textElements = lines.reduce(
      (acc, line2, idx) => {
        const text2 = line2.trim();
        const lineHeight = getDefaultLineHeight(textElementProps.fontFamily);
        if (text2.length) {
          const topLayerFrame = this.getTopLayerFrameAtSceneCoords({
            x: x3,
            y: currentY
          });
          const element = newTextElement({
            ...textElementProps,
            x: x3,
            y: currentY,
            text: text2,
            lineHeight,
            frameId: topLayerFrame ? topLayerFrame.id : null
          });
          acc.push(element);
          currentY += element.height + LINE_GAP;
        } else {
          const prevLine = lines[idx - 1]?.trim();
          if (prevLine) {
            currentY += getLineHeightInPx(textElementProps.fontSize, lineHeight) + LINE_GAP;
          }
        }
        return acc;
      },
      []
    );
    if (textElements.length === 0) {
      return;
    }
    const frameId = textElements[0].frameId;
    if (frameId) {
      this.scene.insertElementsAtIndex(
        textElements,
        this.scene.getElementIndex(frameId)
      );
    } else {
      this.scene.replaceAllElements([
        ...this.scene.getElementsIncludingDeleted(),
        ...textElements
      ]);
    }
    this.setState({
      selectedElementIds: makeNextSelectedElementIds(
        Object.fromEntries(textElements.map((el) => [el.id, true])),
        this.state
      )
    });
    if (!isPlainPaste && textElements.length > 1 && PLAIN_PASTE_TOAST_SHOWN === false && !this.device.editor.isMobile) {
      this.setToast({
        message: t("toast.pasteAsSingleElement", {
          shortcut: getShortcutKey("CtrlOrCmd+Shift+V")
        }),
        duration: 5e3
      });
      PLAIN_PASTE_TOAST_SHOWN = true;
    }
    this.history.resumeRecording();
  }
  setAppState = (state, callback) => {
    this.setState(state, callback);
  };
  removePointer = (event) => {
    if (touchTimeout) {
      this.resetContextMenuTimer();
    }
    gesture.pointers.delete(event.pointerId);
  };
  toggleLock = (source = "ui") => {
    if (!this.state.activeTool.locked) {
      trackEvent(
        "toolbar",
        "toggleLock",
        `${source} (${this.device.editor.isMobile ? "mobile" : "desktop"})`
      );
    }
    this.setState((prevState) => {
      return {
        activeTool: {
          ...prevState.activeTool,
          ...updateActiveTool(
            this.state,
            prevState.activeTool.locked ? { type: "selection" } : prevState.activeTool
          ),
          locked: !prevState.activeTool.locked
        }
      };
    });
  };
  updateFrameRendering = (opts) => {
    this.setState((prevState) => {
      const next = typeof opts === "function" ? opts(prevState.frameRendering) : opts;
      return {
        frameRendering: {
          enabled: next?.enabled ?? prevState.frameRendering.enabled,
          clip: next?.clip ?? prevState.frameRendering.clip,
          name: next?.name ?? prevState.frameRendering.name,
          outline: next?.outline ?? prevState.frameRendering.outline
        }
      };
    });
  };
  togglePenMode = (force) => {
    this.setState((prevState) => {
      return {
        penMode: force ?? !prevState.penMode,
        penDetected: true
      };
    });
  };
  onHandToolToggle = () => {
    this.actionManager.executeAction(actionToggleHandTool);
  };
  /**
   * Zooms on canvas viewport center
   */
  zoomCanvas = (value) => {
    this.setState({
      ...getStateForZoom(
        {
          viewportX: this.state.width / 2 + this.state.offsetLeft,
          viewportY: this.state.height / 2 + this.state.offsetTop,
          nextZoom: getNormalizedZoom(value)
        },
        this.state
      )
    });
  };
  cancelInProgressAnimation = null;
  scrollToContent = (target = this.scene.getNonDeletedElements(), opts) => {
    this.cancelInProgressAnimation?.();
    const targetElements = Array.isArray(target) ? target : [target];
    let zoom = this.state.zoom;
    let scrollX = this.state.scrollX;
    let scrollY = this.state.scrollY;
    if (opts?.fitToContent || opts?.fitToViewport) {
      const { appState } = zoomToFit({
        targetElements,
        appState: this.state,
        fitToViewport: !!opts?.fitToViewport,
        viewportZoomFactor: opts?.viewportZoomFactor
      });
      zoom = appState.zoom;
      scrollX = appState.scrollX;
      scrollY = appState.scrollY;
    } else {
      const scroll = calculateScrollCenter(targetElements, this.state);
      scrollX = scroll.scrollX;
      scrollY = scroll.scrollY;
    }
    if (opts?.animate) {
      const origScrollX = this.state.scrollX;
      const origScrollY = this.state.scrollY;
      const origZoom = this.state.zoom.value;
      const cancel = easeToValuesRAF({
        fromValues: {
          scrollX: origScrollX,
          scrollY: origScrollY,
          zoom: origZoom
        },
        toValues: { scrollX, scrollY, zoom: zoom.value },
        interpolateValue: (from3, to, progress, key) => {
          if (key === "zoom") {
            return from3 * Math.pow(to / from3, easeOut(progress));
          }
          return void 0;
        },
        onStep: ({ scrollX: scrollX2, scrollY: scrollY2, zoom: zoom2 }) => {
          this.setState({
            scrollX: scrollX2,
            scrollY: scrollY2,
            zoom: { value: zoom2 }
          });
        },
        onStart: () => {
          this.setState({ shouldCacheIgnoreZoom: true });
        },
        onEnd: () => {
          this.setState({ shouldCacheIgnoreZoom: false });
        },
        onCancel: () => {
          this.setState({ shouldCacheIgnoreZoom: false });
        },
        duration: opts?.duration ?? 500
      });
      this.cancelInProgressAnimation = () => {
        cancel();
        this.cancelInProgressAnimation = null;
      };
    } else {
      this.setState({ scrollX, scrollY, zoom });
    }
  };
  maybeUnfollowRemoteUser = () => {
    if (this.state.userToFollow) {
      this.setState({ userToFollow: null });
    }
  };
  /** use when changing scrollX/scrollY/zoom based on user interaction */
  translateCanvas = (state) => {
    this.cancelInProgressAnimation?.();
    this.maybeUnfollowRemoteUser();
    this.setState(state);
  };
  setToast = (toast) => {
    this.setState({ toast });
  };
  restoreFileFromShare = async () => {
    try {
      const webShareTargetCache = await caches.open("web-share-target");
      const response = await webShareTargetCache.match("shared-file");
      if (response) {
        const blob = await response.blob();
        const file2 = new File([blob], blob.name || "", { type: blob.type });
        this.loadFileToCanvas(file2, null);
        await webShareTargetCache.delete("shared-file");
        window.history.replaceState(null, APP_NAME, window.location.pathname);
      }
    } catch (error) {
      this.setState({ errorMessage: error.message });
    }
  };
  /** adds supplied files to existing files in the appState */
  addFiles = withBatchedUpdates(
    (files) => {
      const filesMap = files.reduce((acc, fileData) => {
        acc.set(fileData.id, fileData);
        return acc;
      }, /* @__PURE__ */ new Map());
      this.files = { ...this.files, ...Object.fromEntries(filesMap) };
      this.scene.getNonDeletedElements().forEach((element) => {
        if (isInitializedImageElement(element) && filesMap.has(element.fileId)) {
          this.imageCache.delete(element.fileId);
          ShapeCache.delete(element);
        }
      });
      this.scene.informMutation();
      this.addNewImagesToImageCache();
    }
  );
  updateScene = withBatchedUpdates(
    (sceneData) => {
      if (sceneData.commitToHistory) {
        this.history.resumeRecording();
      }
      if (sceneData.appState) {
        this.setState(sceneData.appState);
      }
      if (sceneData.elements) {
        this.scene.replaceAllElements(sceneData.elements);
      }
      if (sceneData.collaborators) {
        this.setState({ collaborators: sceneData.collaborators });
      }
    }
  );
  onSceneUpdated = () => {
    this.setState({});
  };
  /**
   * @returns whether the menu was toggled on or off
   */
  toggleSidebar = ({
    name,
    tab,
    force
  }) => {
    let nextName;
    if (force === void 0) {
      nextName = this.state.openSidebar?.name === name ? null : name;
    } else {
      nextName = force ? name : null;
    }
    this.setState({ openSidebar: nextName ? { name: nextName, tab } : null });
    return !!nextName;
  };
  updateCurrentCursorPosition = withBatchedUpdates(
    (event) => {
      this.lastViewportPosition.x = event.clientX;
      this.lastViewportPosition.y = event.clientY;
    }
  );
  // Input handling
  onKeyDown = withBatchedUpdates(
    (event) => {
      if ("Proxy" in window && (!event.shiftKey && /^[A-Z]$/.test(event.key) || event.shiftKey && /^[a-z]$/.test(event.key))) {
        event = new Proxy(event, {
          get(ev, prop) {
            const value = ev[prop];
            if (typeof value === "function") {
              return value.bind(ev);
            }
            return prop === "key" ? (
              // CapsLock inverts capitalization based on ShiftKey, so invert
              // it back
              event.shiftKey ? ev.key.toUpperCase() : ev.key.toLowerCase()
            ) : value;
          }
        });
      }
      if (event[KEYS.CTRL_OR_CMD] && event.key.toLowerCase() === KEYS.V) {
        IS_PLAIN_PASTE = event.shiftKey;
        clearTimeout(IS_PLAIN_PASTE_TIMER);
        IS_PLAIN_PASTE_TIMER = window.setTimeout(() => {
          IS_PLAIN_PASTE = false;
        }, 100);
      }
      if (event[KEYS.CTRL_OR_CMD] && isWritableElement(event.target)) {
        if (event.code === CODES.MINUS || event.code === CODES.EQUAL) {
          event.preventDefault();
          return;
        }
      }
      if (
        // inside an input
        isWritableElement(event.target) && // unless pressing escape (finalize action)
        event.key !== KEYS.ESCAPE || // or unless using arrows (to move between buttons)
        isArrowKey(event.key) && isInputLike(event.target)
      ) {
        return;
      }
      if (event.key === KEYS.QUESTION_MARK) {
        this.setState({
          openDialog: { name: "help" }
        });
        return;
      } else if (event.key.toLowerCase() === KEYS.E && event.shiftKey && event[KEYS.CTRL_OR_CMD]) {
        event.preventDefault();
        this.setState({ openDialog: { name: "imageExport" } });
        return;
      }
      if (event.key === KEYS.PAGE_UP || event.key === KEYS.PAGE_DOWN) {
        let offset2 = (event.shiftKey ? this.state.width : this.state.height) / this.state.zoom.value;
        if (event.key === KEYS.PAGE_DOWN) {
          offset2 = -offset2;
        }
        if (event.shiftKey) {
          this.translateCanvas((state) => ({
            scrollX: state.scrollX + offset2
          }));
        } else {
          this.translateCanvas((state) => ({
            scrollY: state.scrollY + offset2
          }));
        }
      }
      if (this.actionManager.handleKeyDown(event)) {
        return;
      }
      if (this.state.viewModeEnabled) {
        return;
      }
      if (event[KEYS.CTRL_OR_CMD] && this.state.isBindingEnabled) {
        this.setState({ isBindingEnabled: false });
      }
      if (isArrowKey(event.key)) {
        const step = this.state.gridSize && (event.shiftKey ? ELEMENT_TRANSLATE_AMOUNT : this.state.gridSize) || (event.shiftKey ? ELEMENT_SHIFT_TRANSLATE_AMOUNT : ELEMENT_TRANSLATE_AMOUNT);
        let offsetX = 0;
        let offsetY = 0;
        if (event.key === KEYS.ARROW_LEFT) {
          offsetX = -step;
        } else if (event.key === KEYS.ARROW_RIGHT) {
          offsetX = step;
        } else if (event.key === KEYS.ARROW_UP) {
          offsetY = -step;
        } else if (event.key === KEYS.ARROW_DOWN) {
          offsetY = step;
        }
        const selectedElements = this.scene.getSelectedElements({
          selectedElementIds: this.state.selectedElementIds,
          includeBoundTextElement: true,
          includeElementsInFrames: true
        });
        selectedElements.forEach((element) => {
          mutateElement(element, {
            x: element.x + offsetX,
            y: element.y + offsetY
          });
          updateBoundElements(element, this.scene.getNonDeletedElementsMap(), {
            simultaneouslyUpdated: selectedElements
          });
        });
        this.maybeSuggestBindingForAll(selectedElements);
        event.preventDefault();
      } else if (event.key === KEYS.ENTER) {
        const selectedElements = this.scene.getSelectedElements(this.state);
        if (selectedElements.length === 1) {
          const selectedElement = selectedElements[0];
          if (event[KEYS.CTRL_OR_CMD]) {
            if (isLinearElement(selectedElement)) {
              if (!this.state.editingLinearElement || this.state.editingLinearElement.elementId !== selectedElements[0].id) {
                this.history.resumeRecording();
                this.setState({
                  editingLinearElement: new LinearElementEditor(
                    selectedElement
                  )
                });
              }
            }
          } else if (isTextElement(selectedElement) || isValidTextContainer(selectedElement)) {
            let container;
            if (!isTextElement(selectedElement)) {
              container = selectedElement;
            }
            const midPoint = getContainerCenter(
              selectedElement,
              this.state,
              this.scene.getNonDeletedElementsMap()
            );
            const sceneX = midPoint.x;
            const sceneY = midPoint.y;
            this.startTextEditing({
              sceneX,
              sceneY,
              container
            });
            event.preventDefault();
            return;
          } else if (isFrameLikeElement(selectedElement)) {
            this.setState({
              editingFrame: selectedElement.id
            });
          }
        }
      } else if (!event.ctrlKey && !event.altKey && !event.metaKey && this.state.draggingElement === null) {
        const shape = findShapeByKey(event.key);
        if (shape) {
          if (this.state.activeTool.type !== shape) {
            trackEvent(
              "toolbar",
              shape,
              `keyboard (${this.device.editor.isMobile ? "mobile" : "desktop"})`
            );
          }
          this.setActiveTool({ type: shape });
          event.stopPropagation();
        } else if (event.key === KEYS.Q) {
          this.toggleLock("keyboard");
          event.stopPropagation();
        }
      }
      if (event.key === KEYS.SPACE && gesture.pointers.size === 0) {
        isHoldingSpace = true;
        setCursor(this.interactiveCanvas, CURSOR_TYPE.GRAB);
        event.preventDefault();
      }
      if ((event.key === KEYS.G || event.key === KEYS.S) && !event.altKey && !event[KEYS.CTRL_OR_CMD]) {
        const selectedElements = this.scene.getSelectedElements(this.state);
        if (this.state.activeTool.type === "selection" && !selectedElements.length) {
          return;
        }
        if (event.key === KEYS.G && (hasBackground(this.state.activeTool.type) || selectedElements.some((element) => hasBackground(element.type)))) {
          this.setState({ openPopup: "elementBackground" });
          event.stopPropagation();
        }
        if (event.key === KEYS.S) {
          this.setState({ openPopup: "elementStroke" });
          event.stopPropagation();
        }
      }
      if (event.key === KEYS.K && !event.altKey && !event[KEYS.CTRL_OR_CMD]) {
        if (this.state.activeTool.type === "laser") {
          this.setActiveTool({ type: "selection" });
        } else {
          this.setActiveTool({ type: "laser" });
        }
        return;
      }
      if (event[KEYS.CTRL_OR_CMD] && (event.key === KEYS.BACKSPACE || event.key === KEYS.DELETE)) {
        jotaiStore.set(activeConfirmDialogAtom, "clearCanvas");
      }
      const lowerCased = event.key.toLocaleLowerCase();
      const isPickingStroke = lowerCased === KEYS.S && event.shiftKey;
      const isPickingBackground = event.key === KEYS.I || lowerCased === KEYS.G && event.shiftKey;
      if (isPickingStroke || isPickingBackground) {
        this.openEyeDropper({
          type: isPickingStroke ? "stroke" : "background"
        });
      }
    }
  );
  onWheel = withBatchedUpdates((event) => {
    if (!(event.target instanceof HTMLCanvasElement) && event.ctrlKey) {
      event.preventDefault();
    }
  });
  onKeyUp = withBatchedUpdates((event) => {
    if (event.key === KEYS.SPACE) {
      if (this.state.viewModeEnabled) {
        setCursor(this.interactiveCanvas, CURSOR_TYPE.GRAB);
      } else if (this.state.activeTool.type === "selection") {
        resetCursor(this.interactiveCanvas);
      } else {
        setCursorForShape(this.interactiveCanvas, this.state);
        this.setState({
          selectedElementIds: makeNextSelectedElementIds({}, this.state),
          selectedGroupIds: {},
          editingGroupId: null,
          activeEmbeddable: null
        });
      }
      isHoldingSpace = false;
    }
    if (!event[KEYS.CTRL_OR_CMD] && !this.state.isBindingEnabled) {
      this.setState({ isBindingEnabled: true });
    }
    if (isArrowKey(event.key)) {
      const selectedElements = this.scene.getSelectedElements(this.state);
      const elementsMap = this.scene.getNonDeletedElementsMap();
      isBindingEnabled(this.state) ? bindOrUnbindSelectedElements(
        selectedElements,
        this.scene.getNonDeletedElements(),
        elementsMap
      ) : unbindLinearElements(selectedElements, elementsMap);
      this.setState({ suggestedBindings: [] });
    }
  });
  // We purposely widen the `tool` type so this helper can be called with
  // any tool without having to type check it
  isToolSupported = (tool) => {
    return this.props.UIOptions.tools?.[tool] !== false;
  };
  setActiveTool = (tool) => {
    if (!this.isToolSupported(tool.type)) {
      console.warn(
        `"${tool.type}" tool is disabled via "UIOptions.canvasActions.tools.${tool.type}"`
      );
      return;
    }
    const nextActiveTool = updateActiveTool(this.state, tool);
    if (nextActiveTool.type === "hand") {
      setCursor(this.interactiveCanvas, CURSOR_TYPE.GRAB);
    } else if (!isHoldingSpace) {
      setCursorForShape(this.interactiveCanvas, this.state);
    }
    if (isToolIcon(document.activeElement)) {
      this.focusContainer();
    }
    if (!isLinearElementType(nextActiveTool.type)) {
      this.setState({ suggestedBindings: [] });
    }
    if (nextActiveTool.type === "image") {
      this.onImageAction({
        insertOnCanvasDirectly: (tool.type === "image" && tool.insertOnCanvasDirectly) ?? false
      });
    }
    this.setState((prevState) => {
      const commonResets = {
        snapLines: prevState.snapLines.length ? [] : prevState.snapLines,
        originSnapOffset: null,
        activeEmbeddable: null
      };
      if (nextActiveTool.type !== "selection") {
        return {
          ...prevState,
          activeTool: nextActiveTool,
          selectedElementIds: makeNextSelectedElementIds({}, prevState),
          selectedGroupIds: makeNextSelectedElementIds({}, prevState),
          editingGroupId: null,
          multiElement: null,
          ...commonResets
        };
      }
      return {
        ...prevState,
        activeTool: nextActiveTool,
        ...commonResets
      };
    });
  };
  setOpenDialog = (dialogType) => {
    this.setState({ openDialog: dialogType });
  };
  setCursor = (cursor) => {
    setCursor(this.interactiveCanvas, cursor);
  };
  resetCursor = () => {
    resetCursor(this.interactiveCanvas);
  };
  /**
   * returns whether user is making a gesture with >= 2 fingers (points)
   * on o touch screen (not on a trackpad). Currently only relates to Darwin
   * (iOS/iPadOS,MacOS), but may work on other devices in the future if
   * GestureEvent is standardized.
   */
  isTouchScreenMultiTouchGesture = () => {
    return gesture.pointers.size >= 2;
  };
  getName = () => {
    return this.state.name || this.props.name || `${t("labels.untitled")}-${getDateTime()}`;
  };
  // fires only on Safari
  onGestureStart = withBatchedUpdates((event) => {
    event.preventDefault();
    if (this.isTouchScreenMultiTouchGesture()) {
      this.setState({
        selectedElementIds: makeNextSelectedElementIds({}, this.state),
        activeEmbeddable: null
      });
    }
    gesture.initialScale = this.state.zoom.value;
  });
  // fires only on Safari
  onGestureChange = withBatchedUpdates((event) => {
    event.preventDefault();
    if (this.isTouchScreenMultiTouchGesture()) {
      return;
    }
    const initialScale = gesture.initialScale;
    if (initialScale) {
      this.setState((state) => ({
        ...getStateForZoom(
          {
            viewportX: this.lastViewportPosition.x,
            viewportY: this.lastViewportPosition.y,
            nextZoom: getNormalizedZoom(initialScale * event.scale)
          },
          state
        )
      }));
    }
  });
  // fires only on Safari
  onGestureEnd = withBatchedUpdates((event) => {
    event.preventDefault();
    if (this.isTouchScreenMultiTouchGesture()) {
      this.setState({
        previousSelectedElementIds: {},
        selectedElementIds: makeNextSelectedElementIds(
          this.state.previousSelectedElementIds,
          this.state
        )
      });
    }
    gesture.initialScale = null;
  });
  handleTextWysiwyg(element, {
    isExistingElement = false
  }) {
    const elementsMap = this.scene.getElementsMapIncludingDeleted();
    const updateElement = (text, originalText, isDeleted) => {
      this.scene.replaceAllElements([
        // Not sure why we include deleted elements as well hence using deleted elements map
        ...this.scene.getElementsIncludingDeleted().map((_element) => {
          if (_element.id === element.id && isTextElement(_element)) {
            return updateTextElement(
              _element,
              getContainerElement(_element, elementsMap),
              elementsMap,
              {
                text,
                isDeleted,
                originalText
              }
            );
          }
          return _element;
        })
      ]);
    };
    textWysiwyg({
      id: element.id,
      canvas: this.canvas,
      getViewportCoords: (x3, y3) => {
        const { x: viewportX, y: viewportY } = sceneCoordsToViewportCoords(
          {
            sceneX: x3,
            sceneY: y3
          },
          this.state
        );
        return [
          viewportX - this.state.offsetLeft,
          viewportY - this.state.offsetTop
        ];
      },
      onChange: withBatchedUpdates((text) => {
        updateElement(text, text, false);
        if (isNonDeletedElement(element)) {
          updateBoundElements(element, elementsMap);
        }
      }),
      onSubmit: withBatchedUpdates(({ text, viaKeyboard, originalText }) => {
        const isDeleted = !text.trim();
        updateElement(text, originalText, isDeleted);
        if (!isDeleted && viaKeyboard) {
          const elementIdToSelect = element.containerId ? element.containerId : element.id;
          this.setState((prevState) => ({
            selectedElementIds: makeNextSelectedElementIds(
              {
                ...prevState.selectedElementIds,
                [elementIdToSelect]: true
              },
              prevState
            )
          }));
        }
        if (isDeleted) {
          fixBindingsAfterDeletion(this.scene.getNonDeletedElements(), [
            element
          ]);
        }
        if (!isDeleted || isExistingElement) {
          this.history.resumeRecording();
        }
        this.setState({
          draggingElement: null,
          editingElement: null
        });
        if (this.state.activeTool.locked) {
          setCursorForShape(this.interactiveCanvas, this.state);
        }
        this.focusContainer();
      }),
      element,
      excalidrawContainer: this.excalidrawContainerRef.current,
      app: this
    });
    this.deselectElements();
    updateElement(element.text, element.originalText, false);
  }
  deselectElements() {
    this.setState({
      selectedElementIds: makeNextSelectedElementIds({}, this.state),
      selectedGroupIds: {},
      editingGroupId: null,
      activeEmbeddable: null
    });
  }
  getTextElementAtPosition(x3, y3) {
    const element = this.getElementAtPosition(x3, y3, {
      includeBoundTextElement: true
    });
    if (element && isTextElement(element) && !element.isDeleted) {
      return element;
    }
    return null;
  }
  getElementAtPosition(x3, y3, opts) {
    const allHitElements = this.getElementsAtPosition(
      x3,
      y3,
      opts?.includeBoundTextElement,
      opts?.includeLockedElements
    );
    if (allHitElements.length > 1) {
      if (opts?.preferSelected) {
        for (let index2 = allHitElements.length - 1; index2 > -1; index2--) {
          if (this.state.selectedElementIds[allHitElements[index2].id]) {
            return allHitElements[index2];
          }
        }
      }
      const elementWithHighestZIndex = allHitElements[allHitElements.length - 1];
      return isHittingElementBoundingBoxWithoutHittingElement(
        elementWithHighestZIndex,
        this.state,
        this.frameNameBoundsCache,
        x3,
        y3,
        this.scene.getNonDeletedElementsMap()
      ) ? allHitElements[allHitElements.length - 2] : elementWithHighestZIndex;
    }
    if (allHitElements.length === 1) {
      return allHitElements[0];
    }
    return null;
  }
  getElementsAtPosition(x3, y3, includeBoundTextElement = false, includeLockedElements = false) {
    const elements = includeBoundTextElement && includeLockedElements ? this.scene.getNonDeletedElements() : this.scene.getNonDeletedElements().filter(
      (element) => (includeLockedElements || !element.locked) && (includeBoundTextElement || !(isTextElement(element) && element.containerId))
    );
    const elementsMap = this.scene.getNonDeletedElementsMap();
    return getElementsAtPosition(
      elements,
      (element) => hitTest(
        element,
        this.state,
        this.frameNameBoundsCache,
        x3,
        y3,
        elementsMap
      )
    ).filter((element) => {
      const containingFrame = getContainingFrame(element);
      return containingFrame && this.state.frameRendering.enabled && this.state.frameRendering.clip ? isCursorInFrame({ x: x3, y: y3 }, containingFrame, elementsMap) : true;
    });
  }
  startTextEditing = ({
    sceneX,
    sceneY,
    insertAtParentCenter = true,
    container
  }) => {
    let shouldBindToContainer = false;
    let parentCenterPosition = insertAtParentCenter && this.getTextWysiwygSnappedToCenterPosition(
      sceneX,
      sceneY,
      this.state,
      container
    );
    if (container && parentCenterPosition) {
      const boundTextElementToContainer = getBoundTextElement(
        container,
        this.scene.getNonDeletedElementsMap()
      );
      if (!boundTextElementToContainer) {
        shouldBindToContainer = true;
      }
    }
    let existingTextElement = null;
    const selectedElements = this.scene.getSelectedElements(this.state);
    if (selectedElements.length === 1) {
      if (isTextElement(selectedElements[0])) {
        existingTextElement = selectedElements[0];
      } else if (container) {
        existingTextElement = getBoundTextElement(
          selectedElements[0],
          this.scene.getNonDeletedElementsMap()
        );
      } else {
        existingTextElement = this.getTextElementAtPosition(sceneX, sceneY);
      }
    } else {
      existingTextElement = this.getTextElementAtPosition(sceneX, sceneY);
    }
    const fontFamily = existingTextElement?.fontFamily || this.state.currentItemFontFamily;
    const lineHeight = existingTextElement?.lineHeight || getDefaultLineHeight(fontFamily);
    const fontSize = this.state.currentItemFontSize;
    if (!existingTextElement && shouldBindToContainer && container && !isArrowElement(container)) {
      const fontString = {
        fontSize,
        fontFamily
      };
      const minWidth = getApproxMinLineWidth(
        getFontString(fontString),
        lineHeight
      );
      const minHeight = getApproxMinLineHeight(fontSize, lineHeight);
      const newHeight = Math.max(container.height, minHeight);
      const newWidth = Math.max(container.width, minWidth);
      mutateElement(container, { height: newHeight, width: newWidth });
      sceneX = container.x + newWidth / 2;
      sceneY = container.y + newHeight / 2;
      if (parentCenterPosition) {
        parentCenterPosition = this.getTextWysiwygSnappedToCenterPosition(
          sceneX,
          sceneY,
          this.state,
          container
        );
      }
    }
    const topLayerFrame = this.getTopLayerFrameAtSceneCoords({
      x: sceneX,
      y: sceneY
    });
    const element = existingTextElement ? existingTextElement : newTextElement({
      x: parentCenterPosition ? parentCenterPosition.elementCenterX : sceneX,
      y: parentCenterPosition ? parentCenterPosition.elementCenterY : sceneY,
      strokeColor: this.state.currentItemStrokeColor,
      backgroundColor: this.state.currentItemBackgroundColor,
      fillStyle: this.state.currentItemFillStyle,
      strokeWidth: this.state.currentItemStrokeWidth,
      strokeStyle: this.state.currentItemStrokeStyle,
      roughness: this.state.currentItemRoughness,
      opacity: this.state.currentItemOpacity,
      text: "",
      fontSize,
      fontFamily,
      textAlign: parentCenterPosition ? "center" : this.state.currentItemTextAlign,
      verticalAlign: parentCenterPosition ? VERTICAL_ALIGN.MIDDLE : DEFAULT_VERTICAL_ALIGN,
      containerId: shouldBindToContainer ? container?.id : void 0,
      groupIds: container?.groupIds ?? [],
      lineHeight,
      angle: container?.angle ?? 0,
      frameId: topLayerFrame ? topLayerFrame.id : null
    });
    if (!existingTextElement && shouldBindToContainer && container) {
      mutateElement(container, {
        boundElements: (container.boundElements || []).concat({
          type: "text",
          id: element.id
        })
      });
    }
    this.setState({ editingElement: element });
    if (!existingTextElement) {
      if (container && shouldBindToContainer) {
        const containerIndex = this.scene.getElementIndex(container.id);
        this.scene.insertElementAtIndex(element, containerIndex + 1);
      } else {
        this.scene.addNewElement(element);
      }
    }
    this.setState({
      editingElement: element
    });
    this.handleTextWysiwyg(element, {
      isExistingElement: !!existingTextElement
    });
  };
  handleCanvasDoubleClick = (event) => {
    if (this.state.multiElement) {
      return;
    }
    if (this.state.activeTool.type !== "selection") {
      return;
    }
    const selectedElements = this.scene.getSelectedElements(this.state);
    if (selectedElements.length === 1 && isLinearElement(selectedElements[0])) {
      if (event[KEYS.CTRL_OR_CMD] && (!this.state.editingLinearElement || this.state.editingLinearElement.elementId !== selectedElements[0].id)) {
        this.history.resumeRecording();
        this.setState({
          editingLinearElement: new LinearElementEditor(selectedElements[0])
        });
        return;
      } else if (this.state.editingLinearElement && this.state.editingLinearElement.elementId === selectedElements[0].id) {
        return;
      }
    }
    resetCursor(this.interactiveCanvas);
    let { x: sceneX, y: sceneY } = viewportCoordsToSceneCoords(
      event,
      this.state
    );
    const selectedGroupIds = getSelectedGroupIds(this.state);
    if (selectedGroupIds.length > 0) {
      const hitElement = this.getElementAtPosition(sceneX, sceneY);
      const selectedGroupId = hitElement && getSelectedGroupIdForElement(hitElement, this.state.selectedGroupIds);
      if (selectedGroupId) {
        this.setState((prevState) => ({
          ...prevState,
          ...selectGroupsForSelectedElements(
            {
              editingGroupId: selectedGroupId,
              selectedElementIds: { [hitElement.id]: true }
            },
            this.scene.getNonDeletedElements(),
            prevState,
            this
          )
        }));
        return;
      }
    }
    resetCursor(this.interactiveCanvas);
    if (!event[KEYS.CTRL_OR_CMD] && !this.state.viewModeEnabled) {
      const hitElement = this.getElementAtPosition(sceneX, sceneY);
      if (isIframeLikeElement(hitElement)) {
        this.setState({
          activeEmbeddable: { element: hitElement, state: "active" }
        });
        return;
      }
      const container = getTextBindableContainerAtPosition(
        this.scene.getNonDeletedElements(),
        this.state,
        sceneX,
        sceneY,
        this.scene.getNonDeletedElementsMap()
      );
      if (container) {
        if (hasBoundTextElement(container) || !isTransparent(container.backgroundColor) || isHittingElementNotConsideringBoundingBox(
          container,
          this.state,
          this.frameNameBoundsCache,
          [sceneX, sceneY],
          this.scene.getNonDeletedElementsMap()
        )) {
          const midPoint = getContainerCenter(
            container,
            this.state,
            this.scene.getNonDeletedElementsMap()
          );
          sceneX = midPoint.x;
          sceneY = midPoint.y;
        }
      }
      this.startTextEditing({
        sceneX,
        sceneY,
        insertAtParentCenter: !event.altKey,
        container
      });
    }
  };
  getElementLinkAtPosition = (scenePointer, hitElement) => {
    const elements = this.scene.getNonDeletedElements().slice().reverse();
    let hitElementIndex = Infinity;
    return elements.find((element, index2) => {
      if (hitElement && element.id === hitElement.id) {
        hitElementIndex = index2;
      }
      return element.link && index2 <= hitElementIndex && isPointHittingLink(
        element,
        this.scene.getNonDeletedElementsMap(),
        this.state,
        [scenePointer.x, scenePointer.y],
        this.device.editor.isMobile
      );
    });
  };
  redirectToLink = (event, isTouchScreen) => {
    const draggedDistance = distance2d(
      this.lastPointerDownEvent.clientX,
      this.lastPointerDownEvent.clientY,
      this.lastPointerUpEvent.clientX,
      this.lastPointerUpEvent.clientY
    );
    if (!this.hitLinkElement || // For touch screen allow dragging threshold else strict check
    isTouchScreen && draggedDistance > DRAGGING_THRESHOLD || !isTouchScreen && draggedDistance !== 0) {
      return;
    }
    const lastPointerDownCoords = viewportCoordsToSceneCoords(
      this.lastPointerDownEvent,
      this.state
    );
    const elementsMap = this.scene.getNonDeletedElementsMap();
    const lastPointerDownHittingLinkIcon = isPointHittingLink(
      this.hitLinkElement,
      elementsMap,
      this.state,
      [lastPointerDownCoords.x, lastPointerDownCoords.y],
      this.device.editor.isMobile
    );
    const lastPointerUpCoords = viewportCoordsToSceneCoords(
      this.lastPointerUpEvent,
      this.state
    );
    const lastPointerUpHittingLinkIcon = isPointHittingLink(
      this.hitLinkElement,
      elementsMap,
      this.state,
      [lastPointerUpCoords.x, lastPointerUpCoords.y],
      this.device.editor.isMobile
    );
    if (lastPointerDownHittingLinkIcon && lastPointerUpHittingLinkIcon) {
      let url = this.hitLinkElement.link;
      if (url) {
        url = normalizeLink(url);
        let customEvent;
        if (this.props.onLinkOpen) {
          customEvent = wrapEvent("excalidraw-link" /* EXCALIDRAW_LINK */, event.nativeEvent);
          this.props.onLinkOpen(
            {
              ...this.hitLinkElement,
              link: url
            },
            customEvent
          );
        }
        if (!customEvent?.defaultPrevented) {
          const target = isLocalLink(url) ? "_self" : "_blank";
          const newWindow = window.open(void 0, target);
          if (newWindow) {
            newWindow.opener = null;
            newWindow.location = url;
          }
        }
      }
    }
  };
  getTopLayerFrameAtSceneCoords = (sceneCoords) => {
    const elementsMap = this.scene.getNonDeletedElementsMap();
    const frames = this.scene.getNonDeletedFramesLikes().filter(
      (frame) => isCursorInFrame(sceneCoords, frame, elementsMap)
    );
    return frames.length ? frames[frames.length - 1] : null;
  };
  handleCanvasPointerMove = (event) => {
    this.savePointer(event.clientX, event.clientY, this.state.cursorButton);
    this.lastPointerMoveEvent = event.nativeEvent;
    if (gesture.pointers.has(event.pointerId)) {
      gesture.pointers.set(event.pointerId, {
        x: event.clientX,
        y: event.clientY
      });
    }
    const initialScale = gesture.initialScale;
    if (gesture.pointers.size === 2 && gesture.lastCenter && initialScale && gesture.initialDistance) {
      const center = getCenter(gesture.pointers);
      const deltaX = center.x - gesture.lastCenter.x;
      const deltaY = center.y - gesture.lastCenter.y;
      gesture.lastCenter = center;
      const distance5 = getDistance(Array.from(gesture.pointers.values()));
      const scaleFactor = this.state.activeTool.type === "freedraw" && this.state.penMode ? 1 : distance5 / gesture.initialDistance;
      const nextZoom = scaleFactor ? getNormalizedZoom(initialScale * scaleFactor) : this.state.zoom.value;
      this.setState((state) => {
        const zoomState = getStateForZoom(
          {
            viewportX: center.x,
            viewportY: center.y,
            nextZoom
          },
          state
        );
        this.translateCanvas({
          zoom: zoomState.zoom,
          scrollX: zoomState.scrollX + deltaX / nextZoom,
          scrollY: zoomState.scrollY + deltaY / nextZoom,
          shouldCacheIgnoreZoom: true
        });
      });
      this.resetShouldCacheIgnoreZoomDebounced();
    } else {
      gesture.lastCenter = gesture.initialDistance = gesture.initialScale = null;
    }
    if (isHoldingSpace || isPanning || isDraggingScrollBar || isHandToolActive(this.state)) {
      return;
    }
    const isPointerOverScrollBars = isOverScrollBars(
      currentScrollBars,
      event.clientX - this.state.offsetLeft,
      event.clientY - this.state.offsetTop
    );
    const isOverScrollBar = isPointerOverScrollBars.isOverEither;
    if (!this.state.draggingElement && !this.state.multiElement) {
      if (isOverScrollBar) {
        resetCursor(this.interactiveCanvas);
      } else {
        setCursorForShape(this.interactiveCanvas, this.state);
      }
    }
    const scenePointer = viewportCoordsToSceneCoords(event, this.state);
    const { x: scenePointerX, y: scenePointerY } = scenePointer;
    if (!this.state.draggingElement && isActiveToolNonLinearSnappable(this.state.activeTool.type)) {
      const { originOffset, snapLines } = getSnapLinesAtPointer(
        this.scene.getNonDeletedElements(),
        this.state,
        {
          x: scenePointerX,
          y: scenePointerY
        },
        event,
        this.scene.getNonDeletedElementsMap()
      );
      this.setState((prevState) => {
        const nextSnapLines = updateStable(prevState.snapLines, snapLines);
        const nextOriginOffset = prevState.originSnapOffset ? updateStable(prevState.originSnapOffset, originOffset) : originOffset;
        if (prevState.snapLines === nextSnapLines && prevState.originSnapOffset === nextOriginOffset) {
          return null;
        }
        return {
          snapLines: nextSnapLines,
          originSnapOffset: nextOriginOffset
        };
      });
    } else if (!this.state.draggingElement) {
      this.setState((prevState) => {
        if (prevState.snapLines.length) {
          return {
            snapLines: []
          };
        }
        return null;
      });
    }
    if (this.state.editingLinearElement && !this.state.editingLinearElement.isDragging) {
      const editingLinearElement = LinearElementEditor.handlePointerMove(
        event,
        scenePointerX,
        scenePointerY,
        this.state,
        this.scene.getNonDeletedElementsMap()
      );
      if (editingLinearElement && editingLinearElement !== this.state.editingLinearElement) {
        (0, import_react_dom9.flushSync)(() => {
          this.setState({
            editingLinearElement
          });
        });
      }
      if (editingLinearElement?.lastUncommittedPoint != null) {
        this.maybeSuggestBindingAtCursor(scenePointer);
      } else {
        (0, import_react_dom9.flushSync)(() => {
          this.setState({ suggestedBindings: [] });
        });
      }
    }
    if (isBindingElementType(this.state.activeTool.type)) {
      const { draggingElement } = this.state;
      if (isBindingElement(draggingElement, false)) {
        this.maybeSuggestBindingsForLinearElementAtCoords(
          draggingElement,
          [scenePointer],
          this.state.startBoundElement
        );
      } else {
        this.maybeSuggestBindingAtCursor(scenePointer);
      }
    }
    if (this.state.multiElement) {
      const { multiElement } = this.state;
      const { x: rx, y: ry } = multiElement;
      const { points, lastCommittedPoint } = multiElement;
      const lastPoint = points[points.length - 1];
      setCursorForShape(this.interactiveCanvas, this.state);
      if (lastPoint === lastCommittedPoint) {
        if (distance2d(
          scenePointerX - rx,
          scenePointerY - ry,
          lastPoint[0],
          lastPoint[1]
        ) >= LINE_CONFIRM_THRESHOLD) {
          mutateElement(multiElement, {
            points: [...points, [scenePointerX - rx, scenePointerY - ry]]
          });
        } else {
          setCursor(this.interactiveCanvas, CURSOR_TYPE.POINTER);
        }
      } else if (points.length > 2 && lastCommittedPoint && distance2d(
        scenePointerX - rx,
        scenePointerY - ry,
        lastCommittedPoint[0],
        lastCommittedPoint[1]
      ) < LINE_CONFIRM_THRESHOLD) {
        setCursor(this.interactiveCanvas, CURSOR_TYPE.POINTER);
        mutateElement(multiElement, {
          points: points.slice(0, -1)
        });
      } else {
        const [gridX, gridY] = getGridPoint(
          scenePointerX,
          scenePointerY,
          event[KEYS.CTRL_OR_CMD] ? null : this.state.gridSize
        );
        const [lastCommittedX, lastCommittedY] = multiElement?.lastCommittedPoint ?? [0, 0];
        let dxFromLastCommitted = gridX - rx - lastCommittedX;
        let dyFromLastCommitted = gridY - ry - lastCommittedY;
        if (shouldRotateWithDiscreteAngle(event)) {
          ({ width: dxFromLastCommitted, height: dyFromLastCommitted } = getLockedLinearCursorAlignSize(
            // actual coordinate of the last committed point
            lastCommittedX + rx,
            lastCommittedY + ry,
            // cursor-grid coordinate
            gridX,
            gridY
          ));
        }
        if (isPathALoop(points, this.state.zoom.value)) {
          setCursor(this.interactiveCanvas, CURSOR_TYPE.POINTER);
        }
        mutateElement(multiElement, {
          points: [
            ...points.slice(0, -1),
            [
              lastCommittedX + dxFromLastCommitted,
              lastCommittedY + dyFromLastCommitted
            ]
          ]
        });
      }
      return;
    }
    const hasDeselectedButton = Boolean(event.buttons);
    if (hasDeselectedButton || this.state.activeTool.type !== "selection" && this.state.activeTool.type !== "text" && this.state.activeTool.type !== "eraser") {
      return;
    }
    const elements = this.scene.getNonDeletedElements();
    const selectedElements = this.scene.getSelectedElements(this.state);
    if (selectedElements.length === 1 && !isOverScrollBar && !this.state.editingLinearElement) {
      const elementWithTransformHandleType = getElementWithTransformHandleType(
        elements,
        this.state,
        scenePointerX,
        scenePointerY,
        this.state.zoom,
        event.pointerType,
        this.scene.getNonDeletedElementsMap()
      );
      if (elementWithTransformHandleType && elementWithTransformHandleType.transformHandleType) {
        setCursor(
          this.interactiveCanvas,
          getCursorForResizingElement(elementWithTransformHandleType)
        );
        return;
      }
    } else if (selectedElements.length > 1 && !isOverScrollBar) {
      const transformHandleType = getTransformHandleTypeFromCoords(
        getCommonBounds(selectedElements),
        scenePointerX,
        scenePointerY,
        this.state.zoom,
        event.pointerType
      );
      if (transformHandleType) {
        setCursor(
          this.interactiveCanvas,
          getCursorForResizingElement({
            transformHandleType
          })
        );
        return;
      }
    }
    const hitElement = this.getElementAtPosition(
      scenePointer.x,
      scenePointer.y
    );
    this.hitLinkElement = this.getElementLinkAtPosition(
      scenePointer,
      hitElement
    );
    if (isEraserActive(this.state)) {
      return;
    }
    if (this.hitLinkElement && !this.state.selectedElementIds[this.hitLinkElement.id]) {
      setCursor(this.interactiveCanvas, CURSOR_TYPE.POINTER);
      showHyperlinkTooltip(
        this.hitLinkElement,
        this.state,
        this.scene.getNonDeletedElementsMap()
      );
    } else {
      hideHyperlinkToolip();
      if (hitElement && (hitElement.link || isEmbeddableElement(hitElement)) && this.state.selectedElementIds[hitElement.id] && !this.state.contextMenu && !this.state.showHyperlinkPopup) {
        this.setState({ showHyperlinkPopup: "info" });
      } else if (this.state.activeTool.type === "text") {
        setCursor(
          this.interactiveCanvas,
          isTextElement(hitElement) ? CURSOR_TYPE.TEXT : CURSOR_TYPE.CROSSHAIR
        );
      } else if (this.state.viewModeEnabled) {
        setCursor(this.interactiveCanvas, CURSOR_TYPE.GRAB);
      } else if (isOverScrollBar) {
        setCursor(this.interactiveCanvas, CURSOR_TYPE.AUTO);
      } else if (this.state.selectedLinearElement) {
        this.handleHoverSelectedLinearElement(
          this.state.selectedLinearElement,
          scenePointerX,
          scenePointerY
        );
      } else if (
        // if using cmd/ctrl, we're not dragging
        !event[KEYS.CTRL_OR_CMD]
      ) {
        if ((hitElement || this.isHittingCommonBoundingBoxOfSelectedElements(
          scenePointer,
          selectedElements
        )) && !hitElement?.locked) {
          if (hitElement && isIframeLikeElement(hitElement) && this.isIframeLikeElementCenter(
            hitElement,
            event,
            scenePointerX,
            scenePointerY
          )) {
            setCursor(this.interactiveCanvas, CURSOR_TYPE.POINTER);
            this.setState({
              activeEmbeddable: { element: hitElement, state: "hover" }
            });
          } else {
            setCursor(this.interactiveCanvas, CURSOR_TYPE.MOVE);
            if (this.state.activeEmbeddable?.state === "hover") {
              this.setState({ activeEmbeddable: null });
            }
          }
        }
      } else {
        setCursor(this.interactiveCanvas, CURSOR_TYPE.AUTO);
      }
    }
  };
  handleEraser = (event, pointerDownState, scenePointer) => {
    this.eraserTrail.addPointToPath(scenePointer.x, scenePointer.y);
    let didChange = false;
    const processedGroups = /* @__PURE__ */ new Set();
    const nonDeletedElements = this.scene.getNonDeletedElements();
    const processElements = (elements) => {
      for (const element of elements) {
        if (element.locked) {
          return;
        }
        if (event.altKey) {
          if (this.elementsPendingErasure.delete(element.id)) {
            didChange = true;
          }
        } else if (!this.elementsPendingErasure.has(element.id)) {
          didChange = true;
          this.elementsPendingErasure.add(element.id);
        }
        if (didChange && element.groupIds?.length) {
          const shallowestGroupId = element.groupIds.at(-1);
          if (!processedGroups.has(shallowestGroupId)) {
            processedGroups.add(shallowestGroupId);
            const elems = getElementsInGroup(
              nonDeletedElements,
              shallowestGroupId
            );
            for (const elem of elems) {
              if (event.altKey) {
                this.elementsPendingErasure.delete(elem.id);
              } else {
                this.elementsPendingErasure.add(elem.id);
              }
            }
          }
        }
      }
    };
    const distance5 = distance2d(
      pointerDownState.lastCoords.x,
      pointerDownState.lastCoords.y,
      scenePointer.x,
      scenePointer.y
    );
    const threshold = 10 / this.state.zoom.value;
    const point2 = { ...pointerDownState.lastCoords };
    let samplingInterval = 0;
    while (samplingInterval <= distance5) {
      const hitElements = this.getElementsAtPosition(point2.x, point2.y);
      processElements(hitElements);
      if (samplingInterval === distance5) {
        break;
      }
      samplingInterval = Math.min(samplingInterval + threshold, distance5);
      const distanceRatio = samplingInterval / distance5;
      const nextX = (1 - distanceRatio) * point2.x + distanceRatio * scenePointer.x;
      const nextY = (1 - distanceRatio) * point2.y + distanceRatio * scenePointer.y;
      point2.x = nextX;
      point2.y = nextY;
    }
    pointerDownState.lastCoords.x = scenePointer.x;
    pointerDownState.lastCoords.y = scenePointer.y;
    if (didChange) {
      for (const element of this.scene.getNonDeletedElements()) {
        if (isBoundToContainer(element) && (this.elementsPendingErasure.has(element.id) || this.elementsPendingErasure.has(element.containerId))) {
          if (event.altKey) {
            this.elementsPendingErasure.delete(element.id);
            this.elementsPendingErasure.delete(element.containerId);
          } else {
            this.elementsPendingErasure.add(element.id);
            this.elementsPendingErasure.add(element.containerId);
          }
        }
      }
      this.elementsPendingErasure = new Set(this.elementsPendingErasure);
      this.onSceneUpdated();
    }
  };
  // set touch moving for mobile context menu
  handleTouchMove = (event) => {
    invalidateContextMenu = true;
  };
  handleHoverSelectedLinearElement(linearElementEditor, scenePointerX, scenePointerY) {
    const elementsMap = this.scene.getNonDeletedElementsMap();
    const element = LinearElementEditor.getElement(
      linearElementEditor.elementId,
      elementsMap
    );
    const boundTextElement = getBoundTextElement(element, elementsMap);
    if (!element) {
      return;
    }
    if (this.state.selectedLinearElement) {
      let hoverPointIndex = -1;
      let segmentMidPointHoveredCoords = null;
      if (isHittingElementNotConsideringBoundingBox(
        element,
        this.state,
        this.frameNameBoundsCache,
        [scenePointerX, scenePointerY],
        elementsMap
      )) {
        hoverPointIndex = LinearElementEditor.getPointIndexUnderCursor(
          element,
          elementsMap,
          this.state.zoom,
          scenePointerX,
          scenePointerY
        );
        segmentMidPointHoveredCoords = LinearElementEditor.getSegmentMidpointHitCoords(
          linearElementEditor,
          { x: scenePointerX, y: scenePointerY },
          this.state,
          this.scene.getNonDeletedElementsMap()
        );
        if (hoverPointIndex >= 0 || segmentMidPointHoveredCoords) {
          setCursor(this.interactiveCanvas, CURSOR_TYPE.POINTER);
        } else {
          setCursor(this.interactiveCanvas, CURSOR_TYPE.MOVE);
        }
      } else if (shouldShowBoundingBox([element], this.state) && isHittingElementBoundingBoxWithoutHittingElement(
        element,
        this.state,
        this.frameNameBoundsCache,
        scenePointerX,
        scenePointerY,
        elementsMap
      )) {
        setCursor(this.interactiveCanvas, CURSOR_TYPE.MOVE);
      } else if (boundTextElement && hitTest(
        boundTextElement,
        this.state,
        this.frameNameBoundsCache,
        scenePointerX,
        scenePointerY,
        this.scene.getNonDeletedElementsMap()
      )) {
        setCursor(this.interactiveCanvas, CURSOR_TYPE.MOVE);
      }
      if (this.state.selectedLinearElement.hoverPointIndex !== hoverPointIndex) {
        this.setState({
          selectedLinearElement: {
            ...this.state.selectedLinearElement,
            hoverPointIndex
          }
        });
      }
      if (!LinearElementEditor.arePointsEqual(
        this.state.selectedLinearElement.segmentMidPointHoveredCoords,
        segmentMidPointHoveredCoords
      )) {
        this.setState({
          selectedLinearElement: {
            ...this.state.selectedLinearElement,
            segmentMidPointHoveredCoords
          }
        });
      }
    } else {
      setCursor(this.interactiveCanvas, CURSOR_TYPE.AUTO);
    }
  }
  handleCanvasPointerDown = (event) => {
    this.maybeCleanupAfterMissingPointerUp(event.nativeEvent);
    this.maybeUnfollowRemoteUser();
    if (this.state.contextMenu) {
      this.setState({ contextMenu: null });
    }
    if (this.state.snapLines) {
      this.setAppState({ snapLines: [] });
    }
    this.updateGestureOnPointerDown(event);
    if (event.pointerType === "touch" && this.state.draggingElement && this.state.draggingElement.type === "freedraw") {
      const element = this.state.draggingElement;
      this.updateScene({
        ...element.points.length < 10 ? {
          elements: this.scene.getElementsIncludingDeleted().filter((el) => el.id !== element.id)
        } : {},
        appState: {
          draggingElement: null,
          editingElement: null,
          startBoundElement: null,
          suggestedBindings: [],
          selectedElementIds: makeNextSelectedElementIds(
            Object.keys(this.state.selectedElementIds).filter((key) => key !== element.id).reduce((obj, key) => {
              obj[key] = this.state.selectedElementIds[key];
              return obj;
            }, {}),
            this.state
          )
        }
      });
      return;
    }
    const selection = document.getSelection();
    if (selection?.anchorNode) {
      selection.removeAllRanges();
    }
    this.maybeOpenContextMenuAfterPointerDownOnTouchDevices(event);
    if (!this.state.penDetected && event.pointerType === "pen") {
      this.setState((prevState) => {
        return {
          penMode: true,
          penDetected: true
        };
      });
    }
    if (!this.device.isTouchScreen && ["pen", "touch"].includes(event.pointerType)) {
      this.device = updateObject(this.device, { isTouchScreen: true });
    }
    if (isPanning) {
      return;
    }
    this.lastPointerDownEvent = event;
    if (this.handleCanvasPanUsingWheelOrSpaceDrag(event)) {
      return;
    }
    this.setState({
      lastPointerDownWith: event.pointerType,
      cursorButton: "down"
    });
    this.savePointer(event.clientX, event.clientY, "down");
    if (event.button === POINTER_BUTTON.ERASER && this.state.activeTool.type !== TOOL_TYPE.eraser) {
      this.setState(
        {
          activeTool: updateActiveTool(this.state, {
            type: TOOL_TYPE.eraser,
            lastActiveToolBeforeEraser: this.state.activeTool
          })
        },
        () => {
          this.handleCanvasPointerDown(event);
          const onPointerUp2 = () => {
            unsubPointerUp();
            unsubCleanup?.();
            if (isEraserActive(this.state)) {
              this.setState({
                activeTool: updateActiveTool(this.state, {
                  ...this.state.activeTool.lastActiveTool || {
                    type: TOOL_TYPE.selection
                  },
                  lastActiveToolBeforeEraser: null
                })
              });
            }
          };
          const unsubPointerUp = addEventListener(
            window,
            "pointerup" /* POINTER_UP */,
            onPointerUp2,
            {
              once: true
            }
          );
          let unsubCleanup;
          requestAnimationFrame(() => {
            unsubCleanup = this.missingPointerEventCleanupEmitter.once(onPointerUp2);
          });
        }
      );
      return;
    }
    if (event.button !== POINTER_BUTTON.MAIN && event.button !== POINTER_BUTTON.TOUCH && event.button !== POINTER_BUTTON.ERASER) {
      return;
    }
    if (gesture.pointers.size > 1) {
      return;
    }
    const pointerDownState = this.initialPointerDownState(event);
    this.setState({
      selectedElementsAreBeingDragged: false
    });
    if (this.handleDraggingScrollBar(event, pointerDownState)) {
      return;
    }
    this.clearSelectionIfNotUsingSelection();
    this.updateBindingEnabledOnPointerMove(event);
    if (this.handleSelectionOnPointerDown(event, pointerDownState)) {
      return;
    }
    const allowOnPointerDown = !this.state.penMode || event.pointerType !== "touch" || this.state.activeTool.type === "selection" || this.state.activeTool.type === "text" || this.state.activeTool.type === "image";
    if (!allowOnPointerDown) {
      return;
    }
    if (this.state.activeTool.type === "text") {
      this.handleTextOnPointerDown(event, pointerDownState);
      return;
    } else if (this.state.activeTool.type === "arrow" || this.state.activeTool.type === "line") {
      this.handleLinearElementOnPointerDown(
        event,
        this.state.activeTool.type,
        pointerDownState
      );
    } else if (this.state.activeTool.type === "image") {
      setCursor(this.interactiveCanvas, CURSOR_TYPE.CROSSHAIR);
      const pendingImageElement = this.state.pendingImageElementId && this.scene.getElement(this.state.pendingImageElementId);
      if (!pendingImageElement) {
        return;
      }
      this.setState({
        draggingElement: pendingImageElement,
        editingElement: pendingImageElement,
        pendingImageElementId: null,
        multiElement: null
      });
      const { x: x3, y: y3 } = viewportCoordsToSceneCoords(event, this.state);
      const frame = this.getTopLayerFrameAtSceneCoords({ x: x3, y: y3 });
      mutateElement(pendingImageElement, {
        x: x3,
        y: y3,
        frameId: frame ? frame.id : null
      });
    } else if (this.state.activeTool.type === "freedraw") {
      this.handleFreeDrawElementOnPointerDown(
        event,
        this.state.activeTool.type,
        pointerDownState
      );
    } else if (this.state.activeTool.type === "custom") {
      setCursorForShape(this.interactiveCanvas, this.state);
    } else if (this.state.activeTool.type === TOOL_TYPE.frame || this.state.activeTool.type === TOOL_TYPE.magicframe) {
      this.createFrameElementOnPointerDown(
        pointerDownState,
        this.state.activeTool.type
      );
    } else if (this.state.activeTool.type === "laser") {
      this.laserTrails.startPath(
        pointerDownState.lastCoords.x,
        pointerDownState.lastCoords.y
      );
    } else if (this.state.activeTool.type !== "eraser" && this.state.activeTool.type !== "hand") {
      this.createGenericElementOnPointerDown(
        this.state.activeTool.type,
        pointerDownState
      );
    }
    this.props?.onPointerDown?.(this.state.activeTool, pointerDownState);
    this.onPointerDownEmitter.trigger(
      this.state.activeTool,
      pointerDownState,
      event
    );
    if (this.state.activeTool.type === "eraser") {
      this.eraserTrail.startPath(
        pointerDownState.lastCoords.x,
        pointerDownState.lastCoords.y
      );
    }
    const onPointerMove = this.onPointerMoveFromPointerDownHandler(pointerDownState);
    const onPointerUp = this.onPointerUpFromPointerDownHandler(pointerDownState);
    const onKeyDown = this.onKeyDownFromPointerDownHandler(pointerDownState);
    const onKeyUp = this.onKeyUpFromPointerDownHandler(pointerDownState);
    this.missingPointerEventCleanupEmitter.once(
      (_event) => onPointerUp(_event || event.nativeEvent)
    );
    if (!this.state.viewModeEnabled || this.state.activeTool.type === "laser") {
      window.addEventListener("pointermove" /* POINTER_MOVE */, onPointerMove);
      window.addEventListener("pointerup" /* POINTER_UP */, onPointerUp);
      window.addEventListener("keydown" /* KEYDOWN */, onKeyDown);
      window.addEventListener("keyup" /* KEYUP */, onKeyUp);
      pointerDownState.eventListeners.onMove = onPointerMove;
      pointerDownState.eventListeners.onUp = onPointerUp;
      pointerDownState.eventListeners.onKeyUp = onKeyUp;
      pointerDownState.eventListeners.onKeyDown = onKeyDown;
    }
  };
  handleCanvasPointerUp = (event) => {
    this.removePointer(event);
    this.lastPointerUpEvent = event;
    const scenePointer = viewportCoordsToSceneCoords(
      { clientX: event.clientX, clientY: event.clientY },
      this.state
    );
    const clicklength = event.timeStamp - (this.lastPointerDownEvent?.timeStamp ?? 0);
    if (this.device.editor.isMobile && clicklength < 300) {
      const hitElement = this.getElementAtPosition(
        scenePointer.x,
        scenePointer.y
      );
      if (isIframeLikeElement(hitElement) && this.isIframeLikeElementCenter(
        hitElement,
        event,
        scenePointer.x,
        scenePointer.y
      )) {
        this.handleEmbeddableCenterClick(hitElement);
        return;
      }
    }
    if (this.device.isTouchScreen) {
      const hitElement = this.getElementAtPosition(
        scenePointer.x,
        scenePointer.y
      );
      this.hitLinkElement = this.getElementLinkAtPosition(
        scenePointer,
        hitElement
      );
    }
    if (this.hitLinkElement && !this.state.selectedElementIds[this.hitLinkElement.id]) {
      if (clicklength < 300 && isIframeLikeElement(this.hitLinkElement) && !isPointHittingLinkIcon(
        this.hitLinkElement,
        this.scene.getNonDeletedElementsMap(),
        this.state,
        [scenePointer.x, scenePointer.y]
      )) {
        this.handleEmbeddableCenterClick(this.hitLinkElement);
      } else {
        this.redirectToLink(event, this.device.isTouchScreen);
      }
    } else if (this.state.viewModeEnabled) {
      this.setState({
        activeEmbeddable: null,
        selectedElementIds: {}
      });
    }
  };
  maybeOpenContextMenuAfterPointerDownOnTouchDevices = (event) => {
    if (event.pointerType === "touch") {
      invalidateContextMenu = false;
      if (touchTimeout) {
        invalidateContextMenu = true;
      } else {
        touchTimeout = window.setTimeout(() => {
          touchTimeout = 0;
          if (!invalidateContextMenu) {
            this.handleCanvasContextMenu(event);
          }
        }, TOUCH_CTX_MENU_TIMEOUT);
      }
    }
  };
  resetContextMenuTimer = () => {
    clearTimeout(touchTimeout);
    touchTimeout = 0;
    invalidateContextMenu = false;
  };
  /**
   * pointerup may not fire in certian cases (user tabs away...), so in order
   * to properly cleanup pointerdown state, we need to fire any hanging
   * pointerup handlers manually
   */
  maybeCleanupAfterMissingPointerUp = (event) => {
    lastPointerUp?.();
    this.missingPointerEventCleanupEmitter.trigger(event).clear();
  };
  // Returns whether the event is a panning
  handleCanvasPanUsingWheelOrSpaceDrag = (event) => {
    if (!(gesture.pointers.size <= 1 && (event.button === POINTER_BUTTON.WHEEL || event.button === POINTER_BUTTON.MAIN && isHoldingSpace || isHandToolActive(this.state) || this.state.viewModeEnabled)) || isTextElement(this.state.editingElement)) {
      return false;
    }
    isPanning = true;
    event.preventDefault();
    let nextPastePrevented = false;
    const isLinux = typeof window === void 0 ? false : /Linux/.test(window.navigator.platform);
    setCursor(this.interactiveCanvas, CURSOR_TYPE.GRABBING);
    let { clientX: lastX, clientY: lastY } = event;
    const onPointerMove = withBatchedUpdatesThrottled((event2) => {
      const deltaX = lastX - event2.clientX;
      const deltaY = lastY - event2.clientY;
      lastX = event2.clientX;
      lastY = event2.clientY;
      if (isLinux && !nextPastePrevented && (Math.abs(deltaX) > 1 || Math.abs(deltaY) > 1)) {
        nextPastePrevented = true;
        const preventNextPaste = (event3) => {
          document.body.removeEventListener("paste" /* PASTE */, preventNextPaste);
          event3.stopPropagation();
        };
        const enableNextPaste = () => {
          setTimeout(() => {
            document.body.removeEventListener("paste" /* PASTE */, preventNextPaste);
            window.removeEventListener("pointerup" /* POINTER_UP */, enableNextPaste);
          }, 100);
        };
        document.body.addEventListener("paste" /* PASTE */, preventNextPaste);
        window.addEventListener("pointerup" /* POINTER_UP */, enableNextPaste);
      }
      this.translateCanvas({
        scrollX: this.state.scrollX - deltaX / this.state.zoom.value,
        scrollY: this.state.scrollY - deltaY / this.state.zoom.value
      });
    });
    const teardown = withBatchedUpdates(
      lastPointerUp = () => {
        lastPointerUp = null;
        isPanning = false;
        if (!isHoldingSpace) {
          if (this.state.viewModeEnabled) {
            setCursor(this.interactiveCanvas, CURSOR_TYPE.GRAB);
          } else {
            setCursorForShape(this.interactiveCanvas, this.state);
          }
        }
        this.setState({
          cursorButton: "up"
        });
        this.savePointer(event.clientX, event.clientY, "up");
        window.removeEventListener("pointermove" /* POINTER_MOVE */, onPointerMove);
        window.removeEventListener("pointerup" /* POINTER_UP */, teardown);
        window.removeEventListener("blur" /* BLUR */, teardown);
        onPointerMove.flush();
      }
    );
    window.addEventListener("blur" /* BLUR */, teardown);
    window.addEventListener("pointermove" /* POINTER_MOVE */, onPointerMove, {
      passive: true
    });
    window.addEventListener("pointerup" /* POINTER_UP */, teardown);
    return true;
  };
  updateGestureOnPointerDown(event) {
    gesture.pointers.set(event.pointerId, {
      x: event.clientX,
      y: event.clientY
    });
    if (gesture.pointers.size === 2) {
      gesture.lastCenter = getCenter(gesture.pointers);
      gesture.initialScale = this.state.zoom.value;
      gesture.initialDistance = getDistance(
        Array.from(gesture.pointers.values())
      );
    }
  }
  initialPointerDownState(event) {
    const origin = viewportCoordsToSceneCoords(event, this.state);
    const selectedElements = this.scene.getSelectedElements(this.state);
    const [minX, minY, maxX, maxY] = getCommonBounds(selectedElements);
    return {
      origin,
      withCmdOrCtrl: event[KEYS.CTRL_OR_CMD],
      originInGrid: tupleToCoors(
        getGridPoint(
          origin.x,
          origin.y,
          event[KEYS.CTRL_OR_CMD] ? null : this.state.gridSize
        )
      ),
      scrollbars: isOverScrollBars(
        currentScrollBars,
        event.clientX - this.state.offsetLeft,
        event.clientY - this.state.offsetTop
      ),
      // we need to duplicate because we'll be updating this state
      lastCoords: { ...origin },
      originalElements: this.scene.getNonDeletedElements().reduce((acc, element) => {
        acc.set(element.id, deepCopyElement(element));
        return acc;
      }, /* @__PURE__ */ new Map()),
      resize: {
        handleType: false,
        isResizing: false,
        offset: { x: 0, y: 0 },
        arrowDirection: "origin",
        center: { x: (maxX + minX) / 2, y: (maxY + minY) / 2 }
      },
      hit: {
        element: null,
        allHitElements: [],
        wasAddedToSelection: false,
        hasBeenDuplicated: false,
        hasHitCommonBoundingBoxOfSelectedElements: this.isHittingCommonBoundingBoxOfSelectedElements(
          origin,
          selectedElements
        )
      },
      drag: {
        hasOccurred: false,
        offset: null
      },
      eventListeners: {
        onMove: null,
        onUp: null,
        onKeyUp: null,
        onKeyDown: null
      },
      boxSelection: {
        hasOccurred: false
      }
    };
  }
  // Returns whether the event is a dragging a scrollbar
  handleDraggingScrollBar(event, pointerDownState) {
    if (!(pointerDownState.scrollbars.isOverEither && !this.state.multiElement)) {
      return false;
    }
    isDraggingScrollBar = true;
    pointerDownState.lastCoords.x = event.clientX;
    pointerDownState.lastCoords.y = event.clientY;
    const onPointerMove = withBatchedUpdatesThrottled((event2) => {
      const target = event2.target;
      if (!(target instanceof HTMLElement)) {
        return;
      }
      this.handlePointerMoveOverScrollbars(event2, pointerDownState);
    });
    const onPointerUp = withBatchedUpdates(() => {
      lastPointerUp = null;
      isDraggingScrollBar = false;
      setCursorForShape(this.interactiveCanvas, this.state);
      this.setState({
        cursorButton: "up"
      });
      this.savePointer(event.clientX, event.clientY, "up");
      window.removeEventListener("pointermove" /* POINTER_MOVE */, onPointerMove);
      window.removeEventListener("pointerup" /* POINTER_UP */, onPointerUp);
      onPointerMove.flush();
    });
    lastPointerUp = onPointerUp;
    window.addEventListener("pointermove" /* POINTER_MOVE */, onPointerMove);
    window.addEventListener("pointerup" /* POINTER_UP */, onPointerUp);
    return true;
  }
  clearSelectionIfNotUsingSelection = () => {
    if (this.state.activeTool.type !== "selection") {
      this.setState({
        selectedElementIds: makeNextSelectedElementIds({}, this.state),
        selectedGroupIds: {},
        editingGroupId: null,
        activeEmbeddable: null
      });
    }
  };
  /**
   * @returns whether the pointer event has been completely handled
   */
  handleSelectionOnPointerDown = (event, pointerDownState) => {
    if (this.state.activeTool.type === "selection") {
      const elements = this.scene.getNonDeletedElements();
      const elementsMap = this.scene.getNonDeletedElementsMap();
      const selectedElements = this.scene.getSelectedElements(this.state);
      if (selectedElements.length === 1 && !this.state.editingLinearElement) {
        const elementWithTransformHandleType = getElementWithTransformHandleType(
          elements,
          this.state,
          pointerDownState.origin.x,
          pointerDownState.origin.y,
          this.state.zoom,
          event.pointerType,
          this.scene.getNonDeletedElementsMap()
        );
        if (elementWithTransformHandleType != null) {
          this.setState({
            resizingElement: elementWithTransformHandleType.element
          });
          pointerDownState.resize.handleType = elementWithTransformHandleType.transformHandleType;
        }
      } else if (selectedElements.length > 1) {
        pointerDownState.resize.handleType = getTransformHandleTypeFromCoords(
          getCommonBounds(selectedElements),
          pointerDownState.origin.x,
          pointerDownState.origin.y,
          this.state.zoom,
          event.pointerType
        );
      }
      if (pointerDownState.resize.handleType) {
        pointerDownState.resize.isResizing = true;
        pointerDownState.resize.offset = tupleToCoors(
          getResizeOffsetXY(
            pointerDownState.resize.handleType,
            selectedElements,
            elementsMap,
            pointerDownState.origin.x,
            pointerDownState.origin.y
          )
        );
        if (selectedElements.length === 1 && isLinearElement(selectedElements[0]) && selectedElements[0].points.length === 2) {
          pointerDownState.resize.arrowDirection = getResizeArrowDirection(
            pointerDownState.resize.handleType,
            selectedElements[0]
          );
        }
      } else {
        if (this.state.selectedLinearElement) {
          const linearElementEditor = this.state.editingLinearElement || this.state.selectedLinearElement;
          const ret = LinearElementEditor.handlePointerDown(
            event,
            this.state,
            this.history,
            pointerDownState.origin,
            linearElementEditor,
            this.scene.getNonDeletedElements(),
            elementsMap
          );
          if (ret.hitElement) {
            pointerDownState.hit.element = ret.hitElement;
          }
          if (ret.linearElementEditor) {
            this.setState({ selectedLinearElement: ret.linearElementEditor });
            if (this.state.editingLinearElement) {
              this.setState({ editingLinearElement: ret.linearElementEditor });
            }
          }
          if (ret.didAddPoint) {
            return true;
          }
        }
        pointerDownState.hit.element = pointerDownState.hit.element ?? this.getElementAtPosition(
          pointerDownState.origin.x,
          pointerDownState.origin.y
        );
        if (pointerDownState.hit.element) {
          const hitLinkElement = this.getElementLinkAtPosition(
            {
              x: pointerDownState.origin.x,
              y: pointerDownState.origin.y
            },
            pointerDownState.hit.element
          );
          if (hitLinkElement) {
            return false;
          }
        }
        pointerDownState.hit.allHitElements = this.getElementsAtPosition(
          pointerDownState.origin.x,
          pointerDownState.origin.y
        );
        const hitElement = pointerDownState.hit.element;
        const someHitElementIsSelected = pointerDownState.hit.allHitElements.some(
          (element) => this.isASelectedElement(element)
        );
        if ((hitElement === null || !someHitElementIsSelected) && !event.shiftKey && !pointerDownState.hit.hasHitCommonBoundingBoxOfSelectedElements) {
          this.clearSelection(hitElement);
        }
        if (this.state.editingLinearElement) {
          this.setState({
            selectedElementIds: makeNextSelectedElementIds(
              {
                [this.state.editingLinearElement.elementId]: true
              },
              this.state
            )
          });
        } else if (hitElement != null) {
          if (event[KEYS.CTRL_OR_CMD]) {
            if (!this.state.selectedElementIds[hitElement.id]) {
              pointerDownState.hit.wasAddedToSelection = true;
            }
            this.setState((prevState) => ({
              ...editGroupForSelectedElement(prevState, hitElement),
              previousSelectedElementIds: this.state.selectedElementIds
            }));
            return false;
          }
          if (!this.state.selectedElementIds[hitElement.id]) {
            if (this.state.editingGroupId && !isElementInGroup(hitElement, this.state.editingGroupId)) {
              this.setState({
                selectedElementIds: makeNextSelectedElementIds({}, this.state),
                selectedGroupIds: {},
                editingGroupId: null,
                activeEmbeddable: null
              });
            }
            if (!someHitElementIsSelected && !pointerDownState.hit.hasHitCommonBoundingBoxOfSelectedElements) {
              this.setState((prevState) => {
                const nextSelectedElementIds = {
                  ...prevState.selectedElementIds,
                  [hitElement.id]: true
                };
                const previouslySelectedElements = [];
                Object.keys(prevState.selectedElementIds).forEach((id) => {
                  const element = this.scene.getElement(id);
                  element && previouslySelectedElements.push(element);
                });
                if (isFrameLikeElement(hitElement)) {
                  getFrameChildren(
                    previouslySelectedElements,
                    hitElement.id
                  ).forEach((element) => {
                    delete nextSelectedElementIds[element.id];
                  });
                } else if (hitElement.frameId) {
                  if (nextSelectedElementIds[hitElement.frameId]) {
                    delete nextSelectedElementIds[hitElement.id];
                  }
                } else {
                  const groupIds = hitElement.groupIds;
                  const framesInGroups = new Set(
                    groupIds.flatMap(
                      (gid) => getElementsInGroup(
                        this.scene.getNonDeletedElements(),
                        gid
                      )
                    ).filter((element) => isFrameLikeElement(element)).map((frame) => frame.id)
                  );
                  if (framesInGroups.size > 0) {
                    previouslySelectedElements.forEach((element) => {
                      if (element.frameId && framesInGroups.has(element.frameId)) {
                        delete nextSelectedElementIds[element.id];
                        element.groupIds.flatMap(
                          (gid) => getElementsInGroup(
                            this.scene.getNonDeletedElements(),
                            gid
                          )
                        ).forEach((element2) => {
                          delete nextSelectedElementIds[element2.id];
                        });
                      }
                    });
                  }
                }
                return {
                  ...selectGroupsForSelectedElements(
                    {
                      editingGroupId: prevState.editingGroupId,
                      selectedElementIds: nextSelectedElementIds
                    },
                    this.scene.getNonDeletedElements(),
                    prevState,
                    this
                  ),
                  showHyperlinkPopup: hitElement.link || isEmbeddableElement(hitElement) ? "info" : false
                };
              });
              pointerDownState.hit.wasAddedToSelection = true;
            }
          }
        }
        this.setState({
          previousSelectedElementIds: this.state.selectedElementIds
        });
      }
    }
    return false;
  };
  isASelectedElement(hitElement) {
    return hitElement != null && this.state.selectedElementIds[hitElement.id];
  }
  isHittingCommonBoundingBoxOfSelectedElements(point2, selectedElements) {
    if (selectedElements.length < 2) {
      return false;
    }
    const threshold = 10 / this.state.zoom.value;
    const [x1, y1, x22, y22] = getCommonBounds(selectedElements);
    return point2.x > x1 - threshold && point2.x < x22 + threshold && point2.y > y1 - threshold && point2.y < y22 + threshold;
  }
  handleTextOnPointerDown = (event, pointerDownState) => {
    if (isTextElement(this.state.editingElement)) {
      return;
    }
    let sceneX = pointerDownState.origin.x;
    let sceneY = pointerDownState.origin.y;
    const element = this.getElementAtPosition(sceneX, sceneY, {
      includeBoundTextElement: true
    });
    let container = getTextBindableContainerAtPosition(
      this.scene.getNonDeletedElements(),
      this.state,
      sceneX,
      sceneY,
      this.scene.getNonDeletedElementsMap()
    );
    if (hasBoundTextElement(element)) {
      container = element;
      sceneX = element.x + element.width / 2;
      sceneY = element.y + element.height / 2;
    }
    this.startTextEditing({
      sceneX,
      sceneY,
      insertAtParentCenter: !event.altKey,
      container
    });
    resetCursor(this.interactiveCanvas);
    if (!this.state.activeTool.locked) {
      this.setState({
        activeTool: updateActiveTool(this.state, { type: "selection" })
      });
    }
  };
  handleFreeDrawElementOnPointerDown = (event, elementType, pointerDownState) => {
    const [gridX, gridY] = getGridPoint(
      pointerDownState.origin.x,
      pointerDownState.origin.y,
      null
    );
    const topLayerFrame = this.getTopLayerFrameAtSceneCoords({
      x: gridX,
      y: gridY
    });
    const element = newFreeDrawElement({
      type: elementType,
      x: gridX,
      y: gridY,
      strokeColor: this.state.currentItemStrokeColor,
      backgroundColor: this.state.currentItemBackgroundColor,
      fillStyle: this.state.currentItemFillStyle,
      strokeWidth: this.state.currentItemStrokeWidth,
      strokeStyle: this.state.currentItemStrokeStyle,
      roughness: this.state.currentItemRoughness,
      opacity: this.state.currentItemOpacity,
      roundness: null,
      simulatePressure: event.pressure === 0.5,
      locked: false,
      frameId: topLayerFrame ? topLayerFrame.id : null
    });
    this.setState((prevState) => {
      const nextSelectedElementIds = {
        ...prevState.selectedElementIds
      };
      delete nextSelectedElementIds[element.id];
      return {
        selectedElementIds: makeNextSelectedElementIds(
          nextSelectedElementIds,
          prevState
        )
      };
    });
    const pressures = element.simulatePressure ? element.pressures : [...element.pressures, event.pressure];
    mutateElement(element, {
      points: [[0, 0]],
      pressures
    });
    const boundElement = getHoveredElementForBinding(
      pointerDownState.origin,
      this.scene.getNonDeletedElements(),
      this.scene.getNonDeletedElementsMap()
    );
    this.scene.addNewElement(element);
    this.setState({
      draggingElement: element,
      editingElement: element,
      startBoundElement: boundElement,
      suggestedBindings: []
    });
  };
  insertIframeElement = ({
    sceneX,
    sceneY,
    width,
    height
  }) => {
    const [gridX, gridY] = getGridPoint(
      sceneX,
      sceneY,
      this.lastPointerDownEvent?.[KEYS.CTRL_OR_CMD] ? null : this.state.gridSize
    );
    const element = newIframeElement({
      type: "iframe",
      x: gridX,
      y: gridY,
      strokeColor: "transparent",
      backgroundColor: "transparent",
      fillStyle: this.state.currentItemFillStyle,
      strokeWidth: this.state.currentItemStrokeWidth,
      strokeStyle: this.state.currentItemStrokeStyle,
      roughness: this.state.currentItemRoughness,
      roundness: this.getCurrentItemRoundness("iframe"),
      opacity: this.state.currentItemOpacity,
      locked: false,
      width,
      height
    });
    this.scene.replaceAllElements([
      ...this.scene.getElementsIncludingDeleted(),
      element
    ]);
    return element;
  };
  //create rectangle element with youtube top left on nearest grid point width / hight 640/360
  insertEmbeddableElement = ({
    sceneX,
    sceneY,
    link
  }) => {
    const [gridX, gridY] = getGridPoint(
      sceneX,
      sceneY,
      this.lastPointerDownEvent?.[KEYS.CTRL_OR_CMD] ? null : this.state.gridSize
    );
    const embedLink = getEmbedLink(link);
    if (!embedLink) {
      return;
    }
    if (embedLink.error instanceof URIError) {
      this.setToast({
        message: t("toast.unrecognizedLinkFormat"),
        closable: true
      });
    }
    const element = newEmbeddableElement({
      type: "embeddable",
      x: gridX,
      y: gridY,
      strokeColor: "transparent",
      backgroundColor: "transparent",
      fillStyle: this.state.currentItemFillStyle,
      strokeWidth: this.state.currentItemStrokeWidth,
      strokeStyle: this.state.currentItemStrokeStyle,
      roughness: this.state.currentItemRoughness,
      roundness: this.getCurrentItemRoundness("embeddable"),
      opacity: this.state.currentItemOpacity,
      locked: false,
      width: embedLink.intrinsicSize.w,
      height: embedLink.intrinsicSize.h,
      link
    });
    this.scene.replaceAllElements([
      ...this.scene.getElementsIncludingDeleted(),
      element
    ]);
    return element;
  };
  createImageElement = ({
    sceneX,
    sceneY,
    addToFrameUnderCursor = true
  }) => {
    const [gridX, gridY] = getGridPoint(
      sceneX,
      sceneY,
      this.lastPointerDownEvent?.[KEYS.CTRL_OR_CMD] ? null : this.state.gridSize
    );
    const topLayerFrame = addToFrameUnderCursor ? this.getTopLayerFrameAtSceneCoords({
      x: gridX,
      y: gridY
    }) : null;
    const element = newImageElement({
      type: "image",
      x: gridX,
      y: gridY,
      strokeColor: this.state.currentItemStrokeColor,
      backgroundColor: this.state.currentItemBackgroundColor,
      fillStyle: this.state.currentItemFillStyle,
      strokeWidth: this.state.currentItemStrokeWidth,
      strokeStyle: this.state.currentItemStrokeStyle,
      roughness: this.state.currentItemRoughness,
      roundness: null,
      opacity: this.state.currentItemOpacity,
      locked: false,
      frameId: topLayerFrame ? topLayerFrame.id : null
    });
    return element;
  };
  handleLinearElementOnPointerDown = (event, elementType, pointerDownState) => {
    if (this.state.multiElement) {
      const { multiElement } = this.state;
      if (multiElement.type === "line" && isPathALoop(multiElement.points, this.state.zoom.value)) {
        mutateElement(multiElement, {
          lastCommittedPoint: multiElement.points[multiElement.points.length - 1]
        });
        this.actionManager.executeAction(actionFinalize);
        return;
      }
      const { x: rx, y: ry, lastCommittedPoint } = multiElement;
      if (multiElement.points.length > 1 && lastCommittedPoint && distance2d(
        pointerDownState.origin.x - rx,
        pointerDownState.origin.y - ry,
        lastCommittedPoint[0],
        lastCommittedPoint[1]
      ) < LINE_CONFIRM_THRESHOLD) {
        this.actionManager.executeAction(actionFinalize);
        return;
      }
      this.setState((prevState) => ({
        selectedElementIds: makeNextSelectedElementIds(
          {
            ...prevState.selectedElementIds,
            [multiElement.id]: true
          },
          prevState
        )
      }));
      mutateElement(multiElement, {
        lastCommittedPoint: multiElement.points[multiElement.points.length - 1]
      });
      setCursor(this.interactiveCanvas, CURSOR_TYPE.POINTER);
    } else {
      const [gridX, gridY] = getGridPoint(
        pointerDownState.origin.x,
        pointerDownState.origin.y,
        event[KEYS.CTRL_OR_CMD] ? null : this.state.gridSize
      );
      const topLayerFrame = this.getTopLayerFrameAtSceneCoords({
        x: gridX,
        y: gridY
      });
      const { currentItemStartArrowhead, currentItemEndArrowhead } = this.state;
      const [startArrowhead, endArrowhead] = elementType === "arrow" ? [currentItemStartArrowhead, currentItemEndArrowhead] : [null, null];
      const element = newLinearElement({
        type: elementType,
        x: gridX,
        y: gridY,
        strokeColor: this.state.currentItemStrokeColor,
        backgroundColor: this.state.currentItemBackgroundColor,
        fillStyle: this.state.currentItemFillStyle,
        strokeWidth: this.state.currentItemStrokeWidth,
        strokeStyle: this.state.currentItemStrokeStyle,
        roughness: this.state.currentItemRoughness,
        opacity: this.state.currentItemOpacity,
        roundness: this.state.currentItemRoundness === "round" ? { type: ROUNDNESS.PROPORTIONAL_RADIUS } : null,
        startArrowhead,
        endArrowhead,
        locked: false,
        frameId: topLayerFrame ? topLayerFrame.id : null
      });
      this.setState((prevState) => {
        const nextSelectedElementIds = {
          ...prevState.selectedElementIds
        };
        delete nextSelectedElementIds[element.id];
        return {
          selectedElementIds: makeNextSelectedElementIds(
            nextSelectedElementIds,
            prevState
          )
        };
      });
      mutateElement(element, {
        points: [...element.points, [0, 0]]
      });
      const boundElement = getHoveredElementForBinding(
        pointerDownState.origin,
        this.scene.getNonDeletedElements(),
        this.scene.getNonDeletedElementsMap()
      );
      this.scene.addNewElement(element);
      this.setState({
        draggingElement: element,
        editingElement: element,
        startBoundElement: boundElement,
        suggestedBindings: []
      });
    }
  };
  getCurrentItemRoundness(elementType) {
    return this.state.currentItemRoundness === "round" ? {
      type: isUsingAdaptiveRadius(elementType) ? ROUNDNESS.ADAPTIVE_RADIUS : ROUNDNESS.PROPORTIONAL_RADIUS
    } : null;
  }
  createGenericElementOnPointerDown = (elementType, pointerDownState) => {
    const [gridX, gridY] = getGridPoint(
      pointerDownState.origin.x,
      pointerDownState.origin.y,
      this.lastPointerDownEvent?.[KEYS.CTRL_OR_CMD] ? null : this.state.gridSize
    );
    const topLayerFrame = this.getTopLayerFrameAtSceneCoords({
      x: gridX,
      y: gridY
    });
    const baseElementAttributes = {
      x: gridX,
      y: gridY,
      strokeColor: this.state.currentItemStrokeColor,
      backgroundColor: this.state.currentItemBackgroundColor,
      fillStyle: this.state.currentItemFillStyle,
      strokeWidth: this.state.currentItemStrokeWidth,
      strokeStyle: this.state.currentItemStrokeStyle,
      roughness: this.state.currentItemRoughness,
      opacity: this.state.currentItemOpacity,
      roundness: this.getCurrentItemRoundness(elementType),
      locked: false,
      frameId: topLayerFrame ? topLayerFrame.id : null
    };
    let element;
    if (elementType === "embeddable") {
      element = newEmbeddableElement({
        type: "embeddable",
        ...baseElementAttributes
      });
    } else {
      element = newElement({
        type: elementType,
        ...baseElementAttributes
      });
    }
    if (element.type === "selection") {
      this.setState({
        selectionElement: element,
        draggingElement: element
      });
    } else {
      this.scene.addNewElement(element);
      this.setState({
        multiElement: null,
        draggingElement: element,
        editingElement: element
      });
    }
  };
  createFrameElementOnPointerDown = (pointerDownState, type) => {
    const [gridX, gridY] = getGridPoint(
      pointerDownState.origin.x,
      pointerDownState.origin.y,
      this.lastPointerDownEvent?.[KEYS.CTRL_OR_CMD] ? null : this.state.gridSize
    );
    const constructorOpts = {
      x: gridX,
      y: gridY,
      opacity: this.state.currentItemOpacity,
      locked: false,
      ...FRAME_STYLE
    };
    const frame = type === TOOL_TYPE.magicframe ? newMagicFrameElement(constructorOpts) : newFrameElement(constructorOpts);
    this.scene.replaceAllElements([
      ...this.scene.getElementsIncludingDeleted(),
      frame
    ]);
    this.setState({
      multiElement: null,
      draggingElement: frame,
      editingElement: frame
    });
  };
  maybeCacheReferenceSnapPoints(event, selectedElements, recomputeAnyways = false) {
    if (isSnappingEnabled({
      event,
      appState: this.state,
      selectedElements
    }) && (recomputeAnyways || !SnapCache.getReferenceSnapPoints())) {
      SnapCache.setReferenceSnapPoints(
        getReferenceSnapPoints(
          this.scene.getNonDeletedElements(),
          selectedElements,
          this.state,
          this.scene.getNonDeletedElementsMap()
        )
      );
    }
  }
  maybeCacheVisibleGaps(event, selectedElements, recomputeAnyways = false) {
    if (isSnappingEnabled({
      event,
      appState: this.state,
      selectedElements
    }) && (recomputeAnyways || !SnapCache.getVisibleGaps())) {
      SnapCache.setVisibleGaps(
        getVisibleGaps(
          this.scene.getNonDeletedElements(),
          selectedElements,
          this.state,
          this.scene.getNonDeletedElementsMap()
        )
      );
    }
  }
  onKeyDownFromPointerDownHandler(pointerDownState) {
    return withBatchedUpdates((event) => {
      if (this.maybeHandleResize(pointerDownState, event)) {
        return;
      }
      this.maybeDragNewGenericElement(pointerDownState, event);
    });
  }
  onKeyUpFromPointerDownHandler(pointerDownState) {
    return withBatchedUpdates((event) => {
      event.key === KEYS.ALT && event.preventDefault();
      if (this.maybeHandleResize(pointerDownState, event)) {
        return;
      }
      this.maybeDragNewGenericElement(pointerDownState, event);
    });
  }
  onPointerMoveFromPointerDownHandler(pointerDownState) {
    return withBatchedUpdatesThrottled((event) => {
      if (pointerDownState.drag.offset === null) {
        pointerDownState.drag.offset = tupleToCoors(
          getDragOffsetXY(
            this.scene.getSelectedElements(this.state),
            pointerDownState.origin.x,
            pointerDownState.origin.y
          )
        );
      }
      const target = event.target;
      if (!(target instanceof HTMLElement)) {
        return;
      }
      if (this.handlePointerMoveOverScrollbars(event, pointerDownState)) {
        return;
      }
      const pointerCoords = viewportCoordsToSceneCoords(event, this.state);
      if (isEraserActive(this.state)) {
        this.handleEraser(event, pointerDownState, pointerCoords);
        return;
      }
      if (this.state.activeTool.type === "laser") {
        this.laserTrails.addPointToPath(pointerCoords.x, pointerCoords.y);
      }
      const [gridX, gridY] = getGridPoint(
        pointerCoords.x,
        pointerCoords.y,
        event[KEYS.CTRL_OR_CMD] ? null : this.state.gridSize
      );
      if (!pointerDownState.drag.hasOccurred && (this.state.activeTool.type === "arrow" || this.state.activeTool.type === "line")) {
        if (distance2d(
          pointerCoords.x,
          pointerCoords.y,
          pointerDownState.origin.x,
          pointerDownState.origin.y
        ) < DRAGGING_THRESHOLD) {
          return;
        }
      }
      if (pointerDownState.resize.isResizing) {
        pointerDownState.lastCoords.x = pointerCoords.x;
        pointerDownState.lastCoords.y = pointerCoords.y;
        if (this.maybeHandleResize(pointerDownState, event)) {
          return true;
        }
      }
      const elementsMap = this.scene.getNonDeletedElementsMap();
      if (this.state.selectedLinearElement) {
        const linearElementEditor = this.state.editingLinearElement || this.state.selectedLinearElement;
        if (LinearElementEditor.shouldAddMidpoint(
          this.state.selectedLinearElement,
          pointerCoords,
          this.state,
          elementsMap
        )) {
          const ret = LinearElementEditor.addMidpoint(
            this.state.selectedLinearElement,
            pointerCoords,
            this.state,
            !event[KEYS.CTRL_OR_CMD],
            elementsMap
          );
          if (!ret) {
            return;
          }
          (0, import_react_dom9.flushSync)(() => {
            if (this.state.selectedLinearElement) {
              this.setState({
                selectedLinearElement: {
                  ...this.state.selectedLinearElement,
                  pointerDownState: ret.pointerDownState,
                  selectedPointsIndices: ret.selectedPointsIndices
                }
              });
            }
            if (this.state.editingLinearElement) {
              this.setState({
                editingLinearElement: {
                  ...this.state.editingLinearElement,
                  pointerDownState: ret.pointerDownState,
                  selectedPointsIndices: ret.selectedPointsIndices
                }
              });
            }
          });
          return;
        } else if (linearElementEditor.pointerDownState.segmentMidpoint.value !== null && !linearElementEditor.pointerDownState.segmentMidpoint.added) {
          return;
        }
        const didDrag = LinearElementEditor.handlePointDragging(
          event,
          this.state,
          pointerCoords.x,
          pointerCoords.y,
          (element, pointsSceneCoords) => {
            this.maybeSuggestBindingsForLinearElementAtCoords(
              element,
              pointsSceneCoords
            );
          },
          linearElementEditor,
          this.scene.getNonDeletedElementsMap()
        );
        if (didDrag) {
          pointerDownState.lastCoords.x = pointerCoords.x;
          pointerDownState.lastCoords.y = pointerCoords.y;
          pointerDownState.drag.hasOccurred = true;
          if (this.state.editingLinearElement && !this.state.editingLinearElement.isDragging) {
            this.setState({
              editingLinearElement: {
                ...this.state.editingLinearElement,
                isDragging: true
              }
            });
          }
          if (!this.state.selectedLinearElement.isDragging) {
            this.setState({
              selectedLinearElement: {
                ...this.state.selectedLinearElement,
                isDragging: true
              }
            });
          }
          return;
        }
      }
      const hasHitASelectedElement = pointerDownState.hit.allHitElements.some(
        (element) => this.isASelectedElement(element)
      );
      const isSelectingPointsInLineEditor = this.state.editingLinearElement && event.shiftKey && this.state.editingLinearElement.elementId === pointerDownState.hit.element?.id;
      if ((hasHitASelectedElement || pointerDownState.hit.hasHitCommonBoundingBoxOfSelectedElements) && !isSelectingPointsInLineEditor) {
        const selectedElements = this.scene.getSelectedElements(this.state);
        if (selectedElements.every((element) => element.locked)) {
          return;
        }
        const selectedElementsHasAFrame = selectedElements.find(
          (e3) => isFrameLikeElement(e3)
        );
        const topLayerFrame = this.getTopLayerFrameAtSceneCoords(pointerCoords);
        this.setState({
          frameToHighlight: topLayerFrame && !selectedElementsHasAFrame ? topLayerFrame : null
        });
        pointerDownState.drag.hasOccurred = true;
        this.setState({
          selectedElementsAreBeingDragged: true
        });
        if (selectedElements.length > 0 && !pointerDownState.withCmdOrCtrl && !this.state.editingElement && this.state.activeEmbeddable?.state !== "active") {
          const dragOffset = {
            x: pointerCoords.x - pointerDownState.origin.x,
            y: pointerCoords.y - pointerDownState.origin.y
          };
          const originalElements = [
            ...pointerDownState.originalElements.values()
          ];
          const lockDirection = event.shiftKey;
          if (lockDirection) {
            const distanceX = Math.abs(dragOffset.x);
            const distanceY = Math.abs(dragOffset.y);
            const lockX = lockDirection && distanceX < distanceY;
            const lockY = lockDirection && distanceX > distanceY;
            if (lockX) {
              dragOffset.x = 0;
            }
            if (lockY) {
              dragOffset.y = 0;
            }
          }
          this.maybeCacheVisibleGaps(event, selectedElements);
          this.maybeCacheReferenceSnapPoints(event, selectedElements);
          const { snapOffset, snapLines } = snapDraggedElements(
            originalElements,
            dragOffset,
            this.state,
            event,
            this.scene.getNonDeletedElementsMap()
          );
          this.setState({ snapLines });
          !this.state.editingFrame && dragSelectedElements(
            pointerDownState,
            selectedElements,
            dragOffset,
            this.state,
            this.scene,
            snapOffset,
            event[KEYS.CTRL_OR_CMD] ? null : this.state.gridSize
          );
          this.maybeSuggestBindingForAll(selectedElements);
          if (event.altKey && !pointerDownState.hit.hasBeenDuplicated) {
            pointerDownState.hit.hasBeenDuplicated = true;
            const nextElements = [];
            const elementsToAppend = [];
            const groupIdMap = /* @__PURE__ */ new Map();
            const oldIdToDuplicatedId = /* @__PURE__ */ new Map();
            const hitElement = pointerDownState.hit.element;
            const selectedElementIds = new Set(
              this.scene.getSelectedElements({
                selectedElementIds: this.state.selectedElementIds,
                includeBoundTextElement: true,
                includeElementsInFrames: true
              }).map((element) => element.id)
            );
            const elements = this.scene.getElementsIncludingDeleted();
            for (const element of elements) {
              if (selectedElementIds.has(element.id) || // case: the state.selectedElementIds might not have been
              // updated yet by the time this mousemove event is fired
              element.id === hitElement?.id && pointerDownState.hit.wasAddedToSelection) {
                const duplicatedElement = duplicateElement(
                  this.state.editingGroupId,
                  groupIdMap,
                  element
                );
                const origElement = pointerDownState.originalElements.get(
                  element.id
                );
                mutateElement(duplicatedElement, {
                  x: origElement.x,
                  y: origElement.y
                });
                pointerDownState.originalElements.set(
                  duplicatedElement.id,
                  duplicatedElement
                );
                nextElements.push(duplicatedElement);
                elementsToAppend.push(element);
                oldIdToDuplicatedId.set(element.id, duplicatedElement.id);
              } else {
                nextElements.push(element);
              }
            }
            const nextSceneElements = [...nextElements, ...elementsToAppend];
            bindTextToShapeAfterDuplication(
              nextElements,
              elementsToAppend,
              oldIdToDuplicatedId
            );
            fixBindingsAfterDuplication(
              nextSceneElements,
              elementsToAppend,
              oldIdToDuplicatedId,
              "duplicatesServeAsOld"
            );
            bindElementsToFramesAfterDuplication(
              nextSceneElements,
              elementsToAppend,
              oldIdToDuplicatedId
            );
            this.scene.replaceAllElements(nextSceneElements);
            this.maybeCacheVisibleGaps(event, selectedElements, true);
            this.maybeCacheReferenceSnapPoints(event, selectedElements, true);
          }
          return;
        }
      }
      const draggingElement = this.state.draggingElement;
      if (!draggingElement) {
        return;
      }
      if (draggingElement.type === "freedraw") {
        const points = draggingElement.points;
        const dx = pointerCoords.x - draggingElement.x;
        const dy = pointerCoords.y - draggingElement.y;
        const lastPoint = points.length > 0 && points[points.length - 1];
        const discardPoint = lastPoint && lastPoint[0] === dx && lastPoint[1] === dy;
        if (!discardPoint) {
          const pressures = draggingElement.simulatePressure ? draggingElement.pressures : [...draggingElement.pressures, event.pressure];
          mutateElement(draggingElement, {
            points: [...points, [dx, dy]],
            pressures
          });
        }
      } else if (isLinearElement(draggingElement)) {
        pointerDownState.drag.hasOccurred = true;
        this.setState({
          selectedElementsAreBeingDragged: true
        });
        const points = draggingElement.points;
        let dx = gridX - draggingElement.x;
        let dy = gridY - draggingElement.y;
        if (shouldRotateWithDiscreteAngle(event) && points.length === 2) {
          ({ width: dx, height: dy } = getLockedLinearCursorAlignSize(
            draggingElement.x,
            draggingElement.y,
            pointerCoords.x,
            pointerCoords.y
          ));
        }
        if (points.length === 1) {
          mutateElement(draggingElement, {
            points: [...points, [dx, dy]]
          });
        } else if (points.length === 2) {
          mutateElement(draggingElement, {
            points: [...points.slice(0, -1), [dx, dy]]
          });
        }
        if (isBindingElement(draggingElement, false)) {
          this.maybeSuggestBindingsForLinearElementAtCoords(
            draggingElement,
            [pointerCoords],
            this.state.startBoundElement
          );
        }
      } else {
        pointerDownState.lastCoords.x = pointerCoords.x;
        pointerDownState.lastCoords.y = pointerCoords.y;
        this.maybeDragNewGenericElement(pointerDownState, event);
      }
      if (this.state.activeTool.type === "selection") {
        pointerDownState.boxSelection.hasOccurred = true;
        const elements = this.scene.getNonDeletedElements();
        if (this.state.editingLinearElement) {
          LinearElementEditor.handleBoxSelection(
            event,
            this.state,
            this.setState.bind(this),
            this.scene.getNonDeletedElementsMap()
          );
        } else {
          let shouldReuseSelection = true;
          if (!event.shiftKey && isSomeElementSelected(elements, this.state)) {
            if (pointerDownState.withCmdOrCtrl && pointerDownState.hit.element) {
              this.setState(
                (prevState) => selectGroupsForSelectedElements(
                  {
                    ...prevState,
                    selectedElementIds: {
                      [pointerDownState.hit.element.id]: true
                    }
                  },
                  this.scene.getNonDeletedElements(),
                  prevState,
                  this
                )
              );
            } else {
              shouldReuseSelection = false;
            }
          }
          const elementsWithinSelection = getElementsWithinSelection(
            elements,
            draggingElement,
            this.scene.getNonDeletedElementsMap()
          );
          this.setState((prevState) => {
            const nextSelectedElementIds = {
              ...shouldReuseSelection && prevState.selectedElementIds,
              ...elementsWithinSelection.reduce(
                (acc, element) => {
                  acc[element.id] = true;
                  return acc;
                },
                {}
              )
            };
            if (pointerDownState.hit.element) {
              if (!elementsWithinSelection.length) {
                nextSelectedElementIds[pointerDownState.hit.element.id] = true;
              } else {
                delete nextSelectedElementIds[pointerDownState.hit.element.id];
              }
            }
            prevState = !shouldReuseSelection ? { ...prevState, selectedGroupIds: {}, editingGroupId: null } : prevState;
            return {
              ...selectGroupsForSelectedElements(
                {
                  editingGroupId: prevState.editingGroupId,
                  selectedElementIds: nextSelectedElementIds
                },
                this.scene.getNonDeletedElements(),
                prevState,
                this
              ),
              // select linear element only when we haven't box-selected anything else
              selectedLinearElement: elementsWithinSelection.length === 1 && isLinearElement(elementsWithinSelection[0]) ? new LinearElementEditor(elementsWithinSelection[0]) : null,
              showHyperlinkPopup: elementsWithinSelection.length === 1 && (elementsWithinSelection[0].link || isEmbeddableElement(elementsWithinSelection[0])) ? "info" : false
            };
          });
        }
      }
    });
  }
  // Returns whether the pointer move happened over either scrollbar
  handlePointerMoveOverScrollbars(event, pointerDownState) {
    if (pointerDownState.scrollbars.isOverHorizontal) {
      const x3 = event.clientX;
      const dx = x3 - pointerDownState.lastCoords.x;
      this.translateCanvas({
        scrollX: this.state.scrollX - dx / this.state.zoom.value
      });
      pointerDownState.lastCoords.x = x3;
      return true;
    }
    if (pointerDownState.scrollbars.isOverVertical) {
      const y3 = event.clientY;
      const dy = y3 - pointerDownState.lastCoords.y;
      this.translateCanvas({
        scrollY: this.state.scrollY - dy / this.state.zoom.value
      });
      pointerDownState.lastCoords.y = y3;
      return true;
    }
    return false;
  }
  onPointerUpFromPointerDownHandler(pointerDownState) {
    return withBatchedUpdates((childEvent) => {
      this.removePointer(childEvent);
      if (pointerDownState.eventListeners.onMove) {
        pointerDownState.eventListeners.onMove.flush();
      }
      const {
        draggingElement,
        resizingElement,
        multiElement,
        activeTool,
        isResizing,
        isRotating
      } = this.state;
      this.setState((prevState) => ({
        isResizing: false,
        isRotating: false,
        resizingElement: null,
        selectionElement: null,
        frameToHighlight: null,
        elementsToHighlight: null,
        cursorButton: "up",
        // text elements are reset on finalize, and resetting on pointerup
        // may cause issues with double taps
        editingElement: multiElement || isTextElement(this.state.editingElement) ? this.state.editingElement : null,
        snapLines: updateStable(prevState.snapLines, []),
        originSnapOffset: null
      }));
      SnapCache.setReferenceSnapPoints(null);
      SnapCache.setVisibleGaps(null);
      this.savePointer(childEvent.clientX, childEvent.clientY, "up");
      this.setState({
        selectedElementsAreBeingDragged: false
      });
      const elementsMap = this.scene.getNonDeletedElementsMap();
      if (this.state.editingLinearElement) {
        if (!pointerDownState.boxSelection.hasOccurred && pointerDownState.hit?.element?.id !== this.state.editingLinearElement.elementId) {
          this.actionManager.executeAction(actionFinalize);
        } else {
          const editingLinearElement = LinearElementEditor.handlePointerUp(
            childEvent,
            this.state.editingLinearElement,
            this.state,
            this.scene.getNonDeletedElements(),
            elementsMap
          );
          if (editingLinearElement !== this.state.editingLinearElement) {
            this.setState({
              editingLinearElement,
              suggestedBindings: []
            });
          }
        }
      } else if (this.state.selectedLinearElement) {
        if (pointerDownState.hit?.element?.id !== this.state.selectedLinearElement.elementId) {
          const selectedELements = this.scene.getSelectedElements(this.state);
          if (selectedELements.length > 1) {
            this.setState({ selectedLinearElement: null });
          }
        } else {
          const linearElementEditor = LinearElementEditor.handlePointerUp(
            childEvent,
            this.state.selectedLinearElement,
            this.state,
            this.scene.getNonDeletedElements(),
            elementsMap
          );
          const { startBindingElement, endBindingElement } = linearElementEditor;
          const element = this.scene.getElement(linearElementEditor.elementId);
          if (isBindingElement(element)) {
            bindOrUnbindLinearElement(
              element,
              startBindingElement,
              endBindingElement,
              elementsMap
            );
          }
          if (linearElementEditor !== this.state.selectedLinearElement) {
            this.setState({
              selectedLinearElement: {
                ...linearElementEditor,
                selectedPointsIndices: null
              },
              suggestedBindings: []
            });
          }
        }
      }
      this.missingPointerEventCleanupEmitter.clear();
      window.removeEventListener(
        "pointermove" /* POINTER_MOVE */,
        pointerDownState.eventListeners.onMove
      );
      window.removeEventListener(
        "pointerup" /* POINTER_UP */,
        pointerDownState.eventListeners.onUp
      );
      window.removeEventListener(
        "keydown" /* KEYDOWN */,
        pointerDownState.eventListeners.onKeyDown
      );
      window.removeEventListener(
        "keyup" /* KEYUP */,
        pointerDownState.eventListeners.onKeyUp
      );
      if (this.state.pendingImageElementId) {
        this.setState({ pendingImageElementId: null });
      }
      this.props?.onPointerUp?.(activeTool, pointerDownState);
      this.onPointerUpEmitter.trigger(
        this.state.activeTool,
        pointerDownState,
        childEvent
      );
      if (draggingElement?.type === "freedraw") {
        const pointerCoords = viewportCoordsToSceneCoords(
          childEvent,
          this.state
        );
        const points = draggingElement.points;
        let dx = pointerCoords.x - draggingElement.x;
        let dy = pointerCoords.y - draggingElement.y;
        if (dx === points[0][0] && dy === points[0][1]) {
          dy += 1e-4;
          dx += 1e-4;
        }
        const pressures = draggingElement.simulatePressure ? [] : [...draggingElement.pressures, childEvent.pressure];
        mutateElement(draggingElement, {
          points: [...points, [dx, dy]],
          pressures,
          lastCommittedPoint: [dx, dy]
        });
        this.actionManager.executeAction(actionFinalize);
        return;
      }
      if (isImageElement(draggingElement)) {
        const imageElement = draggingElement;
        try {
          this.initializeImageDimensions(imageElement);
          this.setState(
            {
              selectedElementIds: makeNextSelectedElementIds(
                { [imageElement.id]: true },
                this.state
              )
            },
            () => {
              this.actionManager.executeAction(actionFinalize);
            }
          );
        } catch (error) {
          console.error(error);
          this.scene.replaceAllElements(
            this.scene.getElementsIncludingDeleted().filter((el) => el.id !== imageElement.id)
          );
          this.actionManager.executeAction(actionFinalize);
        }
        return;
      }
      if (isLinearElement(draggingElement)) {
        if (draggingElement.points.length > 1) {
          this.history.resumeRecording();
        }
        const pointerCoords = viewportCoordsToSceneCoords(
          childEvent,
          this.state
        );
        if (!pointerDownState.drag.hasOccurred && draggingElement && !multiElement) {
          mutateElement(draggingElement, {
            points: [
              ...draggingElement.points,
              [
                pointerCoords.x - draggingElement.x,
                pointerCoords.y - draggingElement.y
              ]
            ]
          });
          this.setState({
            multiElement: draggingElement,
            editingElement: this.state.draggingElement
          });
        } else if (pointerDownState.drag.hasOccurred && !multiElement) {
          if (isBindingEnabled(this.state) && isBindingElement(draggingElement, false)) {
            maybeBindLinearElement(
              draggingElement,
              this.state,
              this.scene,
              pointerCoords,
              elementsMap
            );
          }
          this.setState({ suggestedBindings: [], startBoundElement: null });
          if (!activeTool.locked) {
            resetCursor(this.interactiveCanvas);
            this.setState((prevState) => ({
              draggingElement: null,
              activeTool: updateActiveTool(this.state, {
                type: "selection"
              }),
              selectedElementIds: makeNextSelectedElementIds(
                {
                  ...prevState.selectedElementIds,
                  [draggingElement.id]: true
                },
                prevState
              ),
              selectedLinearElement: new LinearElementEditor(draggingElement)
            }));
          } else {
            this.setState((prevState) => ({
              draggingElement: null
            }));
          }
        }
        return;
      }
      if (activeTool.type !== "selection" && draggingElement && isInvisiblySmallElement(draggingElement)) {
        this.scene.replaceAllElements(
          this.scene.getElementsIncludingDeleted().filter((el) => el.id !== draggingElement.id)
        );
        this.setState({
          draggingElement: null
        });
        return;
      }
      if (draggingElement) {
        if (pointerDownState.drag.hasOccurred) {
          const sceneCoords = viewportCoordsToSceneCoords(
            childEvent,
            this.state
          );
          if (this.state.selectedLinearElement && this.state.selectedLinearElement.isDragging) {
            const linearElement = this.scene.getElement(
              this.state.selectedLinearElement.elementId
            );
            if (linearElement?.frameId) {
              const frame = getContainingFrame(linearElement);
              if (frame && linearElement) {
                if (!elementOverlapsWithFrame(
                  linearElement,
                  frame,
                  this.scene.getNonDeletedElementsMap()
                )) {
                  mutateElement(linearElement, {
                    groupIds: []
                  });
                  removeElementsFromFrame(
                    [linearElement],
                    this.scene.getNonDeletedElementsMap()
                  );
                  this.scene.informMutation();
                }
              }
            }
          } else {
            const topLayerFrame = this.getTopLayerFrameAtSceneCoords(sceneCoords);
            const selectedElements = this.scene.getSelectedElements(this.state);
            let nextElements = this.scene.getElementsMapIncludingDeleted();
            const updateGroupIdsAfterEditingGroup = (elements) => {
              if (elements.length > 0) {
                for (const element of elements) {
                  const index2 = element.groupIds.indexOf(
                    this.state.editingGroupId
                  );
                  mutateElement(
                    element,
                    {
                      groupIds: element.groupIds.slice(0, index2)
                    },
                    false
                  );
                }
                nextElements.forEach((element) => {
                  if (element.groupIds.length && getElementsInGroup(
                    nextElements,
                    element.groupIds[element.groupIds.length - 1]
                  ).length < 2) {
                    mutateElement(
                      element,
                      {
                        groupIds: []
                      },
                      false
                    );
                  }
                });
                this.setState({
                  editingGroupId: null
                });
              }
            };
            if (topLayerFrame && !this.state.selectedElementIds[topLayerFrame.id]) {
              const elementsToAdd = selectedElements.filter(
                (element) => element.frameId !== topLayerFrame.id && isElementInFrame(element, nextElements, this.state)
              );
              if (this.state.editingGroupId) {
                updateGroupIdsAfterEditingGroup(elementsToAdd);
              }
              nextElements = addElementsToFrame(
                nextElements,
                elementsToAdd,
                topLayerFrame
              );
            } else if (!topLayerFrame) {
              if (this.state.editingGroupId) {
                const elementsToRemove = selectedElements.filter(
                  (element) => element.frameId && !isElementInFrame(element, nextElements, this.state)
                );
                updateGroupIdsAfterEditingGroup(elementsToRemove);
              }
            }
            nextElements = updateFrameMembershipOfSelectedElements(
              nextElements,
              this.state,
              this
            );
            this.scene.replaceAllElements(nextElements);
          }
        }
        if (isFrameLikeElement(draggingElement)) {
          const elementsInsideFrame = getElementsInNewFrame(
            this.scene.getElementsIncludingDeleted(),
            draggingElement,
            this.scene.getNonDeletedElementsMap()
          );
          this.scene.replaceAllElements(
            addElementsToFrame(
              this.scene.getElementsMapIncludingDeleted(),
              elementsInsideFrame,
              draggingElement
            )
          );
        }
        mutateElement(
          draggingElement,
          getNormalizedDimensions(draggingElement)
        );
      }
      if (resizingElement) {
        this.history.resumeRecording();
      }
      if (resizingElement && isInvisiblySmallElement(resizingElement)) {
        this.scene.replaceAllElements(
          this.scene.getElementsIncludingDeleted().filter((el) => el.id !== resizingElement.id)
        );
      }
      if (pointerDownState.resize.isResizing) {
        let nextElements = updateFrameMembershipOfSelectedElements(
          this.scene.getElementsIncludingDeleted(),
          this.state,
          this
        );
        const selectedFrames = this.scene.getSelectedElements(this.state).filter(
          (element) => isFrameLikeElement(element)
        );
        for (const frame of selectedFrames) {
          nextElements = replaceAllElementsInFrame(
            nextElements,
            getElementsInResizingFrame(
              this.scene.getElementsIncludingDeleted(),
              frame,
              this.state,
              elementsMap
            ),
            frame,
            this
          );
        }
        this.scene.replaceAllElements(nextElements);
      }
      const hitElement = pointerDownState.hit.element;
      if (this.state.selectedLinearElement?.elementId !== hitElement?.id && isLinearElement(hitElement)) {
        const selectedELements = this.scene.getSelectedElements(this.state);
        if (selectedELements.length === 1) {
          this.setState({
            selectedLinearElement: new LinearElementEditor(hitElement)
          });
        }
      }
      const pointerStart = this.lastPointerDownEvent;
      const pointerEnd = this.lastPointerUpEvent || this.lastPointerMoveEvent;
      if (isEraserActive(this.state) && pointerStart && pointerEnd) {
        this.eraserTrail.endPath();
        const draggedDistance = distance2d(
          pointerStart.clientX,
          pointerStart.clientY,
          pointerEnd.clientX,
          pointerEnd.clientY
        );
        if (draggedDistance === 0) {
          const scenePointer = viewportCoordsToSceneCoords(
            {
              clientX: pointerEnd.clientX,
              clientY: pointerEnd.clientY
            },
            this.state
          );
          const hitElements = this.getElementsAtPosition(
            scenePointer.x,
            scenePointer.y
          );
          hitElements.forEach(
            (hitElement2) => this.elementsPendingErasure.add(hitElement2.id)
          );
        }
        this.eraseElements();
        return;
      } else if (this.elementsPendingErasure.size) {
        this.restoreReadyToEraseElements();
      }
      if (hitElement && !pointerDownState.drag.hasOccurred && !pointerDownState.hit.wasAddedToSelection && // if we're editing a line, pointerup shouldn't switch selection if
      // box selected
      (!this.state.editingLinearElement || !pointerDownState.boxSelection.hasOccurred)) {
        if (childEvent.shiftKey && !this.state.editingLinearElement) {
          if (this.state.selectedElementIds[hitElement.id]) {
            if (isSelectedViaGroup(this.state, hitElement)) {
              this.setState((_prevState) => {
                const nextSelectedElementIds = {
                  ..._prevState.selectedElementIds
                };
                for (const groupedElement of hitElement.groupIds.flatMap(
                  (groupId) => getElementsInGroup(
                    this.scene.getNonDeletedElements(),
                    groupId
                  )
                )) {
                  delete nextSelectedElementIds[groupedElement.id];
                }
                return {
                  selectedGroupIds: {
                    ..._prevState.selectedElementIds,
                    ...hitElement.groupIds.map((gId) => ({ [gId]: false })).reduce((prev, acc) => ({ ...prev, ...acc }), {})
                  },
                  selectedElementIds: makeNextSelectedElementIds(
                    nextSelectedElementIds,
                    _prevState
                  )
                };
              });
            } else if (!this.state.selectedLinearElement?.isDragging) {
              this.setState((prevState) => {
                const newSelectedElementIds = {
                  ...prevState.selectedElementIds
                };
                delete newSelectedElementIds[hitElement.id];
                const newSelectedElements = getSelectedElements(
                  this.scene.getNonDeletedElements(),
                  { selectedElementIds: newSelectedElementIds }
                );
                return {
                  ...selectGroupsForSelectedElements(
                    {
                      editingGroupId: prevState.editingGroupId,
                      selectedElementIds: newSelectedElementIds
                    },
                    this.scene.getNonDeletedElements(),
                    prevState,
                    this
                  ),
                  // set selectedLinearElement only if thats the only element selected
                  selectedLinearElement: newSelectedElements.length === 1 && isLinearElement(newSelectedElements[0]) ? new LinearElementEditor(newSelectedElements[0]) : prevState.selectedLinearElement
                };
              });
            }
          } else if (hitElement.frameId && this.state.selectedElementIds[hitElement.frameId]) {
            this.setState((prevState) => {
              const nextSelectedElementIds = {
                ...prevState.selectedElementIds,
                [hitElement.id]: true
              };
              delete nextSelectedElementIds[hitElement.frameId];
              (this.scene.getElement(hitElement.frameId)?.groupIds ?? []).flatMap(
                (gid) => getElementsInGroup(this.scene.getNonDeletedElements(), gid)
              ).forEach((element) => {
                delete nextSelectedElementIds[element.id];
              });
              return {
                ...selectGroupsForSelectedElements(
                  {
                    editingGroupId: prevState.editingGroupId,
                    selectedElementIds: nextSelectedElementIds
                  },
                  this.scene.getNonDeletedElements(),
                  prevState,
                  this
                ),
                showHyperlinkPopup: hitElement.link || isEmbeddableElement(hitElement) ? "info" : false
              };
            });
          } else {
            this.setState((_prevState) => ({
              selectedElementIds: makeNextSelectedElementIds(
                {
                  ..._prevState.selectedElementIds,
                  [hitElement.id]: true
                },
                _prevState
              )
            }));
          }
        } else {
          this.setState((prevState) => ({
            ...selectGroupsForSelectedElements(
              {
                editingGroupId: prevState.editingGroupId,
                selectedElementIds: { [hitElement.id]: true }
              },
              this.scene.getNonDeletedElements(),
              prevState,
              this
            ),
            selectedLinearElement: isLinearElement(hitElement) && // Don't set `selectedLinearElement` if its same as the hitElement, this is mainly to prevent resetting the `hoverPointIndex` to -1.
            // Future we should update the API to take care of setting the correct `hoverPointIndex` when initialized
            prevState.selectedLinearElement?.elementId !== hitElement.id ? new LinearElementEditor(hitElement) : prevState.selectedLinearElement
          }));
        }
      }
      if (!pointerDownState.drag.hasOccurred && !this.state.isResizing && (hitElement && isHittingElementBoundingBoxWithoutHittingElement(
        hitElement,
        this.state,
        this.frameNameBoundsCache,
        pointerDownState.origin.x,
        pointerDownState.origin.y,
        this.scene.getNonDeletedElementsMap()
      ) || !hitElement && pointerDownState.hit.hasHitCommonBoundingBoxOfSelectedElements)) {
        if (this.state.editingLinearElement) {
          this.setState({ editingLinearElement: null });
        } else {
          this.setState({
            selectedElementIds: makeNextSelectedElementIds({}, this.state),
            selectedGroupIds: {},
            editingGroupId: null,
            activeEmbeddable: null
          });
        }
        return;
      }
      if (!activeTool.locked && activeTool.type !== "freedraw" && draggingElement && draggingElement.type !== "selection") {
        this.setState((prevState) => ({
          selectedElementIds: makeNextSelectedElementIds(
            {
              ...prevState.selectedElementIds,
              [draggingElement.id]: true
            },
            prevState
          ),
          showHyperlinkPopup: isEmbeddableElement(draggingElement) && !draggingElement.link ? "editor" : prevState.showHyperlinkPopup
        }));
      }
      if (activeTool.type !== "selection" || isSomeElementSelected(this.scene.getNonDeletedElements(), this.state)) {
        this.history.resumeRecording();
      }
      if (pointerDownState.drag.hasOccurred || isResizing || isRotating) {
        isBindingEnabled(this.state) ? bindOrUnbindSelectedElements(
          this.scene.getSelectedElements(this.state),
          this.scene.getNonDeletedElements(),
          elementsMap
        ) : unbindLinearElements(
          this.scene.getSelectedElements(this.state),
          elementsMap
        );
      }
      if (activeTool.type === "laser") {
        this.laserTrails.endPath();
        return;
      }
      if (!activeTool.locked && activeTool.type !== "freedraw") {
        resetCursor(this.interactiveCanvas);
        this.setState({
          draggingElement: null,
          suggestedBindings: [],
          activeTool: updateActiveTool(this.state, { type: "selection" })
        });
      } else {
        this.setState({
          draggingElement: null,
          suggestedBindings: []
        });
      }
      if (hitElement && this.lastPointerUpEvent && this.lastPointerDownEvent && this.lastPointerUpEvent.timeStamp - this.lastPointerDownEvent.timeStamp < 300 && gesture.pointers.size <= 1 && isIframeLikeElement(hitElement) && this.isIframeLikeElementCenter(
        hitElement,
        this.lastPointerUpEvent,
        pointerDownState.origin.x,
        pointerDownState.origin.y
      )) {
        this.handleEmbeddableCenterClick(hitElement);
      }
    });
  }
  restoreReadyToEraseElements = () => {
    this.elementsPendingErasure = /* @__PURE__ */ new Set();
    this.onSceneUpdated();
  };
  eraseElements = () => {
    let didChange = false;
    const elements = this.scene.getElementsIncludingDeleted().map((ele) => {
      if (this.elementsPendingErasure.has(ele.id) || ele.frameId && this.elementsPendingErasure.has(ele.frameId) || isBoundToContainer(ele) && this.elementsPendingErasure.has(ele.containerId)) {
        didChange = true;
        return newElementWith(ele, { isDeleted: true });
      }
      return ele;
    });
    this.elementsPendingErasure = /* @__PURE__ */ new Set();
    if (didChange) {
      this.history.resumeRecording();
      this.scene.replaceAllElements(elements);
    }
  };
  initializeImage = async ({
    imageFile,
    imageElement: _imageElement,
    showCursorImagePreview = false
  }) => {
    if (!isSupportedImageFile(imageFile)) {
      throw new Error(t("errors.unsupportedFileType"));
    }
    const mimeType = imageFile.type;
    setCursor(this.interactiveCanvas, "wait");
    if (mimeType === MIME_TYPES.svg) {
      try {
        imageFile = SVGStringToFile(
          await normalizeSVG(await imageFile.text()),
          imageFile.name
        );
      } catch (error) {
        console.warn(error);
        throw new Error(t("errors.svgImageInsertError"));
      }
    }
    const fileId = await (this.props.generateIdForFile?.(
      imageFile
    ) || generateIdFromFile(imageFile));
    if (!fileId) {
      console.warn(
        "Couldn't generate file id or the supplied `generateIdForFile` didn't resolve to one."
      );
      throw new Error(t("errors.imageInsertError"));
    }
    const existingFileData = this.files[fileId];
    if (!existingFileData?.dataURL) {
      try {
        imageFile = await resizeImageFile(imageFile, {
          maxWidthOrHeight: DEFAULT_MAX_IMAGE_WIDTH_OR_HEIGHT
        });
      } catch (error) {
        console.error(
          "Error trying to resizing image file on insertion",
          error
        );
      }
      if (imageFile.size > MAX_ALLOWED_FILE_BYTES) {
        throw new Error(
          t("errors.fileTooBig", {
            maxSize: `${Math.trunc(MAX_ALLOWED_FILE_BYTES / 1024 / 1024)}MB`
          })
        );
      }
    }
    if (showCursorImagePreview) {
      const dataURL2 = this.files[fileId]?.dataURL;
      const resizedFile = dataURL2 && dataURLToFile(dataURL2);
      this.setImagePreviewCursor(resizedFile || imageFile);
    }
    const dataURL = this.files[fileId]?.dataURL || await getDataURL(imageFile);
    const imageElement = mutateElement(
      _imageElement,
      {
        fileId
      },
      false
    );
    return new Promise(
      async (resolve, reject) => {
        try {
          this.files = {
            ...this.files,
            [fileId]: {
              mimeType,
              id: fileId,
              dataURL,
              created: Date.now(),
              lastRetrieved: Date.now()
            }
          };
          const cachedImageData = this.imageCache.get(fileId);
          if (!cachedImageData) {
            this.addNewImagesToImageCache();
            await this.updateImageCache([imageElement]);
          }
          if (cachedImageData?.image instanceof Promise) {
            await cachedImageData.image;
          }
          if (this.state.pendingImageElementId !== imageElement.id && this.state.draggingElement?.id !== imageElement.id) {
            this.initializeImageDimensions(imageElement, true);
          }
          resolve(imageElement);
        } catch (error) {
          console.error(error);
          reject(new Error(t("errors.imageInsertError")));
        } finally {
          if (!showCursorImagePreview) {
            resetCursor(this.interactiveCanvas);
          }
        }
      }
    );
  };
  /**
   * inserts image into elements array and rerenders
   */
  insertImageElement = async (imageElement, imageFile, showCursorImagePreview) => {
    if (!this.isToolSupported("image")) {
      this.setState({ errorMessage: t("errors.imageToolNotSupported") });
      return;
    }
    this.scene.addNewElement(imageElement);
    try {
      return await this.initializeImage({
        imageFile,
        imageElement,
        showCursorImagePreview
      });
    } catch (error) {
      mutateElement(imageElement, {
        isDeleted: true
      });
      this.actionManager.executeAction(actionFinalize);
      this.setState({
        errorMessage: error.message || t("errors.imageInsertError")
      });
      return null;
    }
  };
  setImagePreviewCursor = async (imageFile) => {
    const cursorImageSizePx = 96;
    const imagePreview = await resizeImageFile(imageFile, {
      maxWidthOrHeight: cursorImageSizePx
    });
    let previewDataURL2 = await getDataURL(imagePreview);
    if (imageFile.type === MIME_TYPES.svg) {
      const img = await loadHTMLImageElement(previewDataURL2);
      let height = Math.min(img.height, cursorImageSizePx);
      let width = height * (img.width / img.height);
      if (width > cursorImageSizePx) {
        width = cursorImageSizePx;
        height = width * (img.height / img.width);
      }
      const canvas2 = document.createElement("canvas");
      canvas2.height = height;
      canvas2.width = width;
      const context = canvas2.getContext("2d");
      context.drawImage(img, 0, 0, width, height);
      previewDataURL2 = canvas2.toDataURL(MIME_TYPES.svg);
    }
    if (this.state.pendingImageElementId) {
      setCursor(this.interactiveCanvas, `url(${previewDataURL2}) 4 4, auto`);
    }
  };
  onImageAction = async ({
    insertOnCanvasDirectly
  }) => {
    try {
      const clientX = this.state.width / 2 + this.state.offsetLeft;
      const clientY = this.state.height / 2 + this.state.offsetTop;
      const { x: x3, y: y3 } = viewportCoordsToSceneCoords(
        { clientX, clientY },
        this.state
      );
      const imageFile = await fileOpen({
        description: "Image",
        extensions: Object.keys(
          IMAGE_MIME_TYPES
        )
      });
      const imageElement = this.createImageElement({
        sceneX: x3,
        sceneY: y3,
        addToFrameUnderCursor: false
      });
      if (insertOnCanvasDirectly) {
        this.insertImageElement(imageElement, imageFile);
        this.initializeImageDimensions(imageElement);
        this.setState(
          {
            selectedElementIds: makeNextSelectedElementIds(
              { [imageElement.id]: true },
              this.state
            )
          },
          () => {
            this.actionManager.executeAction(actionFinalize);
          }
        );
      } else {
        this.setState(
          {
            pendingImageElementId: imageElement.id
          },
          () => {
            this.insertImageElement(
              imageElement,
              imageFile,
              /* showCursorImagePreview */
              true
            );
          }
        );
      }
    } catch (error) {
      if (error.name !== "AbortError") {
        console.error(error);
      } else {
        console.warn(error);
      }
      this.setState(
        {
          pendingImageElementId: null,
          editingElement: null,
          activeTool: updateActiveTool(this.state, { type: "selection" })
        },
        () => {
          this.actionManager.executeAction(actionFinalize);
        }
      );
    }
  };
  initializeImageDimensions = (imageElement, forceNaturalSize = false) => {
    const image = isInitializedImageElement(imageElement) && this.imageCache.get(imageElement.fileId)?.image;
    if (!image || image instanceof Promise) {
      if (imageElement.width < DRAGGING_THRESHOLD / this.state.zoom.value && imageElement.height < DRAGGING_THRESHOLD / this.state.zoom.value) {
        const placeholderSize = 100 / this.state.zoom.value;
        mutateElement(imageElement, {
          x: imageElement.x - placeholderSize / 2,
          y: imageElement.y - placeholderSize / 2,
          width: placeholderSize,
          height: placeholderSize
        });
      }
      return;
    }
    if (forceNaturalSize || // if user-created bounding box is below threshold, assume the
    // intention was to click instead of drag, and use the image's
    // intrinsic size
    imageElement.width < DRAGGING_THRESHOLD / this.state.zoom.value && imageElement.height < DRAGGING_THRESHOLD / this.state.zoom.value) {
      const minHeight = Math.max(this.state.height - 120, 160);
      const maxHeight = Math.min(
        minHeight,
        Math.floor(this.state.height * 0.5) / this.state.zoom.value
      );
      const height = Math.min(image.naturalHeight, maxHeight);
      const width = height * (image.naturalWidth / image.naturalHeight);
      const x3 = imageElement.x + imageElement.width / 2 - width / 2;
      const y3 = imageElement.y + imageElement.height / 2 - height / 2;
      mutateElement(imageElement, { x: x3, y: y3, width, height });
    }
  };
  /** updates image cache, refreshing updated elements and/or setting status
      to error for images that fail during <img> element creation */
  updateImageCache = async (elements, files = this.files) => {
    const { updatedFiles, erroredFiles } = await updateImageCache({
      imageCache: this.imageCache,
      fileIds: elements.map((element) => element.fileId),
      files
    });
    if (updatedFiles.size || erroredFiles.size) {
      for (const element of elements) {
        if (updatedFiles.has(element.fileId)) {
          ShapeCache.delete(element);
        }
      }
    }
    if (erroredFiles.size) {
      this.scene.replaceAllElements(
        this.scene.getElementsIncludingDeleted().map((element) => {
          if (isInitializedImageElement(element) && erroredFiles.has(element.fileId)) {
            return newElementWith(element, {
              status: "error"
            });
          }
          return element;
        })
      );
    }
    return { updatedFiles, erroredFiles };
  };
  /** adds new images to imageCache and re-renders if needed */
  addNewImagesToImageCache = async (imageElements = getInitializedImageElements(
    this.scene.getNonDeletedElements()
  ), files = this.files) => {
    const uncachedImageElements = imageElements.filter(
      (element) => !element.isDeleted && !this.imageCache.has(element.fileId)
    );
    if (uncachedImageElements.length) {
      const { updatedFiles } = await this.updateImageCache(
        uncachedImageElements,
        files
      );
      if (updatedFiles.size) {
        this.scene.informMutation();
      }
    }
  };
  /** generally you should use `addNewImagesToImageCache()` directly if you need
   *  to render new images. This is just a failsafe  */
  scheduleImageRefresh = (0, import_lodash2.default)(() => {
    this.addNewImagesToImageCache();
  }, IMAGE_RENDER_TIMEOUT);
  updateBindingEnabledOnPointerMove = (event) => {
    const shouldEnableBinding = shouldEnableBindingForPointerEvent(event);
    if (this.state.isBindingEnabled !== shouldEnableBinding) {
      this.setState({ isBindingEnabled: shouldEnableBinding });
    }
  };
  maybeSuggestBindingAtCursor = (pointerCoords) => {
    const hoveredBindableElement = getHoveredElementForBinding(
      pointerCoords,
      this.scene.getNonDeletedElements(),
      this.scene.getNonDeletedElementsMap()
    );
    this.setState({
      suggestedBindings: hoveredBindableElement != null ? [hoveredBindableElement] : []
    });
  };
  maybeSuggestBindingsForLinearElementAtCoords = (linearElement, pointerCoords, oppositeBindingBoundElement) => {
    if (!pointerCoords.length) {
      return;
    }
    const suggestedBindings = pointerCoords.reduce(
      (acc, coords) => {
        const hoveredBindableElement = getHoveredElementForBinding(
          coords,
          this.scene.getNonDeletedElements(),
          this.scene.getNonDeletedElementsMap()
        );
        if (hoveredBindableElement != null && !isLinearElementSimpleAndAlreadyBound(
          linearElement,
          oppositeBindingBoundElement?.id,
          hoveredBindableElement
        )) {
          acc.push(hoveredBindableElement);
        }
        return acc;
      },
      []
    );
    this.setState({ suggestedBindings });
  };
  maybeSuggestBindingForAll(selectedElements) {
    if (selectedElements.length > 50) {
      return;
    }
    const suggestedBindings = getEligibleElementsForBinding(
      selectedElements,
      this.scene.getNonDeletedElements(),
      this.scene.getNonDeletedElementsMap()
    );
    this.setState({ suggestedBindings });
  }
  clearSelection(hitElement) {
    this.setState((prevState) => ({
      selectedElementIds: makeNextSelectedElementIds({}, prevState),
      activeEmbeddable: null,
      selectedGroupIds: {},
      // Continue editing the same group if the user selected a different
      // element from it
      editingGroupId: prevState.editingGroupId && hitElement != null && isElementInGroup(hitElement, prevState.editingGroupId) ? prevState.editingGroupId : null
    }));
    this.setState({
      selectedElementIds: makeNextSelectedElementIds({}, this.state),
      activeEmbeddable: null,
      previousSelectedElementIds: this.state.selectedElementIds
    });
  }
  handleInteractiveCanvasRef = (canvas2) => {
    if (canvas2 !== null) {
      this.interactiveCanvas = canvas2;
      this.interactiveCanvas.addEventListener("wheel" /* WHEEL */, this.handleWheel);
      this.interactiveCanvas.addEventListener(
        "touchstart" /* TOUCH_START */,
        this.onTouchStart
      );
      this.interactiveCanvas.addEventListener("touchend" /* TOUCH_END */, this.onTouchEnd);
    } else {
      this.interactiveCanvas?.removeEventListener(
        "wheel" /* WHEEL */,
        this.handleWheel
      );
      this.interactiveCanvas?.removeEventListener(
        "touchstart" /* TOUCH_START */,
        this.onTouchStart
      );
      this.interactiveCanvas?.removeEventListener(
        "touchend" /* TOUCH_END */,
        this.onTouchEnd
      );
    }
  };
  handleAppOnDrop = async (event) => {
    const { file: file2, fileHandle } = await getFileFromEvent(event);
    const { x: sceneX, y: sceneY } = viewportCoordsToSceneCoords(
      event,
      this.state
    );
    try {
      if (isSupportedImageFile(file2) && this.isToolSupported("image")) {
        if (file2?.type === MIME_TYPES.png || file2?.type === MIME_TYPES.svg) {
          try {
            const scene = await loadFromBlob(
              file2,
              this.state,
              this.scene.getElementsIncludingDeleted(),
              fileHandle
            );
            this.syncActionResult({
              ...scene,
              appState: {
                ...scene.appState || this.state,
                isLoading: false
              },
              replaceFiles: true,
              commitToHistory: true
            });
            return;
          } catch (error) {
            if (error.name !== "EncodingError") {
              throw error;
            }
          }
        }
        const imageElement = this.createImageElement({ sceneX, sceneY });
        this.insertImageElement(imageElement, file2);
        this.initializeImageDimensions(imageElement);
        this.setState({
          selectedElementIds: makeNextSelectedElementIds(
            { [imageElement.id]: true },
            this.state
          )
        });
        return;
      }
    } catch (error) {
      return this.setState({
        isLoading: false,
        errorMessage: error.message
      });
    }
    const libraryJSON = event.dataTransfer.getData(MIME_TYPES.excalidrawlib);
    if (libraryJSON && typeof libraryJSON === "string") {
      try {
        const libraryItems = parseLibraryJSON(libraryJSON);
        this.addElementsFromPasteOrLibrary({
          elements: distributeLibraryItemsOnSquareGrid(libraryItems),
          position: event,
          files: null
        });
      } catch (error) {
        this.setState({ errorMessage: error.message });
      }
      return;
    }
    if (file2) {
      await this.loadFileToCanvas(file2, fileHandle);
    }
    if (event.dataTransfer?.types?.includes("text/plain")) {
      const text = event.dataTransfer?.getData("text");
      if (text && embeddableURLValidator(text, this.props.validateEmbeddable) && (/^(http|https):\/\/[^\s/$.?#].[^\s]*$/.test(text) || getEmbedLink(text)?.type === "video")) {
        const embeddable = this.insertEmbeddableElement({
          sceneX,
          sceneY,
          link: normalizeLink(text)
        });
        if (embeddable) {
          this.setState({ selectedElementIds: { [embeddable.id]: true } });
        }
      }
    }
  };
  loadFileToCanvas = async (file2, fileHandle) => {
    file2 = await normalizeFile(file2);
    try {
      const ret = await loadSceneOrLibraryFromBlob(
        file2,
        this.state,
        this.scene.getElementsIncludingDeleted(),
        fileHandle
      );
      if (ret.type === MIME_TYPES.excalidraw) {
        this.setState({ isLoading: true });
        this.syncActionResult({
          ...ret.data,
          appState: {
            ...ret.data.appState || this.state,
            isLoading: false
          },
          replaceFiles: true,
          commitToHistory: true
        });
      } else if (ret.type === MIME_TYPES.excalidrawlib) {
        await this.library.updateLibrary({
          libraryItems: file2,
          merge: true,
          openLibraryMenu: true
        }).catch((error) => {
          console.error(error);
          this.setState({ errorMessage: t("errors.importLibraryError") });
        });
      }
    } catch (error) {
      if (error instanceof ImageSceneDataError && error.code === "IMAGE_NOT_CONTAINS_SCENE_DATA" && !this.isToolSupported("image")) {
        this.setState({
          isLoading: false,
          errorMessage: t("errors.imageToolNotSupported")
        });
        return;
      }
      this.setState({ isLoading: false, errorMessage: error.message });
    }
  };
  handleCanvasContextMenu = (event) => {
    event.preventDefault();
    if (("pointerType" in event.nativeEvent && event.nativeEvent.pointerType === "touch" || "pointerType" in event.nativeEvent && event.nativeEvent.pointerType === "pen" && // always allow if user uses a pen secondary button
    event.button !== POINTER_BUTTON.SECONDARY) && this.state.activeTool.type !== "selection") {
      return;
    }
    const { x: x3, y: y3 } = viewportCoordsToSceneCoords(event, this.state);
    const element = this.getElementAtPosition(x3, y3, {
      preferSelected: true,
      includeLockedElements: true
    });
    const selectedElements = this.scene.getSelectedElements(this.state);
    const isHittingCommonBoundBox = this.isHittingCommonBoundingBoxOfSelectedElements(
      { x: x3, y: y3 },
      selectedElements
    );
    const type = element || isHittingCommonBoundBox ? "element" : "canvas";
    const container = this.excalidrawContainerRef.current;
    const { top: offsetTop, left: offsetLeft } = container.getBoundingClientRect();
    const left = event.clientX - offsetLeft;
    const top2 = event.clientY - offsetTop;
    trackEvent("contextMenu", "openContextMenu", type);
    this.setState(
      {
        ...element && !this.state.selectedElementIds[element.id] ? {
          ...this.state,
          ...selectGroupsForSelectedElements(
            {
              editingGroupId: this.state.editingGroupId,
              selectedElementIds: { [element.id]: true }
            },
            this.scene.getNonDeletedElements(),
            this.state,
            this
          ),
          selectedLinearElement: isLinearElement(element) ? new LinearElementEditor(element) : null
        } : this.state,
        showHyperlinkPopup: false
      },
      () => {
        this.setState({
          contextMenu: { top: top2, left, items: this.getContextMenuItems(type) }
        });
      }
    );
  };
  maybeDragNewGenericElement = (pointerDownState, event) => {
    const draggingElement = this.state.draggingElement;
    const pointerCoords = pointerDownState.lastCoords;
    if (!draggingElement) {
      return;
    }
    if (draggingElement.type === "selection" && this.state.activeTool.type !== "eraser") {
      dragNewElement(
        draggingElement,
        this.state.activeTool.type,
        pointerDownState.origin.x,
        pointerDownState.origin.y,
        pointerCoords.x,
        pointerCoords.y,
        distance(pointerDownState.origin.x, pointerCoords.x),
        distance(pointerDownState.origin.y, pointerCoords.y),
        shouldMaintainAspectRatio(event),
        shouldResizeFromCenter(event)
      );
    } else {
      let [gridX, gridY] = getGridPoint(
        pointerCoords.x,
        pointerCoords.y,
        event[KEYS.CTRL_OR_CMD] ? null : this.state.gridSize
      );
      const image = isInitializedImageElement(draggingElement) && this.imageCache.get(draggingElement.fileId)?.image;
      const aspectRatio = image && !(image instanceof Promise) ? image.width / image.height : null;
      this.maybeCacheReferenceSnapPoints(event, [draggingElement]);
      const { snapOffset, snapLines } = snapNewElement(
        draggingElement,
        this.state,
        event,
        {
          x: pointerDownState.originInGrid.x + (this.state.originSnapOffset?.x ?? 0),
          y: pointerDownState.originInGrid.y + (this.state.originSnapOffset?.y ?? 0)
        },
        {
          x: gridX - pointerDownState.originInGrid.x,
          y: gridY - pointerDownState.originInGrid.y
        },
        this.scene.getNonDeletedElementsMap()
      );
      gridX += snapOffset.x;
      gridY += snapOffset.y;
      this.setState({
        snapLines
      });
      dragNewElement(
        draggingElement,
        this.state.activeTool.type,
        pointerDownState.originInGrid.x,
        pointerDownState.originInGrid.y,
        gridX,
        gridY,
        distance(pointerDownState.originInGrid.x, gridX),
        distance(pointerDownState.originInGrid.y, gridY),
        isImageElement(draggingElement) ? !shouldMaintainAspectRatio(event) : shouldMaintainAspectRatio(event),
        shouldResizeFromCenter(event),
        aspectRatio,
        this.state.originSnapOffset
      );
      this.maybeSuggestBindingForAll([draggingElement]);
      if (this.state.activeTool.type === TOOL_TYPE.frame || this.state.activeTool.type === TOOL_TYPE.magicframe) {
        this.setState({
          elementsToHighlight: getElementsInResizingFrame(
            this.scene.getNonDeletedElements(),
            draggingElement,
            this.state,
            this.scene.getNonDeletedElementsMap()
          )
        });
      }
    }
  };
  maybeHandleResize = (pointerDownState, event) => {
    const selectedElements = this.scene.getSelectedElements(this.state);
    const selectedFrames = selectedElements.filter(
      (element) => isFrameLikeElement(element)
    );
    const transformHandleType = pointerDownState.resize.handleType;
    if (selectedFrames.length > 0 && transformHandleType === "rotation") {
      return false;
    }
    this.setState({
      // TODO: rename this state field to "isScaling" to distinguish
      // it from the generic "isResizing" which includes scaling and
      // rotating
      isResizing: transformHandleType && transformHandleType !== "rotation",
      isRotating: transformHandleType === "rotation",
      activeEmbeddable: null
    });
    const pointerCoords = pointerDownState.lastCoords;
    let [resizeX, resizeY] = getGridPoint(
      pointerCoords.x - pointerDownState.resize.offset.x,
      pointerCoords.y - pointerDownState.resize.offset.y,
      event[KEYS.CTRL_OR_CMD] ? null : this.state.gridSize
    );
    const frameElementsOffsetsMap = /* @__PURE__ */ new Map();
    selectedFrames.forEach((frame) => {
      const elementsInFrame = getFrameChildren(
        this.scene.getNonDeletedElements(),
        frame.id
      );
      elementsInFrame.forEach((element) => {
        frameElementsOffsetsMap.set(frame.id + element.id, {
          x: element.x - frame.x,
          y: element.y - frame.y
        });
      });
    });
    if (!this.state.selectedElementsAreBeingDragged) {
      const [gridX, gridY] = getGridPoint(
        pointerCoords.x,
        pointerCoords.y,
        event[KEYS.CTRL_OR_CMD] ? null : this.state.gridSize
      );
      const dragOffset = {
        x: gridX - pointerDownState.originInGrid.x,
        y: gridY - pointerDownState.originInGrid.y
      };
      const originalElements = [...pointerDownState.originalElements.values()];
      this.maybeCacheReferenceSnapPoints(event, selectedElements);
      const { snapOffset, snapLines } = snapResizingElements(
        selectedElements,
        getSelectedElements(originalElements, this.state),
        this.state,
        event,
        dragOffset,
        transformHandleType
      );
      resizeX += snapOffset.x;
      resizeY += snapOffset.y;
      this.setState({
        snapLines
      });
    }
    if (transformElements(
      pointerDownState.originalElements,
      transformHandleType,
      selectedElements,
      this.scene.getElementsMapIncludingDeleted(),
      shouldRotateWithDiscreteAngle(event),
      shouldResizeFromCenter(event),
      selectedElements.length === 1 && isImageElement(selectedElements[0]) ? !shouldMaintainAspectRatio(event) : shouldMaintainAspectRatio(event),
      resizeX,
      resizeY,
      pointerDownState.resize.center.x,
      pointerDownState.resize.center.y
    )) {
      this.maybeSuggestBindingForAll(selectedElements);
      const elementsToHighlight = /* @__PURE__ */ new Set();
      selectedFrames.forEach((frame) => {
        getElementsInResizingFrame(
          this.scene.getNonDeletedElements(),
          frame,
          this.state,
          this.scene.getNonDeletedElementsMap()
        ).forEach((element) => elementsToHighlight.add(element));
      });
      this.setState({
        elementsToHighlight: [...elementsToHighlight]
      });
      return true;
    }
    return false;
  };
  getContextMenuItems = (type) => {
    const options = [];
    options.push(actionCopyAsPng, actionCopyAsSvg);
    if (type === "canvas") {
      if (this.state.viewModeEnabled) {
        return [
          ...options,
          actionToggleGridMode,
          actionToggleZenMode,
          actionToggleViewMode,
          actionToggleStats
        ];
      }
      return [
        actionPaste,
        CONTEXT_MENU_SEPARATOR,
        actionCopyAsPng,
        actionCopyAsSvg,
        copyText,
        CONTEXT_MENU_SEPARATOR,
        actionSelectAll,
        actionUnlockAllElements,
        CONTEXT_MENU_SEPARATOR,
        actionToggleGridMode,
        actionToggleObjectsSnapMode,
        actionToggleZenMode,
        actionToggleViewMode,
        actionToggleStats
      ];
    }
    options.push(copyText);
    if (this.state.viewModeEnabled) {
      return [actionCopy, ...options];
    }
    return [
      actionCut,
      actionCopy,
      actionPaste,
      actionSelectAllElementsInFrame,
      actionRemoveAllElementsFromFrame,
      CONTEXT_MENU_SEPARATOR,
      ...options,
      CONTEXT_MENU_SEPARATOR,
      actionCopyStyles,
      actionPasteStyles,
      CONTEXT_MENU_SEPARATOR,
      actionGroup,
      actionUnbindText,
      actionBindText,
      actionWrapTextInContainer,
      actionUngroup,
      CONTEXT_MENU_SEPARATOR,
      actionAddToLibrary,
      CONTEXT_MENU_SEPARATOR,
      actionSendBackward,
      actionBringForward,
      actionSendToBack,
      actionBringToFront,
      CONTEXT_MENU_SEPARATOR,
      actionFlipHorizontal,
      actionFlipVertical,
      CONTEXT_MENU_SEPARATOR,
      actionToggleLinearEditor,
      actionLink,
      actionDuplicateSelection,
      actionToggleElementLock,
      CONTEXT_MENU_SEPARATOR,
      actionDeleteSelected
    ];
  };
  handleWheel = withBatchedUpdates(
    (event) => {
      event.preventDefault();
      if (isPanning) {
        return;
      }
      const { deltaX, deltaY } = event;
      if (event.metaKey || event.ctrlKey) {
        const sign2 = Math.sign(deltaY);
        const MAX_STEP = ZOOM_STEP * 100;
        const absDelta = Math.abs(deltaY);
        let delta = deltaY;
        if (absDelta > MAX_STEP) {
          delta = MAX_STEP * sign2;
        }
        let newZoom = this.state.zoom.value - delta / 100;
        newZoom += Math.log10(Math.max(1, this.state.zoom.value)) * -sign2 * // reduced amplification for small deltas (small movements on a trackpad)
        Math.min(1, absDelta / 20);
        this.translateCanvas((state) => ({
          ...getStateForZoom(
            {
              viewportX: this.lastViewportPosition.x,
              viewportY: this.lastViewportPosition.y,
              nextZoom: getNormalizedZoom(newZoom)
            },
            state
          ),
          shouldCacheIgnoreZoom: true
        }));
        this.resetShouldCacheIgnoreZoomDebounced();
        return;
      }
      if (event.shiftKey) {
        this.translateCanvas(({ zoom, scrollX }) => ({
          // on Mac, shift+wheel tends to result in deltaX
          scrollX: scrollX - (deltaY || deltaX) / zoom.value
        }));
        return;
      }
      this.translateCanvas(({ zoom, scrollX, scrollY }) => ({
        scrollX: scrollX - deltaX / zoom.value,
        scrollY: scrollY - deltaY / zoom.value
      }));
    }
  );
  getTextWysiwygSnappedToCenterPosition(x3, y3, appState, container) {
    if (container) {
      let elementCenterX = container.x + container.width / 2;
      let elementCenterY = container.y + container.height / 2;
      const elementCenter = getContainerCenter(
        container,
        appState,
        this.scene.getNonDeletedElementsMap()
      );
      if (elementCenter) {
        elementCenterX = elementCenter.x;
        elementCenterY = elementCenter.y;
      }
      const distanceToCenter = Math.hypot(
        x3 - elementCenterX,
        y3 - elementCenterY
      );
      const isSnappedToCenter = distanceToCenter < TEXT_TO_CENTER_SNAP_THRESHOLD;
      if (isSnappedToCenter) {
        const { x: viewportX, y: viewportY } = sceneCoordsToViewportCoords(
          { sceneX: elementCenterX, sceneY: elementCenterY },
          appState
        );
        return { viewportX, viewportY, elementCenterX, elementCenterY };
      }
    }
  }
  savePointer = (x3, y3, button) => {
    if (!x3 || !y3) {
      return;
    }
    const { x: sceneX, y: sceneY } = viewportCoordsToSceneCoords(
      { clientX: x3, clientY: y3 },
      this.state
    );
    if (isNaN(sceneX) || isNaN(sceneY)) {
    }
    const pointer = {
      x: sceneX,
      y: sceneY,
      tool: this.state.activeTool.type === "laser" ? "laser" : "pointer"
    };
    this.props.onPointerUpdate?.({
      pointer,
      button,
      pointersMap: gesture.pointers
    });
  };
  resetShouldCacheIgnoreZoomDebounced = debounce(() => {
    if (!this.unmounted) {
      this.setState({ shouldCacheIgnoreZoom: false });
    }
  }, 300);
  updateDOMRect = (cb) => {
    if (this.excalidrawContainerRef?.current) {
      const excalidrawContainer = this.excalidrawContainerRef.current;
      const {
        width,
        height,
        left: offsetLeft,
        top: offsetTop
      } = excalidrawContainer.getBoundingClientRect();
      const {
        width: currentWidth,
        height: currentHeight,
        offsetTop: currentOffsetTop,
        offsetLeft: currentOffsetLeft
      } = this.state;
      if (width === currentWidth && height === currentHeight && offsetLeft === currentOffsetLeft && offsetTop === currentOffsetTop) {
        if (cb) {
          cb();
        }
        return;
      }
      this.setState(
        {
          width,
          height,
          offsetLeft,
          offsetTop
        },
        () => {
          cb && cb();
        }
      );
    }
  };
  refresh = () => {
    this.setState({ ...this.getCanvasOffsets() });
  };
  getCanvasOffsets() {
    if (this.excalidrawContainerRef?.current) {
      const excalidrawContainer = this.excalidrawContainerRef.current;
      const { left, top: top2 } = excalidrawContainer.getBoundingClientRect();
      return {
        offsetLeft: left,
        offsetTop: top2
      };
    }
    return {
      offsetLeft: 0,
      offsetTop: 0
    };
  }
  async updateLanguage() {
    const currentLang2 = languages.find((lang) => lang.code === this.props.langCode) || defaultLang;
    await setLanguage(currentLang2);
    this.setAppState({});
  }
};
if (define_import_meta_env_default.MODE === ENV.TEST || define_import_meta_env_default.DEV) {
  window.h = window.h || {};
  Object.defineProperties(window.h, {
    elements: {
      configurable: true,
      get() {
        return this.app?.scene.getElementsIncludingDeleted();
      },
      set(elements) {
        return this.app?.scene.replaceAllElements(elements);
      }
    }
  });
}
var App_default = App;

// components/ToolButton.tsx
var import_jsx_runtime131 = __toESM(require_jsx_runtime(), 1);
var ToolButton = import_react96.default.forwardRef((props, ref) => {
  const { id: excalId } = useExcalidrawContainer();
  const innerRef = import_react96.default.useRef(null);
  import_react96.default.useImperativeHandle(ref, () => innerRef.current);
  const sizeCn = `ToolIcon_size_${props.size}`;
  const [isLoading, setIsLoading] = (0, import_react96.useState)(false);
  const isMountedRef = (0, import_react96.useRef)(true);
  const onClick = async (event) => {
    const ret = "onClick" in props && props.onClick?.(event);
    if (isPromiseLike(ret)) {
      try {
        setIsLoading(true);
        await ret;
      } catch (error) {
        if (!(error instanceof AbortError)) {
          throw error;
        } else {
          console.warn(error);
        }
      } finally {
        if (isMountedRef.current) {
          setIsLoading(false);
        }
      }
    }
  };
  (0, import_react96.useEffect)(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  const lastPointerTypeRef = (0, import_react96.useRef)(null);
  if (props.type === "button" || props.type === "icon" || props.type === "submit") {
    const type = props.type === "icon" ? "button" : props.type;
    return /* @__PURE__ */ (0, import_jsx_runtime131.jsxs)(
      "button",
      {
        className: clsx_m_default(
          "ToolIcon_type_button",
          sizeCn,
          props.className,
          props.visible && !props.hidden ? "ToolIcon_type_button--show" : "ToolIcon_type_button--hide",
          {
            ToolIcon: !props.hidden,
            "ToolIcon--selected": props.selected,
            "ToolIcon--plain": props.type === "icon"
          }
        ),
        style: props.style,
        "data-testid": props["data-testid"],
        hidden: props.hidden,
        title: props.title,
        "aria-label": props["aria-label"],
        type,
        onClick,
        ref: innerRef,
        disabled: isLoading || props.isLoading,
        children: [
          (props.icon || props.label) && /* @__PURE__ */ (0, import_jsx_runtime131.jsxs)("div", { className: "ToolIcon__icon", "aria-hidden": "true", children: [
            props.icon || props.label,
            props.keyBindingLabel && /* @__PURE__ */ (0, import_jsx_runtime131.jsx)("span", { className: "ToolIcon__keybinding", children: props.keyBindingLabel }),
            props.isLoading && /* @__PURE__ */ (0, import_jsx_runtime131.jsx)(Spinner_default, {})
          ] }),
          props.showAriaLabel && /* @__PURE__ */ (0, import_jsx_runtime131.jsxs)("div", { className: "ToolIcon__label", children: [
            props["aria-label"],
            " ",
            isLoading && /* @__PURE__ */ (0, import_jsx_runtime131.jsx)(Spinner_default, {})
          ] }),
          props.children
        ]
      }
    );
  }
  return /* @__PURE__ */ (0, import_jsx_runtime131.jsxs)(
    "label",
    {
      className: clsx_m_default("ToolIcon", props.className),
      title: props.title,
      onPointerDown: (event) => {
        lastPointerTypeRef.current = event.pointerType || null;
        props.onPointerDown?.({ pointerType: event.pointerType || null });
      },
      onPointerUp: () => {
        requestAnimationFrame(() => {
          lastPointerTypeRef.current = null;
        });
      },
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime131.jsx)(
          "input",
          {
            className: `ToolIcon_type_radio ${sizeCn}`,
            type: "radio",
            name: props.name,
            "aria-label": props["aria-label"],
            "aria-keyshortcuts": props["aria-keyshortcuts"],
            "data-testid": props["data-testid"],
            id: `${excalId}-${props.id}`,
            onChange: () => {
              props.onChange?.({ pointerType: lastPointerTypeRef.current });
            },
            checked: props.checked,
            ref: innerRef
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime131.jsxs)("div", { className: "ToolIcon__icon", children: [
          props.icon,
          props.keyBindingLabel && /* @__PURE__ */ (0, import_jsx_runtime131.jsx)("span", { className: "ToolIcon__keybinding", children: props.keyBindingLabel })
        ] })
      ]
    }
  );
});
ToolButton.defaultProps = {
  visible: true,
  className: "",
  size: "medium"
};
ToolButton.displayName = "ToolButton";

// element/Hyperlink.tsx
var import_react97 = __toESM(require_react(), 1);
var import_jsx_runtime132 = __toESM(require_jsx_runtime(), 1);
var CONTAINER_WIDTH = 320;
var SPACE_BOTTOM = 85;
var CONTAINER_PADDING2 = 5;
var CONTAINER_HEIGHT = 42;
var AUTO_HIDE_TIMEOUT = 500;
var EXTERNAL_LINK_IMG = document.createElement("img");
EXTERNAL_LINK_IMG.src = `data:${MIME_TYPES.svg}, ${encodeURIComponent(
  `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#1971c2" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-external-link"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg>`
)}`;
var IS_HYPERLINK_TOOLTIP_VISIBLE = false;
var embeddableLinkCache = /* @__PURE__ */ new Map();
var Hyperlink = ({
  element,
  elementsMap,
  setAppState,
  onLinkOpen,
  setToast,
  updateEmbedValidationStatus
}) => {
  const appState = useExcalidrawAppState();
  const appProps = useAppProps();
  const linkVal = element.link || "";
  const [inputVal, setInputVal] = (0, import_react97.useState)(linkVal);
  const inputRef = (0, import_react97.useRef)(null);
  const isEditing = appState.showHyperlinkPopup === "editor";
  const handleSubmit = (0, import_react97.useCallback)(() => {
    if (!inputRef.current) {
      return;
    }
    const link = normalizeLink(inputRef.current.value) || null;
    if (!element.link && link) {
      trackEvent("hyperlink", "create");
    }
    if (isEmbeddableElement(element)) {
      if (appState.activeEmbeddable?.element === element) {
        setAppState({ activeEmbeddable: null });
      }
      if (!link) {
        mutateElement(element, {
          link: null
        });
        updateEmbedValidationStatus(element, false);
        return;
      }
      if (!embeddableURLValidator(link, appProps.validateEmbeddable)) {
        if (link) {
          setToast({ message: t("toast.unableToEmbed"), closable: true });
        }
        element.link && embeddableLinkCache.set(element.id, element.link);
        mutateElement(element, {
          link
        });
        updateEmbedValidationStatus(element, false);
      } else {
        const { width, height } = element;
        const embedLink = getEmbedLink(link);
        if (embedLink?.error instanceof URIError) {
          setToast({
            message: t("toast.unrecognizedLinkFormat"),
            closable: true
          });
        }
        const ar = embedLink ? embedLink.intrinsicSize.w / embedLink.intrinsicSize.h : 1;
        const hasLinkChanged = embeddableLinkCache.get(element.id) !== element.link;
        mutateElement(element, {
          ...hasLinkChanged ? {
            width: embedLink?.type === "video" ? width > height ? width : height * ar : width,
            height: embedLink?.type === "video" ? width > height ? width / ar : height : height
          } : {},
          link
        });
        updateEmbedValidationStatus(element, true);
        if (embeddableLinkCache.has(element.id)) {
          embeddableLinkCache.delete(element.id);
        }
      }
    } else {
      mutateElement(element, { link });
    }
  }, [
    element,
    setToast,
    appProps.validateEmbeddable,
    appState.activeEmbeddable,
    setAppState,
    updateEmbedValidationStatus
  ]);
  (0, import_react97.useLayoutEffect)(() => {
    return () => {
      handleSubmit();
    };
  }, [handleSubmit]);
  (0, import_react97.useEffect)(() => {
    let timeoutId = null;
    const handlePointerMove = (event) => {
      if (isEditing) {
        return;
      }
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
      const shouldHide = shouldHideLinkPopup(element, elementsMap, appState, [
        event.clientX,
        event.clientY
      ]);
      if (shouldHide) {
        timeoutId = window.setTimeout(() => {
          setAppState({ showHyperlinkPopup: false });
        }, AUTO_HIDE_TIMEOUT);
      }
    };
    window.addEventListener("pointermove" /* POINTER_MOVE */, handlePointerMove, false);
    return () => {
      window.removeEventListener("pointermove" /* POINTER_MOVE */, handlePointerMove, false);
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
    };
  }, [appState, element, isEditing, setAppState, elementsMap]);
  const handleRemove = (0, import_react97.useCallback)(() => {
    trackEvent("hyperlink", "delete");
    mutateElement(element, { link: null });
    if (isEditing) {
      inputRef.current.value = "";
    }
    setAppState({ showHyperlinkPopup: false });
  }, [setAppState, element, isEditing]);
  const onEdit = () => {
    trackEvent("hyperlink", "edit", "popup-ui");
    setAppState({ showHyperlinkPopup: "editor" });
  };
  const { x: x3, y: y3 } = getCoordsForPopover(element, appState, elementsMap);
  if (appState.contextMenu || appState.draggingElement || appState.resizingElement || appState.isRotating || appState.openMenu || appState.viewModeEnabled) {
    return null;
  }
  return /* @__PURE__ */ (0, import_jsx_runtime132.jsxs)(
    "div",
    {
      className: "excalidraw-hyperlinkContainer",
      style: {
        top: `${y3}px`,
        left: `${x3}px`,
        width: CONTAINER_WIDTH,
        padding: CONTAINER_PADDING2
      },
      onClick: () => {
        if (!element.link && !isEditing) {
          setAppState({ showHyperlinkPopup: "editor" });
        }
      },
      children: [
        isEditing ? /* @__PURE__ */ (0, import_jsx_runtime132.jsx)(
          "input",
          {
            className: clsx_m_default("excalidraw-hyperlinkContainer-input"),
            placeholder: "Type or paste your link here",
            ref: inputRef,
            value: inputVal,
            onChange: (event) => setInputVal(event.target.value),
            autoFocus: true,
            onKeyDown: (event) => {
              event.stopPropagation();
              if (event[KEYS.CTRL_OR_CMD] && event.key === KEYS.K) {
                event.preventDefault();
              }
              if (event.key === KEYS.ENTER || event.key === KEYS.ESCAPE) {
                handleSubmit();
                setAppState({ showHyperlinkPopup: "info" });
              }
            }
          }
        ) : element.link ? /* @__PURE__ */ (0, import_jsx_runtime132.jsx)(
          "a",
          {
            href: normalizeLink(element.link || ""),
            className: "excalidraw-hyperlinkContainer-link",
            target: isLocalLink(element.link) ? "_self" : "_blank",
            onClick: (event) => {
              if (element.link && onLinkOpen) {
                const customEvent = wrapEvent(
                  "excalidraw-link" /* EXCALIDRAW_LINK */,
                  event.nativeEvent
                );
                onLinkOpen(
                  {
                    ...element,
                    link: normalizeLink(element.link)
                  },
                  customEvent
                );
                if (customEvent.defaultPrevented) {
                  event.preventDefault();
                }
              }
            },
            rel: "noopener noreferrer",
            children: element.link
          }
        ) : /* @__PURE__ */ (0, import_jsx_runtime132.jsx)("div", { className: "excalidraw-hyperlinkContainer-link", children: t("labels.link.empty") }),
        /* @__PURE__ */ (0, import_jsx_runtime132.jsxs)("div", { className: "excalidraw-hyperlinkContainer__buttons", children: [
          !isEditing && /* @__PURE__ */ (0, import_jsx_runtime132.jsx)(
            ToolButton,
            {
              type: "button",
              title: t("buttons.edit"),
              "aria-label": t("buttons.edit"),
              label: t("buttons.edit"),
              onClick: onEdit,
              className: "excalidraw-hyperlinkContainer--edit",
              icon: FreedrawIcon
            }
          ),
          linkVal && !isEmbeddableElement(element) && /* @__PURE__ */ (0, import_jsx_runtime132.jsx)(
            ToolButton,
            {
              type: "button",
              title: t("buttons.remove"),
              "aria-label": t("buttons.remove"),
              label: t("buttons.remove"),
              onClick: handleRemove,
              className: "excalidraw-hyperlinkContainer--remove",
              icon: TrashIcon
            }
          )
        ] })
      ]
    }
  );
};
var getCoordsForPopover = (element, appState, elementsMap) => {
  const [x1, y1] = getElementAbsoluteCoords(element, elementsMap);
  const { x: viewportX, y: viewportY } = sceneCoordsToViewportCoords(
    { sceneX: x1 + element.width / 2, sceneY: y1 },
    appState
  );
  const x3 = viewportX - appState.offsetLeft - CONTAINER_WIDTH / 2;
  const y3 = viewportY - appState.offsetTop - SPACE_BOTTOM;
  return { x: x3, y: y3 };
};
var actionLink = register({
  name: "hyperlink",
  perform: (elements, appState) => {
    if (appState.showHyperlinkPopup === "editor") {
      return false;
    }
    return {
      elements,
      appState: {
        ...appState,
        showHyperlinkPopup: "editor",
        openMenu: null
      },
      commitToHistory: true
    };
  },
  trackEvent: { category: "hyperlink", action: "click" },
  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.key === KEYS.K,
  contextItemLabel: (elements, appState) => getContextMenuLabel(elements, appState),
  predicate: (elements, appState) => {
    const selectedElements = getSelectedElements(elements, appState);
    return selectedElements.length === 1;
  },
  PanelComponent: ({ elements, appState, updateData }) => {
    const selectedElements = getSelectedElements(elements, appState);
    return /* @__PURE__ */ (0, import_jsx_runtime132.jsx)(
      ToolButton,
      {
        type: "button",
        icon: LinkIcon,
        "aria-label": t(getContextMenuLabel(elements, appState)),
        title: `${isEmbeddableElement(elements[0]) ? t("labels.link.labelEmbed") : t("labels.link.label")} - ${getShortcutKey("CtrlOrCmd+K")}`,
        onClick: () => updateData(null),
        selected: selectedElements.length === 1 && !!selectedElements[0].link
      }
    );
  }
});
var getContextMenuLabel = (elements, appState) => {
  const selectedElements = getSelectedElements(elements, appState);
  const label = selectedElements[0].link ? isEmbeddableElement(selectedElements[0]) ? "labels.link.editEmbed" : "labels.link.edit" : isEmbeddableElement(selectedElements[0]) ? "labels.link.createEmbed" : "labels.link.create";
  return label;
};
var getLinkHandleFromCoords = ([x1, y1, x22, y22], angle, appState) => {
  const size = DEFAULT_LINK_SIZE;
  const linkWidth = size / appState.zoom.value;
  const linkHeight = size / appState.zoom.value;
  const linkMarginY = size / appState.zoom.value;
  const centerX = (x1 + x22) / 2;
  const centerY = (y1 + y22) / 2;
  const centeringOffset = (size - 8) / (2 * appState.zoom.value);
  const dashedLineMargin = 4 / appState.zoom.value;
  const x3 = x22 + dashedLineMargin - centeringOffset;
  const y3 = y1 - dashedLineMargin - linkMarginY + centeringOffset;
  const [rotatedX, rotatedY] = rotate2(
    x3 + linkWidth / 2,
    y3 + linkHeight / 2,
    centerX,
    centerY,
    angle
  );
  return [
    rotatedX - linkWidth / 2,
    rotatedY - linkHeight / 2,
    linkWidth,
    linkHeight
  ];
};
var isPointHittingLinkIcon = (element, elementsMap, appState, [x3, y3]) => {
  const threshold = 4 / appState.zoom.value;
  const [x1, y1, x22, y22] = getElementAbsoluteCoords(element, elementsMap);
  const [linkX, linkY, linkWidth, linkHeight] = getLinkHandleFromCoords(
    [x1, y1, x22, y22],
    element.angle,
    appState
  );
  const hitLink = x3 > linkX - threshold && x3 < linkX + threshold + linkWidth && y3 > linkY - threshold && y3 < linkY + linkHeight + threshold;
  return hitLink;
};
var isPointHittingLink = (element, elementsMap, appState, [x3, y3], isMobile) => {
  if (!element.link || appState.selectedElementIds[element.id]) {
    return false;
  }
  const threshold = 4 / appState.zoom.value;
  if (!isMobile && appState.viewModeEnabled && isPointHittingElementBoundingBox(
    element,
    elementsMap,
    [x3, y3],
    threshold,
    null
  )) {
    return true;
  }
  return isPointHittingLinkIcon(element, elementsMap, appState, [x3, y3]);
};
var HYPERLINK_TOOLTIP_TIMEOUT_ID = null;
var showHyperlinkTooltip = (element, appState, elementsMap) => {
  if (HYPERLINK_TOOLTIP_TIMEOUT_ID) {
    clearTimeout(HYPERLINK_TOOLTIP_TIMEOUT_ID);
  }
  HYPERLINK_TOOLTIP_TIMEOUT_ID = window.setTimeout(
    () => renderTooltip(element, appState, elementsMap),
    HYPERLINK_TOOLTIP_DELAY
  );
};
var renderTooltip = (element, appState, elementsMap) => {
  if (!element.link) {
    return;
  }
  const tooltipDiv = getTooltipDiv();
  tooltipDiv.classList.add("excalidraw-tooltip--visible");
  tooltipDiv.style.maxWidth = "20rem";
  tooltipDiv.textContent = element.link;
  const [x1, y1, x22, y22] = getElementAbsoluteCoords(element, elementsMap);
  const [linkX, linkY, linkWidth, linkHeight] = getLinkHandleFromCoords(
    [x1, y1, x22, y22],
    element.angle,
    appState
  );
  const linkViewportCoords = sceneCoordsToViewportCoords(
    { sceneX: linkX, sceneY: linkY },
    appState
  );
  updateTooltipPosition(
    tooltipDiv,
    {
      left: linkViewportCoords.x,
      top: linkViewportCoords.y,
      width: linkWidth,
      height: linkHeight
    },
    "top"
  );
  trackEvent("hyperlink", "tooltip", "link-icon");
  IS_HYPERLINK_TOOLTIP_VISIBLE = true;
};
var hideHyperlinkToolip = () => {
  if (HYPERLINK_TOOLTIP_TIMEOUT_ID) {
    clearTimeout(HYPERLINK_TOOLTIP_TIMEOUT_ID);
  }
  if (IS_HYPERLINK_TOOLTIP_VISIBLE) {
    IS_HYPERLINK_TOOLTIP_VISIBLE = false;
    getTooltipDiv().classList.remove("excalidraw-tooltip--visible");
  }
};
var shouldHideLinkPopup = (element, elementsMap, appState, [clientX, clientY]) => {
  const { x: sceneX, y: sceneY } = viewportCoordsToSceneCoords(
    { clientX, clientY },
    appState
  );
  const threshold = 15 / appState.zoom.value;
  if (isPointHittingElementBoundingBox(
    element,
    elementsMap,
    [sceneX, sceneY],
    threshold,
    null
  )) {
    return false;
  }
  const [x1, y1, x22] = getElementAbsoluteCoords(element, elementsMap);
  if (sceneX >= x1 && sceneX <= x22 && sceneY >= y1 - SPACE_BOTTOM && sceneY <= y1) {
    return false;
  }
  const { x: popoverX, y: popoverY } = getCoordsForPopover(
    element,
    appState,
    elementsMap
  );
  if (clientX >= popoverX - threshold && clientX <= popoverX + CONTAINER_WIDTH + CONTAINER_PADDING2 * 2 + threshold && clientY >= popoverY - threshold && clientY <= popoverY + threshold + CONTAINER_PADDING2 * 2 + CONTAINER_HEIGHT) {
    return false;
  }
  return true;
};

// renderer/renderSnaps.ts
init_define_import_meta_env();
var SNAP_COLOR_LIGHT = "#ff6b6b";
var SNAP_COLOR_DARK = "#ff0000";
var SNAP_WIDTH = 1;
var SNAP_CROSS_SIZE = 2;
var renderSnaps = (context, appState) => {
  if (!appState.snapLines.length) {
    return;
  }
  const snapColor = appState.theme === "light" || appState.zenModeEnabled ? SNAP_COLOR_LIGHT : SNAP_COLOR_DARK;
  const snapWidth = (appState.zenModeEnabled ? SNAP_WIDTH * 1.5 : SNAP_WIDTH) / appState.zoom.value;
  context.save();
  context.translate(appState.scrollX, appState.scrollY);
  for (const snapLine of appState.snapLines) {
    if (snapLine.type === "pointer") {
      context.lineWidth = snapWidth;
      context.strokeStyle = snapColor;
      drawPointerSnapLine(snapLine, context, appState);
    } else if (snapLine.type === "gap") {
      context.lineWidth = snapWidth;
      context.strokeStyle = snapColor;
      drawGapLine(
        snapLine.points[0],
        snapLine.points[1],
        snapLine.direction,
        appState,
        context
      );
    } else if (snapLine.type === "points") {
      context.lineWidth = snapWidth;
      context.strokeStyle = snapColor;
      drawPointsSnapLine(snapLine, context, appState);
    }
  }
  context.restore();
};
var drawPointsSnapLine = (pointSnapLine, context, appState) => {
  if (!appState.zenModeEnabled) {
    const firstPoint = pointSnapLine.points[0];
    const lastPoint = pointSnapLine.points[pointSnapLine.points.length - 1];
    drawLine(firstPoint, lastPoint, context);
  }
  for (const point2 of pointSnapLine.points) {
    drawCross(point2, appState, context);
  }
};
var drawPointerSnapLine = (pointerSnapLine, context, appState) => {
  drawCross(pointerSnapLine.points[0], appState, context);
  if (!appState.zenModeEnabled) {
    drawLine(pointerSnapLine.points[0], pointerSnapLine.points[1], context);
  }
};
var drawCross = ([x3, y3], appState, context) => {
  context.save();
  const size = (appState.zenModeEnabled ? SNAP_CROSS_SIZE * 1.5 : SNAP_CROSS_SIZE) / appState.zoom.value;
  context.beginPath();
  context.moveTo(x3 - size, y3 - size);
  context.lineTo(x3 + size, y3 + size);
  context.moveTo(x3 + size, y3 - size);
  context.lineTo(x3 - size, y3 + size);
  context.stroke();
  context.restore();
};
var drawLine = (from3, to, context) => {
  context.beginPath();
  context.lineTo(...from3);
  context.lineTo(...to);
  context.stroke();
};
var drawGapLine = (from3, to, direction, appState, context) => {
  const FULL = 8 / appState.zoom.value;
  const HALF = FULL / 2;
  const QUARTER = FULL / 4;
  if (direction === "horizontal") {
    const halfPoint = [(from3[0] + to[0]) / 2, from3[1]];
    if (!appState.zenModeEnabled) {
      drawLine([from3[0], from3[1] - FULL], [from3[0], from3[1] + FULL], context);
    }
    drawLine(
      [halfPoint[0] - QUARTER, halfPoint[1] - HALF],
      [halfPoint[0] - QUARTER, halfPoint[1] + HALF],
      context
    );
    drawLine(
      [halfPoint[0] + QUARTER, halfPoint[1] - HALF],
      [halfPoint[0] + QUARTER, halfPoint[1] + HALF],
      context
    );
    if (!appState.zenModeEnabled) {
      drawLine([to[0], to[1] - FULL], [to[0], to[1] + FULL], context);
      drawLine(from3, to, context);
    }
  } else {
    const halfPoint = [from3[0], (from3[1] + to[1]) / 2];
    if (!appState.zenModeEnabled) {
      drawLine([from3[0] - FULL, from3[1]], [from3[0] + FULL, from3[1]], context);
    }
    drawLine(
      [halfPoint[0] - HALF, halfPoint[1] - QUARTER],
      [halfPoint[0] + HALF, halfPoint[1] - QUARTER],
      context
    );
    drawLine(
      [halfPoint[0] - HALF, halfPoint[1] + QUARTER],
      [halfPoint[0] + HALF, halfPoint[1] + QUARTER],
      context
    );
    if (!appState.zenModeEnabled) {
      drawLine([to[0] - FULL, to[1]], [to[0] + FULL, to[1]], context);
      drawLine(from3, to, context);
    }
  }
};

// renderer/renderScene.ts
var strokeRectWithRotation = (context, x3, y3, width, height, cx, cy, angle, fill = false, radius = 0) => {
  context.save();
  context.translate(cx, cy);
  context.rotate(angle);
  if (fill) {
    context.fillRect(x3 - cx, y3 - cy, width, height);
  }
  if (radius && context.roundRect) {
    context.beginPath();
    context.roundRect(x3 - cx, y3 - cy, width, height, radius);
    context.stroke();
    context.closePath();
  } else {
    context.strokeRect(x3 - cx, y3 - cy, width, height);
  }
  context.restore();
};
var strokeDiamondWithRotation = (context, width, height, cx, cy, angle) => {
  context.save();
  context.translate(cx, cy);
  context.rotate(angle);
  context.beginPath();
  context.moveTo(0, height / 2);
  context.lineTo(width / 2, 0);
  context.lineTo(0, -height / 2);
  context.lineTo(-width / 2, 0);
  context.closePath();
  context.stroke();
  context.restore();
};
var strokeEllipseWithRotation = (context, width, height, cx, cy, angle) => {
  context.beginPath();
  context.ellipse(cx, cy, width / 2, height / 2, angle, 0, Math.PI * 2);
  context.stroke();
};
var fillCircle = (context, cx, cy, radius, stroke = true) => {
  context.beginPath();
  context.arc(cx, cy, radius, 0, Math.PI * 2);
  context.fill();
  if (stroke) {
    context.stroke();
  }
};
var strokeGrid = (context, gridSize, scrollX, scrollY, zoom, width, height) => {
  const BOLD_LINE_FREQUENCY = 5;
  let GridLineColor;
  ((GridLineColor2) => {
    GridLineColor2["Bold"] = "#cccccc";
    GridLineColor2["Regular"] = "#e5e5e5";
  })(GridLineColor || (GridLineColor = {}));
  const offsetX = -Math.round(zoom.value / gridSize) * gridSize + scrollX % gridSize;
  const offsetY = -Math.round(zoom.value / gridSize) * gridSize + scrollY % gridSize;
  const lineWidth = Math.min(1 / zoom.value, 1);
  const spaceWidth = 1 / zoom.value;
  const lineDash = [lineWidth * 3, spaceWidth + (lineWidth + spaceWidth)];
  context.save();
  context.lineWidth = lineWidth;
  for (let x3 = offsetX; x3 < offsetX + width + gridSize * 2; x3 += gridSize) {
    const isBold = Math.round(x3 - scrollX) % (BOLD_LINE_FREQUENCY * gridSize) === 0;
    context.beginPath();
    context.setLineDash(isBold ? [] : lineDash);
    context.strokeStyle = isBold ? "#cccccc" /* Bold */ : "#e5e5e5" /* Regular */;
    context.moveTo(x3, offsetY - gridSize);
    context.lineTo(x3, offsetY + height + gridSize * 2);
    context.stroke();
  }
  for (let y3 = offsetY; y3 < offsetY + height + gridSize * 2; y3 += gridSize) {
    const isBold = Math.round(y3 - scrollY) % (BOLD_LINE_FREQUENCY * gridSize) === 0;
    context.beginPath();
    context.setLineDash(isBold ? [] : lineDash);
    context.strokeStyle = isBold ? "#cccccc" /* Bold */ : "#e5e5e5" /* Regular */;
    context.moveTo(offsetX - gridSize, y3);
    context.lineTo(offsetX + width + gridSize * 2, y3);
    context.stroke();
  }
  context.restore();
};
var renderSingleLinearPoint = (context, appState, point2, radius, isSelected, isPhantomPoint = false) => {
  context.strokeStyle = "#5e5ad8";
  context.setLineDash([]);
  context.fillStyle = "rgba(255, 255, 255, 0.9)";
  if (isSelected) {
    context.fillStyle = "rgba(134, 131, 226, 0.9)";
  } else if (isPhantomPoint) {
    context.fillStyle = "rgba(177, 151, 252, 0.7)";
  }
  fillCircle(
    context,
    point2[0],
    point2[1],
    radius / appState.zoom.value,
    !isPhantomPoint
  );
};
var renderLinearPointHandles = (context, appState, element, elementsMap) => {
  if (!appState.selectedLinearElement) {
    return;
  }
  context.save();
  context.translate(appState.scrollX, appState.scrollY);
  context.lineWidth = 1 / appState.zoom.value;
  const points = LinearElementEditor.getPointsGlobalCoordinates(
    element,
    elementsMap
  );
  const { POINT_HANDLE_SIZE } = LinearElementEditor;
  const radius = appState.editingLinearElement ? POINT_HANDLE_SIZE : POINT_HANDLE_SIZE / 2;
  points.forEach((point2, idx) => {
    const isSelected = !!appState.editingLinearElement?.selectedPointsIndices?.includes(idx);
    renderSingleLinearPoint(context, appState, point2, radius, isSelected);
  });
  const midPoints = LinearElementEditor.getEditorMidPoints(
    element,
    elementsMap,
    appState
  ).filter((midPoint) => midPoint !== null);
  midPoints.forEach((segmentMidPoint) => {
    if (appState?.selectedLinearElement?.segmentMidPointHoveredCoords && LinearElementEditor.arePointsEqual(
      segmentMidPoint,
      appState.selectedLinearElement.segmentMidPointHoveredCoords
    )) {
      if (appState.editingLinearElement) {
        renderSingleLinearPoint(
          context,
          appState,
          segmentMidPoint,
          radius,
          false
        );
        highlightPoint(segmentMidPoint, context, appState);
      } else {
        highlightPoint(segmentMidPoint, context, appState);
        renderSingleLinearPoint(
          context,
          appState,
          segmentMidPoint,
          radius,
          false
        );
      }
    } else if (appState.editingLinearElement || points.length === 2) {
      renderSingleLinearPoint(
        context,
        appState,
        segmentMidPoint,
        POINT_HANDLE_SIZE / 2,
        false,
        true
      );
    }
  });
  context.restore();
};
var highlightPoint = (point2, context, appState) => {
  context.fillStyle = "rgba(105, 101, 219, 0.4)";
  fillCircle(
    context,
    point2[0],
    point2[1],
    LinearElementEditor.POINT_HANDLE_SIZE / appState.zoom.value,
    false
  );
};
var renderLinearElementPointHighlight = (context, appState, elementsMap) => {
  const { elementId, hoverPointIndex } = appState.selectedLinearElement;
  if (appState.editingLinearElement?.selectedPointsIndices?.includes(
    hoverPointIndex
  )) {
    return;
  }
  const element = LinearElementEditor.getElement(elementId, elementsMap);
  if (!element) {
    return;
  }
  const point2 = LinearElementEditor.getPointAtIndexGlobalCoordinates(
    element,
    hoverPointIndex,
    elementsMap
  );
  context.save();
  context.translate(appState.scrollX, appState.scrollY);
  highlightPoint(point2, context, appState);
  context.restore();
};
var frameClip = (frame, context, renderConfig, appState) => {
  context.translate(frame.x + appState.scrollX, frame.y + appState.scrollY);
  context.beginPath();
  if (context.roundRect) {
    context.roundRect(
      0,
      0,
      frame.width,
      frame.height,
      FRAME_STYLE.radius / appState.zoom.value
    );
  } else {
    context.rect(0, 0, frame.width, frame.height);
  }
  context.clip();
  context.translate(
    -(frame.x + appState.scrollX),
    -(frame.y + appState.scrollY)
  );
};
var getNormalizedCanvasDimensions = (canvas2, scale) => {
  return [canvas2.width / scale, canvas2.height / scale];
};
var bootstrapCanvas = ({
  canvas: canvas2,
  scale,
  normalizedWidth,
  normalizedHeight,
  theme,
  isExporting,
  viewBackgroundColor
}) => {
  const context = canvas2.getContext("2d");
  context.setTransform(1, 0, 0, 1, 0, 0);
  context.scale(scale, scale);
  if (isExporting && theme === "dark") {
    context.filter = THEME_FILTER;
  }
  if (typeof viewBackgroundColor === "string") {
    const hasTransparence = viewBackgroundColor === "transparent" || viewBackgroundColor.length === 5 || // #RGBA
    viewBackgroundColor.length === 9 || // #RRGGBBA
    /(hsla|rgba)\(/.test(viewBackgroundColor);
    if (hasTransparence) {
      context.clearRect(0, 0, normalizedWidth, normalizedHeight);
    }
    context.save();
    context.fillStyle = viewBackgroundColor;
    context.fillRect(0, 0, normalizedWidth, normalizedHeight);
    context.restore();
  } else {
    context.clearRect(0, 0, normalizedWidth, normalizedHeight);
  }
  return context;
};
var _renderInteractiveScene = ({
  canvas: canvas2,
  elementsMap,
  visibleElements,
  selectedElements,
  scale,
  appState,
  renderConfig
}) => {
  if (canvas2 === null) {
    return { atLeastOneVisibleElement: false, elementsMap };
  }
  const [normalizedWidth, normalizedHeight] = getNormalizedCanvasDimensions(
    canvas2,
    scale
  );
  const context = bootstrapCanvas({
    canvas: canvas2,
    scale,
    normalizedWidth,
    normalizedHeight
  });
  context.save();
  context.scale(appState.zoom.value, appState.zoom.value);
  let editingLinearElement = void 0;
  visibleElements.forEach((element) => {
    if (appState.editingLinearElement?.elementId === element.id) {
      if (element) {
        editingLinearElement = element;
      }
    }
  });
  if (editingLinearElement) {
    renderLinearPointHandles(
      context,
      appState,
      editingLinearElement,
      elementsMap
    );
  }
  if (appState.selectionElement) {
    try {
      renderSelectionElement(appState.selectionElement, context, appState);
    } catch (error) {
      console.error(error);
    }
  }
  if (appState.isBindingEnabled) {
    appState.suggestedBindings.filter((binding) => binding != null).forEach((suggestedBinding) => {
      renderBindingHighlight(
        context,
        appState,
        suggestedBinding,
        elementsMap
      );
    });
  }
  if (appState.frameToHighlight) {
    renderFrameHighlight(
      context,
      appState,
      appState.frameToHighlight,
      elementsMap
    );
  }
  if (appState.elementsToHighlight) {
    renderElementsBoxHighlight(context, appState, appState.elementsToHighlight);
  }
  const isFrameSelected = selectedElements.some(
    (element) => isFrameLikeElement(element)
  );
  if (selectedElements.length === 1 && appState.editingLinearElement?.elementId === selectedElements[0].id) {
    renderLinearPointHandles(
      context,
      appState,
      selectedElements[0],
      elementsMap
    );
  }
  if (appState.selectedLinearElement && appState.selectedLinearElement.hoverPointIndex >= 0) {
    renderLinearElementPointHighlight(context, appState, elementsMap);
  }
  if (!appState.multiElement && !appState.editingLinearElement) {
    const showBoundingBox = shouldShowBoundingBox(selectedElements, appState);
    const isSingleLinearElementSelected = selectedElements.length === 1 && isLinearElement(selectedElements[0]);
    if (isSingleLinearElementSelected && appState.selectedLinearElement?.elementId === selectedElements[0].id && !selectedElements[0].locked) {
      renderLinearPointHandles(
        context,
        appState,
        selectedElements[0],
        elementsMap
      );
    }
    const selectionColor = renderConfig.selectionColor || open_color_default.black;
    if (showBoundingBox) {
      const locallySelectedIds = arrayToMap(selectedElements);
      const selections = [];
      for (const element of elementsMap.values()) {
        const selectionColors = [];
        if (locallySelectedIds.has(element.id) && !isSelectedViaGroup(appState, element)) {
          selectionColors.push(selectionColor);
        }
        if (renderConfig.remoteSelectedElementIds[element.id]) {
          selectionColors.push(
            ...renderConfig.remoteSelectedElementIds[element.id].map(
              (socketId) => {
                const background = getClientColor(socketId);
                return background;
              }
            )
          );
        }
        if (selectionColors.length) {
          const [elementX1, elementY1, elementX2, elementY2, cx, cy] = getElementAbsoluteCoords(element, elementsMap, true);
          selections.push({
            angle: element.angle,
            elementX1,
            elementY1,
            elementX2,
            elementY2,
            selectionColors,
            dashed: !!renderConfig.remoteSelectedElementIds[element.id],
            cx,
            cy,
            activeEmbeddable: appState.activeEmbeddable?.element === element && appState.activeEmbeddable.state === "active"
          });
        }
      }
      const addSelectionForGroupId = (groupId) => {
        const groupElements = getElementsInGroup(elementsMap, groupId);
        const [elementX1, elementY1, elementX2, elementY2] = getCommonBounds(groupElements);
        selections.push({
          angle: 0,
          elementX1,
          elementX2,
          elementY1,
          elementY2,
          selectionColors: [open_color_default.black],
          dashed: true,
          cx: elementX1 + (elementX2 - elementX1) / 2,
          cy: elementY1 + (elementY2 - elementY1) / 2,
          activeEmbeddable: false
        });
      };
      for (const groupId of getSelectedGroupIds(appState)) {
        addSelectionForGroupId(groupId);
      }
      if (appState.editingGroupId) {
        addSelectionForGroupId(appState.editingGroupId);
      }
      selections.forEach(
        (selection) => renderSelectionBorder(context, appState, selection)
      );
    }
    context.save();
    context.translate(appState.scrollX, appState.scrollY);
    if (selectedElements.length === 1) {
      context.fillStyle = open_color_default.white;
      const transformHandles = getTransformHandles(
        selectedElements[0],
        appState.zoom,
        elementsMap,
        "mouse"
        // when we render we don't know which pointer type so use mouse,
      );
      if (!appState.viewModeEnabled && showBoundingBox) {
        renderTransformHandles(
          context,
          renderConfig,
          appState,
          transformHandles,
          selectedElements[0].angle
        );
      }
    } else if (selectedElements.length > 1 && !appState.isRotating) {
      const dashedLinePadding = DEFAULT_TRANSFORM_HANDLE_SPACING * 2 / appState.zoom.value;
      context.fillStyle = open_color_default.white;
      const [x1, y1, x22, y22] = getCommonBounds(selectedElements);
      const initialLineDash = context.getLineDash();
      context.setLineDash([2 / appState.zoom.value]);
      const lineWidth = context.lineWidth;
      context.lineWidth = 1 / appState.zoom.value;
      context.strokeStyle = selectionColor;
      strokeRectWithRotation(
        context,
        x1 - dashedLinePadding,
        y1 - dashedLinePadding,
        x22 - x1 + dashedLinePadding * 2,
        y22 - y1 + dashedLinePadding * 2,
        (x1 + x22) / 2,
        (y1 + y22) / 2,
        0
      );
      context.lineWidth = lineWidth;
      context.setLineDash(initialLineDash);
      const transformHandles = getTransformHandlesFromCoords(
        [x1, y1, x22, y22, (x1 + x22) / 2, (y1 + y22) / 2],
        0,
        appState.zoom,
        "mouse",
        isFrameSelected ? OMIT_SIDES_FOR_FRAME : OMIT_SIDES_FOR_MULTIPLE_ELEMENTS
      );
      if (selectedElements.some((element) => !element.locked)) {
        renderTransformHandles(
          context,
          renderConfig,
          appState,
          transformHandles,
          0
        );
      }
    }
    context.restore();
  }
  renderSnaps(context, appState);
  context.restore();
  for (const clientId in renderConfig.remotePointerViewportCoords) {
    let { x: x3, y: y3 } = renderConfig.remotePointerViewportCoords[clientId];
    x3 -= appState.offsetLeft;
    y3 -= appState.offsetTop;
    const width = 11;
    const height = 14;
    const isOutOfBounds = x3 < 0 || x3 > normalizedWidth - width || y3 < 0 || y3 > normalizedHeight - height;
    x3 = Math.max(x3, 0);
    x3 = Math.min(x3, normalizedWidth - width);
    y3 = Math.max(y3, 0);
    y3 = Math.min(y3, normalizedHeight - height);
    const background = getClientColor(clientId);
    context.save();
    context.strokeStyle = background;
    context.fillStyle = background;
    const userState = renderConfig.remotePointerUserStates[clientId];
    const isInactive = isOutOfBounds || userState === "idle" /* IDLE */ || userState === "away" /* AWAY */;
    if (isInactive) {
      context.globalAlpha = 0.3;
    }
    if (renderConfig.remotePointerButton && renderConfig.remotePointerButton[clientId] === "down") {
      context.beginPath();
      context.arc(x3, y3, 15, 0, 2 * Math.PI, false);
      context.lineWidth = 3;
      context.strokeStyle = "#ffffff88";
      context.stroke();
      context.closePath();
      context.beginPath();
      context.arc(x3, y3, 15, 0, 2 * Math.PI, false);
      context.lineWidth = 1;
      context.strokeStyle = background;
      context.stroke();
      context.closePath();
    }
    context.fillStyle = open_color_default.white;
    context.strokeStyle = open_color_default.white;
    context.lineWidth = 6;
    context.lineJoin = "round";
    context.beginPath();
    context.moveTo(x3, y3);
    context.lineTo(x3 + 0, y3 + 14);
    context.lineTo(x3 + 4, y3 + 9);
    context.lineTo(x3 + 11, y3 + 8);
    context.closePath();
    context.stroke();
    context.fill();
    context.fillStyle = background;
    context.strokeStyle = background;
    context.lineWidth = 2;
    context.lineJoin = "round";
    context.beginPath();
    if (isInactive) {
      context.moveTo(x3 - 1, y3 - 1);
      context.lineTo(x3 - 1, y3 + 15);
      context.lineTo(x3 + 5, y3 + 10);
      context.lineTo(x3 + 12, y3 + 9);
      context.closePath();
      context.fill();
    } else {
      context.moveTo(x3, y3);
      context.lineTo(x3 + 0, y3 + 14);
      context.lineTo(x3 + 4, y3 + 9);
      context.lineTo(x3 + 11, y3 + 8);
      context.closePath();
      context.fill();
      context.stroke();
    }
    const username = renderConfig.remotePointerUsernames[clientId] || "";
    if (!isOutOfBounds && username) {
      context.font = "600 12px sans-serif";
      const offsetX = x3 + width / 2;
      const offsetY = y3 + height + 2;
      const paddingHorizontal = 5;
      const paddingVertical = 3;
      const measure = context.measureText(username);
      const measureHeight = measure.actualBoundingBoxDescent + measure.actualBoundingBoxAscent;
      const finalHeight = Math.max(measureHeight, 12);
      const boxX = offsetX - 1;
      const boxY = offsetY - 1;
      const boxWidth = measure.width + 2 + paddingHorizontal * 2 + 2;
      const boxHeight = finalHeight + 2 + paddingVertical * 2 + 2;
      if (context.roundRect) {
        context.beginPath();
        context.roundRect(boxX, boxY, boxWidth, boxHeight, 8);
        context.fillStyle = background;
        context.fill();
        context.strokeStyle = open_color_default.white;
        context.stroke();
      } else {
        roundRect(context, boxX, boxY, boxWidth, boxHeight, 8, open_color_default.white);
      }
      context.fillStyle = open_color_default.black;
      context.fillText(
        username,
        offsetX + paddingHorizontal + 1,
        offsetY + paddingVertical + measure.actualBoundingBoxAscent + Math.floor((finalHeight - measureHeight) / 2) + 2
      );
    }
    context.restore();
    context.closePath();
  }
  let scrollBars;
  if (renderConfig.renderScrollbars) {
    scrollBars = getScrollBars(
      visibleElements,
      normalizedWidth,
      normalizedHeight,
      appState
    );
    context.save();
    context.fillStyle = SCROLLBAR_COLOR;
    context.strokeStyle = "rgba(255,255,255,0.8)";
    [scrollBars.horizontal, scrollBars.vertical].forEach((scrollBar) => {
      if (scrollBar) {
        roundRect(
          context,
          scrollBar.x,
          scrollBar.y,
          scrollBar.width,
          scrollBar.height,
          SCROLLBAR_WIDTH / 2
        );
      }
    });
    context.restore();
  }
  return {
    scrollBars,
    atLeastOneVisibleElement: visibleElements.length > 0,
    elementsMap
  };
};
var _renderStaticScene = ({
  canvas: canvas2,
  rc,
  elementsMap,
  allElementsMap,
  visibleElements,
  scale,
  appState,
  renderConfig
}) => {
  if (canvas2 === null) {
    return;
  }
  const { renderGrid = true, isExporting } = renderConfig;
  const [normalizedWidth, normalizedHeight] = getNormalizedCanvasDimensions(
    canvas2,
    scale
  );
  const context = bootstrapCanvas({
    canvas: canvas2,
    scale,
    normalizedWidth,
    normalizedHeight,
    theme: appState.theme,
    isExporting,
    viewBackgroundColor: appState.viewBackgroundColor
  });
  context.scale(appState.zoom.value, appState.zoom.value);
  if (renderGrid && appState.gridSize) {
    strokeGrid(
      context,
      appState.gridSize,
      appState.scrollX,
      appState.scrollY,
      appState.zoom,
      normalizedWidth / appState.zoom.value,
      normalizedHeight / appState.zoom.value
    );
  }
  const groupsToBeAddedToFrame = /* @__PURE__ */ new Set();
  visibleElements.forEach((element) => {
    if (element.groupIds.length > 0 && appState.frameToHighlight && appState.selectedElementIds[element.id] && (elementOverlapsWithFrame(
      element,
      appState.frameToHighlight,
      elementsMap
    ) || element.groupIds.find((groupId) => groupsToBeAddedToFrame.has(groupId)))) {
      element.groupIds.forEach(
        (groupId) => groupsToBeAddedToFrame.add(groupId)
      );
    }
  });
  visibleElements.filter((el) => !isIframeLikeElement(el)).forEach((element) => {
    try {
      const frameId = element.frameId || appState.frameToHighlight?.id;
      if (frameId && appState.frameRendering.enabled && appState.frameRendering.clip) {
        context.save();
        const frame = getTargetFrame(element, elementsMap, appState);
        if (frame && isElementInFrame(element, elementsMap, appState)) {
          frameClip(frame, context, renderConfig, appState);
        }
        renderElement(
          element,
          elementsMap,
          allElementsMap,
          rc,
          context,
          renderConfig,
          appState
        );
        context.restore();
      } else {
        renderElement(
          element,
          elementsMap,
          allElementsMap,
          rc,
          context,
          renderConfig,
          appState
        );
      }
      if (!isExporting) {
        renderLinkIcon(element, context, appState, elementsMap);
      }
    } catch (error) {
      console.error(error);
    }
  });
  visibleElements.filter((el) => isIframeLikeElement(el)).forEach((element) => {
    try {
      const render = () => {
        renderElement(
          element,
          elementsMap,
          allElementsMap,
          rc,
          context,
          renderConfig,
          appState
        );
        if (isIframeLikeElement(element) && (isExporting || isEmbeddableElement(element) && renderConfig.embedsValidationStatus.get(element.id) !== true) && element.width && element.height) {
          const label = createPlaceholderEmbeddableLabel(element);
          renderElement(
            label,
            elementsMap,
            allElementsMap,
            rc,
            context,
            renderConfig,
            appState
          );
        }
        if (!isExporting) {
          renderLinkIcon(element, context, appState, elementsMap);
        }
      };
      const frameId = element.frameId || appState.frameToHighlight?.id;
      if (frameId && appState.frameRendering.enabled && appState.frameRendering.clip) {
        context.save();
        const frame = getTargetFrame(element, elementsMap, appState);
        if (frame && isElementInFrame(element, elementsMap, appState)) {
          frameClip(frame, context, renderConfig, appState);
        }
        render();
        context.restore();
      } else {
        render();
      }
    } catch (error) {
      console.error(error);
    }
  });
};
var renderInteractiveSceneThrottled = throttleRAF(
  (config) => {
    const ret = _renderInteractiveScene(config);
    config.callback?.(ret);
  },
  { trailing: true }
);
var renderInteractiveScene = (renderConfig, throttle3) => {
  if (throttle3) {
    renderInteractiveSceneThrottled(renderConfig);
    return void 0;
  }
  const ret = _renderInteractiveScene(renderConfig);
  renderConfig.callback(ret);
  return ret;
};
var renderStaticSceneThrottled = throttleRAF(
  (config) => {
    _renderStaticScene(config);
  },
  { trailing: true }
);
var renderStaticScene = (renderConfig, throttle3) => {
  if (throttle3) {
    renderStaticSceneThrottled(renderConfig);
    return;
  }
  _renderStaticScene(renderConfig);
};
var cancelRender = () => {
  renderInteractiveSceneThrottled.cancel();
  renderStaticSceneThrottled.cancel();
};
var renderTransformHandles = (context, renderConfig, appState, transformHandles, angle) => {
  Object.keys(transformHandles).forEach((key) => {
    const transformHandle = transformHandles[key];
    if (transformHandle !== void 0) {
      const [x3, y3, width, height] = transformHandle;
      context.save();
      context.lineWidth = 1 / appState.zoom.value;
      if (renderConfig.selectionColor) {
        context.strokeStyle = renderConfig.selectionColor;
      }
      if (key === "rotation") {
        fillCircle(context, x3 + width / 2, y3 + height / 2, width / 2);
      } else if (context.roundRect) {
        context.beginPath();
        context.roundRect(x3, y3, width, height, 2 / appState.zoom.value);
        context.fill();
        context.stroke();
      } else {
        strokeRectWithRotation(
          context,
          x3,
          y3,
          width,
          height,
          x3 + width / 2,
          y3 + height / 2,
          angle,
          true
          // fill before stroke
        );
      }
      context.restore();
    }
  });
};
var renderSelectionBorder = (context, appState, elementProperties, padding = DEFAULT_TRANSFORM_HANDLE_SPACING * 2) => {
  const {
    angle,
    elementX1,
    elementY1,
    elementX2,
    elementY2,
    selectionColors,
    cx,
    cy,
    dashed,
    activeEmbeddable
  } = elementProperties;
  const elementWidth = elementX2 - elementX1;
  const elementHeight = elementY2 - elementY1;
  const linePadding = padding / appState.zoom.value;
  const lineWidth = 8 / appState.zoom.value;
  const spaceWidth = 4 / appState.zoom.value;
  context.save();
  context.translate(appState.scrollX, appState.scrollY);
  context.lineWidth = (activeEmbeddable ? 4 : 1) / appState.zoom.value;
  const count = selectionColors.length;
  for (let index2 = 0; index2 < count; ++index2) {
    context.strokeStyle = selectionColors[index2];
    if (dashed) {
      context.setLineDash([
        lineWidth,
        spaceWidth + (lineWidth + spaceWidth) * (count - 1)
      ]);
    }
    context.lineDashOffset = (lineWidth + spaceWidth) * index2;
    strokeRectWithRotation(
      context,
      elementX1 - linePadding,
      elementY1 - linePadding,
      elementWidth + linePadding * 2,
      elementHeight + linePadding * 2,
      cx,
      cy,
      angle
    );
  }
  context.restore();
};
var renderBindingHighlight = (context, appState, suggestedBinding, elementsMap) => {
  const renderHighlight = Array.isArray(suggestedBinding) ? renderBindingHighlightForSuggestedPointBinding : renderBindingHighlightForBindableElement;
  context.save();
  context.translate(appState.scrollX, appState.scrollY);
  renderHighlight(context, suggestedBinding, elementsMap);
  context.restore();
};
var renderBindingHighlightForBindableElement = (context, element, elementsMap) => {
  const [x1, y1, x22, y22] = getElementAbsoluteCoords(element, elementsMap);
  const width = x22 - x1;
  const height = y22 - y1;
  const threshold = maxBindingGap(element, width, height);
  const strokeOffset = 4;
  context.strokeStyle = "rgba(0,0,0,.05)";
  context.lineWidth = threshold - strokeOffset;
  const padding = strokeOffset / 2 + threshold / 2;
  switch (element.type) {
    case "rectangle":
    case "text":
    case "image":
    case "iframe":
    case "embeddable":
    case "frame":
    case "magicframe":
      strokeRectWithRotation(
        context,
        x1 - padding,
        y1 - padding,
        width + padding * 2,
        height + padding * 2,
        x1 + width / 2,
        y1 + height / 2,
        element.angle
      );
      break;
    case "diamond":
      const side = Math.hypot(width, height);
      const wPadding = padding * side / height;
      const hPadding = padding * side / width;
      strokeDiamondWithRotation(
        context,
        width + wPadding * 2,
        height + hPadding * 2,
        x1 + width / 2,
        y1 + height / 2,
        element.angle
      );
      break;
    case "ellipse":
      strokeEllipseWithRotation(
        context,
        width + padding * 2,
        height + padding * 2,
        x1 + width / 2,
        y1 + height / 2,
        element.angle
      );
      break;
  }
};
var renderFrameHighlight = (context, appState, frame, elementsMap) => {
  const [x1, y1, x22, y22] = getElementAbsoluteCoords(frame, elementsMap);
  const width = x22 - x1;
  const height = y22 - y1;
  context.strokeStyle = "rgb(0,118,255)";
  context.lineWidth = FRAME_STYLE.strokeWidth / appState.zoom.value;
  context.save();
  context.translate(appState.scrollX, appState.scrollY);
  strokeRectWithRotation(
    context,
    x1,
    y1,
    width,
    height,
    x1 + width / 2,
    y1 + height / 2,
    frame.angle,
    false,
    FRAME_STYLE.radius / appState.zoom.value
  );
  context.restore();
};
var renderElementsBoxHighlight = (context, appState, elements) => {
  const individualElements = elements.filter(
    (element) => element.groupIds.length === 0
  );
  const elementsInGroups = elements.filter(
    (element) => element.groupIds.length > 0
  );
  const getSelectionFromElements = (elements2) => {
    const [elementX1, elementY1, elementX2, elementY2] = getCommonBounds(elements2);
    return {
      angle: 0,
      elementX1,
      elementX2,
      elementY1,
      elementY2,
      selectionColors: ["rgb(0,118,255)"],
      dashed: false,
      cx: elementX1 + (elementX2 - elementX1) / 2,
      cy: elementY1 + (elementY2 - elementY1) / 2,
      activeEmbeddable: false
    };
  };
  const getSelectionForGroupId = (groupId) => {
    const groupElements = getElementsInGroup(elements, groupId);
    return getSelectionFromElements(groupElements);
  };
  Object.entries(selectGroupsFromGivenElements(elementsInGroups, appState)).filter(([id, isSelected]) => isSelected).map(([id, isSelected]) => id).map((groupId) => getSelectionForGroupId(groupId)).concat(
    individualElements.map((element) => getSelectionFromElements([element]))
  ).forEach(
    (selection) => renderSelectionBorder(context, appState, selection)
  );
};
var renderBindingHighlightForSuggestedPointBinding = (context, suggestedBinding, elementsMap) => {
  const [element, startOrEnd, bindableElement] = suggestedBinding;
  const threshold = maxBindingGap(
    bindableElement,
    bindableElement.width,
    bindableElement.height
  );
  context.strokeStyle = "rgba(0,0,0,0)";
  context.fillStyle = "rgba(0,0,0,.05)";
  const pointIndices = startOrEnd === "both" ? [0, -1] : startOrEnd === "start" ? [0] : [-1];
  pointIndices.forEach((index2) => {
    const [x3, y3] = LinearElementEditor.getPointAtIndexGlobalCoordinates(
      element,
      index2,
      elementsMap
    );
    fillCircle(context, x3, y3, threshold);
  });
};
var linkCanvasCache;
var renderLinkIcon = (element, context, appState, elementsMap) => {
  if (element.link && !appState.selectedElementIds[element.id]) {
    const [x1, y1, x22, y22] = getElementAbsoluteCoords(element, elementsMap);
    const [x3, y3, width, height] = getLinkHandleFromCoords(
      [x1, y1, x22, y22],
      element.angle,
      appState
    );
    const centerX = x3 + width / 2;
    const centerY = y3 + height / 2;
    context.save();
    context.translate(appState.scrollX + centerX, appState.scrollY + centerY);
    context.rotate(element.angle);
    if (!linkCanvasCache || linkCanvasCache.zoom !== appState.zoom.value) {
      linkCanvasCache = document.createElement("canvas");
      linkCanvasCache.zoom = appState.zoom.value;
      linkCanvasCache.width = width * window.devicePixelRatio * appState.zoom.value;
      linkCanvasCache.height = height * window.devicePixelRatio * appState.zoom.value;
      const linkCanvasCacheContext = linkCanvasCache.getContext("2d");
      linkCanvasCacheContext.scale(
        window.devicePixelRatio * appState.zoom.value,
        window.devicePixelRatio * appState.zoom.value
      );
      linkCanvasCacheContext.fillStyle = "#fff";
      linkCanvasCacheContext.fillRect(0, 0, width, height);
      linkCanvasCacheContext.drawImage(EXTERNAL_LINK_IMG, 0, 0, width, height);
      linkCanvasCacheContext.restore();
      context.drawImage(
        linkCanvasCache,
        x3 - centerX,
        y3 - centerY,
        width,
        height
      );
    } else {
      context.drawImage(
        linkCanvasCache,
        x3 - centerX,
        y3 - centerY,
        width,
        height
      );
    }
    context.restore();
  }
};
var renderSceneToSvg = (elements, elementsMap, rsvg, svgRoot, files, renderConfig) => {
  if (!svgRoot) {
    return;
  }
  elements.filter((el) => !isIframeLikeElement(el)).forEach((element) => {
    if (!element.isDeleted) {
      try {
        renderElementToSvg(
          element,
          elementsMap,
          rsvg,
          svgRoot,
          files,
          element.x + renderConfig.offsetX,
          element.y + renderConfig.offsetY,
          renderConfig
        );
      } catch (error) {
        console.error(error);
      }
    }
  });
  elements.filter((el) => isIframeLikeElement(el)).forEach((element) => {
    if (!element.isDeleted) {
      try {
        renderElementToSvg(
          element,
          elementsMap,
          rsvg,
          svgRoot,
          files,
          element.x + renderConfig.offsetX,
          element.y + renderConfig.offsetY,
          renderConfig
        );
      } catch (error) {
        console.error(error);
      }
    }
  });
};

// scene/export.ts
var SVG_EXPORT_TAG = `<!-- svg-source:excalidraw -->`;
var __createSceneForElementsHack__ = (elements) => {
  const scene = new Scene_default();
  scene.replaceAllElements(cloneJSON(elements), false);
  return scene;
};
var truncateText = (element, maxWidth) => {
  if (element.width <= maxWidth) {
    return element;
  }
  const canvas2 = document.createElement("canvas");
  const ctx = canvas2.getContext("2d");
  ctx.font = getFontString({
    fontFamily: element.fontFamily,
    fontSize: element.fontSize
  });
  let text = element.text;
  const metrics = ctx.measureText(text);
  if (metrics.width > maxWidth) {
    for (let i4 = text.length; i4 > 0; i4--) {
      const newText = `${text.slice(0, i4)}...`;
      if (ctx.measureText(newText).width <= maxWidth) {
        text = newText;
        break;
      }
    }
  }
  return newElementWith(element, { text, width: maxWidth });
};
var addFrameLabelsAsTextElements = (elements, opts) => {
  const nextElements = [];
  let frameIndex = 0;
  let magicFrameIndex = 0;
  for (const element of elements) {
    if (isFrameLikeElement(element)) {
      if (isFrameElement(element)) {
        frameIndex++;
      } else {
        magicFrameIndex++;
      }
      let textElement = newTextElement({
        x: element.x,
        y: element.y - FRAME_STYLE.nameOffsetY,
        fontFamily: FONT_FAMILY.Assistant,
        fontSize: FRAME_STYLE.nameFontSize,
        lineHeight: FRAME_STYLE.nameLineHeight,
        strokeColor: opts.exportWithDarkMode ? FRAME_STYLE.nameColorDarkTheme : FRAME_STYLE.nameColorLightTheme,
        text: getFrameLikeTitle(
          element,
          isFrameElement(element) ? frameIndex : magicFrameIndex
        )
      });
      textElement.y -= textElement.height;
      textElement = truncateText(textElement, element.width);
      nextElements.push(textElement);
    }
    nextElements.push(element);
  }
  return nextElements;
};
var getFrameRenderingConfig = (exportingFrame, frameRendering) => {
  frameRendering = frameRendering || getDefaultAppState().frameRendering;
  return {
    enabled: exportingFrame ? true : frameRendering.enabled,
    outline: exportingFrame ? false : frameRendering.outline,
    name: exportingFrame ? false : frameRendering.name,
    clip: exportingFrame ? true : frameRendering.clip
  };
};
var prepareElementsForRender = ({
  elements,
  exportingFrame,
  frameRendering,
  exportWithDarkMode
}) => {
  let nextElements;
  if (exportingFrame) {
    nextElements = getElementsOverlappingFrame(elements, exportingFrame);
  } else if (frameRendering.enabled && frameRendering.name) {
    nextElements = addFrameLabelsAsTextElements(elements, {
      exportWithDarkMode
    });
  } else {
    nextElements = elements;
  }
  return nextElements;
};
var exportToCanvas = async (elements, appState, files, {
  exportBackground,
  exportPadding = DEFAULT_EXPORT_PADDING,
  viewBackgroundColor,
  exportingFrame
}, createCanvas = (width, height) => {
  const canvas2 = document.createElement("canvas");
  canvas2.width = width * appState.exportScale;
  canvas2.height = height * appState.exportScale;
  return { canvas: canvas2, scale: appState.exportScale };
}) => {
  const tempScene = __createSceneForElementsHack__(elements);
  elements = tempScene.getNonDeletedElements();
  const frameRendering = getFrameRenderingConfig(
    exportingFrame ?? null,
    appState.frameRendering ?? null
  );
  const elementsForRender = prepareElementsForRender({
    elements,
    exportingFrame,
    exportWithDarkMode: appState.exportWithDarkMode,
    frameRendering
  });
  if (exportingFrame) {
    exportPadding = 0;
  }
  const [minX, minY, width, height] = getCanvasSize(
    exportingFrame ? [exportingFrame] : getRootElements(elementsForRender),
    exportPadding
  );
  const { canvas: canvas2, scale = 1 } = createCanvas(width, height);
  const defaultAppState2 = getDefaultAppState();
  const { imageCache } = await updateImageCache({
    imageCache: /* @__PURE__ */ new Map(),
    fileIds: getInitializedImageElements(elementsForRender).map(
      (element) => element.fileId
    ),
    files
  });
  renderStaticScene({
    canvas: canvas2,
    rc: rough_default.canvas(canvas2),
    elementsMap: toBrandedType(
      arrayToMap(elementsForRender)
    ),
    allElementsMap: toBrandedType(
      arrayToMap(elements)
    ),
    visibleElements: elementsForRender,
    scale,
    appState: {
      ...appState,
      frameRendering,
      viewBackgroundColor: exportBackground ? viewBackgroundColor : null,
      scrollX: -minX + exportPadding,
      scrollY: -minY + exportPadding,
      zoom: defaultAppState2.zoom,
      shouldCacheIgnoreZoom: false,
      theme: appState.exportWithDarkMode ? "dark" : "light"
    },
    renderConfig: {
      canvasBackgroundColor: viewBackgroundColor,
      imageCache,
      renderGrid: false,
      isExporting: true,
      // empty disables embeddable rendering
      embedsValidationStatus: /* @__PURE__ */ new Map(),
      elementsPendingErasure: /* @__PURE__ */ new Set()
    }
  });
  tempScene.destroy();
  return canvas2;
};
var exportToSvg = async (elements, appState, files, opts) => {
  const tempScene = __createSceneForElementsHack__(elements);
  elements = tempScene.getNonDeletedElements();
  const frameRendering = getFrameRenderingConfig(
    opts?.exportingFrame ?? null,
    appState.frameRendering ?? null
  );
  let {
    exportPadding = DEFAULT_EXPORT_PADDING,
    exportWithDarkMode = false,
    viewBackgroundColor,
    exportScale = 1,
    exportEmbedScene
  } = appState;
  const { exportingFrame = null } = opts || {};
  const elementsForRender = prepareElementsForRender({
    elements,
    exportingFrame,
    exportWithDarkMode,
    frameRendering
  });
  if (exportingFrame) {
    exportPadding = 0;
  }
  let metadata = "";
  if (exportEmbedScene) {
    try {
      metadata = await (await import("./image-YINPW27J.js")).encodeSvgMetadata({
        // when embedding scene, we want to embed the origionally supplied
        // elements which don't contain the temp frame labels.
        // But it also requires that the exportToSvg is being supplied with
        // only the elements that we're exporting, and no extra.
        text: serializeAsJSON(elements, appState, files || {}, "local")
      });
    } catch (error) {
      console.error(error);
    }
  }
  const [minX, minY, width, height] = getCanvasSize(
    exportingFrame ? [exportingFrame] : getRootElements(elementsForRender),
    exportPadding
  );
  const svgRoot = document.createElementNS(SVG_NS, "svg");
  svgRoot.setAttribute("version", "1.1");
  svgRoot.setAttribute("xmlns", SVG_NS);
  svgRoot.setAttribute("viewBox", `0 0 ${width} ${height}`);
  svgRoot.setAttribute("width", `${width * exportScale}`);
  svgRoot.setAttribute("height", `${height * exportScale}`);
  if (exportWithDarkMode) {
    svgRoot.setAttribute("filter", THEME_FILTER);
  }
  let assetPath = "https://excalidraw.com/";
  if (define_import_meta_env_default.VITE_IS_EXCALIDRAW_NPM_PACKAGE) {
    assetPath = window.EXCALIDRAW_ASSET_PATH || `https://unpkg.com/${define_import_meta_env_default.VITE_PKG_NAME}@${define_import_meta_env_default.PKG_VERSION}`;
    if (assetPath?.startsWith("/")) {
      assetPath = assetPath.replace("/", `${window.location.origin}/`);
    }
    assetPath = `${assetPath}/dist/excalidraw-assets/`;
  }
  const offsetX = -minX + exportPadding;
  const offsetY = -minY + exportPadding;
  const frameElements = getFrameLikeElements(elements);
  let exportingFrameClipPath = "";
  const elementsMap = arrayToMap(elements);
  for (const frame of frameElements) {
    const [x1, y1, x22, y22] = getElementAbsoluteCoords(frame, elementsMap);
    const cx = (x22 - x1) / 2 - (frame.x - x1);
    const cy = (y22 - y1) / 2 - (frame.y - y1);
    exportingFrameClipPath += `<clipPath id=${frame.id}>
            <rect transform="translate(${frame.x + offsetX} ${frame.y + offsetY}) rotate(${frame.angle} ${cx} ${cy})"
          width="${frame.width}"
          height="${frame.height}"
          >
          </rect>
        </clipPath>`;
  }
  svgRoot.innerHTML = `
  ${SVG_EXPORT_TAG}
  ${metadata}
  <defs>
    <style class="style-fonts">
      @font-face {
        font-family: "Virgil";
        src: url("${assetPath}Virgil.woff2");
      }
      @font-face {
        font-family: "Cascadia";
        src: url("${assetPath}Cascadia.woff2");
      }
      @font-face {
        font-family: "Assistant";
        src: url("${assetPath}Assistant-Regular.woff2");
      }
    </style>
    ${exportingFrameClipPath}
  </defs>
  `;
  if (appState.exportBackground && viewBackgroundColor) {
    const rect = svgRoot.ownerDocument.createElementNS(SVG_NS, "rect");
    rect.setAttribute("x", "0");
    rect.setAttribute("y", "0");
    rect.setAttribute("width", `${width}`);
    rect.setAttribute("height", `${height}`);
    rect.setAttribute("fill", viewBackgroundColor);
    svgRoot.appendChild(rect);
  }
  const rsvg = rough_default.svg(svgRoot);
  const renderEmbeddables = opts?.renderEmbeddables ?? false;
  renderSceneToSvg(
    elementsForRender,
    toBrandedType(arrayToMap(elementsForRender)),
    rsvg,
    svgRoot,
    files || {},
    {
      offsetX,
      offsetY,
      isExporting: true,
      exportWithDarkMode,
      renderEmbeddables,
      frameRendering,
      canvasBackgroundColor: viewBackgroundColor,
      embedsValidationStatus: renderEmbeddables ? new Map(
        elementsForRender.filter((element) => isFrameLikeElement(element)).map((element) => [element.id, true])
      ) : /* @__PURE__ */ new Map()
    }
  );
  tempScene.destroy();
  return svgRoot;
};
var getCanvasSize = (elements, exportPadding) => {
  const [minX, minY, maxX, maxY] = getCommonBounds(elements);
  const width = distance(minX, maxX) + exportPadding * 2;
  const height = distance(minY, maxY) + exportPadding * 2;
  return [minX, minY, width, height];
};
var getExportSize = (elements, exportPadding, scale) => {
  const [, , width, height] = getCanvasSize(elements, exportPadding).map(
    (dimension) => Math.trunc(dimension * scale)
  );
  return [width, height];
};

// ../utils/bbox.ts
init_define_import_meta_env();
function getBBox(line2) {
  return [
    Math.min(line2[0][0], line2[1][0]),
    Math.min(line2[0][1], line2[1][1]),
    Math.max(line2[0][0], line2[1][0]),
    Math.max(line2[0][1], line2[1][1])
  ];
}
function crossProduct(a4, b4) {
  return a4[0] * b4[1] - b4[0] * a4[1];
}
function doBBoxesIntersect(a4, b4) {
  return a4[0] <= b4[2] && a4[2] >= b4[0] && a4[1] <= b4[3] && a4[3] >= b4[1];
}
function translate(a4, b4) {
  return [a4[0] - b4[0], a4[1] - b4[1]];
}
var EPSILON = 1e-6;
function isPointOnLine(l4, p3) {
  const p1 = translate(l4[1], l4[0]);
  const p22 = translate(p3, l4[0]);
  const r3 = crossProduct(p1, p22);
  return Math.abs(r3) < EPSILON;
}
function isPointRightOfLine(l4, p3) {
  const p1 = translate(l4[1], l4[0]);
  const p22 = translate(p3, l4[0]);
  return crossProduct(p1, p22) < 0;
}
function isLineSegmentTouchingOrCrossingLine(a4, b4) {
  return isPointOnLine(a4, b4[0]) || isPointOnLine(a4, b4[1]) || (isPointRightOfLine(a4, b4[0]) ? !isPointRightOfLine(a4, b4[1]) : isPointRightOfLine(a4, b4[1]));
}
function doLineSegmentsIntersect(a4, b4) {
  return doBBoxesIntersect(getBBox(a4), getBBox(b4)) && isLineSegmentTouchingOrCrossingLine(a4, b4) && isLineSegmentTouchingOrCrossingLine(b4, a4);
}

// ../utils/withinBounds.ts
init_define_import_meta_env();
var getNonLinearElementRelativePoints = (element) => {
  if (element.type === "diamond") {
    return [
      [element.width / 2, 0],
      [element.width, element.height / 2],
      [element.width / 2, element.height],
      [0, element.height / 2]
    ];
  }
  return [
    [0, 0],
    [0 + element.width, 0],
    [0 + element.width, element.height],
    [0, element.height]
  ];
};
var getElementRelativePoints = (element) => {
  if (isLinearElement(element) || isFreeDrawElement(element)) {
    return element.points;
  }
  return getNonLinearElementRelativePoints(element);
};
var getMinMaxPoints = (points) => {
  const ret = points.reduce(
    (limits, [x3, y3]) => {
      limits.minY = Math.min(limits.minY, y3);
      limits.minX = Math.min(limits.minX, x3);
      limits.maxX = Math.max(limits.maxX, x3);
      limits.maxY = Math.max(limits.maxY, y3);
      return limits;
    },
    {
      minX: Infinity,
      minY: Infinity,
      maxX: -Infinity,
      maxY: -Infinity,
      cx: 0,
      cy: 0
    }
  );
  ret.cx = (ret.maxX + ret.minX) / 2;
  ret.cy = (ret.maxY + ret.minY) / 2;
  return ret;
};
var getRotatedBBox = (element) => {
  const points = getElementRelativePoints(element);
  const { cx, cy } = getMinMaxPoints(points);
  const centerPoint2 = [cx, cy];
  const rotatedPoints = points.map(
    (point2) => rotatePoint([point2[0], point2[1]], centerPoint2, element.angle)
  );
  const { minX, minY, maxX, maxY } = getMinMaxPoints(rotatedPoints);
  return [
    minX + element.x,
    minY + element.y,
    maxX + element.x,
    maxY + element.y
  ];
};
var isElementInsideBBox = (element, bbox, eitherDirection = false) => {
  const elementBBox = getRotatedBBox(element);
  const elementInsideBbox = bbox[0] <= elementBBox[0] && bbox[2] >= elementBBox[2] && bbox[1] <= elementBBox[1] && bbox[3] >= elementBBox[3];
  if (!eitherDirection) {
    return elementInsideBbox;
  }
  if (elementInsideBbox) {
    return true;
  }
  return elementBBox[0] <= bbox[0] && elementBBox[2] >= bbox[2] && elementBBox[1] <= bbox[1] && elementBBox[3] >= bbox[3];
};
var elementPartiallyOverlapsWithOrContainsBBox = (element, bbox) => {
  const elementBBox = getRotatedBBox(element);
  return (isValueInRange(elementBBox[0], bbox[0], bbox[2]) || isValueInRange(bbox[0], elementBBox[0], elementBBox[2])) && (isValueInRange(elementBBox[1], bbox[1], bbox[3]) || isValueInRange(bbox[1], elementBBox[1], elementBBox[3]));
};
var elementsOverlappingBBox = ({
  elements,
  bounds,
  type,
  errorMargin = 0
}) => {
  if (isExcalidrawElement(bounds)) {
    bounds = getElementBounds(bounds, arrayToMap(elements));
  }
  const adjustedBBox = [
    bounds[0] - errorMargin,
    bounds[1] - errorMargin,
    bounds[2] + errorMargin,
    bounds[3] + errorMargin
  ];
  const includedElementSet = /* @__PURE__ */ new Set();
  for (const element of elements) {
    if (includedElementSet.has(element.id)) {
      continue;
    }
    const isOverlaping = type === "overlap" ? elementPartiallyOverlapsWithOrContainsBBox(element, adjustedBBox) : type === "inside" ? isElementInsideBBox(element, adjustedBBox) : isElementInsideBBox(element, adjustedBBox, true);
    if (isOverlaping) {
      includedElementSet.add(element.id);
      if (element.boundElements) {
        for (const boundElement of element.boundElements) {
          includedElementSet.add(boundElement.id);
        }
      }
      if (isTextElement(element) && element.containerId) {
        includedElementSet.add(element.containerId);
      }
      if (isArrowElement(element)) {
        if (element.startBinding) {
          includedElementSet.add(element.startBinding.elementId);
        }
        if (element.endBinding) {
          includedElementSet.add(element.endBinding?.elementId);
        }
      }
    }
  }
  return elements.filter((element) => includedElementSet.has(element.id));
};

// ../utils/export.ts
var exportToCanvas2 = ({
  elements,
  appState,
  files,
  maxWidthOrHeight,
  getDimensions,
  exportPadding,
  exportingFrame
}) => {
  const { elements: restoredElements, appState: restoredAppState } = restore(
    { elements, appState },
    null,
    null
  );
  const { exportBackground, viewBackgroundColor } = restoredAppState;
  return exportToCanvas(
    restoredElements,
    { ...restoredAppState, offsetTop: 0, offsetLeft: 0, width: 0, height: 0 },
    files || {},
    { exportBackground, exportPadding, viewBackgroundColor, exportingFrame },
    (width, height) => {
      const canvas2 = document.createElement("canvas");
      if (maxWidthOrHeight) {
        if (typeof getDimensions === "function") {
          console.warn(
            "`getDimensions()` is ignored when `maxWidthOrHeight` is supplied."
          );
        }
        const max = Math.max(width, height);
        const scale = maxWidthOrHeight < max ? maxWidthOrHeight / max : appState?.exportScale ?? 1;
        canvas2.width = width * scale;
        canvas2.height = height * scale;
        return {
          canvas: canvas2,
          scale
        };
      }
      const ret = getDimensions?.(width, height) || { width, height };
      canvas2.width = ret.width;
      canvas2.height = ret.height;
      return {
        canvas: canvas2,
        scale: ret.scale ?? 1
      };
    }
  );
};
var exportToBlob = async (opts) => {
  let { mimeType = MIME_TYPES.png, quality } = opts;
  if (mimeType === MIME_TYPES.png && typeof quality === "number") {
    console.warn(`"quality" will be ignored for "${MIME_TYPES.png}" mimeType`);
  }
  if (mimeType === "image/jpg") {
    mimeType = MIME_TYPES.jpg;
  }
  if (mimeType === MIME_TYPES.jpg && !opts.appState?.exportBackground) {
    console.warn(
      `Defaulting "exportBackground" to "true" for "${MIME_TYPES.jpg}" mimeType`
    );
    opts = {
      ...opts,
      appState: { ...opts.appState, exportBackground: true }
    };
  }
  const canvas2 = await exportToCanvas2(opts);
  quality = quality ? quality : /image\/jpe?g/.test(mimeType) ? 0.92 : 0.8;
  return new Promise((resolve, reject) => {
    canvas2.toBlob(
      async (blob) => {
        if (!blob) {
          return reject(new Error("couldn't export to blob"));
        }
        if (blob && mimeType === MIME_TYPES.png && opts.appState?.exportEmbedScene) {
          blob = await encodePngMetadata({
            blob,
            metadata: serializeAsJSON(
              // NOTE as long as we're using the Scene hack, we need to ensure
              // we pass the original, uncloned elements when serializing
              // so that we keep ids stable
              opts.elements,
              opts.appState,
              opts.files || {},
              "local"
            )
          });
        }
        resolve(blob);
      },
      mimeType,
      quality
    );
  });
};
var exportToSvg2 = async ({
  elements,
  appState = getDefaultAppState(),
  files = {},
  exportPadding,
  renderEmbeddables,
  exportingFrame
}) => {
  const { elements: restoredElements, appState: restoredAppState } = restore(
    { elements, appState },
    null,
    null
  );
  const exportAppState = {
    ...restoredAppState,
    exportPadding
  };
  return exportToSvg(restoredElements, exportAppState, files, {
    exportingFrame,
    renderEmbeddables
  });
};
var exportToClipboard = async (opts) => {
  if (opts.type === "svg") {
    const svg = await exportToSvg2(opts);
    await copyTextToSystemClipboard(svg.outerHTML);
  } else if (opts.type === "png") {
    await copyBlobToClipboardAsPng(exportToBlob(opts));
  } else if (opts.type === "json") {
    await copyToClipboard(opts.elements, opts.files);
  } else {
    throw new Error("Invalid export type");
  }
};

// frame.ts
var bindElementsToFramesAfterDuplication = (nextElements, oldElements, oldIdToDuplicatedId) => {
  const nextElementMap = arrayToMap(nextElements);
  for (const element of oldElements) {
    if (element.frameId) {
      const nextElementId = oldIdToDuplicatedId.get(element.id);
      const nextFrameId = oldIdToDuplicatedId.get(element.frameId);
      if (nextElementId) {
        const nextElement = nextElementMap.get(nextElementId);
        if (nextElement) {
          mutateElement(
            nextElement,
            {
              frameId: nextFrameId ?? element.frameId
            },
            false
          );
        }
      }
    }
  }
};
function isElementIntersectingFrame(element, frame, elementsMap) {
  const frameLineSegments = getElementLineSegments(frame, elementsMap);
  const elementLineSegments = getElementLineSegments(element, elementsMap);
  const intersecting = frameLineSegments.some(
    (frameLineSegment) => elementLineSegments.some(
      (elementLineSegment) => doLineSegmentsIntersect(frameLineSegment, elementLineSegment)
    )
  );
  return intersecting;
}
var getElementsCompletelyInFrame = (elements, frame, elementsMap) => omitGroupsContainingFrameLikes(
  getElementsWithinSelection(elements, frame, elementsMap, false)
).filter(
  (element) => !isFrameLikeElement(element) && !element.frameId || element.frameId === frame.id
);
var isElementContainingFrame = (elements, element, frame, elementsMap) => {
  return getElementsWithinSelection(elements, element, elementsMap).some(
    (e3) => e3.id === frame.id
  );
};
var elementsAreInFrameBounds = (elements, frame, elementsMap) => {
  const [frameX1, frameY1, frameX2, frameY2] = getElementAbsoluteCoords(
    frame,
    elementsMap
  );
  const [elementX1, elementY1, elementX2, elementY2] = getCommonBounds(elements);
  return frameX1 <= elementX1 && frameY1 <= elementY1 && frameX2 >= elementX2 && frameY2 >= elementY2;
};
var elementOverlapsWithFrame = (element, frame, elementsMap) => {
  return elementsAreInFrameBounds([element], frame, elementsMap) || isElementIntersectingFrame(element, frame, elementsMap) || isElementContainingFrame([frame], element, frame, elementsMap);
};
var isCursorInFrame = (cursorCoords, frame, elementsMap) => {
  const [fx1, fy1, fx2, fy2] = getElementAbsoluteCoords(frame, elementsMap);
  return isPointWithinBounds(
    [fx1, fy1],
    [cursorCoords.x, cursorCoords.y],
    [fx2, fy2]
  );
};
var groupByFrameLikes = (elements) => {
  const frameElementsMap = /* @__PURE__ */ new Map();
  for (const element of elements) {
    const frameId = isFrameLikeElement(element) ? element.id : element.frameId;
    if (frameId && !frameElementsMap.has(frameId)) {
      frameElementsMap.set(frameId, getFrameChildren(elements, frameId));
    }
  }
  return frameElementsMap;
};
var getFrameChildren = (allElements, frameId) => {
  const frameChildren = [];
  for (const element of allElements.values()) {
    if (element.frameId === frameId) {
      frameChildren.push(element);
    }
  }
  return frameChildren;
};
var getFrameLikeElements = (allElements) => {
  return allElements.filter(
    (element) => isFrameLikeElement(element)
  );
};
var getRootElements = (allElements) => {
  const frameElements = arrayToMap(getFrameLikeElements(allElements));
  return allElements.filter(
    (element) => frameElements.has(element.id) || !element.frameId || !frameElements.has(element.frameId)
  );
};
var getElementsInResizingFrame = (allElements, frame, appState, elementsMap) => {
  const prevElementsInFrame = getFrameChildren(allElements, frame.id);
  const nextElementsInFrame = new Set(prevElementsInFrame);
  const elementsCompletelyInFrame = /* @__PURE__ */ new Set([
    ...getElementsCompletelyInFrame(allElements, frame, elementsMap),
    ...prevElementsInFrame.filter(
      (element) => isElementContainingFrame(allElements, element, frame, elementsMap)
    )
  ]);
  const elementsNotCompletelyInFrame = prevElementsInFrame.filter(
    (element) => !elementsCompletelyInFrame.has(element)
  );
  const groupsToKeep = new Set(
    Array.from(elementsCompletelyInFrame).flatMap(
      (element) => element.groupIds
    )
  );
  for (const element of elementsNotCompletelyInFrame) {
    if (!isElementIntersectingFrame(element, frame, elementsMap)) {
      if (element.groupIds.length === 0) {
        nextElementsInFrame.delete(element);
      }
    } else if (element.groupIds.length > 0) {
      for (const id of element.groupIds) {
        groupsToKeep.add(id);
      }
    }
  }
  for (const element of elementsNotCompletelyInFrame) {
    if (element.groupIds.length > 0) {
      let shouldRemoveElement = true;
      for (const id of element.groupIds) {
        if (groupsToKeep.has(id)) {
          shouldRemoveElement = false;
        }
      }
      if (shouldRemoveElement) {
        nextElementsInFrame.delete(element);
      }
    }
  }
  const individualElementsCompletelyInFrame = Array.from(
    elementsCompletelyInFrame
  ).filter((element) => element.groupIds.length === 0);
  for (const element of individualElementsCompletelyInFrame) {
    nextElementsInFrame.add(element);
  }
  const newGroupElementsCompletelyInFrame = Array.from(
    elementsCompletelyInFrame
  ).filter((element) => element.groupIds.length > 0);
  const groupIds = selectGroupsFromGivenElements(
    newGroupElementsCompletelyInFrame,
    appState
  );
  for (const [id, isSelected] of Object.entries(groupIds)) {
    if (isSelected) {
      const elementsInGroup = getElementsInGroup(allElements, id);
      if (elementsAreInFrameBounds(elementsInGroup, frame, elementsMap)) {
        for (const element of elementsInGroup) {
          nextElementsInFrame.add(element);
        }
      }
    }
  }
  return [...nextElementsInFrame].filter((element) => {
    return !(isTextElement(element) && element.containerId);
  });
};
var getElementsInNewFrame = (elements, frame, elementsMap) => {
  return omitGroupsContainingFrameLikes(
    elements,
    getElementsCompletelyInFrame(elements, frame, elementsMap)
  );
};
var getContainingFrame = (element, elementsMap) => {
  if (element.frameId) {
    if (elementsMap) {
      return elementsMap.get(element.frameId) || null;
    }
    return Scene_default.getScene(element)?.getElement(
      element.frameId
    ) || null;
  }
  return null;
};
var filterElementsEligibleAsFrameChildren = (elements, frame) => {
  const otherFrames = /* @__PURE__ */ new Set();
  const elementsMap = arrayToMap(elements);
  elements = omitGroupsContainingFrameLikes(elements);
  for (const element of elements) {
    if (isFrameLikeElement(element) && element.id !== frame.id) {
      otherFrames.add(element.id);
    }
  }
  const processedGroups = /* @__PURE__ */ new Set();
  const eligibleElements = [];
  for (const element of elements) {
    if (isFrameLikeElement(element) || element.frameId && otherFrames.has(element.frameId)) {
      continue;
    }
    if (element.groupIds.length) {
      const shallowestGroupId = element.groupIds.at(-1);
      if (!processedGroups.has(shallowestGroupId)) {
        processedGroups.add(shallowestGroupId);
        const groupElements = getElementsInGroup(elements, shallowestGroupId);
        if (groupElements.some(
          (el) => elementOverlapsWithFrame(el, frame, elementsMap)
        )) {
          for (const child of groupElements) {
            eligibleElements.push(child);
          }
        }
      }
    } else {
      const overlaps = elementOverlapsWithFrame(element, frame, elementsMap);
      if (overlaps) {
        eligibleElements.push(element);
      }
    }
  }
  return eligibleElements;
};
var addElementsToFrame = (allElements, elementsToAdd, frame) => {
  const elementsMap = arrayToMap(allElements);
  const currTargetFrameChildrenMap = /* @__PURE__ */ new Map();
  for (const element of allElements.values()) {
    if (element.frameId === frame.id) {
      currTargetFrameChildrenMap.set(element.id, true);
    }
  }
  const suppliedElementsToAddSet = new Set(elementsToAdd.map((el) => el.id));
  const finalElementsToAdd = [];
  const otherFrames = /* @__PURE__ */ new Set();
  for (const element of elementsToAdd) {
    if (isFrameLikeElement(element) && element.id !== frame.id) {
      otherFrames.add(element.id);
    }
  }
  for (const element of omitGroupsContainingFrameLikes(
    allElements,
    elementsToAdd
  )) {
    if (isFrameLikeElement(element) || element.frameId && otherFrames.has(element.frameId)) {
      continue;
    }
    if (!currTargetFrameChildrenMap.has(element.id)) {
      finalElementsToAdd.push(element);
    }
    const boundTextElement = getBoundTextElement(element, elementsMap);
    if (boundTextElement && !suppliedElementsToAddSet.has(boundTextElement.id) && !currTargetFrameChildrenMap.has(boundTextElement.id)) {
      finalElementsToAdd.push(boundTextElement);
    }
  }
  for (const element of finalElementsToAdd) {
    mutateElement(
      element,
      {
        frameId: frame.id
      },
      false
    );
  }
  return allElements;
};
var removeElementsFromFrame = (elementsToRemove, elementsMap) => {
  const _elementsToRemove = /* @__PURE__ */ new Map();
  const toRemoveElementsByFrame = /* @__PURE__ */ new Map();
  for (const element of elementsToRemove) {
    if (element.frameId) {
      _elementsToRemove.set(element.id, element);
      const arr = toRemoveElementsByFrame.get(element.frameId) || [];
      arr.push(element);
      const boundTextElement = getBoundTextElement(element, elementsMap);
      if (boundTextElement) {
        _elementsToRemove.set(boundTextElement.id, boundTextElement);
        arr.push(boundTextElement);
      }
      toRemoveElementsByFrame.set(element.frameId, arr);
    }
  }
  for (const [, element] of _elementsToRemove) {
    mutateElement(
      element,
      {
        frameId: null
      },
      false
    );
  }
};
var removeAllElementsFromFrame = (allElements, frame) => {
  const elementsInFrame = getFrameChildren(allElements, frame.id);
  removeElementsFromFrame(elementsInFrame, arrayToMap(allElements));
  return allElements;
};
var replaceAllElementsInFrame = (allElements, nextElementsInFrame, frame, app) => {
  return addElementsToFrame(
    removeAllElementsFromFrame(allElements, frame),
    nextElementsInFrame,
    frame
  ).slice();
};
var updateFrameMembershipOfSelectedElements = (allElements, appState, app) => {
  const selectedElements = app.scene.getSelectedElements({
    selectedElementIds: appState.selectedElementIds,
    // supplying elements explicitly in case we're passed non-state elements
    elements: allElements
  });
  const elementsToFilter = new Set(selectedElements);
  if (appState.editingGroupId) {
    for (const element of selectedElements) {
      if (element.groupIds.length === 0) {
        elementsToFilter.add(element);
      } else {
        element.groupIds.flatMap((gid) => getElementsInGroup(allElements, gid)).forEach((element2) => elementsToFilter.add(element2));
      }
    }
  }
  const elementsToRemove = /* @__PURE__ */ new Set();
  const elementsMap = arrayToMap(allElements);
  elementsToFilter.forEach((element) => {
    if (element.frameId && !isFrameLikeElement(element) && !isElementInFrame(element, elementsMap, appState)) {
      elementsToRemove.add(element);
    }
  });
  if (elementsToRemove.size > 0) {
    removeElementsFromFrame(elementsToRemove, elementsMap);
  }
  return allElements;
};
var omitGroupsContainingFrameLikes = (allElements, selectedElements) => {
  const uniqueGroupIds = /* @__PURE__ */ new Set();
  const elements = selectedElements || allElements;
  for (const el of elements.values()) {
    const topMostGroupId = el.groupIds[el.groupIds.length - 1];
    if (topMostGroupId) {
      uniqueGroupIds.add(topMostGroupId);
    }
  }
  const rejectedGroupIds = /* @__PURE__ */ new Set();
  for (const groupId of uniqueGroupIds) {
    if (getElementsInGroup(allElements, groupId).some(
      (el) => isFrameLikeElement(el)
    )) {
      rejectedGroupIds.add(groupId);
    }
  }
  const ret = [];
  for (const element of elements.values()) {
    if (!rejectedGroupIds.has(element.groupIds[element.groupIds.length - 1])) {
      ret.push(element);
    }
  }
  return ret;
};
var getTargetFrame = (element, elementsMap, appState) => {
  const _element = isTextElement(element) ? getContainerElement(element, elementsMap) || element : element;
  return appState.selectedElementIds[_element.id] && appState.selectedElementsAreBeingDragged ? appState.frameToHighlight : getContainingFrame(_element);
};
var isElementInFrame = (element, allElementsMap, appState) => {
  const frame = getTargetFrame(element, allElementsMap, appState);
  const _element = isTextElement(element) ? getContainerElement(element, allElementsMap) || element : element;
  if (frame) {
    if (!appState.selectedElementIds[element.id] || !appState.selectedElementsAreBeingDragged) {
      return true;
    }
    if (_element.groupIds.length === 0) {
      return elementOverlapsWithFrame(_element, frame, allElementsMap);
    }
    const allElementsInGroup = new Set(
      _element.groupIds.flatMap(
        (gid) => getElementsInGroup(allElementsMap, gid)
      )
    );
    if (appState.editingGroupId && appState.selectedElementsAreBeingDragged) {
      const selectedElements = new Set(
        getSelectedElements(allElementsMap, appState)
      );
      const editingGroupOverlapsFrame = appState.frameToHighlight !== null;
      if (editingGroupOverlapsFrame) {
        return true;
      }
      selectedElements.forEach((selectedElement) => {
        allElementsInGroup.delete(selectedElement);
      });
    }
    for (const elementInGroup of allElementsInGroup) {
      if (isFrameLikeElement(elementInGroup)) {
        return false;
      }
    }
    for (const elementInGroup of allElementsInGroup) {
      if (elementOverlapsWithFrame(elementInGroup, frame, allElementsMap)) {
        return true;
      }
    }
  }
  return false;
};
var getFrameLikeTitle = (element, frameIdx) => {
  return element.name === null ? isFrameElement(element) ? `Frame ${frameIdx}` : `AI Frame $${frameIdx}` : element.name;
};
var getElementsOverlappingFrame = (elements, frame) => {
  return elementsOverlappingBBox({
    elements,
    bounds: frame,
    type: "overlap"
  }).filter((el) => !el.frameId || el.frameId === frame.id);
};

// scene/selection.ts
var excludeElementsInFramesFromSelection = (selectedElements) => {
  const framesInSelection = /* @__PURE__ */ new Set();
  selectedElements.forEach((element) => {
    if (isFrameLikeElement(element)) {
      framesInSelection.add(element.id);
    }
  });
  return selectedElements.filter((element) => {
    if (element.frameId && framesInSelection.has(element.frameId)) {
      return false;
    }
    return true;
  });
};
var getElementsWithinSelection = (elements, selection, elementsMap, excludeElementsInFrames = true) => {
  const [selectionX1, selectionY1, selectionX2, selectionY2] = getElementAbsoluteCoords(selection, elementsMap);
  let elementsInSelection = elements.filter((element) => {
    let [elementX1, elementY1, elementX2, elementY2] = getElementBounds(
      element,
      elementsMap
    );
    const containingFrame = getContainingFrame(element);
    if (containingFrame) {
      const [fx1, fy1, fx2, fy2] = getElementBounds(
        containingFrame,
        elementsMap
      );
      elementX1 = Math.max(fx1, elementX1);
      elementY1 = Math.max(fy1, elementY1);
      elementX2 = Math.min(fx2, elementX2);
      elementY2 = Math.min(fy2, elementY2);
    }
    return element.locked === false && element.type !== "selection" && !isBoundToContainer(element) && selectionX1 <= elementX1 && selectionY1 <= elementY1 && selectionX2 >= elementX2 && selectionY2 >= elementY2;
  });
  elementsInSelection = excludeElementsInFrames ? excludeElementsInFramesFromSelection(elementsInSelection) : elementsInSelection;
  elementsInSelection = elementsInSelection.filter((element) => {
    const containingFrame = getContainingFrame(element);
    if (containingFrame) {
      return elementOverlapsWithFrame(element, containingFrame, elementsMap);
    }
    return true;
  });
  return elementsInSelection;
};
var getVisibleAndNonSelectedElements = (elements, selectedElements, appState, elementsMap) => {
  const selectedElementsSet = new Set(
    selectedElements.map((element) => element.id)
  );
  return elements.filter((element) => {
    const isVisible = isElementInViewport(
      element,
      appState.width,
      appState.height,
      appState,
      elementsMap
    );
    return !selectedElementsSet.has(element.id) && isVisible;
  });
};
var isSomeElementSelected = function() {
  let lastElements = null;
  let lastSelectedElementIds = null;
  let isSelected = null;
  const ret = (elements, appState) => {
    if (isSelected != null && elements === lastElements && appState.selectedElementIds === lastSelectedElementIds) {
      return isSelected;
    }
    isSelected = elements.some(
      (element) => appState.selectedElementIds[element.id]
    );
    lastElements = elements;
    lastSelectedElementIds = appState.selectedElementIds;
    return isSelected;
  };
  ret.clearCache = () => {
    lastElements = null;
    lastSelectedElementIds = null;
    isSelected = null;
  };
  return ret;
}();
var getCommonAttributeOfSelectedElements = (elements, appState, getAttribute) => {
  const attributes = Array.from(
    new Set(
      getSelectedElements(elements, appState).map(
        (element) => getAttribute(element)
      )
    )
  );
  return attributes.length === 1 ? attributes[0] : null;
};
var getSelectedElements = (elements, appState, opts) => {
  const selectedElements = [];
  for (const element of elements.values()) {
    if (appState.selectedElementIds[element.id]) {
      selectedElements.push(element);
      continue;
    }
    if (opts?.includeBoundTextElement && isBoundToContainer(element) && appState.selectedElementIds[element?.containerId]) {
      selectedElements.push(element);
      continue;
    }
  }
  if (opts?.includeElementsInFrames) {
    const elementsToInclude = [];
    selectedElements.forEach((element) => {
      if (isFrameLikeElement(element)) {
        getFrameChildren(elements, element.id).forEach(
          (e3) => elementsToInclude.push(e3)
        );
      }
      elementsToInclude.push(element);
    });
    return elementsToInclude;
  }
  return selectedElements;
};
var getTargetElements = (elements, appState) => appState.editingElement ? [appState.editingElement] : getSelectedElements(elements, appState, {
  includeBoundTextElement: true
});
var makeNextSelectedElementIds = (nextSelectedElementIds, prevState) => {
  if (isShallowEqual(prevState.selectedElementIds, nextSelectedElementIds)) {
    return prevState.selectedElementIds;
  }
  return nextSelectedElementIds;
};

// scene/Scene.ts
var getNonDeletedElements3 = (allElements) => {
  const elementsMap = /* @__PURE__ */ new Map();
  const elements = [];
  for (const element of allElements) {
    if (!element.isDeleted) {
      elements.push(element);
      elementsMap.set(element.id, element);
    }
  }
  return { elementsMap, elements };
};
var hashSelectionOpts = (opts) => {
  const keys = ["includeBoundTextElement", "includeElementsInFrames"];
  let hash = "";
  for (const key of keys) {
    hash += `${key}:${opts[key] ? "1" : "0"}`;
  }
  return hash;
};
var isIdKey = (elementKey) => {
  if (typeof elementKey === "string") {
    return true;
  }
  return false;
};
var Scene = class _Scene {
  // ---------------------------------------------------------------------------
  // static methods/props
  // ---------------------------------------------------------------------------
  static sceneMapByElement = /* @__PURE__ */ new WeakMap();
  static sceneMapById = /* @__PURE__ */ new Map();
  static mapElementToScene(elementKey, scene, mapElementIds = true) {
    if (isIdKey(elementKey)) {
      if (!mapElementIds) {
        return;
      }
      this.sceneMapById.set(elementKey, scene);
    } else {
      this.sceneMapByElement.set(elementKey, scene);
      if (!mapElementIds) {
        this.sceneMapById.set(elementKey.id, scene);
      }
    }
  }
  static getScene(elementKey) {
    if (isIdKey(elementKey)) {
      return this.sceneMapById.get(elementKey) || null;
    }
    return this.sceneMapByElement.get(elementKey) || null;
  }
  // ---------------------------------------------------------------------------
  // instance methods/props
  // ---------------------------------------------------------------------------
  callbacks = /* @__PURE__ */ new Set();
  nonDeletedElements = [];
  nonDeletedElementsMap = toBrandedType(
    /* @__PURE__ */ new Map()
  );
  elements = [];
  nonDeletedFramesLikes = [];
  frames = [];
  elementsMap = toBrandedType(/* @__PURE__ */ new Map());
  selectedElementsCache = {
    selectedElementIds: null,
    elements: null,
    cache: /* @__PURE__ */ new Map()
  };
  versionNonce;
  getElementsMapIncludingDeleted() {
    return this.elementsMap;
  }
  getNonDeletedElementsMap() {
    return this.nonDeletedElementsMap;
  }
  getElementsIncludingDeleted() {
    return this.elements;
  }
  getNonDeletedElements() {
    return this.nonDeletedElements;
  }
  getFramesIncludingDeleted() {
    return this.frames;
  }
  getSelectedElements(opts) {
    const hash = hashSelectionOpts(opts);
    const elements = opts?.elements || this.nonDeletedElements;
    if (this.selectedElementsCache.elements === elements && this.selectedElementsCache.selectedElementIds === opts.selectedElementIds) {
      const cached = this.selectedElementsCache.cache.get(hash);
      if (cached) {
        return cached;
      }
    } else if (opts?.elements == null) {
      this.selectedElementsCache.cache.clear();
    }
    const selectedElements = getSelectedElements(
      elements,
      { selectedElementIds: opts.selectedElementIds },
      opts
    );
    if (opts?.elements == null) {
      this.selectedElementsCache.selectedElementIds = opts.selectedElementIds;
      this.selectedElementsCache.elements = this.nonDeletedElements;
      this.selectedElementsCache.cache.set(hash, selectedElements);
    }
    return selectedElements;
  }
  getNonDeletedFramesLikes() {
    return this.nonDeletedFramesLikes;
  }
  getElement(id) {
    return this.elementsMap.get(id) || null;
  }
  getVersionNonce() {
    return this.versionNonce;
  }
  getNonDeletedElement(id) {
    const element = this.getElement(id);
    if (element && isNonDeletedElement(element)) {
      return element;
    }
    return null;
  }
  /**
   * A utility method to help with updating all scene elements, with the added
   * performance optimization of not renewing the array if no change is made.
   *
   * Maps all current excalidraw elements, invoking the callback for each
   * element. The callback should either return a new mapped element, or the
   * original element if no changes are made. If no changes are made to any
   * element, this results in a no-op. Otherwise, the newly mapped elements
   * are set as the next scene's elements.
   *
   * @returns whether a change was made
   */
  mapElements(iteratee) {
    let didChange = false;
    const newElements = this.elements.map((element) => {
      const nextElement = iteratee(element);
      if (nextElement !== element) {
        didChange = true;
      }
      return nextElement;
    });
    if (didChange) {
      this.replaceAllElements(newElements);
    }
    return didChange;
  }
  replaceAllElements(nextElements, mapElementIds = true) {
    this.elements = // ts doesn't like `Array.isArray` of `instanceof Map`
    nextElements instanceof Array ? nextElements : Array.from(nextElements.values());
    const nextFrameLikes = [];
    this.elementsMap.clear();
    this.elements.forEach((element) => {
      if (isFrameLikeElement(element)) {
        nextFrameLikes.push(element);
      }
      this.elementsMap.set(element.id, element);
      _Scene.mapElementToScene(element, this, mapElementIds);
    });
    const nonDeletedElements = getNonDeletedElements3(this.elements);
    this.nonDeletedElements = nonDeletedElements.elements;
    this.nonDeletedElementsMap = nonDeletedElements.elementsMap;
    this.frames = nextFrameLikes;
    this.nonDeletedFramesLikes = getNonDeletedElements3(this.frames).elements;
    this.informMutation();
  }
  informMutation() {
    this.versionNonce = randomInteger();
    for (const callback of Array.from(this.callbacks)) {
      callback();
    }
  }
  addCallback(cb) {
    if (this.callbacks.has(cb)) {
      throw new Error();
    }
    this.callbacks.add(cb);
    return () => {
      if (!this.callbacks.has(cb)) {
        throw new Error();
      }
      this.callbacks.delete(cb);
    };
  }
  destroy() {
    this.nonDeletedElements = [];
    this.elements = [];
    this.nonDeletedFramesLikes = [];
    this.frames = [];
    this.elementsMap.clear();
    this.selectedElementsCache.selectedElementIds = null;
    this.selectedElementsCache.elements = null;
    this.selectedElementsCache.cache.clear();
    _Scene.sceneMapById.forEach((scene, elementKey) => {
      if (scene === this) {
        _Scene.sceneMapById.delete(elementKey);
      }
    });
    this.callbacks.clear();
  }
  insertElementAtIndex(element, index2) {
    if (!Number.isFinite(index2) || index2 < 0) {
      throw new Error(
        "insertElementAtIndex can only be called with index >= 0"
      );
    }
    const nextElements = [
      ...this.elements.slice(0, index2),
      element,
      ...this.elements.slice(index2)
    ];
    this.replaceAllElements(nextElements);
  }
  insertElementsAtIndex(elements, index2) {
    if (!Number.isFinite(index2) || index2 < 0) {
      throw new Error(
        "insertElementAtIndex can only be called with index >= 0"
      );
    }
    const nextElements = [
      ...this.elements.slice(0, index2),
      ...elements,
      ...this.elements.slice(index2)
    ];
    this.replaceAllElements(nextElements);
  }
  addNewElement = (element) => {
    if (element.frameId) {
      this.insertElementAtIndex(element, this.getElementIndex(element.frameId));
    } else {
      this.replaceAllElements([...this.elements, element]);
    }
  };
  getElementIndex(elementId) {
    return this.elements.findIndex((element) => element.id === elementId);
  }
  getContainerElement = (element) => {
    if (!element) {
      return null;
    }
    if (element.containerId) {
      return this.getElement(element.containerId) || null;
    }
    return null;
  };
};
var Scene_default = Scene;

// element/mutateElement.ts
var mutateElement = (element, updates, informMutation = true) => {
  let didChange = false;
  const { points, fileId } = updates;
  if (typeof points !== "undefined") {
    updates = { ...getSizeFromPoints(points), ...updates };
  }
  for (const key in updates) {
    const value = updates[key];
    if (typeof value !== "undefined") {
      if (element[key] === value && // if object, always update because its attrs could have changed
      // (except for specific keys we handle below)
      (typeof value !== "object" || value === null || key === "groupIds" || key === "scale")) {
        continue;
      }
      if (key === "scale") {
        const prevScale = element[key];
        const nextScale = value;
        if (prevScale[0] === nextScale[0] && prevScale[1] === nextScale[1]) {
          continue;
        }
      } else if (key === "points") {
        const prevPoints = element[key];
        const nextPoints = value;
        if (prevPoints.length === nextPoints.length) {
          let didChangePoints = false;
          let index2 = prevPoints.length;
          while (--index2) {
            const prevPoint = prevPoints[index2];
            const nextPoint = nextPoints[index2];
            if (prevPoint[0] !== nextPoint[0] || prevPoint[1] !== nextPoint[1]) {
              didChangePoints = true;
              break;
            }
          }
          if (!didChangePoints) {
            continue;
          }
        }
      }
      element[key] = value;
      didChange = true;
    }
  }
  if (!didChange) {
    return element;
  }
  if (typeof updates.height !== "undefined" || typeof updates.width !== "undefined" || typeof fileId != "undefined" || typeof points !== "undefined") {
    ShapeCache.delete(element);
  }
  element.version++;
  element.versionNonce = randomInteger();
  element.updated = getUpdatedTimestamp();
  if (informMutation) {
    Scene_default.getScene(element)?.informMutation();
  }
  return element;
};
var newElementWith = (element, updates) => {
  let didChange = false;
  for (const key in updates) {
    const value = updates[key];
    if (typeof value !== "undefined") {
      if (element[key] === value && // if object, always update because its attrs could have changed
      (typeof value !== "object" || value === null)) {
        continue;
      }
      didChange = true;
    }
  }
  if (!didChange) {
    return element;
  }
  return {
    ...element,
    ...updates,
    updated: getUpdatedTimestamp(),
    version: element.version + 1,
    versionNonce: randomInteger()
  };
};
var bumpVersion = (element, version) => {
  element.version = (version ?? element.version) + 1;
  element.versionNonce = randomInteger();
  element.updated = getUpdatedTimestamp();
  return element;
};

// element/sizeHelpers.ts
var isInvisiblySmallElement = (element) => {
  if (isLinearElement(element) || isFreeDrawElement(element)) {
    return element.points.length < 2;
  }
  return element.width === 0 && element.height === 0;
};
var isElementInViewport = (element, width, height, viewTransformations, elementsMap) => {
  const [x1, y1, x22, y22] = getElementBounds(element, elementsMap);
  const topLeftSceneCoords = viewportCoordsToSceneCoords(
    {
      clientX: viewTransformations.offsetLeft,
      clientY: viewTransformations.offsetTop
    },
    viewTransformations
  );
  const bottomRightSceneCoords = viewportCoordsToSceneCoords(
    {
      clientX: viewTransformations.offsetLeft + width,
      clientY: viewTransformations.offsetTop + height
    },
    viewTransformations
  );
  return topLeftSceneCoords.x <= x22 && topLeftSceneCoords.y <= y22 && bottomRightSceneCoords.x >= x1 && bottomRightSceneCoords.y >= y1;
};
var getPerfectElementSize = (elementType, width, height) => {
  const absWidth = Math.abs(width);
  const absHeight = Math.abs(height);
  if (elementType === "line" || elementType === "arrow" || elementType === "freedraw") {
    const lockedAngle = Math.round(Math.atan(absHeight / absWidth) / SHIFT_LOCKING_ANGLE) * SHIFT_LOCKING_ANGLE;
    if (lockedAngle === 0) {
      height = 0;
    } else if (lockedAngle === Math.PI / 2) {
      width = 0;
    } else {
      height = absWidth * Math.tan(lockedAngle) * Math.sign(height) || height;
    }
  } else if (elementType !== "selection") {
    height = absWidth * Math.sign(height);
  }
  return { width, height };
};
var getLockedLinearCursorAlignSize = (originX, originY, x3, y3) => {
  let width = x3 - originX;
  let height = y3 - originY;
  const lockedAngle = Math.round(Math.atan(height / width) / SHIFT_LOCKING_ANGLE) * SHIFT_LOCKING_ANGLE;
  if (lockedAngle === 0) {
    height = 0;
  } else if (lockedAngle === Math.PI / 2) {
    width = 0;
  } else {
    const a1 = Math.tan(lockedAngle);
    const b1 = -1;
    const c1 = originY - a1 * originX;
    const a22 = -1 / a1;
    const b22 = -1;
    const c22 = y3 - a22 * x3;
    const intersectX = (b1 * c22 - b22 * c1) / (a1 * b22 - a22 * b1);
    const intersectY = (c1 * a22 - c22 * a1) / (a1 * b22 - a22 * b1);
    width = intersectX - originX;
    height = intersectY - originY;
  }
  return { width, height };
};
var getNormalizedDimensions = (element) => {
  const ret = {
    width: element.width,
    height: element.height,
    x: element.x,
    y: element.y
  };
  if (element.width < 0) {
    const nextWidth = Math.abs(element.width);
    ret.width = nextWidth;
    ret.x = element.x - nextWidth;
  }
  if (element.height < 0) {
    const nextHeight = Math.abs(element.height);
    ret.height = nextHeight;
    ret.y = element.y - nextHeight;
  }
  return ret;
};

// element/resizeTest.ts
init_define_import_meta_env();
var isInsideTransformHandle = (transformHandle, x3, y3) => x3 >= transformHandle[0] && x3 <= transformHandle[0] + transformHandle[2] && y3 >= transformHandle[1] && y3 <= transformHandle[1] + transformHandle[3];
var resizeTest = (element, elementsMap, appState, x3, y3, zoom, pointerType) => {
  if (!appState.selectedElementIds[element.id]) {
    return false;
  }
  const { rotation: rotationTransformHandle, ...transformHandles } = getTransformHandles(element, zoom, elementsMap, pointerType);
  if (rotationTransformHandle && isInsideTransformHandle(rotationTransformHandle, x3, y3)) {
    return "rotation";
  }
  const filter = Object.keys(transformHandles).filter((key) => {
    const transformHandle = transformHandles[key];
    if (!transformHandle) {
      return false;
    }
    return isInsideTransformHandle(transformHandle, x3, y3);
  });
  if (filter.length > 0) {
    return filter[0];
  }
  return false;
};
var getElementWithTransformHandleType = (elements, appState, scenePointerX, scenePointerY, zoom, pointerType, elementsMap) => {
  return elements.reduce((result, element) => {
    if (result) {
      return result;
    }
    const transformHandleType = resizeTest(
      element,
      elementsMap,
      appState,
      scenePointerX,
      scenePointerY,
      zoom,
      pointerType
    );
    return transformHandleType ? { element, transformHandleType } : null;
  }, null);
};
var getTransformHandleTypeFromCoords = ([x1, y1, x22, y22], scenePointerX, scenePointerY, zoom, pointerType) => {
  const transformHandles = getTransformHandlesFromCoords(
    [x1, y1, x22, y22, (x1 + x22) / 2, (y1 + y22) / 2],
    0,
    zoom,
    pointerType,
    OMIT_SIDES_FOR_MULTIPLE_ELEMENTS
  );
  const found = Object.keys(transformHandles).find((key) => {
    const transformHandle = transformHandles[key];
    return transformHandle && isInsideTransformHandle(transformHandle, scenePointerX, scenePointerY);
  });
  return found || false;
};
var RESIZE_CURSORS = ["ns", "nesw", "ew", "nwse"];
var rotateResizeCursor = (cursor, angle) => {
  const index2 = RESIZE_CURSORS.indexOf(cursor);
  if (index2 >= 0) {
    const a4 = Math.round(angle / (Math.PI / 4));
    cursor = RESIZE_CURSORS[(index2 + a4) % RESIZE_CURSORS.length];
  }
  return cursor;
};
var getCursorForResizingElement = (resizingElement) => {
  const { element, transformHandleType } = resizingElement;
  const shouldSwapCursors = element && Math.sign(element.height) * Math.sign(element.width) === -1;
  let cursor = null;
  switch (transformHandleType) {
    case "n":
    case "s":
      cursor = "ns";
      break;
    case "w":
    case "e":
      cursor = "ew";
      break;
    case "nw":
    case "se":
      if (shouldSwapCursors) {
        cursor = "nesw";
      } else {
        cursor = "nwse";
      }
      break;
    case "ne":
    case "sw":
      if (shouldSwapCursors) {
        cursor = "nwse";
      } else {
        cursor = "nesw";
      }
      break;
    case "rotation":
      return "grab";
  }
  if (cursor && element) {
    cursor = rotateResizeCursor(cursor, element.angle);
  }
  return cursor ? `${cursor}-resize` : "";
};

// element/dragElements.ts
init_define_import_meta_env();
var dragSelectedElements = (pointerDownState, selectedElements, offset2, appState, scene, snapOffset, gridSize) => {
  const elementsToUpdate = new Set(
    selectedElements
  );
  const frames = selectedElements.filter((e3) => isFrameLikeElement(e3)).map((f3) => f3.id);
  if (frames.length > 0) {
    for (const element of scene.getNonDeletedElements()) {
      if (element.frameId !== null && frames.includes(element.frameId)) {
        elementsToUpdate.add(element);
      }
    }
  }
  const commonBounds = getCommonBounds(
    Array.from(elementsToUpdate).map(
      (el) => pointerDownState.originalElements.get(el.id) ?? el
    )
  );
  const adjustedOffset = calculateOffset(
    commonBounds,
    offset2,
    snapOffset,
    gridSize
  );
  elementsToUpdate.forEach((element) => {
    updateElementCoords(pointerDownState, element, adjustedOffset);
    if (
      // skip arrow labels since we calculate its position during render
      !isArrowElement(element)
    ) {
      const textElement = getBoundTextElement(
        element,
        scene.getNonDeletedElementsMap()
      );
      if (textElement) {
        updateElementCoords(pointerDownState, textElement, adjustedOffset);
      }
    }
    updateBoundElements(element, scene.getElementsMapIncludingDeleted(), {
      simultaneouslyUpdated: Array.from(elementsToUpdate)
    });
  });
};
var calculateOffset = (commonBounds, dragOffset, snapOffset, gridSize) => {
  const [x3, y3] = commonBounds;
  let nextX = x3 + dragOffset.x + snapOffset.x;
  let nextY = y3 + dragOffset.y + snapOffset.y;
  if (snapOffset.x === 0 || snapOffset.y === 0) {
    const [nextGridX, nextGridY] = getGridPoint(
      x3 + dragOffset.x,
      y3 + dragOffset.y,
      gridSize
    );
    if (snapOffset.x === 0) {
      nextX = nextGridX;
    }
    if (snapOffset.y === 0) {
      nextY = nextGridY;
    }
  }
  return {
    x: nextX - x3,
    y: nextY - y3
  };
};
var updateElementCoords = (pointerDownState, element, dragOffset) => {
  const originalElement = pointerDownState.originalElements.get(element.id) ?? element;
  const nextX = originalElement.x + dragOffset.x;
  const nextY = originalElement.y + dragOffset.y;
  mutateElement(element, {
    x: nextX,
    y: nextY
  });
};
var getDragOffsetXY = (selectedElements, x3, y3) => {
  const [x1, y1] = getCommonBounds(selectedElements);
  return [x3 - x1, y3 - y1];
};
var dragNewElement = (draggingElement, elementType, originX, originY, x3, y3, width, height, shouldMaintainAspectRatio2, shouldResizeFromCenter2, widthAspectRatio, originOffset = null) => {
  if (shouldMaintainAspectRatio2 && draggingElement.type !== "selection") {
    if (widthAspectRatio) {
      height = width / widthAspectRatio;
    } else {
      if (Math.abs(y3 - originY) > Math.abs(x3 - originX)) {
        ({ width, height } = getPerfectElementSize(
          elementType,
          height,
          x3 < originX ? -width : width
        ));
      } else {
        ({ width, height } = getPerfectElementSize(
          elementType,
          width,
          y3 < originY ? -height : height
        ));
      }
      if (height < 0) {
        height = -height;
      }
    }
  }
  let newX = x3 < originX ? originX - width : originX;
  let newY = y3 < originY ? originY - height : originY;
  if (shouldResizeFromCenter2) {
    width += width;
    height += height;
    newX = originX - width / 2;
    newY = originY - height / 2;
  }
  if (width !== 0 && height !== 0) {
    mutateElement(draggingElement, {
      x: newX + (originOffset?.x ?? 0),
      y: newY + (originOffset?.y ?? 0),
      width,
      height
    });
  }
};

// element/showSelectedShapeActions.ts
init_define_import_meta_env();
var showSelectedShapeActions = (appState, elements) => Boolean(
  !appState.viewModeEnabled && (appState.activeTool.type !== "custom" && (appState.editingElement || appState.activeTool.type !== "selection" && appState.activeTool.type !== "eraser" && appState.activeTool.type !== "hand" && appState.activeTool.type !== "laser") || getSelectedElements(elements, appState).length)
);

// element/index.ts
var getSceneVersion = (elements) => elements.reduce((acc, el) => acc + el.version, 0);
var getVisibleElements = (elements) => elements.filter(
  (el) => !el.isDeleted && !isInvisiblySmallElement(el)
);
var getNonDeletedElements2 = (elements) => elements.filter((element) => !element.isDeleted);
var isNonDeletedElement = (element) => !element.isDeleted;
var _clearElements = (elements) => getNonDeletedElements2(elements).map(
  (element) => isLinearElementType(element.type) ? { ...element, lastCommittedPoint: null } : element
);
var clearElementsForDatabase = (elements) => _clearElements(elements);
var clearElementsForExport = (elements) => _clearElements(elements);

// data/blob.ts
var parseFileContents = async (blob) => {
  let contents;
  if (blob.type === MIME_TYPES.png) {
    try {
      return await (await import("./image-YINPW27J.js")).decodePngMetadata(blob);
    } catch (error) {
      if (error.message === "INVALID") {
        throw new ImageSceneDataError(
          t("alerts.imageDoesNotContainScene"),
          "IMAGE_NOT_CONTAINS_SCENE_DATA"
        );
      } else {
        throw new ImageSceneDataError(t("alerts.cannotRestoreFromImage"));
      }
    }
  } else {
    if ("text" in Blob) {
      contents = await blob.text();
    } else {
      contents = await new Promise((resolve) => {
        const reader = new FileReader();
        reader.readAsText(blob, "utf8");
        reader.onloadend = () => {
          if (reader.readyState === FileReader.DONE) {
            resolve(reader.result);
          }
        };
      });
    }
    if (blob.type === MIME_TYPES.svg) {
      try {
        return await (await import("./image-YINPW27J.js")).decodeSvgMetadata({
          svg: contents
        });
      } catch (error) {
        if (error.message === "INVALID") {
          throw new ImageSceneDataError(
            t("alerts.imageDoesNotContainScene"),
            "IMAGE_NOT_CONTAINS_SCENE_DATA"
          );
        } else {
          throw new ImageSceneDataError(t("alerts.cannotRestoreFromImage"));
        }
      }
    }
  }
  return contents;
};
var getFileHandleType = (handle) => {
  if (!handle) {
    return null;
  }
  return handle.name.match(/\.(json|excalidraw|png|svg)$/)?.[1] || null;
};
var isImageFileHandleType = (type) => {
  return type === "png" || type === "svg";
};
var isImageFileHandle = (handle) => {
  const type = getFileHandleType(handle);
  return type === "png" || type === "svg";
};
var isSupportedImageFile = (blob) => {
  const { type } = blob || {};
  return !!type && Object.values(IMAGE_MIME_TYPES).includes(type);
};
var loadSceneOrLibraryFromBlob = async (blob, localAppState, localElements, fileHandle) => {
  const contents = await parseFileContents(blob);
  let data;
  try {
    try {
      data = JSON.parse(contents);
    } catch (error) {
      if (isSupportedImageFile(blob)) {
        throw new ImageSceneDataError(
          t("alerts.imageDoesNotContainScene"),
          "IMAGE_NOT_CONTAINS_SCENE_DATA"
        );
      }
      throw error;
    }
    if (isValidExcalidrawData(data)) {
      return {
        type: MIME_TYPES.excalidraw,
        data: restore(
          {
            elements: clearElementsForExport(data.elements || []),
            appState: {
              theme: localAppState?.theme,
              fileHandle: fileHandle || blob.handle || null,
              ...cleanAppStateForExport(data.appState || {}),
              ...localAppState ? calculateScrollCenter(data.elements || [], localAppState) : {}
            },
            files: data.files
          },
          localAppState,
          localElements,
          { repairBindings: true, refreshDimensions: false }
        )
      };
    } else if (isValidLibrary(data)) {
      return {
        type: MIME_TYPES.excalidrawlib,
        data
      };
    }
    throw new Error(t("alerts.couldNotLoadInvalidFile"));
  } catch (error) {
    if (error instanceof ImageSceneDataError) {
      throw error;
    }
    throw new Error(t("alerts.couldNotLoadInvalidFile"));
  }
};
var loadFromBlob = async (blob, localAppState, localElements, fileHandle) => {
  const ret = await loadSceneOrLibraryFromBlob(
    blob,
    localAppState,
    localElements,
    fileHandle
  );
  if (ret.type !== MIME_TYPES.excalidraw) {
    throw new Error(t("alerts.couldNotLoadInvalidFile"));
  }
  return ret.data;
};
var parseLibraryJSON = (json, defaultStatus = "unpublished") => {
  const data = JSON.parse(json);
  if (!isValidLibrary(data)) {
    throw new Error("Invalid library");
  }
  const libraryItems = data.libraryItems || data.library;
  return restoreLibraryItems(libraryItems, defaultStatus);
};
var loadLibraryFromBlob = async (blob, defaultStatus = "unpublished") => {
  return parseLibraryJSON(await parseFileContents(blob), defaultStatus);
};
var canvasToBlob = async (canvas2) => {
  return new Promise(async (resolve, reject) => {
    try {
      if (isPromiseLike(canvas2)) {
        canvas2 = await canvas2;
      }
      canvas2.toBlob((blob) => {
        if (!blob) {
          return reject(
            new CanvasError(
              t("canvasError.canvasTooBig"),
              "CANVAS_POSSIBLY_TOO_BIG"
            )
          );
        }
        resolve(blob);
      });
    } catch (error) {
      reject(error);
    }
  });
};
var generateIdFromFile = async (file2) => {
  try {
    const hashBuffer = await window.crypto.subtle.digest(
      "SHA-1",
      await blobToArrayBuffer(file2)
    );
    return bytesToHexString(new Uint8Array(hashBuffer));
  } catch (error) {
    console.error(error);
    return nanoid(40);
  }
};
var getDataURL = async (file2) => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => {
      const dataURL = reader.result;
      resolve(dataURL);
    };
    reader.onerror = (error) => reject(error);
    reader.readAsDataURL(file2);
  });
};
var dataURLToFile = (dataURL, filename = "") => {
  const dataIndexStart = dataURL.indexOf(",");
  const byteString = atob(dataURL.slice(dataIndexStart + 1));
  const mimeType = dataURL.slice(0, dataIndexStart).split(":")[1].split(";")[0];
  const ab = new ArrayBuffer(byteString.length);
  const ia = new Uint8Array(ab);
  for (let i4 = 0; i4 < byteString.length; i4++) {
    ia[i4] = byteString.charCodeAt(i4);
  }
  return new File([ab], filename, { type: mimeType });
};
var resizeImageFile = async (file2, opts) => {
  if (file2.type === MIME_TYPES.svg) {
    return file2;
  }
  const [pica, imageBlobReduce] = await Promise.all([
    import("./pica-I5JPSWU2.js").then((res) => res.default),
    // a wrapper for pica for better API
    import("./image-blob-reduce.esm-S5U7V4TF.js").then((res) => res.default)
  ]);
  const reduce = imageBlobReduce({
    pica: pica({ features: ["js", "wasm"] })
  });
  if (opts.outputType) {
    const { outputType } = opts;
    reduce._create_blob = function(env) {
      return this.pica.toBlob(env.out_canvas, outputType, 0.8).then((blob) => {
        env.out_blob = blob;
        return env;
      });
    };
  }
  if (!isSupportedImageFile(file2)) {
    throw new Error(t("errors.unsupportedFileType"));
  }
  return new File(
    [await reduce.toBlob(file2, { max: opts.maxWidthOrHeight })],
    file2.name,
    {
      type: opts.outputType || file2.type
    }
  );
};
var SVGStringToFile = (SVGString, filename = "") => {
  return new File([new TextEncoder().encode(SVGString)], filename, {
    type: MIME_TYPES.svg
  });
};
var ImageURLToFile = async (imageUrl, filename = "") => {
  let response;
  try {
    response = await fetch(imageUrl);
  } catch (error) {
    throw new Error(t("errors.failedToFetchImage"));
  }
  if (!response.ok) {
    throw new Error(t("errors.failedToFetchImage"));
  }
  const blob = await response.blob();
  if (blob.type && isSupportedImageFile(blob)) {
    const name = filename || blob.name || "";
    return new File([blob], name, { type: blob.type });
  }
  throw new Error(t("errors.unsupportedFileType"));
};
var getFileFromEvent = async (event) => {
  const file2 = event.dataTransfer.files.item(0);
  const fileHandle = await getFileHandle(event);
  return { file: file2 ? await normalizeFile(file2) : null, fileHandle };
};
var getFileHandle = async (event) => {
  if (e2) {
    try {
      const item = event.dataTransfer.items[0];
      const handle = await item.getAsFileSystemHandle() || null;
      return handle;
    } catch (error) {
      console.warn(error.name, error.message);
      return null;
    }
  }
  return null;
};
var getActualMimeTypeFromImage = (buffer) => {
  let mimeType = null;
  const first8Bytes = `${[...new Uint8Array(buffer).slice(0, 8)].join(" ")} `;
  const headerBytes = {
    // https://en.wikipedia.org/wiki/Portable_Network_Graphics#File_header
    png: "137 80 78 71 13 10 26 10 ",
    // https://en.wikipedia.org/wiki/JPEG#Syntax_and_structure
    // jpg is a bit wonky. Checking the first three bytes should be enough,
    // but may yield false positives. (https://stackoverflow.com/a/23360709/927631)
    jpg: "255 216 255 ",
    // https://en.wikipedia.org/wiki/GIF#Example_GIF_file
    gif: "71 73 70 56 57 97 "
  };
  if (first8Bytes === headerBytes.png) {
    mimeType = MIME_TYPES.png;
  } else if (first8Bytes.startsWith(headerBytes.jpg)) {
    mimeType = MIME_TYPES.jpg;
  } else if (first8Bytes.startsWith(headerBytes.gif)) {
    mimeType = MIME_TYPES.gif;
  }
  return mimeType;
};
var createFile = (blob, mimeType, name) => {
  return new File([blob], name || "", {
    type: mimeType
  });
};
var normalizeFile = async (file2) => {
  if (!file2.type) {
    if (file2?.name?.endsWith(".excalidrawlib")) {
      file2 = createFile(
        await blobToArrayBuffer(file2),
        MIME_TYPES.excalidrawlib,
        file2.name
      );
    } else if (file2?.name?.endsWith(".excalidraw")) {
      file2 = createFile(
        await blobToArrayBuffer(file2),
        MIME_TYPES.excalidraw,
        file2.name
      );
    } else {
      const buffer = await blobToArrayBuffer(file2);
      const mimeType = getActualMimeTypeFromImage(buffer);
      if (mimeType) {
        file2 = createFile(buffer, mimeType, file2.name);
      }
    }
  } else if (isSupportedImageFile(file2)) {
    const buffer = await blobToArrayBuffer(file2);
    const mimeType = getActualMimeTypeFromImage(buffer);
    if (mimeType && mimeType !== file2.type) {
      file2 = createFile(buffer, mimeType, file2.name);
    }
  }
  return file2;
};
var blobToArrayBuffer = (blob) => {
  if ("arrayBuffer" in blob) {
    return blob.arrayBuffer();
  }
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = (event) => {
      if (!event.target?.result) {
        return reject(new Error("Couldn't convert blob to ArrayBuffer"));
      }
      resolve(event.target.result);
    };
    reader.readAsArrayBuffer(blob);
  });
};

// data/encode.ts
var toByteString = (data) => {
  return new Promise((resolve, reject) => {
    const blob = typeof data === "string" ? new Blob([new TextEncoder().encode(data)]) : new Blob([data instanceof Uint8Array ? data : new Uint8Array(data)]);
    const reader = new FileReader();
    reader.onload = (event) => {
      if (!event.target || typeof event.target.result !== "string") {
        return reject(new Error("couldn't convert to byte string"));
      }
      resolve(event.target.result);
    };
    reader.readAsBinaryString(blob);
  });
};
var byteStringToArrayBuffer = (byteString) => {
  const buffer = new ArrayBuffer(byteString.length);
  const bufferView = new Uint8Array(buffer);
  for (let i4 = 0, len = byteString.length; i4 < len; i4++) {
    bufferView[i4] = byteString.charCodeAt(i4);
  }
  return buffer;
};
var byteStringToString = (byteString) => {
  return new TextDecoder("utf-8").decode(byteStringToArrayBuffer(byteString));
};
var stringToBase64 = async (str, isByteString = false) => {
  return isByteString ? window.btoa(str) : window.btoa(await toByteString(str));
};
var base64ToString = async (base64, isByteString = false) => {
  return isByteString ? window.atob(base64) : byteStringToString(window.atob(base64));
};
var encode = async ({
  text,
  compress
}) => {
  let deflated;
  if (compress !== false) {
    try {
      deflated = await toByteString((0, import_pako.deflate)(text));
    } catch (error) {
      console.error("encode: cannot deflate", error);
    }
  }
  return {
    version: "1",
    encoding: "bstring",
    compressed: !!deflated,
    encoded: deflated || await toByteString(text)
  };
};
var decode = async (data) => {
  let decoded;
  switch (data.encoding) {
    case "bstring":
      decoded = data.compressed ? data.encoded : await byteStringToString(data.encoded);
      break;
    default:
      throw new Error(`decode: unknown encoding "${data.encoding}"`);
  }
  if (data.compressed) {
    return (0, import_pako.inflate)(new Uint8Array(byteStringToArrayBuffer(decoded)), {
      to: "string"
    });
  }
  return decoded;
};

// data/image.ts
var getTEXtChunk = async (blob) => {
  const chunks = (0, import_png_chunks_extract.default)(new Uint8Array(await blobToArrayBuffer(blob)));
  const metadataChunk = chunks.find((chunk2) => chunk2.name === "tEXt");
  if (metadataChunk) {
    return import_png_chunk_text.default.decode(metadataChunk.data);
  }
  return null;
};
var encodePngMetadata = async ({
  blob,
  metadata
}) => {
  const chunks = (0, import_png_chunks_extract.default)(new Uint8Array(await blobToArrayBuffer(blob)));
  const metadataChunk = import_png_chunk_text.default.encode(
    MIME_TYPES.excalidraw,
    JSON.stringify(
      await encode({
        text: metadata,
        compress: true
      })
    )
  );
  chunks.splice(-1, 0, metadataChunk);
  return new Blob([(0, import_png_chunks_encode.default)(chunks)], { type: MIME_TYPES.png });
};
var decodePngMetadata = async (blob) => {
  const metadata = await getTEXtChunk(blob);
  if (metadata?.keyword === MIME_TYPES.excalidraw) {
    try {
      const encodedData = JSON.parse(metadata.text);
      if (!("encoded" in encodedData)) {
        if ("type" in encodedData && encodedData.type === EXPORT_DATA_TYPES.excalidraw) {
          return metadata.text;
        }
        throw new Error("FAILED");
      }
      return await decode(encodedData);
    } catch (error) {
      console.error(error);
      throw new Error("FAILED");
    }
  }
  throw new Error("INVALID");
};
var encodeSvgMetadata = async ({ text }) => {
  const base64 = await stringToBase64(
    JSON.stringify(await encode({ text })),
    true
  );
  let metadata = "";
  metadata += `<!-- payload-type:${MIME_TYPES.excalidraw} -->`;
  metadata += `<!-- payload-version:2 -->`;
  metadata += "<!-- payload-start -->";
  metadata += base64;
  metadata += "<!-- payload-end -->";
  return metadata;
};
var decodeSvgMetadata = async ({ svg }) => {
  if (svg.includes(`payload-type:${MIME_TYPES.excalidraw}`)) {
    const match = svg.match(
      /<!-- payload-start -->\s*(.+?)\s*<!-- payload-end -->/
    );
    if (!match) {
      throw new Error("INVALID");
    }
    const versionMatch = svg.match(/<!-- payload-version:(\d+) -->/);
    const version = versionMatch?.[1] || "1";
    const isByteString = version !== "1";
    try {
      const json = await base64ToString(match[1], isByteString);
      const encodedData = JSON.parse(json);
      if (!("encoded" in encodedData)) {
        if ("type" in encodedData && encodedData.type === EXPORT_DATA_TYPES.excalidraw) {
          return json;
        }
        throw new Error("FAILED");
      }
      return await decode(encodedData);
    } catch (error) {
      console.error(error);
      throw new Error("FAILED");
    }
  }
  throw new Error("INVALID");
};

export {
  defaultLang,
  languages,
  useI18n,
  FONT_FAMILY,
  THEME,
  MIME_TYPES,
  ROUNDNESS,
  viewportCoordsToSceneCoords,
  sceneCoordsToViewportCoords,
  isLinearElement,
  getCommonBounds,
  getVisibleSceneBounds,
  normalizeLink,
  restoreElements,
  restoreAppState,
  restore,
  restoreLibraryItems,
  getTEXtChunk,
  encodePngMetadata,
  decodePngMetadata,
  encodeSvgMetadata,
  decodeSvgMetadata,
  loadSceneOrLibraryFromBlob,
  loadFromBlob,
  loadLibraryFromBlob,
  serializeAsJSON,
  serializeLibraryAsJSON,
  isElementInsideBBox,
  elementPartiallyOverlapsWithOrContainsBBox,
  elementsOverlappingBBox,
  mergeLibraryItems,
  parseLibraryTokensFromUrl,
  useHandleLibrary,
  exportToCanvas2 as exportToCanvas,
  exportToBlob,
  exportToSvg2 as exportToSvg,
  exportToClipboard,
  getFreeDrawSvgPath,
  mutateElement,
  newElementWith,
  bumpVersion,
  isInvisiblySmallElement,
  getSceneVersion,
  getNonDeletedElements2 as getNonDeletedElements,
  zoomToFitBounds,
  Button,
  Sidebar,
  MainMenu_default,
  DefaultSidebar,
  TTDDialog,
  convertToExcalidrawElements,
  useDevice,
  FooterCenter_default,
  WelcomeScreen_default,
  LiveCollaborationTrigger_default,
  TTDDialogTrigger,
  Excalidraw
};
/*! Bundled license information:

react/cjs/react-jsx-runtime.development.js:
  (**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

use-sync-external-store/cjs/use-sync-external-store-shim.development.js:
  (**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js:
  (**
   * @license React
   * use-sync-external-store-shim/with-selector.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=chunk-F4S37DNV.js.map
